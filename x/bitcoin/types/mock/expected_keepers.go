// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"github.com/axelarnetwork/axelar-core/utils"
	"github.com/axelarnetwork/axelar-core/x/bitcoin/types"
	nexus "github.com/axelarnetwork/axelar-core/x/nexus/exported"
	snapshot "github.com/axelarnetwork/axelar-core/x/snapshot/exported"
	tss "github.com/axelarnetwork/axelar-core/x/tss/exported"
	exported "github.com/axelarnetwork/axelar-core/x/vote/exported"
	votetypes "github.com/axelarnetwork/axelar-core/x/vote/types"
	"github.com/btcsuite/btcd/chaincfg/chainhash"
	"github.com/btcsuite/btcd/wire"
	github_com_btcsuite_btcutil "github.com/btcsuite/btcutil"
	"github.com/cosmos/cosmos-sdk/codec"
	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/tendermint/tendermint/libs/log"
	"sync"
)

// Ensure, that VoterMock does implement types.Voter.
// If this is not the case, regenerate this file with moq.
var _ types.Voter = &VoterMock{}

// VoterMock is a mock implementation of types.Voter.
//
// 	func TestSomethingThatUsesVoter(t *testing.T) {
//
// 		// make and configure a mocked types.Voter
// 		mockedVoter := &VoterMock{
// 			DeletePollFunc: func(ctx sdk.Context, poll exported.PollKey)  {
// 				panic("mock out the DeletePoll method")
// 			},
// 			InitPollFunc: func(ctx sdk.Context, poll exported.PollKey, snapshotCounter int64, expireAt int64, threshold ...utils.Threshold) error {
// 				panic("mock out the InitPoll method")
// 			},
// 			TallyVoteFunc: func(ctx sdk.Context, sender sdk.AccAddress, pollKey exported.PollKey, data codec.ProtoMarshaler) (*votetypes.Poll, error) {
// 				panic("mock out the TallyVote method")
// 			},
// 		}
//
// 		// use mockedVoter in code that requires types.Voter
// 		// and then make assertions.
//
// 	}
type VoterMock struct {
	// DeletePollFunc mocks the DeletePoll method.
	DeletePollFunc func(ctx sdk.Context, poll exported.PollKey)

	// InitPollFunc mocks the InitPoll method.
	InitPollFunc func(ctx sdk.Context, poll exported.PollKey, snapshotCounter int64, expireAt int64, threshold ...utils.Threshold) error

	// TallyVoteFunc mocks the TallyVote method.
	TallyVoteFunc func(ctx sdk.Context, sender sdk.AccAddress, pollKey exported.PollKey, data codec.ProtoMarshaler) (*votetypes.Poll, error)

	// calls tracks calls to the methods.
	calls struct {
		// DeletePoll holds details about calls to the DeletePoll method.
		DeletePoll []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Poll is the poll argument value.
			Poll exported.PollKey
		}
		// InitPoll holds details about calls to the InitPoll method.
		InitPoll []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Poll is the poll argument value.
			Poll exported.PollKey
			// SnapshotCounter is the snapshotCounter argument value.
			SnapshotCounter int64
			// ExpireAt is the expireAt argument value.
			ExpireAt int64
			// Threshold is the threshold argument value.
			Threshold []utils.Threshold
		}
		// TallyVote holds details about calls to the TallyVote method.
		TallyVote []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Sender is the sender argument value.
			Sender sdk.AccAddress
			// PollKey is the pollKey argument value.
			PollKey exported.PollKey
			// Data is the data argument value.
			Data codec.ProtoMarshaler
		}
	}
	lockDeletePoll sync.RWMutex
	lockInitPoll   sync.RWMutex
	lockTallyVote  sync.RWMutex
}

// DeletePoll calls DeletePollFunc.
func (mock *VoterMock) DeletePoll(ctx sdk.Context, poll exported.PollKey) {
	if mock.DeletePollFunc == nil {
		panic("VoterMock.DeletePollFunc: method is nil but Voter.DeletePoll was just called")
	}
	callInfo := struct {
		Ctx  sdk.Context
		Poll exported.PollKey
	}{
		Ctx:  ctx,
		Poll: poll,
	}
	mock.lockDeletePoll.Lock()
	mock.calls.DeletePoll = append(mock.calls.DeletePoll, callInfo)
	mock.lockDeletePoll.Unlock()
	mock.DeletePollFunc(ctx, poll)
}

// DeletePollCalls gets all the calls that were made to DeletePoll.
// Check the length with:
//     len(mockedVoter.DeletePollCalls())
func (mock *VoterMock) DeletePollCalls() []struct {
	Ctx  sdk.Context
	Poll exported.PollKey
} {
	var calls []struct {
		Ctx  sdk.Context
		Poll exported.PollKey
	}
	mock.lockDeletePoll.RLock()
	calls = mock.calls.DeletePoll
	mock.lockDeletePoll.RUnlock()
	return calls
}

// InitPoll calls InitPollFunc.
func (mock *VoterMock) InitPoll(ctx sdk.Context, poll exported.PollKey, snapshotCounter int64, expireAt int64, threshold ...utils.Threshold) error {
	if mock.InitPollFunc == nil {
		panic("VoterMock.InitPollFunc: method is nil but Voter.InitPoll was just called")
	}
	callInfo := struct {
		Ctx             sdk.Context
		Poll            exported.PollKey
		SnapshotCounter int64
		ExpireAt        int64
		Threshold       []utils.Threshold
	}{
		Ctx:             ctx,
		Poll:            poll,
		SnapshotCounter: snapshotCounter,
		ExpireAt:        expireAt,
		Threshold:       threshold,
	}
	mock.lockInitPoll.Lock()
	mock.calls.InitPoll = append(mock.calls.InitPoll, callInfo)
	mock.lockInitPoll.Unlock()
	return mock.InitPollFunc(ctx, poll, snapshotCounter, expireAt, threshold...)
}

// InitPollCalls gets all the calls that were made to InitPoll.
// Check the length with:
//     len(mockedVoter.InitPollCalls())
func (mock *VoterMock) InitPollCalls() []struct {
	Ctx             sdk.Context
	Poll            exported.PollKey
	SnapshotCounter int64
	ExpireAt        int64
	Threshold       []utils.Threshold
} {
	var calls []struct {
		Ctx             sdk.Context
		Poll            exported.PollKey
		SnapshotCounter int64
		ExpireAt        int64
		Threshold       []utils.Threshold
	}
	mock.lockInitPoll.RLock()
	calls = mock.calls.InitPoll
	mock.lockInitPoll.RUnlock()
	return calls
}

// TallyVote calls TallyVoteFunc.
func (mock *VoterMock) TallyVote(ctx sdk.Context, sender sdk.AccAddress, pollKey exported.PollKey, data codec.ProtoMarshaler) (*votetypes.Poll, error) {
	if mock.TallyVoteFunc == nil {
		panic("VoterMock.TallyVoteFunc: method is nil but Voter.TallyVote was just called")
	}
	callInfo := struct {
		Ctx     sdk.Context
		Sender  sdk.AccAddress
		PollKey exported.PollKey
		Data    codec.ProtoMarshaler
	}{
		Ctx:     ctx,
		Sender:  sender,
		PollKey: pollKey,
		Data:    data,
	}
	mock.lockTallyVote.Lock()
	mock.calls.TallyVote = append(mock.calls.TallyVote, callInfo)
	mock.lockTallyVote.Unlock()
	return mock.TallyVoteFunc(ctx, sender, pollKey, data)
}

// TallyVoteCalls gets all the calls that were made to TallyVote.
// Check the length with:
//     len(mockedVoter.TallyVoteCalls())
func (mock *VoterMock) TallyVoteCalls() []struct {
	Ctx     sdk.Context
	Sender  sdk.AccAddress
	PollKey exported.PollKey
	Data    codec.ProtoMarshaler
} {
	var calls []struct {
		Ctx     sdk.Context
		Sender  sdk.AccAddress
		PollKey exported.PollKey
		Data    codec.ProtoMarshaler
	}
	mock.lockTallyVote.RLock()
	calls = mock.calls.TallyVote
	mock.lockTallyVote.RUnlock()
	return calls
}

// Ensure, that SignerMock does implement types.Signer.
// If this is not the case, regenerate this file with moq.
var _ types.Signer = &SignerMock{}

// SignerMock is a mock implementation of types.Signer.
//
// 	func TestSomethingThatUsesSigner(t *testing.T) {
//
// 		// make and configure a mocked types.Signer
// 		mockedSigner := &SignerMock{
// 			AssertMatchesRequirementsFunc: func(ctx sdk.Context, snapshotter snapshot.Snapshotter, chain nexus.Chain, keyID string, keyRole tss.KeyRole) error {
// 				panic("mock out the AssertMatchesRequirements method")
// 			},
// 			AssignNextKeyFunc: func(ctx sdk.Context, chain nexus.Chain, keyRole tss.KeyRole, keyID string) error {
// 				panic("mock out the AssignNextKey method")
// 			},
// 			GetCurrentKeyFunc: func(ctx sdk.Context, chain nexus.Chain, keyRole tss.KeyRole) (tss.Key, bool) {
// 				panic("mock out the GetCurrentKey method")
// 			},
// 			GetCurrentKeyIDFunc: func(ctx sdk.Context, chain nexus.Chain, keyRole tss.KeyRole) (string, bool) {
// 				panic("mock out the GetCurrentKeyID method")
// 			},
// 			GetKeyFunc: func(ctx sdk.Context, keyID string) (tss.Key, bool) {
// 				panic("mock out the GetKey method")
// 			},
// 			GetNextKeyFunc: func(ctx sdk.Context, chain nexus.Chain, keyRole tss.KeyRole) (tss.Key, bool) {
// 				panic("mock out the GetNextKey method")
// 			},
// 			GetSigFunc: func(ctx sdk.Context, sigID string) (tss.Signature, bool) {
// 				panic("mock out the GetSig method")
// 			},
// 			GetSnapshotCounterForKeyIDFunc: func(ctx sdk.Context, keyID string) (int64, bool) {
// 				panic("mock out the GetSnapshotCounterForKeyID method")
// 			},
// 			StartSignFunc: func(ctx sdk.Context, initPoll interface{InitPoll(ctx sdk.Context, poll exported.PollKey, snapshotCounter int64, expireAt int64, threshold ...utils.Threshold) error}, keyID string, sigID string, msg []byte, snapshotMoqParam snapshot.Snapshot) error {
// 				panic("mock out the StartSign method")
// 			},
// 		}
//
// 		// use mockedSigner in code that requires types.Signer
// 		// and then make assertions.
//
// 	}
type SignerMock struct {
	// AssertMatchesRequirementsFunc mocks the AssertMatchesRequirements method.
	AssertMatchesRequirementsFunc func(ctx sdk.Context, snapshotter snapshot.Snapshotter, chain nexus.Chain, keyID string, keyRole tss.KeyRole) error

	// AssignNextKeyFunc mocks the AssignNextKey method.
	AssignNextKeyFunc func(ctx sdk.Context, chain nexus.Chain, keyRole tss.KeyRole, keyID string) error

	// GetCurrentKeyFunc mocks the GetCurrentKey method.
	GetCurrentKeyFunc func(ctx sdk.Context, chain nexus.Chain, keyRole tss.KeyRole) (tss.Key, bool)

	// GetCurrentKeyIDFunc mocks the GetCurrentKeyID method.
	GetCurrentKeyIDFunc func(ctx sdk.Context, chain nexus.Chain, keyRole tss.KeyRole) (string, bool)

	// GetKeyFunc mocks the GetKey method.
	GetKeyFunc func(ctx sdk.Context, keyID string) (tss.Key, bool)

	// GetNextKeyFunc mocks the GetNextKey method.
	GetNextKeyFunc func(ctx sdk.Context, chain nexus.Chain, keyRole tss.KeyRole) (tss.Key, bool)

	// GetSigFunc mocks the GetSig method.
	GetSigFunc func(ctx sdk.Context, sigID string) (tss.Signature, bool)

	// GetSnapshotCounterForKeyIDFunc mocks the GetSnapshotCounterForKeyID method.
	GetSnapshotCounterForKeyIDFunc func(ctx sdk.Context, keyID string) (int64, bool)

	// StartSignFunc mocks the StartSign method.
	StartSignFunc func(ctx sdk.Context, initPoll interface {
		InitPoll(ctx sdk.Context, poll exported.PollKey, snapshotCounter int64, expireAt int64, threshold ...utils.Threshold) error
	}, keyID string, sigID string, msg []byte, snapshotMoqParam snapshot.Snapshot) error

	// calls tracks calls to the methods.
	calls struct {
		// AssertMatchesRequirements holds details about calls to the AssertMatchesRequirements method.
		AssertMatchesRequirements []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Snapshotter is the snapshotter argument value.
			Snapshotter snapshot.Snapshotter
			// Chain is the chain argument value.
			Chain nexus.Chain
			// KeyID is the keyID argument value.
			KeyID string
			// KeyRole is the keyRole argument value.
			KeyRole tss.KeyRole
		}
		// AssignNextKey holds details about calls to the AssignNextKey method.
		AssignNextKey []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Chain is the chain argument value.
			Chain nexus.Chain
			// KeyRole is the keyRole argument value.
			KeyRole tss.KeyRole
			// KeyID is the keyID argument value.
			KeyID string
		}
		// GetCurrentKey holds details about calls to the GetCurrentKey method.
		GetCurrentKey []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Chain is the chain argument value.
			Chain nexus.Chain
			// KeyRole is the keyRole argument value.
			KeyRole tss.KeyRole
		}
		// GetCurrentKeyID holds details about calls to the GetCurrentKeyID method.
		GetCurrentKeyID []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Chain is the chain argument value.
			Chain nexus.Chain
			// KeyRole is the keyRole argument value.
			KeyRole tss.KeyRole
		}
		// GetKey holds details about calls to the GetKey method.
		GetKey []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// KeyID is the keyID argument value.
			KeyID string
		}
		// GetNextKey holds details about calls to the GetNextKey method.
		GetNextKey []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Chain is the chain argument value.
			Chain nexus.Chain
			// KeyRole is the keyRole argument value.
			KeyRole tss.KeyRole
		}
		// GetSig holds details about calls to the GetSig method.
		GetSig []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// SigID is the sigID argument value.
			SigID string
		}
		// GetSnapshotCounterForKeyID holds details about calls to the GetSnapshotCounterForKeyID method.
		GetSnapshotCounterForKeyID []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// KeyID is the keyID argument value.
			KeyID string
		}
		// StartSign holds details about calls to the StartSign method.
		StartSign []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// InitPoll is the initPoll argument value.
			InitPoll interface {
				InitPoll(ctx sdk.Context, poll exported.PollKey, snapshotCounter int64, expireAt int64, threshold ...utils.Threshold) error
			}
			// KeyID is the keyID argument value.
			KeyID string
			// SigID is the sigID argument value.
			SigID string
			// Msg is the msg argument value.
			Msg []byte
			// SnapshotMoqParam is the snapshotMoqParam argument value.
			SnapshotMoqParam snapshot.Snapshot
		}
	}
	lockAssertMatchesRequirements  sync.RWMutex
	lockAssignNextKey              sync.RWMutex
	lockGetCurrentKey              sync.RWMutex
	lockGetCurrentKeyID            sync.RWMutex
	lockGetKey                     sync.RWMutex
	lockGetNextKey                 sync.RWMutex
	lockGetSig                     sync.RWMutex
	lockGetSnapshotCounterForKeyID sync.RWMutex
	lockStartSign                  sync.RWMutex
}

// AssertMatchesRequirements calls AssertMatchesRequirementsFunc.
func (mock *SignerMock) AssertMatchesRequirements(ctx sdk.Context, snapshotter snapshot.Snapshotter, chain nexus.Chain, keyID string, keyRole tss.KeyRole) error {
	if mock.AssertMatchesRequirementsFunc == nil {
		panic("SignerMock.AssertMatchesRequirementsFunc: method is nil but Signer.AssertMatchesRequirements was just called")
	}
	callInfo := struct {
		Ctx         sdk.Context
		Snapshotter snapshot.Snapshotter
		Chain       nexus.Chain
		KeyID       string
		KeyRole     tss.KeyRole
	}{
		Ctx:         ctx,
		Snapshotter: snapshotter,
		Chain:       chain,
		KeyID:       keyID,
		KeyRole:     keyRole,
	}
	mock.lockAssertMatchesRequirements.Lock()
	mock.calls.AssertMatchesRequirements = append(mock.calls.AssertMatchesRequirements, callInfo)
	mock.lockAssertMatchesRequirements.Unlock()
	return mock.AssertMatchesRequirementsFunc(ctx, snapshotter, chain, keyID, keyRole)
}

// AssertMatchesRequirementsCalls gets all the calls that were made to AssertMatchesRequirements.
// Check the length with:
//     len(mockedSigner.AssertMatchesRequirementsCalls())
func (mock *SignerMock) AssertMatchesRequirementsCalls() []struct {
	Ctx         sdk.Context
	Snapshotter snapshot.Snapshotter
	Chain       nexus.Chain
	KeyID       string
	KeyRole     tss.KeyRole
} {
	var calls []struct {
		Ctx         sdk.Context
		Snapshotter snapshot.Snapshotter
		Chain       nexus.Chain
		KeyID       string
		KeyRole     tss.KeyRole
	}
	mock.lockAssertMatchesRequirements.RLock()
	calls = mock.calls.AssertMatchesRequirements
	mock.lockAssertMatchesRequirements.RUnlock()
	return calls
}

// AssignNextKey calls AssignNextKeyFunc.
func (mock *SignerMock) AssignNextKey(ctx sdk.Context, chain nexus.Chain, keyRole tss.KeyRole, keyID string) error {
	if mock.AssignNextKeyFunc == nil {
		panic("SignerMock.AssignNextKeyFunc: method is nil but Signer.AssignNextKey was just called")
	}
	callInfo := struct {
		Ctx     sdk.Context
		Chain   nexus.Chain
		KeyRole tss.KeyRole
		KeyID   string
	}{
		Ctx:     ctx,
		Chain:   chain,
		KeyRole: keyRole,
		KeyID:   keyID,
	}
	mock.lockAssignNextKey.Lock()
	mock.calls.AssignNextKey = append(mock.calls.AssignNextKey, callInfo)
	mock.lockAssignNextKey.Unlock()
	return mock.AssignNextKeyFunc(ctx, chain, keyRole, keyID)
}

// AssignNextKeyCalls gets all the calls that were made to AssignNextKey.
// Check the length with:
//     len(mockedSigner.AssignNextKeyCalls())
func (mock *SignerMock) AssignNextKeyCalls() []struct {
	Ctx     sdk.Context
	Chain   nexus.Chain
	KeyRole tss.KeyRole
	KeyID   string
} {
	var calls []struct {
		Ctx     sdk.Context
		Chain   nexus.Chain
		KeyRole tss.KeyRole
		KeyID   string
	}
	mock.lockAssignNextKey.RLock()
	calls = mock.calls.AssignNextKey
	mock.lockAssignNextKey.RUnlock()
	return calls
}

// GetCurrentKey calls GetCurrentKeyFunc.
func (mock *SignerMock) GetCurrentKey(ctx sdk.Context, chain nexus.Chain, keyRole tss.KeyRole) (tss.Key, bool) {
	if mock.GetCurrentKeyFunc == nil {
		panic("SignerMock.GetCurrentKeyFunc: method is nil but Signer.GetCurrentKey was just called")
	}
	callInfo := struct {
		Ctx     sdk.Context
		Chain   nexus.Chain
		KeyRole tss.KeyRole
	}{
		Ctx:     ctx,
		Chain:   chain,
		KeyRole: keyRole,
	}
	mock.lockGetCurrentKey.Lock()
	mock.calls.GetCurrentKey = append(mock.calls.GetCurrentKey, callInfo)
	mock.lockGetCurrentKey.Unlock()
	return mock.GetCurrentKeyFunc(ctx, chain, keyRole)
}

// GetCurrentKeyCalls gets all the calls that were made to GetCurrentKey.
// Check the length with:
//     len(mockedSigner.GetCurrentKeyCalls())
func (mock *SignerMock) GetCurrentKeyCalls() []struct {
	Ctx     sdk.Context
	Chain   nexus.Chain
	KeyRole tss.KeyRole
} {
	var calls []struct {
		Ctx     sdk.Context
		Chain   nexus.Chain
		KeyRole tss.KeyRole
	}
	mock.lockGetCurrentKey.RLock()
	calls = mock.calls.GetCurrentKey
	mock.lockGetCurrentKey.RUnlock()
	return calls
}

// GetCurrentKeyID calls GetCurrentKeyIDFunc.
func (mock *SignerMock) GetCurrentKeyID(ctx sdk.Context, chain nexus.Chain, keyRole tss.KeyRole) (string, bool) {
	if mock.GetCurrentKeyIDFunc == nil {
		panic("SignerMock.GetCurrentKeyIDFunc: method is nil but Signer.GetCurrentKeyID was just called")
	}
	callInfo := struct {
		Ctx     sdk.Context
		Chain   nexus.Chain
		KeyRole tss.KeyRole
	}{
		Ctx:     ctx,
		Chain:   chain,
		KeyRole: keyRole,
	}
	mock.lockGetCurrentKeyID.Lock()
	mock.calls.GetCurrentKeyID = append(mock.calls.GetCurrentKeyID, callInfo)
	mock.lockGetCurrentKeyID.Unlock()
	return mock.GetCurrentKeyIDFunc(ctx, chain, keyRole)
}

// GetCurrentKeyIDCalls gets all the calls that were made to GetCurrentKeyID.
// Check the length with:
//     len(mockedSigner.GetCurrentKeyIDCalls())
func (mock *SignerMock) GetCurrentKeyIDCalls() []struct {
	Ctx     sdk.Context
	Chain   nexus.Chain
	KeyRole tss.KeyRole
} {
	var calls []struct {
		Ctx     sdk.Context
		Chain   nexus.Chain
		KeyRole tss.KeyRole
	}
	mock.lockGetCurrentKeyID.RLock()
	calls = mock.calls.GetCurrentKeyID
	mock.lockGetCurrentKeyID.RUnlock()
	return calls
}

// GetKey calls GetKeyFunc.
func (mock *SignerMock) GetKey(ctx sdk.Context, keyID string) (tss.Key, bool) {
	if mock.GetKeyFunc == nil {
		panic("SignerMock.GetKeyFunc: method is nil but Signer.GetKey was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		KeyID string
	}{
		Ctx:   ctx,
		KeyID: keyID,
	}
	mock.lockGetKey.Lock()
	mock.calls.GetKey = append(mock.calls.GetKey, callInfo)
	mock.lockGetKey.Unlock()
	return mock.GetKeyFunc(ctx, keyID)
}

// GetKeyCalls gets all the calls that were made to GetKey.
// Check the length with:
//     len(mockedSigner.GetKeyCalls())
func (mock *SignerMock) GetKeyCalls() []struct {
	Ctx   sdk.Context
	KeyID string
} {
	var calls []struct {
		Ctx   sdk.Context
		KeyID string
	}
	mock.lockGetKey.RLock()
	calls = mock.calls.GetKey
	mock.lockGetKey.RUnlock()
	return calls
}

// GetNextKey calls GetNextKeyFunc.
func (mock *SignerMock) GetNextKey(ctx sdk.Context, chain nexus.Chain, keyRole tss.KeyRole) (tss.Key, bool) {
	if mock.GetNextKeyFunc == nil {
		panic("SignerMock.GetNextKeyFunc: method is nil but Signer.GetNextKey was just called")
	}
	callInfo := struct {
		Ctx     sdk.Context
		Chain   nexus.Chain
		KeyRole tss.KeyRole
	}{
		Ctx:     ctx,
		Chain:   chain,
		KeyRole: keyRole,
	}
	mock.lockGetNextKey.Lock()
	mock.calls.GetNextKey = append(mock.calls.GetNextKey, callInfo)
	mock.lockGetNextKey.Unlock()
	return mock.GetNextKeyFunc(ctx, chain, keyRole)
}

// GetNextKeyCalls gets all the calls that were made to GetNextKey.
// Check the length with:
//     len(mockedSigner.GetNextKeyCalls())
func (mock *SignerMock) GetNextKeyCalls() []struct {
	Ctx     sdk.Context
	Chain   nexus.Chain
	KeyRole tss.KeyRole
} {
	var calls []struct {
		Ctx     sdk.Context
		Chain   nexus.Chain
		KeyRole tss.KeyRole
	}
	mock.lockGetNextKey.RLock()
	calls = mock.calls.GetNextKey
	mock.lockGetNextKey.RUnlock()
	return calls
}

// GetSig calls GetSigFunc.
func (mock *SignerMock) GetSig(ctx sdk.Context, sigID string) (tss.Signature, bool) {
	if mock.GetSigFunc == nil {
		panic("SignerMock.GetSigFunc: method is nil but Signer.GetSig was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		SigID string
	}{
		Ctx:   ctx,
		SigID: sigID,
	}
	mock.lockGetSig.Lock()
	mock.calls.GetSig = append(mock.calls.GetSig, callInfo)
	mock.lockGetSig.Unlock()
	return mock.GetSigFunc(ctx, sigID)
}

// GetSigCalls gets all the calls that were made to GetSig.
// Check the length with:
//     len(mockedSigner.GetSigCalls())
func (mock *SignerMock) GetSigCalls() []struct {
	Ctx   sdk.Context
	SigID string
} {
	var calls []struct {
		Ctx   sdk.Context
		SigID string
	}
	mock.lockGetSig.RLock()
	calls = mock.calls.GetSig
	mock.lockGetSig.RUnlock()
	return calls
}

// GetSnapshotCounterForKeyID calls GetSnapshotCounterForKeyIDFunc.
func (mock *SignerMock) GetSnapshotCounterForKeyID(ctx sdk.Context, keyID string) (int64, bool) {
	if mock.GetSnapshotCounterForKeyIDFunc == nil {
		panic("SignerMock.GetSnapshotCounterForKeyIDFunc: method is nil but Signer.GetSnapshotCounterForKeyID was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		KeyID string
	}{
		Ctx:   ctx,
		KeyID: keyID,
	}
	mock.lockGetSnapshotCounterForKeyID.Lock()
	mock.calls.GetSnapshotCounterForKeyID = append(mock.calls.GetSnapshotCounterForKeyID, callInfo)
	mock.lockGetSnapshotCounterForKeyID.Unlock()
	return mock.GetSnapshotCounterForKeyIDFunc(ctx, keyID)
}

// GetSnapshotCounterForKeyIDCalls gets all the calls that were made to GetSnapshotCounterForKeyID.
// Check the length with:
//     len(mockedSigner.GetSnapshotCounterForKeyIDCalls())
func (mock *SignerMock) GetSnapshotCounterForKeyIDCalls() []struct {
	Ctx   sdk.Context
	KeyID string
} {
	var calls []struct {
		Ctx   sdk.Context
		KeyID string
	}
	mock.lockGetSnapshotCounterForKeyID.RLock()
	calls = mock.calls.GetSnapshotCounterForKeyID
	mock.lockGetSnapshotCounterForKeyID.RUnlock()
	return calls
}

// StartSign calls StartSignFunc.
func (mock *SignerMock) StartSign(ctx sdk.Context, initPoll interface {
	InitPoll(ctx sdk.Context, poll exported.PollKey, snapshotCounter int64, expireAt int64, threshold ...utils.Threshold) error
}, keyID string, sigID string, msg []byte, snapshotMoqParam snapshot.Snapshot) error {
	if mock.StartSignFunc == nil {
		panic("SignerMock.StartSignFunc: method is nil but Signer.StartSign was just called")
	}
	callInfo := struct {
		Ctx      sdk.Context
		InitPoll interface {
			InitPoll(ctx sdk.Context, poll exported.PollKey, snapshotCounter int64, expireAt int64, threshold ...utils.Threshold) error
		}
		KeyID            string
		SigID            string
		Msg              []byte
		SnapshotMoqParam snapshot.Snapshot
	}{
		Ctx:              ctx,
		InitPoll:         initPoll,
		KeyID:            keyID,
		SigID:            sigID,
		Msg:              msg,
		SnapshotMoqParam: snapshotMoqParam,
	}
	mock.lockStartSign.Lock()
	mock.calls.StartSign = append(mock.calls.StartSign, callInfo)
	mock.lockStartSign.Unlock()
	return mock.StartSignFunc(ctx, initPoll, keyID, sigID, msg, snapshotMoqParam)
}

// StartSignCalls gets all the calls that were made to StartSign.
// Check the length with:
//     len(mockedSigner.StartSignCalls())
func (mock *SignerMock) StartSignCalls() []struct {
	Ctx      sdk.Context
	InitPoll interface {
		InitPoll(ctx sdk.Context, poll exported.PollKey, snapshotCounter int64, expireAt int64, threshold ...utils.Threshold) error
	}
	KeyID            string
	SigID            string
	Msg              []byte
	SnapshotMoqParam snapshot.Snapshot
} {
	var calls []struct {
		Ctx      sdk.Context
		InitPoll interface {
			InitPoll(ctx sdk.Context, poll exported.PollKey, snapshotCounter int64, expireAt int64, threshold ...utils.Threshold) error
		}
		KeyID            string
		SigID            string
		Msg              []byte
		SnapshotMoqParam snapshot.Snapshot
	}
	mock.lockStartSign.RLock()
	calls = mock.calls.StartSign
	mock.lockStartSign.RUnlock()
	return calls
}

// Ensure, that NexusMock does implement types.Nexus.
// If this is not the case, regenerate this file with moq.
var _ types.Nexus = &NexusMock{}

// NexusMock is a mock implementation of types.Nexus.
//
// 	func TestSomethingThatUsesNexus(t *testing.T) {
//
// 		// make and configure a mocked types.Nexus
// 		mockedNexus := &NexusMock{
// 			ArchivePendingTransferFunc: func(ctx sdk.Context, transfer nexus.CrossChainTransfer)  {
// 				panic("mock out the ArchivePendingTransfer method")
// 			},
// 			EnqueueForTransferFunc: func(ctx sdk.Context, sender nexus.CrossChainAddress, amount sdk.Coin) error {
// 				panic("mock out the EnqueueForTransfer method")
// 			},
// 			GetChainFunc: func(ctx sdk.Context, chain string) (nexus.Chain, bool) {
// 				panic("mock out the GetChain method")
// 			},
// 			GetRecipientFunc: func(ctx sdk.Context, sender nexus.CrossChainAddress) (nexus.CrossChainAddress, bool) {
// 				panic("mock out the GetRecipient method")
// 			},
// 			GetTransfersForChainFunc: func(ctx sdk.Context, chain nexus.Chain, state nexus.TransferState) []nexus.CrossChainTransfer {
// 				panic("mock out the GetTransfersForChain method")
// 			},
// 			IsAssetRegisteredFunc: func(ctx sdk.Context, chainName string, denom string) bool {
// 				panic("mock out the IsAssetRegistered method")
// 			},
// 			LinkAddressesFunc: func(ctx sdk.Context, sender nexus.CrossChainAddress, recipient nexus.CrossChainAddress)  {
// 				panic("mock out the LinkAddresses method")
// 			},
// 		}
//
// 		// use mockedNexus in code that requires types.Nexus
// 		// and then make assertions.
//
// 	}
type NexusMock struct {
	// ArchivePendingTransferFunc mocks the ArchivePendingTransfer method.
	ArchivePendingTransferFunc func(ctx sdk.Context, transfer nexus.CrossChainTransfer)

	// EnqueueForTransferFunc mocks the EnqueueForTransfer method.
	EnqueueForTransferFunc func(ctx sdk.Context, sender nexus.CrossChainAddress, amount sdk.Coin) error

	// GetChainFunc mocks the GetChain method.
	GetChainFunc func(ctx sdk.Context, chain string) (nexus.Chain, bool)

	// GetRecipientFunc mocks the GetRecipient method.
	GetRecipientFunc func(ctx sdk.Context, sender nexus.CrossChainAddress) (nexus.CrossChainAddress, bool)

	// GetTransfersForChainFunc mocks the GetTransfersForChain method.
	GetTransfersForChainFunc func(ctx sdk.Context, chain nexus.Chain, state nexus.TransferState) []nexus.CrossChainTransfer

	// IsAssetRegisteredFunc mocks the IsAssetRegistered method.
	IsAssetRegisteredFunc func(ctx sdk.Context, chainName string, denom string) bool

	// LinkAddressesFunc mocks the LinkAddresses method.
	LinkAddressesFunc func(ctx sdk.Context, sender nexus.CrossChainAddress, recipient nexus.CrossChainAddress)

	// calls tracks calls to the methods.
	calls struct {
		// ArchivePendingTransfer holds details about calls to the ArchivePendingTransfer method.
		ArchivePendingTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Transfer is the transfer argument value.
			Transfer nexus.CrossChainTransfer
		}
		// EnqueueForTransfer holds details about calls to the EnqueueForTransfer method.
		EnqueueForTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Sender is the sender argument value.
			Sender nexus.CrossChainAddress
			// Amount is the amount argument value.
			Amount sdk.Coin
		}
		// GetChain holds details about calls to the GetChain method.
		GetChain []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Chain is the chain argument value.
			Chain string
		}
		// GetRecipient holds details about calls to the GetRecipient method.
		GetRecipient []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Sender is the sender argument value.
			Sender nexus.CrossChainAddress
		}
		// GetTransfersForChain holds details about calls to the GetTransfersForChain method.
		GetTransfersForChain []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Chain is the chain argument value.
			Chain nexus.Chain
			// State is the state argument value.
			State nexus.TransferState
		}
		// IsAssetRegistered holds details about calls to the IsAssetRegistered method.
		IsAssetRegistered []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// ChainName is the chainName argument value.
			ChainName string
			// Denom is the denom argument value.
			Denom string
		}
		// LinkAddresses holds details about calls to the LinkAddresses method.
		LinkAddresses []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Sender is the sender argument value.
			Sender nexus.CrossChainAddress
			// Recipient is the recipient argument value.
			Recipient nexus.CrossChainAddress
		}
	}
	lockArchivePendingTransfer sync.RWMutex
	lockEnqueueForTransfer     sync.RWMutex
	lockGetChain               sync.RWMutex
	lockGetRecipient           sync.RWMutex
	lockGetTransfersForChain   sync.RWMutex
	lockIsAssetRegistered      sync.RWMutex
	lockLinkAddresses          sync.RWMutex
}

// ArchivePendingTransfer calls ArchivePendingTransferFunc.
func (mock *NexusMock) ArchivePendingTransfer(ctx sdk.Context, transfer nexus.CrossChainTransfer) {
	if mock.ArchivePendingTransferFunc == nil {
		panic("NexusMock.ArchivePendingTransferFunc: method is nil but Nexus.ArchivePendingTransfer was just called")
	}
	callInfo := struct {
		Ctx      sdk.Context
		Transfer nexus.CrossChainTransfer
	}{
		Ctx:      ctx,
		Transfer: transfer,
	}
	mock.lockArchivePendingTransfer.Lock()
	mock.calls.ArchivePendingTransfer = append(mock.calls.ArchivePendingTransfer, callInfo)
	mock.lockArchivePendingTransfer.Unlock()
	mock.ArchivePendingTransferFunc(ctx, transfer)
}

// ArchivePendingTransferCalls gets all the calls that were made to ArchivePendingTransfer.
// Check the length with:
//     len(mockedNexus.ArchivePendingTransferCalls())
func (mock *NexusMock) ArchivePendingTransferCalls() []struct {
	Ctx      sdk.Context
	Transfer nexus.CrossChainTransfer
} {
	var calls []struct {
		Ctx      sdk.Context
		Transfer nexus.CrossChainTransfer
	}
	mock.lockArchivePendingTransfer.RLock()
	calls = mock.calls.ArchivePendingTransfer
	mock.lockArchivePendingTransfer.RUnlock()
	return calls
}

// EnqueueForTransfer calls EnqueueForTransferFunc.
func (mock *NexusMock) EnqueueForTransfer(ctx sdk.Context, sender nexus.CrossChainAddress, amount sdk.Coin) error {
	if mock.EnqueueForTransferFunc == nil {
		panic("NexusMock.EnqueueForTransferFunc: method is nil but Nexus.EnqueueForTransfer was just called")
	}
	callInfo := struct {
		Ctx    sdk.Context
		Sender nexus.CrossChainAddress
		Amount sdk.Coin
	}{
		Ctx:    ctx,
		Sender: sender,
		Amount: amount,
	}
	mock.lockEnqueueForTransfer.Lock()
	mock.calls.EnqueueForTransfer = append(mock.calls.EnqueueForTransfer, callInfo)
	mock.lockEnqueueForTransfer.Unlock()
	return mock.EnqueueForTransferFunc(ctx, sender, amount)
}

// EnqueueForTransferCalls gets all the calls that were made to EnqueueForTransfer.
// Check the length with:
//     len(mockedNexus.EnqueueForTransferCalls())
func (mock *NexusMock) EnqueueForTransferCalls() []struct {
	Ctx    sdk.Context
	Sender nexus.CrossChainAddress
	Amount sdk.Coin
} {
	var calls []struct {
		Ctx    sdk.Context
		Sender nexus.CrossChainAddress
		Amount sdk.Coin
	}
	mock.lockEnqueueForTransfer.RLock()
	calls = mock.calls.EnqueueForTransfer
	mock.lockEnqueueForTransfer.RUnlock()
	return calls
}

// GetChain calls GetChainFunc.
func (mock *NexusMock) GetChain(ctx sdk.Context, chain string) (nexus.Chain, bool) {
	if mock.GetChainFunc == nil {
		panic("NexusMock.GetChainFunc: method is nil but Nexus.GetChain was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		Chain string
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockGetChain.Lock()
	mock.calls.GetChain = append(mock.calls.GetChain, callInfo)
	mock.lockGetChain.Unlock()
	return mock.GetChainFunc(ctx, chain)
}

// GetChainCalls gets all the calls that were made to GetChain.
// Check the length with:
//     len(mockedNexus.GetChainCalls())
func (mock *NexusMock) GetChainCalls() []struct {
	Ctx   sdk.Context
	Chain string
} {
	var calls []struct {
		Ctx   sdk.Context
		Chain string
	}
	mock.lockGetChain.RLock()
	calls = mock.calls.GetChain
	mock.lockGetChain.RUnlock()
	return calls
}

// GetRecipient calls GetRecipientFunc.
func (mock *NexusMock) GetRecipient(ctx sdk.Context, sender nexus.CrossChainAddress) (nexus.CrossChainAddress, bool) {
	if mock.GetRecipientFunc == nil {
		panic("NexusMock.GetRecipientFunc: method is nil but Nexus.GetRecipient was just called")
	}
	callInfo := struct {
		Ctx    sdk.Context
		Sender nexus.CrossChainAddress
	}{
		Ctx:    ctx,
		Sender: sender,
	}
	mock.lockGetRecipient.Lock()
	mock.calls.GetRecipient = append(mock.calls.GetRecipient, callInfo)
	mock.lockGetRecipient.Unlock()
	return mock.GetRecipientFunc(ctx, sender)
}

// GetRecipientCalls gets all the calls that were made to GetRecipient.
// Check the length with:
//     len(mockedNexus.GetRecipientCalls())
func (mock *NexusMock) GetRecipientCalls() []struct {
	Ctx    sdk.Context
	Sender nexus.CrossChainAddress
} {
	var calls []struct {
		Ctx    sdk.Context
		Sender nexus.CrossChainAddress
	}
	mock.lockGetRecipient.RLock()
	calls = mock.calls.GetRecipient
	mock.lockGetRecipient.RUnlock()
	return calls
}

// GetTransfersForChain calls GetTransfersForChainFunc.
func (mock *NexusMock) GetTransfersForChain(ctx sdk.Context, chain nexus.Chain, state nexus.TransferState) []nexus.CrossChainTransfer {
	if mock.GetTransfersForChainFunc == nil {
		panic("NexusMock.GetTransfersForChainFunc: method is nil but Nexus.GetTransfersForChain was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		Chain nexus.Chain
		State nexus.TransferState
	}{
		Ctx:   ctx,
		Chain: chain,
		State: state,
	}
	mock.lockGetTransfersForChain.Lock()
	mock.calls.GetTransfersForChain = append(mock.calls.GetTransfersForChain, callInfo)
	mock.lockGetTransfersForChain.Unlock()
	return mock.GetTransfersForChainFunc(ctx, chain, state)
}

// GetTransfersForChainCalls gets all the calls that were made to GetTransfersForChain.
// Check the length with:
//     len(mockedNexus.GetTransfersForChainCalls())
func (mock *NexusMock) GetTransfersForChainCalls() []struct {
	Ctx   sdk.Context
	Chain nexus.Chain
	State nexus.TransferState
} {
	var calls []struct {
		Ctx   sdk.Context
		Chain nexus.Chain
		State nexus.TransferState
	}
	mock.lockGetTransfersForChain.RLock()
	calls = mock.calls.GetTransfersForChain
	mock.lockGetTransfersForChain.RUnlock()
	return calls
}

// IsAssetRegistered calls IsAssetRegisteredFunc.
func (mock *NexusMock) IsAssetRegistered(ctx sdk.Context, chainName string, denom string) bool {
	if mock.IsAssetRegisteredFunc == nil {
		panic("NexusMock.IsAssetRegisteredFunc: method is nil but Nexus.IsAssetRegistered was just called")
	}
	callInfo := struct {
		Ctx       sdk.Context
		ChainName string
		Denom     string
	}{
		Ctx:       ctx,
		ChainName: chainName,
		Denom:     denom,
	}
	mock.lockIsAssetRegistered.Lock()
	mock.calls.IsAssetRegistered = append(mock.calls.IsAssetRegistered, callInfo)
	mock.lockIsAssetRegistered.Unlock()
	return mock.IsAssetRegisteredFunc(ctx, chainName, denom)
}

// IsAssetRegisteredCalls gets all the calls that were made to IsAssetRegistered.
// Check the length with:
//     len(mockedNexus.IsAssetRegisteredCalls())
func (mock *NexusMock) IsAssetRegisteredCalls() []struct {
	Ctx       sdk.Context
	ChainName string
	Denom     string
} {
	var calls []struct {
		Ctx       sdk.Context
		ChainName string
		Denom     string
	}
	mock.lockIsAssetRegistered.RLock()
	calls = mock.calls.IsAssetRegistered
	mock.lockIsAssetRegistered.RUnlock()
	return calls
}

// LinkAddresses calls LinkAddressesFunc.
func (mock *NexusMock) LinkAddresses(ctx sdk.Context, sender nexus.CrossChainAddress, recipient nexus.CrossChainAddress) {
	if mock.LinkAddressesFunc == nil {
		panic("NexusMock.LinkAddressesFunc: method is nil but Nexus.LinkAddresses was just called")
	}
	callInfo := struct {
		Ctx       sdk.Context
		Sender    nexus.CrossChainAddress
		Recipient nexus.CrossChainAddress
	}{
		Ctx:       ctx,
		Sender:    sender,
		Recipient: recipient,
	}
	mock.lockLinkAddresses.Lock()
	mock.calls.LinkAddresses = append(mock.calls.LinkAddresses, callInfo)
	mock.lockLinkAddresses.Unlock()
	mock.LinkAddressesFunc(ctx, sender, recipient)
}

// LinkAddressesCalls gets all the calls that were made to LinkAddresses.
// Check the length with:
//     len(mockedNexus.LinkAddressesCalls())
func (mock *NexusMock) LinkAddressesCalls() []struct {
	Ctx       sdk.Context
	Sender    nexus.CrossChainAddress
	Recipient nexus.CrossChainAddress
} {
	var calls []struct {
		Ctx       sdk.Context
		Sender    nexus.CrossChainAddress
		Recipient nexus.CrossChainAddress
	}
	mock.lockLinkAddresses.RLock()
	calls = mock.calls.LinkAddresses
	mock.lockLinkAddresses.RUnlock()
	return calls
}

// Ensure, that SnapshotterMock does implement types.Snapshotter.
// If this is not the case, regenerate this file with moq.
var _ types.Snapshotter = &SnapshotterMock{}

// SnapshotterMock is a mock implementation of types.Snapshotter.
//
// 	func TestSomethingThatUsesSnapshotter(t *testing.T) {
//
// 		// make and configure a mocked types.Snapshotter
// 		mockedSnapshotter := &SnapshotterMock{
// 			GetLatestCounterFunc: func(ctx sdk.Context) int64 {
// 				panic("mock out the GetLatestCounter method")
// 			},
// 			GetLatestSnapshotFunc: func(ctx sdk.Context) (snapshot.Snapshot, bool) {
// 				panic("mock out the GetLatestSnapshot method")
// 			},
// 			GetPrincipalFunc: func(ctx sdk.Context, proxy sdk.AccAddress) sdk.ValAddress {
// 				panic("mock out the GetPrincipal method")
// 			},
// 			GetProxyFunc: func(ctx sdk.Context, principal sdk.ValAddress) (sdk.AccAddress, bool) {
// 				panic("mock out the GetProxy method")
// 			},
// 			GetSnapshotFunc: func(ctx sdk.Context, counter int64) (snapshot.Snapshot, bool) {
// 				panic("mock out the GetSnapshot method")
// 			},
// 			TakeSnapshotFunc: func(ctx sdk.Context, subsetSize int64, keyShareDistributionPolicy tss.KeyShareDistributionPolicy) (sdk.Int, sdk.Int, error) {
// 				panic("mock out the TakeSnapshot method")
// 			},
// 		}
//
// 		// use mockedSnapshotter in code that requires types.Snapshotter
// 		// and then make assertions.
//
// 	}
type SnapshotterMock struct {
	// GetLatestCounterFunc mocks the GetLatestCounter method.
	GetLatestCounterFunc func(ctx sdk.Context) int64

	// GetLatestSnapshotFunc mocks the GetLatestSnapshot method.
	GetLatestSnapshotFunc func(ctx sdk.Context) (snapshot.Snapshot, bool)

	// GetPrincipalFunc mocks the GetPrincipal method.
	GetPrincipalFunc func(ctx sdk.Context, proxy sdk.AccAddress) sdk.ValAddress

	// GetProxyFunc mocks the GetProxy method.
	GetProxyFunc func(ctx sdk.Context, principal sdk.ValAddress) (sdk.AccAddress, bool)

	// GetSnapshotFunc mocks the GetSnapshot method.
	GetSnapshotFunc func(ctx sdk.Context, counter int64) (snapshot.Snapshot, bool)

	// TakeSnapshotFunc mocks the TakeSnapshot method.
	TakeSnapshotFunc func(ctx sdk.Context, subsetSize int64, keyShareDistributionPolicy tss.KeyShareDistributionPolicy) (sdk.Int, sdk.Int, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetLatestCounter holds details about calls to the GetLatestCounter method.
		GetLatestCounter []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetLatestSnapshot holds details about calls to the GetLatestSnapshot method.
		GetLatestSnapshot []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetPrincipal holds details about calls to the GetPrincipal method.
		GetPrincipal []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Proxy is the proxy argument value.
			Proxy sdk.AccAddress
		}
		// GetProxy holds details about calls to the GetProxy method.
		GetProxy []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Principal is the principal argument value.
			Principal sdk.ValAddress
		}
		// GetSnapshot holds details about calls to the GetSnapshot method.
		GetSnapshot []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Counter is the counter argument value.
			Counter int64
		}
		// TakeSnapshot holds details about calls to the TakeSnapshot method.
		TakeSnapshot []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// SubsetSize is the subsetSize argument value.
			SubsetSize int64
			// KeyShareDistributionPolicy is the keyShareDistributionPolicy argument value.
			KeyShareDistributionPolicy tss.KeyShareDistributionPolicy
		}
	}
	lockGetLatestCounter  sync.RWMutex
	lockGetLatestSnapshot sync.RWMutex
	lockGetPrincipal      sync.RWMutex
	lockGetProxy          sync.RWMutex
	lockGetSnapshot       sync.RWMutex
	lockTakeSnapshot      sync.RWMutex
}

// GetLatestCounter calls GetLatestCounterFunc.
func (mock *SnapshotterMock) GetLatestCounter(ctx sdk.Context) int64 {
	if mock.GetLatestCounterFunc == nil {
		panic("SnapshotterMock.GetLatestCounterFunc: method is nil but Snapshotter.GetLatestCounter was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetLatestCounter.Lock()
	mock.calls.GetLatestCounter = append(mock.calls.GetLatestCounter, callInfo)
	mock.lockGetLatestCounter.Unlock()
	return mock.GetLatestCounterFunc(ctx)
}

// GetLatestCounterCalls gets all the calls that were made to GetLatestCounter.
// Check the length with:
//     len(mockedSnapshotter.GetLatestCounterCalls())
func (mock *SnapshotterMock) GetLatestCounterCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetLatestCounter.RLock()
	calls = mock.calls.GetLatestCounter
	mock.lockGetLatestCounter.RUnlock()
	return calls
}

// GetLatestSnapshot calls GetLatestSnapshotFunc.
func (mock *SnapshotterMock) GetLatestSnapshot(ctx sdk.Context) (snapshot.Snapshot, bool) {
	if mock.GetLatestSnapshotFunc == nil {
		panic("SnapshotterMock.GetLatestSnapshotFunc: method is nil but Snapshotter.GetLatestSnapshot was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetLatestSnapshot.Lock()
	mock.calls.GetLatestSnapshot = append(mock.calls.GetLatestSnapshot, callInfo)
	mock.lockGetLatestSnapshot.Unlock()
	return mock.GetLatestSnapshotFunc(ctx)
}

// GetLatestSnapshotCalls gets all the calls that were made to GetLatestSnapshot.
// Check the length with:
//     len(mockedSnapshotter.GetLatestSnapshotCalls())
func (mock *SnapshotterMock) GetLatestSnapshotCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetLatestSnapshot.RLock()
	calls = mock.calls.GetLatestSnapshot
	mock.lockGetLatestSnapshot.RUnlock()
	return calls
}

// GetPrincipal calls GetPrincipalFunc.
func (mock *SnapshotterMock) GetPrincipal(ctx sdk.Context, proxy sdk.AccAddress) sdk.ValAddress {
	if mock.GetPrincipalFunc == nil {
		panic("SnapshotterMock.GetPrincipalFunc: method is nil but Snapshotter.GetPrincipal was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		Proxy sdk.AccAddress
	}{
		Ctx:   ctx,
		Proxy: proxy,
	}
	mock.lockGetPrincipal.Lock()
	mock.calls.GetPrincipal = append(mock.calls.GetPrincipal, callInfo)
	mock.lockGetPrincipal.Unlock()
	return mock.GetPrincipalFunc(ctx, proxy)
}

// GetPrincipalCalls gets all the calls that were made to GetPrincipal.
// Check the length with:
//     len(mockedSnapshotter.GetPrincipalCalls())
func (mock *SnapshotterMock) GetPrincipalCalls() []struct {
	Ctx   sdk.Context
	Proxy sdk.AccAddress
} {
	var calls []struct {
		Ctx   sdk.Context
		Proxy sdk.AccAddress
	}
	mock.lockGetPrincipal.RLock()
	calls = mock.calls.GetPrincipal
	mock.lockGetPrincipal.RUnlock()
	return calls
}

// GetProxy calls GetProxyFunc.
func (mock *SnapshotterMock) GetProxy(ctx sdk.Context, principal sdk.ValAddress) (sdk.AccAddress, bool) {
	if mock.GetProxyFunc == nil {
		panic("SnapshotterMock.GetProxyFunc: method is nil but Snapshotter.GetProxy was just called")
	}
	callInfo := struct {
		Ctx       sdk.Context
		Principal sdk.ValAddress
	}{
		Ctx:       ctx,
		Principal: principal,
	}
	mock.lockGetProxy.Lock()
	mock.calls.GetProxy = append(mock.calls.GetProxy, callInfo)
	mock.lockGetProxy.Unlock()
	return mock.GetProxyFunc(ctx, principal)
}

// GetProxyCalls gets all the calls that were made to GetProxy.
// Check the length with:
//     len(mockedSnapshotter.GetProxyCalls())
func (mock *SnapshotterMock) GetProxyCalls() []struct {
	Ctx       sdk.Context
	Principal sdk.ValAddress
} {
	var calls []struct {
		Ctx       sdk.Context
		Principal sdk.ValAddress
	}
	mock.lockGetProxy.RLock()
	calls = mock.calls.GetProxy
	mock.lockGetProxy.RUnlock()
	return calls
}

// GetSnapshot calls GetSnapshotFunc.
func (mock *SnapshotterMock) GetSnapshot(ctx sdk.Context, counter int64) (snapshot.Snapshot, bool) {
	if mock.GetSnapshotFunc == nil {
		panic("SnapshotterMock.GetSnapshotFunc: method is nil but Snapshotter.GetSnapshot was just called")
	}
	callInfo := struct {
		Ctx     sdk.Context
		Counter int64
	}{
		Ctx:     ctx,
		Counter: counter,
	}
	mock.lockGetSnapshot.Lock()
	mock.calls.GetSnapshot = append(mock.calls.GetSnapshot, callInfo)
	mock.lockGetSnapshot.Unlock()
	return mock.GetSnapshotFunc(ctx, counter)
}

// GetSnapshotCalls gets all the calls that were made to GetSnapshot.
// Check the length with:
//     len(mockedSnapshotter.GetSnapshotCalls())
func (mock *SnapshotterMock) GetSnapshotCalls() []struct {
	Ctx     sdk.Context
	Counter int64
} {
	var calls []struct {
		Ctx     sdk.Context
		Counter int64
	}
	mock.lockGetSnapshot.RLock()
	calls = mock.calls.GetSnapshot
	mock.lockGetSnapshot.RUnlock()
	return calls
}

// TakeSnapshot calls TakeSnapshotFunc.
func (mock *SnapshotterMock) TakeSnapshot(ctx sdk.Context, subsetSize int64, keyShareDistributionPolicy tss.KeyShareDistributionPolicy) (sdk.Int, sdk.Int, error) {
	if mock.TakeSnapshotFunc == nil {
		panic("SnapshotterMock.TakeSnapshotFunc: method is nil but Snapshotter.TakeSnapshot was just called")
	}
	callInfo := struct {
		Ctx                        sdk.Context
		SubsetSize                 int64
		KeyShareDistributionPolicy tss.KeyShareDistributionPolicy
	}{
		Ctx:                        ctx,
		SubsetSize:                 subsetSize,
		KeyShareDistributionPolicy: keyShareDistributionPolicy,
	}
	mock.lockTakeSnapshot.Lock()
	mock.calls.TakeSnapshot = append(mock.calls.TakeSnapshot, callInfo)
	mock.lockTakeSnapshot.Unlock()
	return mock.TakeSnapshotFunc(ctx, subsetSize, keyShareDistributionPolicy)
}

// TakeSnapshotCalls gets all the calls that were made to TakeSnapshot.
// Check the length with:
//     len(mockedSnapshotter.TakeSnapshotCalls())
func (mock *SnapshotterMock) TakeSnapshotCalls() []struct {
	Ctx                        sdk.Context
	SubsetSize                 int64
	KeyShareDistributionPolicy tss.KeyShareDistributionPolicy
} {
	var calls []struct {
		Ctx                        sdk.Context
		SubsetSize                 int64
		KeyShareDistributionPolicy tss.KeyShareDistributionPolicy
	}
	mock.lockTakeSnapshot.RLock()
	calls = mock.calls.TakeSnapshot
	mock.lockTakeSnapshot.RUnlock()
	return calls
}

// Ensure, that BTCKeeperMock does implement types.BTCKeeper.
// If this is not the case, regenerate this file with moq.
var _ types.BTCKeeper = &BTCKeeperMock{}

// BTCKeeperMock is a mock implementation of types.BTCKeeper.
//
// 	func TestSomethingThatUsesBTCKeeper(t *testing.T) {
//
// 		// make and configure a mocked types.BTCKeeper
// 		mockedBTCKeeper := &BTCKeeperMock{
// 			DeleteDustAmountFunc: func(ctx sdk.Context, encodedAddress string)  {
// 				panic("mock out the DeleteDustAmount method")
// 			},
// 			DeleteOutpointInfoFunc: func(ctx sdk.Context, outPoint wire.OutPoint)  {
// 				panic("mock out the DeleteOutpointInfo method")
// 			},
// 			DeletePendingOutPointInfoFunc: func(ctx sdk.Context, poll exported.PollKey)  {
// 				panic("mock out the DeletePendingOutPointInfo method")
// 			},
// 			DeleteUnsignedTxFunc: func(ctx sdk.Context)  {
// 				panic("mock out the DeleteUnsignedTx method")
// 			},
// 			GetAddressFunc: func(ctx sdk.Context, encodedAddress string) (types.AddressInfo, bool) {
// 				panic("mock out the GetAddress method")
// 			},
// 			GetAnyoneCanSpendAddressFunc: func(ctx sdk.Context) types.AddressInfo {
// 				panic("mock out the GetAnyoneCanSpendAddress method")
// 			},
// 			GetConfirmedOutpointInfoQueueForKeyFunc: func(ctx sdk.Context, keyID string) utils.KVQueue {
// 				panic("mock out the GetConfirmedOutpointInfoQueueForKey method")
// 			},
// 			GetDustAmountFunc: func(ctx sdk.Context, encodedAddress string) github_com_btcsuite_btcutil.Amount {
// 				panic("mock out the GetDustAmount method")
// 			},
// 			GetLatestSignedTxHashFunc: func(ctx sdk.Context) (*chainhash.Hash, bool) {
// 				panic("mock out the GetLatestSignedTxHash method")
// 			},
// 			GetMaxInputCountFunc: func(ctx sdk.Context) int64 {
// 				panic("mock out the GetMaxInputCount method")
// 			},
// 			GetMinimumWithdrawalAmountFunc: func(ctx sdk.Context) github_com_btcsuite_btcutil.Amount {
// 				panic("mock out the GetMinimumWithdrawalAmount method")
// 			},
// 			GetNetworkFunc: func(ctx sdk.Context) types.Network {
// 				panic("mock out the GetNetwork method")
// 			},
// 			GetOutPointInfoFunc: func(ctx sdk.Context, outPoint wire.OutPoint) (types.OutPointInfo, types.OutPointState, bool) {
// 				panic("mock out the GetOutPointInfo method")
// 			},
// 			GetParamsFunc: func(ctx sdk.Context) types.Params {
// 				panic("mock out the GetParams method")
// 			},
// 			GetPendingOutPointInfoFunc: func(ctx sdk.Context, poll exported.PollKey) (types.OutPointInfo, bool) {
// 				panic("mock out the GetPendingOutPointInfo method")
// 			},
// 			GetRequiredConfirmationHeightFunc: func(ctx sdk.Context) uint64 {
// 				panic("mock out the GetRequiredConfirmationHeight method")
// 			},
// 			GetRevoteLockingPeriodFunc: func(ctx sdk.Context) int64 {
// 				panic("mock out the GetRevoteLockingPeriod method")
// 			},
// 			GetSigCheckIntervalFunc: func(ctx sdk.Context) int64 {
// 				panic("mock out the GetSigCheckInterval method")
// 			},
// 			GetSignedTxFunc: func(ctx sdk.Context, txHash chainhash.Hash) (*wire.MsgTx, bool) {
// 				panic("mock out the GetSignedTx method")
// 			},
// 			GetUnsignedTxFunc: func(ctx sdk.Context) (*types.Transaction, bool) {
// 				panic("mock out the GetUnsignedTx method")
// 			},
// 			LoggerFunc: func(ctx sdk.Context) log.Logger {
// 				panic("mock out the Logger method")
// 			},
// 			SetAddressFunc: func(ctx sdk.Context, address types.AddressInfo)  {
// 				panic("mock out the SetAddress method")
// 			},
// 			SetConfirmedOutpointInfoFunc: func(ctx sdk.Context, keyID string, info types.OutPointInfo)  {
// 				panic("mock out the SetConfirmedOutpointInfo method")
// 			},
// 			SetDustAmountFunc: func(ctx sdk.Context, encodedAddress string, amount github_com_btcsuite_btcutil.Amount)  {
// 				panic("mock out the SetDustAmount method")
// 			},
// 			SetParamsFunc: func(ctx sdk.Context, p types.Params)  {
// 				panic("mock out the SetParams method")
// 			},
// 			SetPendingOutpointInfoFunc: func(ctx sdk.Context, poll exported.PollKey, info types.OutPointInfo)  {
// 				panic("mock out the SetPendingOutpointInfo method")
// 			},
// 			SetSignedTxFunc: func(ctx sdk.Context, tx *wire.MsgTx)  {
// 				panic("mock out the SetSignedTx method")
// 			},
// 			SetSpentOutpointInfoFunc: func(ctx sdk.Context, info types.OutPointInfo)  {
// 				panic("mock out the SetSpentOutpointInfo method")
// 			},
// 			SetUnsignedTxFunc: func(ctx sdk.Context, tx *types.Transaction)  {
// 				panic("mock out the SetUnsignedTx method")
// 			},
// 		}
//
// 		// use mockedBTCKeeper in code that requires types.BTCKeeper
// 		// and then make assertions.
//
// 	}
type BTCKeeperMock struct {
	// DeleteDustAmountFunc mocks the DeleteDustAmount method.
	DeleteDustAmountFunc func(ctx sdk.Context, encodedAddress string)

	// DeleteOutpointInfoFunc mocks the DeleteOutpointInfo method.
	DeleteOutpointInfoFunc func(ctx sdk.Context, outPoint wire.OutPoint)

	// DeletePendingOutPointInfoFunc mocks the DeletePendingOutPointInfo method.
	DeletePendingOutPointInfoFunc func(ctx sdk.Context, poll exported.PollKey)

	// DeleteUnsignedTxFunc mocks the DeleteUnsignedTx method.
	DeleteUnsignedTxFunc func(ctx sdk.Context)

	// GetAddressFunc mocks the GetAddress method.
	GetAddressFunc func(ctx sdk.Context, encodedAddress string) (types.AddressInfo, bool)

	// GetAnyoneCanSpendAddressFunc mocks the GetAnyoneCanSpendAddress method.
	GetAnyoneCanSpendAddressFunc func(ctx sdk.Context) types.AddressInfo

	// GetConfirmedOutpointInfoQueueForKeyFunc mocks the GetConfirmedOutpointInfoQueueForKey method.
	GetConfirmedOutpointInfoQueueForKeyFunc func(ctx sdk.Context, keyID string) utils.KVQueue

	// GetDustAmountFunc mocks the GetDustAmount method.
	GetDustAmountFunc func(ctx sdk.Context, encodedAddress string) github_com_btcsuite_btcutil.Amount

	// GetLatestSignedTxHashFunc mocks the GetLatestSignedTxHash method.
	GetLatestSignedTxHashFunc func(ctx sdk.Context) (*chainhash.Hash, bool)

	// GetMaxInputCountFunc mocks the GetMaxInputCount method.
	GetMaxInputCountFunc func(ctx sdk.Context) int64

	// GetMinimumWithdrawalAmountFunc mocks the GetMinimumWithdrawalAmount method.
	GetMinimumWithdrawalAmountFunc func(ctx sdk.Context) github_com_btcsuite_btcutil.Amount

	// GetNetworkFunc mocks the GetNetwork method.
	GetNetworkFunc func(ctx sdk.Context) types.Network

	// GetOutPointInfoFunc mocks the GetOutPointInfo method.
	GetOutPointInfoFunc func(ctx sdk.Context, outPoint wire.OutPoint) (types.OutPointInfo, types.OutPointState, bool)

	// GetParamsFunc mocks the GetParams method.
	GetParamsFunc func(ctx sdk.Context) types.Params

	// GetPendingOutPointInfoFunc mocks the GetPendingOutPointInfo method.
	GetPendingOutPointInfoFunc func(ctx sdk.Context, poll exported.PollKey) (types.OutPointInfo, bool)

	// GetRequiredConfirmationHeightFunc mocks the GetRequiredConfirmationHeight method.
	GetRequiredConfirmationHeightFunc func(ctx sdk.Context) uint64

	// GetRevoteLockingPeriodFunc mocks the GetRevoteLockingPeriod method.
	GetRevoteLockingPeriodFunc func(ctx sdk.Context) int64

	// GetSigCheckIntervalFunc mocks the GetSigCheckInterval method.
	GetSigCheckIntervalFunc func(ctx sdk.Context) int64

	// GetSignedTxFunc mocks the GetSignedTx method.
	GetSignedTxFunc func(ctx sdk.Context, txHash chainhash.Hash) (*wire.MsgTx, bool)

	// GetUnsignedTxFunc mocks the GetUnsignedTx method.
	GetUnsignedTxFunc func(ctx sdk.Context) (*types.Transaction, bool)

	// LoggerFunc mocks the Logger method.
	LoggerFunc func(ctx sdk.Context) log.Logger

	// SetAddressFunc mocks the SetAddress method.
	SetAddressFunc func(ctx sdk.Context, address types.AddressInfo)

	// SetConfirmedOutpointInfoFunc mocks the SetConfirmedOutpointInfo method.
	SetConfirmedOutpointInfoFunc func(ctx sdk.Context, keyID string, info types.OutPointInfo)

	// SetDustAmountFunc mocks the SetDustAmount method.
	SetDustAmountFunc func(ctx sdk.Context, encodedAddress string, amount github_com_btcsuite_btcutil.Amount)

	// SetParamsFunc mocks the SetParams method.
	SetParamsFunc func(ctx sdk.Context, p types.Params)

	// SetPendingOutpointInfoFunc mocks the SetPendingOutpointInfo method.
	SetPendingOutpointInfoFunc func(ctx sdk.Context, poll exported.PollKey, info types.OutPointInfo)

	// SetSignedTxFunc mocks the SetSignedTx method.
	SetSignedTxFunc func(ctx sdk.Context, tx *wire.MsgTx)

	// SetSpentOutpointInfoFunc mocks the SetSpentOutpointInfo method.
	SetSpentOutpointInfoFunc func(ctx sdk.Context, info types.OutPointInfo)

	// SetUnsignedTxFunc mocks the SetUnsignedTx method.
	SetUnsignedTxFunc func(ctx sdk.Context, tx *types.Transaction)

	// calls tracks calls to the methods.
	calls struct {
		// DeleteDustAmount holds details about calls to the DeleteDustAmount method.
		DeleteDustAmount []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// EncodedAddress is the encodedAddress argument value.
			EncodedAddress string
		}
		// DeleteOutpointInfo holds details about calls to the DeleteOutpointInfo method.
		DeleteOutpointInfo []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// OutPoint is the outPoint argument value.
			OutPoint wire.OutPoint
		}
		// DeletePendingOutPointInfo holds details about calls to the DeletePendingOutPointInfo method.
		DeletePendingOutPointInfo []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Poll is the poll argument value.
			Poll exported.PollKey
		}
		// DeleteUnsignedTx holds details about calls to the DeleteUnsignedTx method.
		DeleteUnsignedTx []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetAddress holds details about calls to the GetAddress method.
		GetAddress []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// EncodedAddress is the encodedAddress argument value.
			EncodedAddress string
		}
		// GetAnyoneCanSpendAddress holds details about calls to the GetAnyoneCanSpendAddress method.
		GetAnyoneCanSpendAddress []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetConfirmedOutpointInfoQueueForKey holds details about calls to the GetConfirmedOutpointInfoQueueForKey method.
		GetConfirmedOutpointInfoQueueForKey []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// KeyID is the keyID argument value.
			KeyID string
		}
		// GetDustAmount holds details about calls to the GetDustAmount method.
		GetDustAmount []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// EncodedAddress is the encodedAddress argument value.
			EncodedAddress string
		}
		// GetLatestSignedTxHash holds details about calls to the GetLatestSignedTxHash method.
		GetLatestSignedTxHash []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetMaxInputCount holds details about calls to the GetMaxInputCount method.
		GetMaxInputCount []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetMinimumWithdrawalAmount holds details about calls to the GetMinimumWithdrawalAmount method.
		GetMinimumWithdrawalAmount []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetNetwork holds details about calls to the GetNetwork method.
		GetNetwork []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetOutPointInfo holds details about calls to the GetOutPointInfo method.
		GetOutPointInfo []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// OutPoint is the outPoint argument value.
			OutPoint wire.OutPoint
		}
		// GetParams holds details about calls to the GetParams method.
		GetParams []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetPendingOutPointInfo holds details about calls to the GetPendingOutPointInfo method.
		GetPendingOutPointInfo []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Poll is the poll argument value.
			Poll exported.PollKey
		}
		// GetRequiredConfirmationHeight holds details about calls to the GetRequiredConfirmationHeight method.
		GetRequiredConfirmationHeight []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetRevoteLockingPeriod holds details about calls to the GetRevoteLockingPeriod method.
		GetRevoteLockingPeriod []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetSigCheckInterval holds details about calls to the GetSigCheckInterval method.
		GetSigCheckInterval []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetSignedTx holds details about calls to the GetSignedTx method.
		GetSignedTx []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// TxHash is the txHash argument value.
			TxHash chainhash.Hash
		}
		// GetUnsignedTx holds details about calls to the GetUnsignedTx method.
		GetUnsignedTx []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// Logger holds details about calls to the Logger method.
		Logger []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// SetAddress holds details about calls to the SetAddress method.
		SetAddress []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Address is the address argument value.
			Address types.AddressInfo
		}
		// SetConfirmedOutpointInfo holds details about calls to the SetConfirmedOutpointInfo method.
		SetConfirmedOutpointInfo []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// KeyID is the keyID argument value.
			KeyID string
			// Info is the info argument value.
			Info types.OutPointInfo
		}
		// SetDustAmount holds details about calls to the SetDustAmount method.
		SetDustAmount []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// EncodedAddress is the encodedAddress argument value.
			EncodedAddress string
			// Amount is the amount argument value.
			Amount github_com_btcsuite_btcutil.Amount
		}
		// SetParams holds details about calls to the SetParams method.
		SetParams []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// P is the p argument value.
			P types.Params
		}
		// SetPendingOutpointInfo holds details about calls to the SetPendingOutpointInfo method.
		SetPendingOutpointInfo []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Poll is the poll argument value.
			Poll exported.PollKey
			// Info is the info argument value.
			Info types.OutPointInfo
		}
		// SetSignedTx holds details about calls to the SetSignedTx method.
		SetSignedTx []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Tx is the tx argument value.
			Tx *wire.MsgTx
		}
		// SetSpentOutpointInfo holds details about calls to the SetSpentOutpointInfo method.
		SetSpentOutpointInfo []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Info is the info argument value.
			Info types.OutPointInfo
		}
		// SetUnsignedTx holds details about calls to the SetUnsignedTx method.
		SetUnsignedTx []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Tx is the tx argument value.
			Tx *types.Transaction
		}
	}
	lockDeleteDustAmount                    sync.RWMutex
	lockDeleteOutpointInfo                  sync.RWMutex
	lockDeletePendingOutPointInfo           sync.RWMutex
	lockDeleteUnsignedTx                    sync.RWMutex
	lockGetAddress                          sync.RWMutex
	lockGetAnyoneCanSpendAddress            sync.RWMutex
	lockGetConfirmedOutpointInfoQueueForKey sync.RWMutex
	lockGetDustAmount                       sync.RWMutex
	lockGetLatestSignedTxHash               sync.RWMutex
	lockGetMaxInputCount                    sync.RWMutex
	lockGetMinimumWithdrawalAmount          sync.RWMutex
	lockGetNetwork                          sync.RWMutex
	lockGetOutPointInfo                     sync.RWMutex
	lockGetParams                           sync.RWMutex
	lockGetPendingOutPointInfo              sync.RWMutex
	lockGetRequiredConfirmationHeight       sync.RWMutex
	lockGetRevoteLockingPeriod              sync.RWMutex
	lockGetSigCheckInterval                 sync.RWMutex
	lockGetSignedTx                         sync.RWMutex
	lockGetUnsignedTx                       sync.RWMutex
	lockLogger                              sync.RWMutex
	lockSetAddress                          sync.RWMutex
	lockSetConfirmedOutpointInfo            sync.RWMutex
	lockSetDustAmount                       sync.RWMutex
	lockSetParams                           sync.RWMutex
	lockSetPendingOutpointInfo              sync.RWMutex
	lockSetSignedTx                         sync.RWMutex
	lockSetSpentOutpointInfo                sync.RWMutex
	lockSetUnsignedTx                       sync.RWMutex
}

// DeleteDustAmount calls DeleteDustAmountFunc.
func (mock *BTCKeeperMock) DeleteDustAmount(ctx sdk.Context, encodedAddress string) {
	if mock.DeleteDustAmountFunc == nil {
		panic("BTCKeeperMock.DeleteDustAmountFunc: method is nil but BTCKeeper.DeleteDustAmount was just called")
	}
	callInfo := struct {
		Ctx            sdk.Context
		EncodedAddress string
	}{
		Ctx:            ctx,
		EncodedAddress: encodedAddress,
	}
	mock.lockDeleteDustAmount.Lock()
	mock.calls.DeleteDustAmount = append(mock.calls.DeleteDustAmount, callInfo)
	mock.lockDeleteDustAmount.Unlock()
	mock.DeleteDustAmountFunc(ctx, encodedAddress)
}

// DeleteDustAmountCalls gets all the calls that were made to DeleteDustAmount.
// Check the length with:
//     len(mockedBTCKeeper.DeleteDustAmountCalls())
func (mock *BTCKeeperMock) DeleteDustAmountCalls() []struct {
	Ctx            sdk.Context
	EncodedAddress string
} {
	var calls []struct {
		Ctx            sdk.Context
		EncodedAddress string
	}
	mock.lockDeleteDustAmount.RLock()
	calls = mock.calls.DeleteDustAmount
	mock.lockDeleteDustAmount.RUnlock()
	return calls
}

// DeleteOutpointInfo calls DeleteOutpointInfoFunc.
func (mock *BTCKeeperMock) DeleteOutpointInfo(ctx sdk.Context, outPoint wire.OutPoint) {
	if mock.DeleteOutpointInfoFunc == nil {
		panic("BTCKeeperMock.DeleteOutpointInfoFunc: method is nil but BTCKeeper.DeleteOutpointInfo was just called")
	}
	callInfo := struct {
		Ctx      sdk.Context
		OutPoint wire.OutPoint
	}{
		Ctx:      ctx,
		OutPoint: outPoint,
	}
	mock.lockDeleteOutpointInfo.Lock()
	mock.calls.DeleteOutpointInfo = append(mock.calls.DeleteOutpointInfo, callInfo)
	mock.lockDeleteOutpointInfo.Unlock()
	mock.DeleteOutpointInfoFunc(ctx, outPoint)
}

// DeleteOutpointInfoCalls gets all the calls that were made to DeleteOutpointInfo.
// Check the length with:
//     len(mockedBTCKeeper.DeleteOutpointInfoCalls())
func (mock *BTCKeeperMock) DeleteOutpointInfoCalls() []struct {
	Ctx      sdk.Context
	OutPoint wire.OutPoint
} {
	var calls []struct {
		Ctx      sdk.Context
		OutPoint wire.OutPoint
	}
	mock.lockDeleteOutpointInfo.RLock()
	calls = mock.calls.DeleteOutpointInfo
	mock.lockDeleteOutpointInfo.RUnlock()
	return calls
}

// DeletePendingOutPointInfo calls DeletePendingOutPointInfoFunc.
func (mock *BTCKeeperMock) DeletePendingOutPointInfo(ctx sdk.Context, poll exported.PollKey) {
	if mock.DeletePendingOutPointInfoFunc == nil {
		panic("BTCKeeperMock.DeletePendingOutPointInfoFunc: method is nil but BTCKeeper.DeletePendingOutPointInfo was just called")
	}
	callInfo := struct {
		Ctx  sdk.Context
		Poll exported.PollKey
	}{
		Ctx:  ctx,
		Poll: poll,
	}
	mock.lockDeletePendingOutPointInfo.Lock()
	mock.calls.DeletePendingOutPointInfo = append(mock.calls.DeletePendingOutPointInfo, callInfo)
	mock.lockDeletePendingOutPointInfo.Unlock()
	mock.DeletePendingOutPointInfoFunc(ctx, poll)
}

// DeletePendingOutPointInfoCalls gets all the calls that were made to DeletePendingOutPointInfo.
// Check the length with:
//     len(mockedBTCKeeper.DeletePendingOutPointInfoCalls())
func (mock *BTCKeeperMock) DeletePendingOutPointInfoCalls() []struct {
	Ctx  sdk.Context
	Poll exported.PollKey
} {
	var calls []struct {
		Ctx  sdk.Context
		Poll exported.PollKey
	}
	mock.lockDeletePendingOutPointInfo.RLock()
	calls = mock.calls.DeletePendingOutPointInfo
	mock.lockDeletePendingOutPointInfo.RUnlock()
	return calls
}

// DeleteUnsignedTx calls DeleteUnsignedTxFunc.
func (mock *BTCKeeperMock) DeleteUnsignedTx(ctx sdk.Context) {
	if mock.DeleteUnsignedTxFunc == nil {
		panic("BTCKeeperMock.DeleteUnsignedTxFunc: method is nil but BTCKeeper.DeleteUnsignedTx was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockDeleteUnsignedTx.Lock()
	mock.calls.DeleteUnsignedTx = append(mock.calls.DeleteUnsignedTx, callInfo)
	mock.lockDeleteUnsignedTx.Unlock()
	mock.DeleteUnsignedTxFunc(ctx)
}

// DeleteUnsignedTxCalls gets all the calls that were made to DeleteUnsignedTx.
// Check the length with:
//     len(mockedBTCKeeper.DeleteUnsignedTxCalls())
func (mock *BTCKeeperMock) DeleteUnsignedTxCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockDeleteUnsignedTx.RLock()
	calls = mock.calls.DeleteUnsignedTx
	mock.lockDeleteUnsignedTx.RUnlock()
	return calls
}

// GetAddress calls GetAddressFunc.
func (mock *BTCKeeperMock) GetAddress(ctx sdk.Context, encodedAddress string) (types.AddressInfo, bool) {
	if mock.GetAddressFunc == nil {
		panic("BTCKeeperMock.GetAddressFunc: method is nil but BTCKeeper.GetAddress was just called")
	}
	callInfo := struct {
		Ctx            sdk.Context
		EncodedAddress string
	}{
		Ctx:            ctx,
		EncodedAddress: encodedAddress,
	}
	mock.lockGetAddress.Lock()
	mock.calls.GetAddress = append(mock.calls.GetAddress, callInfo)
	mock.lockGetAddress.Unlock()
	return mock.GetAddressFunc(ctx, encodedAddress)
}

// GetAddressCalls gets all the calls that were made to GetAddress.
// Check the length with:
//     len(mockedBTCKeeper.GetAddressCalls())
func (mock *BTCKeeperMock) GetAddressCalls() []struct {
	Ctx            sdk.Context
	EncodedAddress string
} {
	var calls []struct {
		Ctx            sdk.Context
		EncodedAddress string
	}
	mock.lockGetAddress.RLock()
	calls = mock.calls.GetAddress
	mock.lockGetAddress.RUnlock()
	return calls
}

// GetAnyoneCanSpendAddress calls GetAnyoneCanSpendAddressFunc.
func (mock *BTCKeeperMock) GetAnyoneCanSpendAddress(ctx sdk.Context) types.AddressInfo {
	if mock.GetAnyoneCanSpendAddressFunc == nil {
		panic("BTCKeeperMock.GetAnyoneCanSpendAddressFunc: method is nil but BTCKeeper.GetAnyoneCanSpendAddress was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAnyoneCanSpendAddress.Lock()
	mock.calls.GetAnyoneCanSpendAddress = append(mock.calls.GetAnyoneCanSpendAddress, callInfo)
	mock.lockGetAnyoneCanSpendAddress.Unlock()
	return mock.GetAnyoneCanSpendAddressFunc(ctx)
}

// GetAnyoneCanSpendAddressCalls gets all the calls that were made to GetAnyoneCanSpendAddress.
// Check the length with:
//     len(mockedBTCKeeper.GetAnyoneCanSpendAddressCalls())
func (mock *BTCKeeperMock) GetAnyoneCanSpendAddressCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetAnyoneCanSpendAddress.RLock()
	calls = mock.calls.GetAnyoneCanSpendAddress
	mock.lockGetAnyoneCanSpendAddress.RUnlock()
	return calls
}

// GetConfirmedOutpointInfoQueueForKey calls GetConfirmedOutpointInfoQueueForKeyFunc.
func (mock *BTCKeeperMock) GetConfirmedOutpointInfoQueueForKey(ctx sdk.Context, keyID string) utils.KVQueue {
	if mock.GetConfirmedOutpointInfoQueueForKeyFunc == nil {
		panic("BTCKeeperMock.GetConfirmedOutpointInfoQueueForKeyFunc: method is nil but BTCKeeper.GetConfirmedOutpointInfoQueueForKey was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		KeyID string
	}{
		Ctx:   ctx,
		KeyID: keyID,
	}
	mock.lockGetConfirmedOutpointInfoQueueForKey.Lock()
	mock.calls.GetConfirmedOutpointInfoQueueForKey = append(mock.calls.GetConfirmedOutpointInfoQueueForKey, callInfo)
	mock.lockGetConfirmedOutpointInfoQueueForKey.Unlock()
	return mock.GetConfirmedOutpointInfoQueueForKeyFunc(ctx, keyID)
}

// GetConfirmedOutpointInfoQueueForKeyCalls gets all the calls that were made to GetConfirmedOutpointInfoQueueForKey.
// Check the length with:
//     len(mockedBTCKeeper.GetConfirmedOutpointInfoQueueForKeyCalls())
func (mock *BTCKeeperMock) GetConfirmedOutpointInfoQueueForKeyCalls() []struct {
	Ctx   sdk.Context
	KeyID string
} {
	var calls []struct {
		Ctx   sdk.Context
		KeyID string
	}
	mock.lockGetConfirmedOutpointInfoQueueForKey.RLock()
	calls = mock.calls.GetConfirmedOutpointInfoQueueForKey
	mock.lockGetConfirmedOutpointInfoQueueForKey.RUnlock()
	return calls
}

// GetDustAmount calls GetDustAmountFunc.
func (mock *BTCKeeperMock) GetDustAmount(ctx sdk.Context, encodedAddress string) github_com_btcsuite_btcutil.Amount {
	if mock.GetDustAmountFunc == nil {
		panic("BTCKeeperMock.GetDustAmountFunc: method is nil but BTCKeeper.GetDustAmount was just called")
	}
	callInfo := struct {
		Ctx            sdk.Context
		EncodedAddress string
	}{
		Ctx:            ctx,
		EncodedAddress: encodedAddress,
	}
	mock.lockGetDustAmount.Lock()
	mock.calls.GetDustAmount = append(mock.calls.GetDustAmount, callInfo)
	mock.lockGetDustAmount.Unlock()
	return mock.GetDustAmountFunc(ctx, encodedAddress)
}

// GetDustAmountCalls gets all the calls that were made to GetDustAmount.
// Check the length with:
//     len(mockedBTCKeeper.GetDustAmountCalls())
func (mock *BTCKeeperMock) GetDustAmountCalls() []struct {
	Ctx            sdk.Context
	EncodedAddress string
} {
	var calls []struct {
		Ctx            sdk.Context
		EncodedAddress string
	}
	mock.lockGetDustAmount.RLock()
	calls = mock.calls.GetDustAmount
	mock.lockGetDustAmount.RUnlock()
	return calls
}

// GetLatestSignedTxHash calls GetLatestSignedTxHashFunc.
func (mock *BTCKeeperMock) GetLatestSignedTxHash(ctx sdk.Context) (*chainhash.Hash, bool) {
	if mock.GetLatestSignedTxHashFunc == nil {
		panic("BTCKeeperMock.GetLatestSignedTxHashFunc: method is nil but BTCKeeper.GetLatestSignedTxHash was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetLatestSignedTxHash.Lock()
	mock.calls.GetLatestSignedTxHash = append(mock.calls.GetLatestSignedTxHash, callInfo)
	mock.lockGetLatestSignedTxHash.Unlock()
	return mock.GetLatestSignedTxHashFunc(ctx)
}

// GetLatestSignedTxHashCalls gets all the calls that were made to GetLatestSignedTxHash.
// Check the length with:
//     len(mockedBTCKeeper.GetLatestSignedTxHashCalls())
func (mock *BTCKeeperMock) GetLatestSignedTxHashCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetLatestSignedTxHash.RLock()
	calls = mock.calls.GetLatestSignedTxHash
	mock.lockGetLatestSignedTxHash.RUnlock()
	return calls
}

// GetMaxInputCount calls GetMaxInputCountFunc.
func (mock *BTCKeeperMock) GetMaxInputCount(ctx sdk.Context) int64 {
	if mock.GetMaxInputCountFunc == nil {
		panic("BTCKeeperMock.GetMaxInputCountFunc: method is nil but BTCKeeper.GetMaxInputCount was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetMaxInputCount.Lock()
	mock.calls.GetMaxInputCount = append(mock.calls.GetMaxInputCount, callInfo)
	mock.lockGetMaxInputCount.Unlock()
	return mock.GetMaxInputCountFunc(ctx)
}

// GetMaxInputCountCalls gets all the calls that were made to GetMaxInputCount.
// Check the length with:
//     len(mockedBTCKeeper.GetMaxInputCountCalls())
func (mock *BTCKeeperMock) GetMaxInputCountCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetMaxInputCount.RLock()
	calls = mock.calls.GetMaxInputCount
	mock.lockGetMaxInputCount.RUnlock()
	return calls
}

// GetMinimumWithdrawalAmount calls GetMinimumWithdrawalAmountFunc.
func (mock *BTCKeeperMock) GetMinimumWithdrawalAmount(ctx sdk.Context) github_com_btcsuite_btcutil.Amount {
	if mock.GetMinimumWithdrawalAmountFunc == nil {
		panic("BTCKeeperMock.GetMinimumWithdrawalAmountFunc: method is nil but BTCKeeper.GetMinimumWithdrawalAmount was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetMinimumWithdrawalAmount.Lock()
	mock.calls.GetMinimumWithdrawalAmount = append(mock.calls.GetMinimumWithdrawalAmount, callInfo)
	mock.lockGetMinimumWithdrawalAmount.Unlock()
	return mock.GetMinimumWithdrawalAmountFunc(ctx)
}

// GetMinimumWithdrawalAmountCalls gets all the calls that were made to GetMinimumWithdrawalAmount.
// Check the length with:
//     len(mockedBTCKeeper.GetMinimumWithdrawalAmountCalls())
func (mock *BTCKeeperMock) GetMinimumWithdrawalAmountCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetMinimumWithdrawalAmount.RLock()
	calls = mock.calls.GetMinimumWithdrawalAmount
	mock.lockGetMinimumWithdrawalAmount.RUnlock()
	return calls
}

// GetNetwork calls GetNetworkFunc.
func (mock *BTCKeeperMock) GetNetwork(ctx sdk.Context) types.Network {
	if mock.GetNetworkFunc == nil {
		panic("BTCKeeperMock.GetNetworkFunc: method is nil but BTCKeeper.GetNetwork was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetNetwork.Lock()
	mock.calls.GetNetwork = append(mock.calls.GetNetwork, callInfo)
	mock.lockGetNetwork.Unlock()
	return mock.GetNetworkFunc(ctx)
}

// GetNetworkCalls gets all the calls that were made to GetNetwork.
// Check the length with:
//     len(mockedBTCKeeper.GetNetworkCalls())
func (mock *BTCKeeperMock) GetNetworkCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetNetwork.RLock()
	calls = mock.calls.GetNetwork
	mock.lockGetNetwork.RUnlock()
	return calls
}

// GetOutPointInfo calls GetOutPointInfoFunc.
func (mock *BTCKeeperMock) GetOutPointInfo(ctx sdk.Context, outPoint wire.OutPoint) (types.OutPointInfo, types.OutPointState, bool) {
	if mock.GetOutPointInfoFunc == nil {
		panic("BTCKeeperMock.GetOutPointInfoFunc: method is nil but BTCKeeper.GetOutPointInfo was just called")
	}
	callInfo := struct {
		Ctx      sdk.Context
		OutPoint wire.OutPoint
	}{
		Ctx:      ctx,
		OutPoint: outPoint,
	}
	mock.lockGetOutPointInfo.Lock()
	mock.calls.GetOutPointInfo = append(mock.calls.GetOutPointInfo, callInfo)
	mock.lockGetOutPointInfo.Unlock()
	return mock.GetOutPointInfoFunc(ctx, outPoint)
}

// GetOutPointInfoCalls gets all the calls that were made to GetOutPointInfo.
// Check the length with:
//     len(mockedBTCKeeper.GetOutPointInfoCalls())
func (mock *BTCKeeperMock) GetOutPointInfoCalls() []struct {
	Ctx      sdk.Context
	OutPoint wire.OutPoint
} {
	var calls []struct {
		Ctx      sdk.Context
		OutPoint wire.OutPoint
	}
	mock.lockGetOutPointInfo.RLock()
	calls = mock.calls.GetOutPointInfo
	mock.lockGetOutPointInfo.RUnlock()
	return calls
}

// GetParams calls GetParamsFunc.
func (mock *BTCKeeperMock) GetParams(ctx sdk.Context) types.Params {
	if mock.GetParamsFunc == nil {
		panic("BTCKeeperMock.GetParamsFunc: method is nil but BTCKeeper.GetParams was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetParams.Lock()
	mock.calls.GetParams = append(mock.calls.GetParams, callInfo)
	mock.lockGetParams.Unlock()
	return mock.GetParamsFunc(ctx)
}

// GetParamsCalls gets all the calls that were made to GetParams.
// Check the length with:
//     len(mockedBTCKeeper.GetParamsCalls())
func (mock *BTCKeeperMock) GetParamsCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetParams.RLock()
	calls = mock.calls.GetParams
	mock.lockGetParams.RUnlock()
	return calls
}

// GetPendingOutPointInfo calls GetPendingOutPointInfoFunc.
func (mock *BTCKeeperMock) GetPendingOutPointInfo(ctx sdk.Context, poll exported.PollKey) (types.OutPointInfo, bool) {
	if mock.GetPendingOutPointInfoFunc == nil {
		panic("BTCKeeperMock.GetPendingOutPointInfoFunc: method is nil but BTCKeeper.GetPendingOutPointInfo was just called")
	}
	callInfo := struct {
		Ctx  sdk.Context
		Poll exported.PollKey
	}{
		Ctx:  ctx,
		Poll: poll,
	}
	mock.lockGetPendingOutPointInfo.Lock()
	mock.calls.GetPendingOutPointInfo = append(mock.calls.GetPendingOutPointInfo, callInfo)
	mock.lockGetPendingOutPointInfo.Unlock()
	return mock.GetPendingOutPointInfoFunc(ctx, poll)
}

// GetPendingOutPointInfoCalls gets all the calls that were made to GetPendingOutPointInfo.
// Check the length with:
//     len(mockedBTCKeeper.GetPendingOutPointInfoCalls())
func (mock *BTCKeeperMock) GetPendingOutPointInfoCalls() []struct {
	Ctx  sdk.Context
	Poll exported.PollKey
} {
	var calls []struct {
		Ctx  sdk.Context
		Poll exported.PollKey
	}
	mock.lockGetPendingOutPointInfo.RLock()
	calls = mock.calls.GetPendingOutPointInfo
	mock.lockGetPendingOutPointInfo.RUnlock()
	return calls
}

// GetRequiredConfirmationHeight calls GetRequiredConfirmationHeightFunc.
func (mock *BTCKeeperMock) GetRequiredConfirmationHeight(ctx sdk.Context) uint64 {
	if mock.GetRequiredConfirmationHeightFunc == nil {
		panic("BTCKeeperMock.GetRequiredConfirmationHeightFunc: method is nil but BTCKeeper.GetRequiredConfirmationHeight was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetRequiredConfirmationHeight.Lock()
	mock.calls.GetRequiredConfirmationHeight = append(mock.calls.GetRequiredConfirmationHeight, callInfo)
	mock.lockGetRequiredConfirmationHeight.Unlock()
	return mock.GetRequiredConfirmationHeightFunc(ctx)
}

// GetRequiredConfirmationHeightCalls gets all the calls that were made to GetRequiredConfirmationHeight.
// Check the length with:
//     len(mockedBTCKeeper.GetRequiredConfirmationHeightCalls())
func (mock *BTCKeeperMock) GetRequiredConfirmationHeightCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetRequiredConfirmationHeight.RLock()
	calls = mock.calls.GetRequiredConfirmationHeight
	mock.lockGetRequiredConfirmationHeight.RUnlock()
	return calls
}

// GetRevoteLockingPeriod calls GetRevoteLockingPeriodFunc.
func (mock *BTCKeeperMock) GetRevoteLockingPeriod(ctx sdk.Context) int64 {
	if mock.GetRevoteLockingPeriodFunc == nil {
		panic("BTCKeeperMock.GetRevoteLockingPeriodFunc: method is nil but BTCKeeper.GetRevoteLockingPeriod was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetRevoteLockingPeriod.Lock()
	mock.calls.GetRevoteLockingPeriod = append(mock.calls.GetRevoteLockingPeriod, callInfo)
	mock.lockGetRevoteLockingPeriod.Unlock()
	return mock.GetRevoteLockingPeriodFunc(ctx)
}

// GetRevoteLockingPeriodCalls gets all the calls that were made to GetRevoteLockingPeriod.
// Check the length with:
//     len(mockedBTCKeeper.GetRevoteLockingPeriodCalls())
func (mock *BTCKeeperMock) GetRevoteLockingPeriodCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetRevoteLockingPeriod.RLock()
	calls = mock.calls.GetRevoteLockingPeriod
	mock.lockGetRevoteLockingPeriod.RUnlock()
	return calls
}

// GetSigCheckInterval calls GetSigCheckIntervalFunc.
func (mock *BTCKeeperMock) GetSigCheckInterval(ctx sdk.Context) int64 {
	if mock.GetSigCheckIntervalFunc == nil {
		panic("BTCKeeperMock.GetSigCheckIntervalFunc: method is nil but BTCKeeper.GetSigCheckInterval was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetSigCheckInterval.Lock()
	mock.calls.GetSigCheckInterval = append(mock.calls.GetSigCheckInterval, callInfo)
	mock.lockGetSigCheckInterval.Unlock()
	return mock.GetSigCheckIntervalFunc(ctx)
}

// GetSigCheckIntervalCalls gets all the calls that were made to GetSigCheckInterval.
// Check the length with:
//     len(mockedBTCKeeper.GetSigCheckIntervalCalls())
func (mock *BTCKeeperMock) GetSigCheckIntervalCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetSigCheckInterval.RLock()
	calls = mock.calls.GetSigCheckInterval
	mock.lockGetSigCheckInterval.RUnlock()
	return calls
}

// GetSignedTx calls GetSignedTxFunc.
func (mock *BTCKeeperMock) GetSignedTx(ctx sdk.Context, txHash chainhash.Hash) (*wire.MsgTx, bool) {
	if mock.GetSignedTxFunc == nil {
		panic("BTCKeeperMock.GetSignedTxFunc: method is nil but BTCKeeper.GetSignedTx was just called")
	}
	callInfo := struct {
		Ctx    sdk.Context
		TxHash chainhash.Hash
	}{
		Ctx:    ctx,
		TxHash: txHash,
	}
	mock.lockGetSignedTx.Lock()
	mock.calls.GetSignedTx = append(mock.calls.GetSignedTx, callInfo)
	mock.lockGetSignedTx.Unlock()
	return mock.GetSignedTxFunc(ctx, txHash)
}

// GetSignedTxCalls gets all the calls that were made to GetSignedTx.
// Check the length with:
//     len(mockedBTCKeeper.GetSignedTxCalls())
func (mock *BTCKeeperMock) GetSignedTxCalls() []struct {
	Ctx    sdk.Context
	TxHash chainhash.Hash
} {
	var calls []struct {
		Ctx    sdk.Context
		TxHash chainhash.Hash
	}
	mock.lockGetSignedTx.RLock()
	calls = mock.calls.GetSignedTx
	mock.lockGetSignedTx.RUnlock()
	return calls
}

// GetUnsignedTx calls GetUnsignedTxFunc.
func (mock *BTCKeeperMock) GetUnsignedTx(ctx sdk.Context) (*types.Transaction, bool) {
	if mock.GetUnsignedTxFunc == nil {
		panic("BTCKeeperMock.GetUnsignedTxFunc: method is nil but BTCKeeper.GetUnsignedTx was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetUnsignedTx.Lock()
	mock.calls.GetUnsignedTx = append(mock.calls.GetUnsignedTx, callInfo)
	mock.lockGetUnsignedTx.Unlock()
	return mock.GetUnsignedTxFunc(ctx)
}

// GetUnsignedTxCalls gets all the calls that were made to GetUnsignedTx.
// Check the length with:
//     len(mockedBTCKeeper.GetUnsignedTxCalls())
func (mock *BTCKeeperMock) GetUnsignedTxCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetUnsignedTx.RLock()
	calls = mock.calls.GetUnsignedTx
	mock.lockGetUnsignedTx.RUnlock()
	return calls
}

// Logger calls LoggerFunc.
func (mock *BTCKeeperMock) Logger(ctx sdk.Context) log.Logger {
	if mock.LoggerFunc == nil {
		panic("BTCKeeperMock.LoggerFunc: method is nil but BTCKeeper.Logger was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockLogger.Lock()
	mock.calls.Logger = append(mock.calls.Logger, callInfo)
	mock.lockLogger.Unlock()
	return mock.LoggerFunc(ctx)
}

// LoggerCalls gets all the calls that were made to Logger.
// Check the length with:
//     len(mockedBTCKeeper.LoggerCalls())
func (mock *BTCKeeperMock) LoggerCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockLogger.RLock()
	calls = mock.calls.Logger
	mock.lockLogger.RUnlock()
	return calls
}

// SetAddress calls SetAddressFunc.
func (mock *BTCKeeperMock) SetAddress(ctx sdk.Context, address types.AddressInfo) {
	if mock.SetAddressFunc == nil {
		panic("BTCKeeperMock.SetAddressFunc: method is nil but BTCKeeper.SetAddress was just called")
	}
	callInfo := struct {
		Ctx     sdk.Context
		Address types.AddressInfo
	}{
		Ctx:     ctx,
		Address: address,
	}
	mock.lockSetAddress.Lock()
	mock.calls.SetAddress = append(mock.calls.SetAddress, callInfo)
	mock.lockSetAddress.Unlock()
	mock.SetAddressFunc(ctx, address)
}

// SetAddressCalls gets all the calls that were made to SetAddress.
// Check the length with:
//     len(mockedBTCKeeper.SetAddressCalls())
func (mock *BTCKeeperMock) SetAddressCalls() []struct {
	Ctx     sdk.Context
	Address types.AddressInfo
} {
	var calls []struct {
		Ctx     sdk.Context
		Address types.AddressInfo
	}
	mock.lockSetAddress.RLock()
	calls = mock.calls.SetAddress
	mock.lockSetAddress.RUnlock()
	return calls
}

// SetConfirmedOutpointInfo calls SetConfirmedOutpointInfoFunc.
func (mock *BTCKeeperMock) SetConfirmedOutpointInfo(ctx sdk.Context, keyID string, info types.OutPointInfo) {
	if mock.SetConfirmedOutpointInfoFunc == nil {
		panic("BTCKeeperMock.SetConfirmedOutpointInfoFunc: method is nil but BTCKeeper.SetConfirmedOutpointInfo was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		KeyID string
		Info  types.OutPointInfo
	}{
		Ctx:   ctx,
		KeyID: keyID,
		Info:  info,
	}
	mock.lockSetConfirmedOutpointInfo.Lock()
	mock.calls.SetConfirmedOutpointInfo = append(mock.calls.SetConfirmedOutpointInfo, callInfo)
	mock.lockSetConfirmedOutpointInfo.Unlock()
	mock.SetConfirmedOutpointInfoFunc(ctx, keyID, info)
}

// SetConfirmedOutpointInfoCalls gets all the calls that were made to SetConfirmedOutpointInfo.
// Check the length with:
//     len(mockedBTCKeeper.SetConfirmedOutpointInfoCalls())
func (mock *BTCKeeperMock) SetConfirmedOutpointInfoCalls() []struct {
	Ctx   sdk.Context
	KeyID string
	Info  types.OutPointInfo
} {
	var calls []struct {
		Ctx   sdk.Context
		KeyID string
		Info  types.OutPointInfo
	}
	mock.lockSetConfirmedOutpointInfo.RLock()
	calls = mock.calls.SetConfirmedOutpointInfo
	mock.lockSetConfirmedOutpointInfo.RUnlock()
	return calls
}

// SetDustAmount calls SetDustAmountFunc.
func (mock *BTCKeeperMock) SetDustAmount(ctx sdk.Context, encodedAddress string, amount github_com_btcsuite_btcutil.Amount) {
	if mock.SetDustAmountFunc == nil {
		panic("BTCKeeperMock.SetDustAmountFunc: method is nil but BTCKeeper.SetDustAmount was just called")
	}
	callInfo := struct {
		Ctx            sdk.Context
		EncodedAddress string
		Amount         github_com_btcsuite_btcutil.Amount
	}{
		Ctx:            ctx,
		EncodedAddress: encodedAddress,
		Amount:         amount,
	}
	mock.lockSetDustAmount.Lock()
	mock.calls.SetDustAmount = append(mock.calls.SetDustAmount, callInfo)
	mock.lockSetDustAmount.Unlock()
	mock.SetDustAmountFunc(ctx, encodedAddress, amount)
}

// SetDustAmountCalls gets all the calls that were made to SetDustAmount.
// Check the length with:
//     len(mockedBTCKeeper.SetDustAmountCalls())
func (mock *BTCKeeperMock) SetDustAmountCalls() []struct {
	Ctx            sdk.Context
	EncodedAddress string
	Amount         github_com_btcsuite_btcutil.Amount
} {
	var calls []struct {
		Ctx            sdk.Context
		EncodedAddress string
		Amount         github_com_btcsuite_btcutil.Amount
	}
	mock.lockSetDustAmount.RLock()
	calls = mock.calls.SetDustAmount
	mock.lockSetDustAmount.RUnlock()
	return calls
}

// SetParams calls SetParamsFunc.
func (mock *BTCKeeperMock) SetParams(ctx sdk.Context, p types.Params) {
	if mock.SetParamsFunc == nil {
		panic("BTCKeeperMock.SetParamsFunc: method is nil but BTCKeeper.SetParams was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
		P   types.Params
	}{
		Ctx: ctx,
		P:   p,
	}
	mock.lockSetParams.Lock()
	mock.calls.SetParams = append(mock.calls.SetParams, callInfo)
	mock.lockSetParams.Unlock()
	mock.SetParamsFunc(ctx, p)
}

// SetParamsCalls gets all the calls that were made to SetParams.
// Check the length with:
//     len(mockedBTCKeeper.SetParamsCalls())
func (mock *BTCKeeperMock) SetParamsCalls() []struct {
	Ctx sdk.Context
	P   types.Params
} {
	var calls []struct {
		Ctx sdk.Context
		P   types.Params
	}
	mock.lockSetParams.RLock()
	calls = mock.calls.SetParams
	mock.lockSetParams.RUnlock()
	return calls
}

// SetPendingOutpointInfo calls SetPendingOutpointInfoFunc.
func (mock *BTCKeeperMock) SetPendingOutpointInfo(ctx sdk.Context, poll exported.PollKey, info types.OutPointInfo) {
	if mock.SetPendingOutpointInfoFunc == nil {
		panic("BTCKeeperMock.SetPendingOutpointInfoFunc: method is nil but BTCKeeper.SetPendingOutpointInfo was just called")
	}
	callInfo := struct {
		Ctx  sdk.Context
		Poll exported.PollKey
		Info types.OutPointInfo
	}{
		Ctx:  ctx,
		Poll: poll,
		Info: info,
	}
	mock.lockSetPendingOutpointInfo.Lock()
	mock.calls.SetPendingOutpointInfo = append(mock.calls.SetPendingOutpointInfo, callInfo)
	mock.lockSetPendingOutpointInfo.Unlock()
	mock.SetPendingOutpointInfoFunc(ctx, poll, info)
}

// SetPendingOutpointInfoCalls gets all the calls that were made to SetPendingOutpointInfo.
// Check the length with:
//     len(mockedBTCKeeper.SetPendingOutpointInfoCalls())
func (mock *BTCKeeperMock) SetPendingOutpointInfoCalls() []struct {
	Ctx  sdk.Context
	Poll exported.PollKey
	Info types.OutPointInfo
} {
	var calls []struct {
		Ctx  sdk.Context
		Poll exported.PollKey
		Info types.OutPointInfo
	}
	mock.lockSetPendingOutpointInfo.RLock()
	calls = mock.calls.SetPendingOutpointInfo
	mock.lockSetPendingOutpointInfo.RUnlock()
	return calls
}

// SetSignedTx calls SetSignedTxFunc.
func (mock *BTCKeeperMock) SetSignedTx(ctx sdk.Context, tx *wire.MsgTx) {
	if mock.SetSignedTxFunc == nil {
		panic("BTCKeeperMock.SetSignedTxFunc: method is nil but BTCKeeper.SetSignedTx was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
		Tx  *wire.MsgTx
	}{
		Ctx: ctx,
		Tx:  tx,
	}
	mock.lockSetSignedTx.Lock()
	mock.calls.SetSignedTx = append(mock.calls.SetSignedTx, callInfo)
	mock.lockSetSignedTx.Unlock()
	mock.SetSignedTxFunc(ctx, tx)
}

// SetSignedTxCalls gets all the calls that were made to SetSignedTx.
// Check the length with:
//     len(mockedBTCKeeper.SetSignedTxCalls())
func (mock *BTCKeeperMock) SetSignedTxCalls() []struct {
	Ctx sdk.Context
	Tx  *wire.MsgTx
} {
	var calls []struct {
		Ctx sdk.Context
		Tx  *wire.MsgTx
	}
	mock.lockSetSignedTx.RLock()
	calls = mock.calls.SetSignedTx
	mock.lockSetSignedTx.RUnlock()
	return calls
}

// SetSpentOutpointInfo calls SetSpentOutpointInfoFunc.
func (mock *BTCKeeperMock) SetSpentOutpointInfo(ctx sdk.Context, info types.OutPointInfo) {
	if mock.SetSpentOutpointInfoFunc == nil {
		panic("BTCKeeperMock.SetSpentOutpointInfoFunc: method is nil but BTCKeeper.SetSpentOutpointInfo was just called")
	}
	callInfo := struct {
		Ctx  sdk.Context
		Info types.OutPointInfo
	}{
		Ctx:  ctx,
		Info: info,
	}
	mock.lockSetSpentOutpointInfo.Lock()
	mock.calls.SetSpentOutpointInfo = append(mock.calls.SetSpentOutpointInfo, callInfo)
	mock.lockSetSpentOutpointInfo.Unlock()
	mock.SetSpentOutpointInfoFunc(ctx, info)
}

// SetSpentOutpointInfoCalls gets all the calls that were made to SetSpentOutpointInfo.
// Check the length with:
//     len(mockedBTCKeeper.SetSpentOutpointInfoCalls())
func (mock *BTCKeeperMock) SetSpentOutpointInfoCalls() []struct {
	Ctx  sdk.Context
	Info types.OutPointInfo
} {
	var calls []struct {
		Ctx  sdk.Context
		Info types.OutPointInfo
	}
	mock.lockSetSpentOutpointInfo.RLock()
	calls = mock.calls.SetSpentOutpointInfo
	mock.lockSetSpentOutpointInfo.RUnlock()
	return calls
}

// SetUnsignedTx calls SetUnsignedTxFunc.
func (mock *BTCKeeperMock) SetUnsignedTx(ctx sdk.Context, tx *types.Transaction) {
	if mock.SetUnsignedTxFunc == nil {
		panic("BTCKeeperMock.SetUnsignedTxFunc: method is nil but BTCKeeper.SetUnsignedTx was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
		Tx  *types.Transaction
	}{
		Ctx: ctx,
		Tx:  tx,
	}
	mock.lockSetUnsignedTx.Lock()
	mock.calls.SetUnsignedTx = append(mock.calls.SetUnsignedTx, callInfo)
	mock.lockSetUnsignedTx.Unlock()
	mock.SetUnsignedTxFunc(ctx, tx)
}

// SetUnsignedTxCalls gets all the calls that were made to SetUnsignedTx.
// Check the length with:
//     len(mockedBTCKeeper.SetUnsignedTxCalls())
func (mock *BTCKeeperMock) SetUnsignedTxCalls() []struct {
	Ctx sdk.Context
	Tx  *types.Transaction
} {
	var calls []struct {
		Ctx sdk.Context
		Tx  *types.Transaction
	}
	mock.lockSetUnsignedTx.RLock()
	calls = mock.calls.SetUnsignedTx
	mock.lockSetUnsignedTx.RUnlock()
	return calls
}
