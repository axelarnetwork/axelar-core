// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"github.com/axelarnetwork/axelar-core/x/bitcoin/types"
	nexus "github.com/axelarnetwork/axelar-core/x/nexus/exported"
	snapshot "github.com/axelarnetwork/axelar-core/x/snapshot/exported"
	tss "github.com/axelarnetwork/axelar-core/x/tss/exported"
	exported "github.com/axelarnetwork/axelar-core/x/vote/exported"
	"github.com/btcsuite/btcd/wire"
	"github.com/cosmos/cosmos-sdk/codec"
	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/tendermint/tendermint/libs/log"
	"sync"
)

// Ensure, that VoterMock does implement types.Voter.
// If this is not the case, regenerate this file with moq.
var _ types.Voter = &VoterMock{}

// VoterMock is a mock implementation of types.Voter.
//
// 	func TestSomethingThatUsesVoter(t *testing.T) {
//
// 		// make and configure a mocked types.Voter
// 		mockedVoter := &VoterMock{
// 			DeletePollFunc: func(ctx sdk.Context, poll exported.PollMeta)  {
// 				panic("mock out the DeletePoll method")
// 			},
// 			InitPollFunc: func(ctx sdk.Context, poll exported.PollMeta, snapshotCounter int64) error {
// 				panic("mock out the InitPoll method")
// 			},
// 			ResultFunc: func(ctx sdk.Context, poll exported.PollMeta) exported.VotingData {
// 				panic("mock out the Result method")
// 			},
// 			TallyVoteFunc: func(ctx sdk.Context, sender sdk.AccAddress, pollMeta exported.PollMeta, data exported.VotingData) error {
// 				panic("mock out the TallyVote method")
// 			},
// 		}
//
// 		// use mockedVoter in code that requires types.Voter
// 		// and then make assertions.
//
// 	}
type VoterMock struct {
	// DeletePollFunc mocks the DeletePoll method.
	DeletePollFunc func(ctx sdk.Context, poll exported.PollMeta)

	// InitPollFunc mocks the InitPoll method.
	InitPollFunc func(ctx sdk.Context, poll exported.PollMeta, snapshotCounter int64) error

	// ResultFunc mocks the Result method.
	ResultFunc func(ctx sdk.Context, poll exported.PollMeta) exported.VotingData

	// TallyVoteFunc mocks the TallyVote method.
	TallyVoteFunc func(ctx sdk.Context, sender sdk.AccAddress, pollMeta exported.PollMeta, data exported.VotingData) error

	// calls tracks calls to the methods.
	calls struct {
		// DeletePoll holds details about calls to the DeletePoll method.
		DeletePoll []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Poll is the poll argument value.
			Poll exported.PollMeta
		}
		// InitPoll holds details about calls to the InitPoll method.
		InitPoll []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Poll is the poll argument value.
			Poll exported.PollMeta
			// SnapshotCounter is the snapshotCounter argument value.
			SnapshotCounter int64
		}
		// Result holds details about calls to the Result method.
		Result []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Poll is the poll argument value.
			Poll exported.PollMeta
		}
		// TallyVote holds details about calls to the TallyVote method.
		TallyVote []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Sender is the sender argument value.
			Sender sdk.AccAddress
			// PollMeta is the pollMeta argument value.
			PollMeta exported.PollMeta
			// Data is the data argument value.
			Data exported.VotingData
		}
	}
	lockDeletePoll sync.RWMutex
	lockInitPoll   sync.RWMutex
	lockResult     sync.RWMutex
	lockTallyVote  sync.RWMutex
}

// DeletePoll calls DeletePollFunc.
func (mock *VoterMock) DeletePoll(ctx sdk.Context, poll exported.PollMeta) {
	if mock.DeletePollFunc == nil {
		panic("VoterMock.DeletePollFunc: method is nil but Voter.DeletePoll was just called")
	}
	callInfo := struct {
		Ctx  sdk.Context
		Poll exported.PollMeta
	}{
		Ctx:  ctx,
		Poll: poll,
	}
	mock.lockDeletePoll.Lock()
	mock.calls.DeletePoll = append(mock.calls.DeletePoll, callInfo)
	mock.lockDeletePoll.Unlock()
	mock.DeletePollFunc(ctx, poll)
}

// DeletePollCalls gets all the calls that were made to DeletePoll.
// Check the length with:
//     len(mockedVoter.DeletePollCalls())
func (mock *VoterMock) DeletePollCalls() []struct {
	Ctx  sdk.Context
	Poll exported.PollMeta
} {
	var calls []struct {
		Ctx  sdk.Context
		Poll exported.PollMeta
	}
	mock.lockDeletePoll.RLock()
	calls = mock.calls.DeletePoll
	mock.lockDeletePoll.RUnlock()
	return calls
}

// InitPoll calls InitPollFunc.
func (mock *VoterMock) InitPoll(ctx sdk.Context, poll exported.PollMeta, snapshotCounter int64) error {
	if mock.InitPollFunc == nil {
		panic("VoterMock.InitPollFunc: method is nil but Voter.InitPoll was just called")
	}
	callInfo := struct {
		Ctx             sdk.Context
		Poll            exported.PollMeta
		SnapshotCounter int64
	}{
		Ctx:             ctx,
		Poll:            poll,
		SnapshotCounter: snapshotCounter,
	}
	mock.lockInitPoll.Lock()
	mock.calls.InitPoll = append(mock.calls.InitPoll, callInfo)
	mock.lockInitPoll.Unlock()
	return mock.InitPollFunc(ctx, poll, snapshotCounter)
}

// InitPollCalls gets all the calls that were made to InitPoll.
// Check the length with:
//     len(mockedVoter.InitPollCalls())
func (mock *VoterMock) InitPollCalls() []struct {
	Ctx             sdk.Context
	Poll            exported.PollMeta
	SnapshotCounter int64
} {
	var calls []struct {
		Ctx             sdk.Context
		Poll            exported.PollMeta
		SnapshotCounter int64
	}
	mock.lockInitPoll.RLock()
	calls = mock.calls.InitPoll
	mock.lockInitPoll.RUnlock()
	return calls
}

// Result calls ResultFunc.
func (mock *VoterMock) Result(ctx sdk.Context, poll exported.PollMeta) exported.VotingData {
	if mock.ResultFunc == nil {
		panic("VoterMock.ResultFunc: method is nil but Voter.Result was just called")
	}
	callInfo := struct {
		Ctx  sdk.Context
		Poll exported.PollMeta
	}{
		Ctx:  ctx,
		Poll: poll,
	}
	mock.lockResult.Lock()
	mock.calls.Result = append(mock.calls.Result, callInfo)
	mock.lockResult.Unlock()
	return mock.ResultFunc(ctx, poll)
}

// ResultCalls gets all the calls that were made to Result.
// Check the length with:
//     len(mockedVoter.ResultCalls())
func (mock *VoterMock) ResultCalls() []struct {
	Ctx  sdk.Context
	Poll exported.PollMeta
} {
	var calls []struct {
		Ctx  sdk.Context
		Poll exported.PollMeta
	}
	mock.lockResult.RLock()
	calls = mock.calls.Result
	mock.lockResult.RUnlock()
	return calls
}

// TallyVote calls TallyVoteFunc.
func (mock *VoterMock) TallyVote(ctx sdk.Context, sender sdk.AccAddress, pollMeta exported.PollMeta, data exported.VotingData) error {
	if mock.TallyVoteFunc == nil {
		panic("VoterMock.TallyVoteFunc: method is nil but Voter.TallyVote was just called")
	}
	callInfo := struct {
		Ctx      sdk.Context
		Sender   sdk.AccAddress
		PollMeta exported.PollMeta
		Data     exported.VotingData
	}{
		Ctx:      ctx,
		Sender:   sender,
		PollMeta: pollMeta,
		Data:     data,
	}
	mock.lockTallyVote.Lock()
	mock.calls.TallyVote = append(mock.calls.TallyVote, callInfo)
	mock.lockTallyVote.Unlock()
	return mock.TallyVoteFunc(ctx, sender, pollMeta, data)
}

// TallyVoteCalls gets all the calls that were made to TallyVote.
// Check the length with:
//     len(mockedVoter.TallyVoteCalls())
func (mock *VoterMock) TallyVoteCalls() []struct {
	Ctx      sdk.Context
	Sender   sdk.AccAddress
	PollMeta exported.PollMeta
	Data     exported.VotingData
} {
	var calls []struct {
		Ctx      sdk.Context
		Sender   sdk.AccAddress
		PollMeta exported.PollMeta
		Data     exported.VotingData
	}
	mock.lockTallyVote.RLock()
	calls = mock.calls.TallyVote
	mock.lockTallyVote.RUnlock()
	return calls
}

// Ensure, that SignerMock does implement types.Signer.
// If this is not the case, regenerate this file with moq.
var _ types.Signer = &SignerMock{}

// SignerMock is a mock implementation of types.Signer.
//
// 	func TestSomethingThatUsesSigner(t *testing.T) {
//
// 		// make and configure a mocked types.Signer
// 		mockedSigner := &SignerMock{
// 			GetCurrentKeyFunc: func(ctx sdk.Context, chain nexus.Chain, keyRole tss.KeyRole) (tss.Key, bool) {
// 				panic("mock out the GetCurrentKey method")
// 			},
// 			GetCurrentKeyIDFunc: func(ctx sdk.Context, chain nexus.Chain, keyRole tss.KeyRole) (string, bool) {
// 				panic("mock out the GetCurrentKeyID method")
// 			},
// 			GetKeyFunc: func(ctx sdk.Context, keyID string) (tss.Key, bool) {
// 				panic("mock out the GetKey method")
// 			},
// 			GetNextKeyFunc: func(ctx sdk.Context, chain nexus.Chain, keyRole tss.KeyRole) (tss.Key, bool) {
// 				panic("mock out the GetNextKey method")
// 			},
// 			GetSigFunc: func(ctx sdk.Context, sigID string) (tss.Signature, bool) {
// 				panic("mock out the GetSig method")
// 			},
// 			GetSnapshotCounterForKeyIDFunc: func(ctx sdk.Context, keyID string) (int64, bool) {
// 				panic("mock out the GetSnapshotCounterForKeyID method")
// 			},
// 			StartSignFunc: func(ctx sdk.Context, initPoll interface{InitPoll(ctx sdk.Context, poll exported.PollMeta, snapshotCounter int64) error}, keyID string, sigID string, msg []byte, snapshotMoqParam snapshot.Snapshot) error {
// 				panic("mock out the StartSign method")
// 			},
// 		}
//
// 		// use mockedSigner in code that requires types.Signer
// 		// and then make assertions.
//
// 	}
type SignerMock struct {
	// GetCurrentKeyFunc mocks the GetCurrentKey method.
	GetCurrentKeyFunc func(ctx sdk.Context, chain nexus.Chain, keyRole tss.KeyRole) (tss.Key, bool)

	// GetCurrentKeyIDFunc mocks the GetCurrentKeyID method.
	GetCurrentKeyIDFunc func(ctx sdk.Context, chain nexus.Chain, keyRole tss.KeyRole) (string, bool)

	// GetKeyFunc mocks the GetKey method.
	GetKeyFunc func(ctx sdk.Context, keyID string) (tss.Key, bool)

	// GetNextKeyFunc mocks the GetNextKey method.
	GetNextKeyFunc func(ctx sdk.Context, chain nexus.Chain, keyRole tss.KeyRole) (tss.Key, bool)

	// GetSigFunc mocks the GetSig method.
	GetSigFunc func(ctx sdk.Context, sigID string) (tss.Signature, bool)

	// GetSnapshotCounterForKeyIDFunc mocks the GetSnapshotCounterForKeyID method.
	GetSnapshotCounterForKeyIDFunc func(ctx sdk.Context, keyID string) (int64, bool)

	// StartSignFunc mocks the StartSign method.
	StartSignFunc func(ctx sdk.Context, initPoll interface {
		InitPoll(ctx sdk.Context, poll exported.PollMeta, snapshotCounter int64) error
	}, keyID string, sigID string, msg []byte, snapshotMoqParam snapshot.Snapshot) error

	// calls tracks calls to the methods.
	calls struct {
		// GetCurrentKey holds details about calls to the GetCurrentKey method.
		GetCurrentKey []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Chain is the chain argument value.
			Chain nexus.Chain
			// KeyRole is the keyRole argument value.
			KeyRole tss.KeyRole
		}
		// GetCurrentKeyID holds details about calls to the GetCurrentKeyID method.
		GetCurrentKeyID []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Chain is the chain argument value.
			Chain nexus.Chain
			// KeyRole is the keyRole argument value.
			KeyRole tss.KeyRole
		}
		// GetKey holds details about calls to the GetKey method.
		GetKey []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// KeyID is the keyID argument value.
			KeyID string
		}
		// GetNextKey holds details about calls to the GetNextKey method.
		GetNextKey []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Chain is the chain argument value.
			Chain nexus.Chain
			// KeyRole is the keyRole argument value.
			KeyRole tss.KeyRole
		}
		// GetSig holds details about calls to the GetSig method.
		GetSig []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// SigID is the sigID argument value.
			SigID string
		}
		// GetSnapshotCounterForKeyID holds details about calls to the GetSnapshotCounterForKeyID method.
		GetSnapshotCounterForKeyID []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// KeyID is the keyID argument value.
			KeyID string
		}
		// StartSign holds details about calls to the StartSign method.
		StartSign []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// InitPoll is the initPoll argument value.
			InitPoll interface {
				InitPoll(ctx sdk.Context, poll exported.PollMeta, snapshotCounter int64) error
			}
			// KeyID is the keyID argument value.
			KeyID string
			// SigID is the sigID argument value.
			SigID string
			// Msg is the msg argument value.
			Msg []byte
			// SnapshotMoqParam is the snapshotMoqParam argument value.
			SnapshotMoqParam snapshot.Snapshot
		}
	}
	lockGetCurrentKey              sync.RWMutex
	lockGetCurrentKeyID            sync.RWMutex
	lockGetKey                     sync.RWMutex
	lockGetNextKey                 sync.RWMutex
	lockGetSig                     sync.RWMutex
	lockGetSnapshotCounterForKeyID sync.RWMutex
	lockStartSign                  sync.RWMutex
}

// GetCurrentKey calls GetCurrentKeyFunc.
func (mock *SignerMock) GetCurrentKey(ctx sdk.Context, chain nexus.Chain, keyRole tss.KeyRole) (tss.Key, bool) {
	if mock.GetCurrentKeyFunc == nil {
		panic("SignerMock.GetCurrentKeyFunc: method is nil but Signer.GetCurrentKey was just called")
	}
	callInfo := struct {
		Ctx     sdk.Context
		Chain   nexus.Chain
		KeyRole tss.KeyRole
	}{
		Ctx:     ctx,
		Chain:   chain,
		KeyRole: keyRole,
	}
	mock.lockGetCurrentKey.Lock()
	mock.calls.GetCurrentKey = append(mock.calls.GetCurrentKey, callInfo)
	mock.lockGetCurrentKey.Unlock()
	return mock.GetCurrentKeyFunc(ctx, chain, keyRole)
}

// GetCurrentKeyCalls gets all the calls that were made to GetCurrentKey.
// Check the length with:
//     len(mockedSigner.GetCurrentKeyCalls())
func (mock *SignerMock) GetCurrentKeyCalls() []struct {
	Ctx     sdk.Context
	Chain   nexus.Chain
	KeyRole tss.KeyRole
} {
	var calls []struct {
		Ctx     sdk.Context
		Chain   nexus.Chain
		KeyRole tss.KeyRole
	}
	mock.lockGetCurrentKey.RLock()
	calls = mock.calls.GetCurrentKey
	mock.lockGetCurrentKey.RUnlock()
	return calls
}

// GetCurrentKeyID calls GetCurrentKeyIDFunc.
func (mock *SignerMock) GetCurrentKeyID(ctx sdk.Context, chain nexus.Chain, keyRole tss.KeyRole) (string, bool) {
	if mock.GetCurrentKeyIDFunc == nil {
		panic("SignerMock.GetCurrentKeyIDFunc: method is nil but Signer.GetCurrentKeyID was just called")
	}
	callInfo := struct {
		Ctx     sdk.Context
		Chain   nexus.Chain
		KeyRole tss.KeyRole
	}{
		Ctx:     ctx,
		Chain:   chain,
		KeyRole: keyRole,
	}
	mock.lockGetCurrentKeyID.Lock()
	mock.calls.GetCurrentKeyID = append(mock.calls.GetCurrentKeyID, callInfo)
	mock.lockGetCurrentKeyID.Unlock()
	return mock.GetCurrentKeyIDFunc(ctx, chain, keyRole)
}

// GetCurrentKeyIDCalls gets all the calls that were made to GetCurrentKeyID.
// Check the length with:
//     len(mockedSigner.GetCurrentKeyIDCalls())
func (mock *SignerMock) GetCurrentKeyIDCalls() []struct {
	Ctx     sdk.Context
	Chain   nexus.Chain
	KeyRole tss.KeyRole
} {
	var calls []struct {
		Ctx     sdk.Context
		Chain   nexus.Chain
		KeyRole tss.KeyRole
	}
	mock.lockGetCurrentKeyID.RLock()
	calls = mock.calls.GetCurrentKeyID
	mock.lockGetCurrentKeyID.RUnlock()
	return calls
}

// GetKey calls GetKeyFunc.
func (mock *SignerMock) GetKey(ctx sdk.Context, keyID string) (tss.Key, bool) {
	if mock.GetKeyFunc == nil {
		panic("SignerMock.GetKeyFunc: method is nil but Signer.GetKey was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		KeyID string
	}{
		Ctx:   ctx,
		KeyID: keyID,
	}
	mock.lockGetKey.Lock()
	mock.calls.GetKey = append(mock.calls.GetKey, callInfo)
	mock.lockGetKey.Unlock()
	return mock.GetKeyFunc(ctx, keyID)
}

// GetKeyCalls gets all the calls that were made to GetKey.
// Check the length with:
//     len(mockedSigner.GetKeyCalls())
func (mock *SignerMock) GetKeyCalls() []struct {
	Ctx   sdk.Context
	KeyID string
} {
	var calls []struct {
		Ctx   sdk.Context
		KeyID string
	}
	mock.lockGetKey.RLock()
	calls = mock.calls.GetKey
	mock.lockGetKey.RUnlock()
	return calls
}

// GetNextKey calls GetNextKeyFunc.
func (mock *SignerMock) GetNextKey(ctx sdk.Context, chain nexus.Chain, keyRole tss.KeyRole) (tss.Key, bool) {
	if mock.GetNextKeyFunc == nil {
		panic("SignerMock.GetNextKeyFunc: method is nil but Signer.GetNextKey was just called")
	}
	callInfo := struct {
		Ctx     sdk.Context
		Chain   nexus.Chain
		KeyRole tss.KeyRole
	}{
		Ctx:     ctx,
		Chain:   chain,
		KeyRole: keyRole,
	}
	mock.lockGetNextKey.Lock()
	mock.calls.GetNextKey = append(mock.calls.GetNextKey, callInfo)
	mock.lockGetNextKey.Unlock()
	return mock.GetNextKeyFunc(ctx, chain, keyRole)
}

// GetNextKeyCalls gets all the calls that were made to GetNextKey.
// Check the length with:
//     len(mockedSigner.GetNextKeyCalls())
func (mock *SignerMock) GetNextKeyCalls() []struct {
	Ctx     sdk.Context
	Chain   nexus.Chain
	KeyRole tss.KeyRole
} {
	var calls []struct {
		Ctx     sdk.Context
		Chain   nexus.Chain
		KeyRole tss.KeyRole
	}
	mock.lockGetNextKey.RLock()
	calls = mock.calls.GetNextKey
	mock.lockGetNextKey.RUnlock()
	return calls
}

// GetSig calls GetSigFunc.
func (mock *SignerMock) GetSig(ctx sdk.Context, sigID string) (tss.Signature, bool) {
	if mock.GetSigFunc == nil {
		panic("SignerMock.GetSigFunc: method is nil but Signer.GetSig was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		SigID string
	}{
		Ctx:   ctx,
		SigID: sigID,
	}
	mock.lockGetSig.Lock()
	mock.calls.GetSig = append(mock.calls.GetSig, callInfo)
	mock.lockGetSig.Unlock()
	return mock.GetSigFunc(ctx, sigID)
}

// GetSigCalls gets all the calls that were made to GetSig.
// Check the length with:
//     len(mockedSigner.GetSigCalls())
func (mock *SignerMock) GetSigCalls() []struct {
	Ctx   sdk.Context
	SigID string
} {
	var calls []struct {
		Ctx   sdk.Context
		SigID string
	}
	mock.lockGetSig.RLock()
	calls = mock.calls.GetSig
	mock.lockGetSig.RUnlock()
	return calls
}

// GetSnapshotCounterForKeyID calls GetSnapshotCounterForKeyIDFunc.
func (mock *SignerMock) GetSnapshotCounterForKeyID(ctx sdk.Context, keyID string) (int64, bool) {
	if mock.GetSnapshotCounterForKeyIDFunc == nil {
		panic("SignerMock.GetSnapshotCounterForKeyIDFunc: method is nil but Signer.GetSnapshotCounterForKeyID was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		KeyID string
	}{
		Ctx:   ctx,
		KeyID: keyID,
	}
	mock.lockGetSnapshotCounterForKeyID.Lock()
	mock.calls.GetSnapshotCounterForKeyID = append(mock.calls.GetSnapshotCounterForKeyID, callInfo)
	mock.lockGetSnapshotCounterForKeyID.Unlock()
	return mock.GetSnapshotCounterForKeyIDFunc(ctx, keyID)
}

// GetSnapshotCounterForKeyIDCalls gets all the calls that were made to GetSnapshotCounterForKeyID.
// Check the length with:
//     len(mockedSigner.GetSnapshotCounterForKeyIDCalls())
func (mock *SignerMock) GetSnapshotCounterForKeyIDCalls() []struct {
	Ctx   sdk.Context
	KeyID string
} {
	var calls []struct {
		Ctx   sdk.Context
		KeyID string
	}
	mock.lockGetSnapshotCounterForKeyID.RLock()
	calls = mock.calls.GetSnapshotCounterForKeyID
	mock.lockGetSnapshotCounterForKeyID.RUnlock()
	return calls
}

// StartSign calls StartSignFunc.
func (mock *SignerMock) StartSign(ctx sdk.Context, initPoll interface {
	InitPoll(ctx sdk.Context, poll exported.PollMeta, snapshotCounter int64) error
}, keyID string, sigID string, msg []byte, snapshotMoqParam snapshot.Snapshot) error {
	if mock.StartSignFunc == nil {
		panic("SignerMock.StartSignFunc: method is nil but Signer.StartSign was just called")
	}
	callInfo := struct {
		Ctx      sdk.Context
		InitPoll interface {
			InitPoll(ctx sdk.Context, poll exported.PollMeta, snapshotCounter int64) error
		}
		KeyID            string
		SigID            string
		Msg              []byte
		SnapshotMoqParam snapshot.Snapshot
	}{
		Ctx:              ctx,
		InitPoll:         initPoll,
		KeyID:            keyID,
		SigID:            sigID,
		Msg:              msg,
		SnapshotMoqParam: snapshotMoqParam,
	}
	mock.lockStartSign.Lock()
	mock.calls.StartSign = append(mock.calls.StartSign, callInfo)
	mock.lockStartSign.Unlock()
	return mock.StartSignFunc(ctx, initPoll, keyID, sigID, msg, snapshotMoqParam)
}

// StartSignCalls gets all the calls that were made to StartSign.
// Check the length with:
//     len(mockedSigner.StartSignCalls())
func (mock *SignerMock) StartSignCalls() []struct {
	Ctx      sdk.Context
	InitPoll interface {
		InitPoll(ctx sdk.Context, poll exported.PollMeta, snapshotCounter int64) error
	}
	KeyID            string
	SigID            string
	Msg              []byte
	SnapshotMoqParam snapshot.Snapshot
} {
	var calls []struct {
		Ctx      sdk.Context
		InitPoll interface {
			InitPoll(ctx sdk.Context, poll exported.PollMeta, snapshotCounter int64) error
		}
		KeyID            string
		SigID            string
		Msg              []byte
		SnapshotMoqParam snapshot.Snapshot
	}
	mock.lockStartSign.RLock()
	calls = mock.calls.StartSign
	mock.lockStartSign.RUnlock()
	return calls
}

// Ensure, that NexusMock does implement types.Nexus.
// If this is not the case, regenerate this file with moq.
var _ types.Nexus = &NexusMock{}

// NexusMock is a mock implementation of types.Nexus.
//
// 	func TestSomethingThatUsesNexus(t *testing.T) {
//
// 		// make and configure a mocked types.Nexus
// 		mockedNexus := &NexusMock{
// 			ArchivePendingTransferFunc: func(ctx sdk.Context, transfer nexus.CrossChainTransfer)  {
// 				panic("mock out the ArchivePendingTransfer method")
// 			},
// 			EnqueueForTransferFunc: func(ctx sdk.Context, sender nexus.CrossChainAddress, amount sdk.Coin) error {
// 				panic("mock out the EnqueueForTransfer method")
// 			},
// 			GetArchivedTransfersForChainFunc: func(ctx sdk.Context, chain nexus.Chain) []nexus.CrossChainTransfer {
// 				panic("mock out the GetArchivedTransfersForChain method")
// 			},
// 			GetChainFunc: func(ctx sdk.Context, chain string) (nexus.Chain, bool) {
// 				panic("mock out the GetChain method")
// 			},
// 			GetPendingTransfersForChainFunc: func(ctx sdk.Context, chain nexus.Chain) []nexus.CrossChainTransfer {
// 				panic("mock out the GetPendingTransfersForChain method")
// 			},
// 			GetRecipientFunc: func(ctx sdk.Context, sender nexus.CrossChainAddress) (nexus.CrossChainAddress, bool) {
// 				panic("mock out the GetRecipient method")
// 			},
// 			IsAssetRegisteredFunc: func(ctx sdk.Context, chainName string, denom string) bool {
// 				panic("mock out the IsAssetRegistered method")
// 			},
// 			LinkAddressesFunc: func(ctx sdk.Context, sender nexus.CrossChainAddress, recipient nexus.CrossChainAddress)  {
// 				panic("mock out the LinkAddresses method")
// 			},
// 		}
//
// 		// use mockedNexus in code that requires types.Nexus
// 		// and then make assertions.
//
// 	}
type NexusMock struct {
	// ArchivePendingTransferFunc mocks the ArchivePendingTransfer method.
	ArchivePendingTransferFunc func(ctx sdk.Context, transfer nexus.CrossChainTransfer)

	// EnqueueForTransferFunc mocks the EnqueueForTransfer method.
	EnqueueForTransferFunc func(ctx sdk.Context, sender nexus.CrossChainAddress, amount sdk.Coin) error

	// GetArchivedTransfersForChainFunc mocks the GetArchivedTransfersForChain method.
	GetArchivedTransfersForChainFunc func(ctx sdk.Context, chain nexus.Chain) []nexus.CrossChainTransfer

	// GetChainFunc mocks the GetChain method.
	GetChainFunc func(ctx sdk.Context, chain string) (nexus.Chain, bool)

	// GetPendingTransfersForChainFunc mocks the GetPendingTransfersForChain method.
	GetPendingTransfersForChainFunc func(ctx sdk.Context, chain nexus.Chain) []nexus.CrossChainTransfer

	// GetRecipientFunc mocks the GetRecipient method.
	GetRecipientFunc func(ctx sdk.Context, sender nexus.CrossChainAddress) (nexus.CrossChainAddress, bool)

	// IsAssetRegisteredFunc mocks the IsAssetRegistered method.
	IsAssetRegisteredFunc func(ctx sdk.Context, chainName string, denom string) bool

	// LinkAddressesFunc mocks the LinkAddresses method.
	LinkAddressesFunc func(ctx sdk.Context, sender nexus.CrossChainAddress, recipient nexus.CrossChainAddress)

	// calls tracks calls to the methods.
	calls struct {
		// ArchivePendingTransfer holds details about calls to the ArchivePendingTransfer method.
		ArchivePendingTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Transfer is the transfer argument value.
			Transfer nexus.CrossChainTransfer
		}
		// EnqueueForTransfer holds details about calls to the EnqueueForTransfer method.
		EnqueueForTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Sender is the sender argument value.
			Sender nexus.CrossChainAddress
			// Amount is the amount argument value.
			Amount sdk.Coin
		}
		// GetArchivedTransfersForChain holds details about calls to the GetArchivedTransfersForChain method.
		GetArchivedTransfersForChain []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Chain is the chain argument value.
			Chain nexus.Chain
		}
		// GetChain holds details about calls to the GetChain method.
		GetChain []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Chain is the chain argument value.
			Chain string
		}
		// GetPendingTransfersForChain holds details about calls to the GetPendingTransfersForChain method.
		GetPendingTransfersForChain []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Chain is the chain argument value.
			Chain nexus.Chain
		}
		// GetRecipient holds details about calls to the GetRecipient method.
		GetRecipient []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Sender is the sender argument value.
			Sender nexus.CrossChainAddress
		}
		// IsAssetRegistered holds details about calls to the IsAssetRegistered method.
		IsAssetRegistered []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// ChainName is the chainName argument value.
			ChainName string
			// Denom is the denom argument value.
			Denom string
		}
		// LinkAddresses holds details about calls to the LinkAddresses method.
		LinkAddresses []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Sender is the sender argument value.
			Sender nexus.CrossChainAddress
			// Recipient is the recipient argument value.
			Recipient nexus.CrossChainAddress
		}
	}
	lockArchivePendingTransfer       sync.RWMutex
	lockEnqueueForTransfer           sync.RWMutex
	lockGetArchivedTransfersForChain sync.RWMutex
	lockGetChain                     sync.RWMutex
	lockGetPendingTransfersForChain  sync.RWMutex
	lockGetRecipient                 sync.RWMutex
	lockIsAssetRegistered            sync.RWMutex
	lockLinkAddresses                sync.RWMutex
}

// ArchivePendingTransfer calls ArchivePendingTransferFunc.
func (mock *NexusMock) ArchivePendingTransfer(ctx sdk.Context, transfer nexus.CrossChainTransfer) {
	if mock.ArchivePendingTransferFunc == nil {
		panic("NexusMock.ArchivePendingTransferFunc: method is nil but Nexus.ArchivePendingTransfer was just called")
	}
	callInfo := struct {
		Ctx      sdk.Context
		Transfer nexus.CrossChainTransfer
	}{
		Ctx:      ctx,
		Transfer: transfer,
	}
	mock.lockArchivePendingTransfer.Lock()
	mock.calls.ArchivePendingTransfer = append(mock.calls.ArchivePendingTransfer, callInfo)
	mock.lockArchivePendingTransfer.Unlock()
	mock.ArchivePendingTransferFunc(ctx, transfer)
}

// ArchivePendingTransferCalls gets all the calls that were made to ArchivePendingTransfer.
// Check the length with:
//     len(mockedNexus.ArchivePendingTransferCalls())
func (mock *NexusMock) ArchivePendingTransferCalls() []struct {
	Ctx      sdk.Context
	Transfer nexus.CrossChainTransfer
} {
	var calls []struct {
		Ctx      sdk.Context
		Transfer nexus.CrossChainTransfer
	}
	mock.lockArchivePendingTransfer.RLock()
	calls = mock.calls.ArchivePendingTransfer
	mock.lockArchivePendingTransfer.RUnlock()
	return calls
}

// EnqueueForTransfer calls EnqueueForTransferFunc.
func (mock *NexusMock) EnqueueForTransfer(ctx sdk.Context, sender nexus.CrossChainAddress, amount sdk.Coin) error {
	if mock.EnqueueForTransferFunc == nil {
		panic("NexusMock.EnqueueForTransferFunc: method is nil but Nexus.EnqueueForTransfer was just called")
	}
	callInfo := struct {
		Ctx    sdk.Context
		Sender nexus.CrossChainAddress
		Amount sdk.Coin
	}{
		Ctx:    ctx,
		Sender: sender,
		Amount: amount,
	}
	mock.lockEnqueueForTransfer.Lock()
	mock.calls.EnqueueForTransfer = append(mock.calls.EnqueueForTransfer, callInfo)
	mock.lockEnqueueForTransfer.Unlock()
	return mock.EnqueueForTransferFunc(ctx, sender, amount)
}

// EnqueueForTransferCalls gets all the calls that were made to EnqueueForTransfer.
// Check the length with:
//     len(mockedNexus.EnqueueForTransferCalls())
func (mock *NexusMock) EnqueueForTransferCalls() []struct {
	Ctx    sdk.Context
	Sender nexus.CrossChainAddress
	Amount sdk.Coin
} {
	var calls []struct {
		Ctx    sdk.Context
		Sender nexus.CrossChainAddress
		Amount sdk.Coin
	}
	mock.lockEnqueueForTransfer.RLock()
	calls = mock.calls.EnqueueForTransfer
	mock.lockEnqueueForTransfer.RUnlock()
	return calls
}

// GetArchivedTransfersForChain calls GetArchivedTransfersForChainFunc.
func (mock *NexusMock) GetArchivedTransfersForChain(ctx sdk.Context, chain nexus.Chain) []nexus.CrossChainTransfer {
	if mock.GetArchivedTransfersForChainFunc == nil {
		panic("NexusMock.GetArchivedTransfersForChainFunc: method is nil but Nexus.GetArchivedTransfersForChain was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		Chain nexus.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockGetArchivedTransfersForChain.Lock()
	mock.calls.GetArchivedTransfersForChain = append(mock.calls.GetArchivedTransfersForChain, callInfo)
	mock.lockGetArchivedTransfersForChain.Unlock()
	return mock.GetArchivedTransfersForChainFunc(ctx, chain)
}

// GetArchivedTransfersForChainCalls gets all the calls that were made to GetArchivedTransfersForChain.
// Check the length with:
//     len(mockedNexus.GetArchivedTransfersForChainCalls())
func (mock *NexusMock) GetArchivedTransfersForChainCalls() []struct {
	Ctx   sdk.Context
	Chain nexus.Chain
} {
	var calls []struct {
		Ctx   sdk.Context
		Chain nexus.Chain
	}
	mock.lockGetArchivedTransfersForChain.RLock()
	calls = mock.calls.GetArchivedTransfersForChain
	mock.lockGetArchivedTransfersForChain.RUnlock()
	return calls
}

// GetChain calls GetChainFunc.
func (mock *NexusMock) GetChain(ctx sdk.Context, chain string) (nexus.Chain, bool) {
	if mock.GetChainFunc == nil {
		panic("NexusMock.GetChainFunc: method is nil but Nexus.GetChain was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		Chain string
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockGetChain.Lock()
	mock.calls.GetChain = append(mock.calls.GetChain, callInfo)
	mock.lockGetChain.Unlock()
	return mock.GetChainFunc(ctx, chain)
}

// GetChainCalls gets all the calls that were made to GetChain.
// Check the length with:
//     len(mockedNexus.GetChainCalls())
func (mock *NexusMock) GetChainCalls() []struct {
	Ctx   sdk.Context
	Chain string
} {
	var calls []struct {
		Ctx   sdk.Context
		Chain string
	}
	mock.lockGetChain.RLock()
	calls = mock.calls.GetChain
	mock.lockGetChain.RUnlock()
	return calls
}

// GetPendingTransfersForChain calls GetPendingTransfersForChainFunc.
func (mock *NexusMock) GetPendingTransfersForChain(ctx sdk.Context, chain nexus.Chain) []nexus.CrossChainTransfer {
	if mock.GetPendingTransfersForChainFunc == nil {
		panic("NexusMock.GetPendingTransfersForChainFunc: method is nil but Nexus.GetPendingTransfersForChain was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		Chain nexus.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockGetPendingTransfersForChain.Lock()
	mock.calls.GetPendingTransfersForChain = append(mock.calls.GetPendingTransfersForChain, callInfo)
	mock.lockGetPendingTransfersForChain.Unlock()
	return mock.GetPendingTransfersForChainFunc(ctx, chain)
}

// GetPendingTransfersForChainCalls gets all the calls that were made to GetPendingTransfersForChain.
// Check the length with:
//     len(mockedNexus.GetPendingTransfersForChainCalls())
func (mock *NexusMock) GetPendingTransfersForChainCalls() []struct {
	Ctx   sdk.Context
	Chain nexus.Chain
} {
	var calls []struct {
		Ctx   sdk.Context
		Chain nexus.Chain
	}
	mock.lockGetPendingTransfersForChain.RLock()
	calls = mock.calls.GetPendingTransfersForChain
	mock.lockGetPendingTransfersForChain.RUnlock()
	return calls
}

// GetRecipient calls GetRecipientFunc.
func (mock *NexusMock) GetRecipient(ctx sdk.Context, sender nexus.CrossChainAddress) (nexus.CrossChainAddress, bool) {
	if mock.GetRecipientFunc == nil {
		panic("NexusMock.GetRecipientFunc: method is nil but Nexus.GetRecipient was just called")
	}
	callInfo := struct {
		Ctx    sdk.Context
		Sender nexus.CrossChainAddress
	}{
		Ctx:    ctx,
		Sender: sender,
	}
	mock.lockGetRecipient.Lock()
	mock.calls.GetRecipient = append(mock.calls.GetRecipient, callInfo)
	mock.lockGetRecipient.Unlock()
	return mock.GetRecipientFunc(ctx, sender)
}

// GetRecipientCalls gets all the calls that were made to GetRecipient.
// Check the length with:
//     len(mockedNexus.GetRecipientCalls())
func (mock *NexusMock) GetRecipientCalls() []struct {
	Ctx    sdk.Context
	Sender nexus.CrossChainAddress
} {
	var calls []struct {
		Ctx    sdk.Context
		Sender nexus.CrossChainAddress
	}
	mock.lockGetRecipient.RLock()
	calls = mock.calls.GetRecipient
	mock.lockGetRecipient.RUnlock()
	return calls
}

// IsAssetRegistered calls IsAssetRegisteredFunc.
func (mock *NexusMock) IsAssetRegistered(ctx sdk.Context, chainName string, denom string) bool {
	if mock.IsAssetRegisteredFunc == nil {
		panic("NexusMock.IsAssetRegisteredFunc: method is nil but Nexus.IsAssetRegistered was just called")
	}
	callInfo := struct {
		Ctx       sdk.Context
		ChainName string
		Denom     string
	}{
		Ctx:       ctx,
		ChainName: chainName,
		Denom:     denom,
	}
	mock.lockIsAssetRegistered.Lock()
	mock.calls.IsAssetRegistered = append(mock.calls.IsAssetRegistered, callInfo)
	mock.lockIsAssetRegistered.Unlock()
	return mock.IsAssetRegisteredFunc(ctx, chainName, denom)
}

// IsAssetRegisteredCalls gets all the calls that were made to IsAssetRegistered.
// Check the length with:
//     len(mockedNexus.IsAssetRegisteredCalls())
func (mock *NexusMock) IsAssetRegisteredCalls() []struct {
	Ctx       sdk.Context
	ChainName string
	Denom     string
} {
	var calls []struct {
		Ctx       sdk.Context
		ChainName string
		Denom     string
	}
	mock.lockIsAssetRegistered.RLock()
	calls = mock.calls.IsAssetRegistered
	mock.lockIsAssetRegistered.RUnlock()
	return calls
}

// LinkAddresses calls LinkAddressesFunc.
func (mock *NexusMock) LinkAddresses(ctx sdk.Context, sender nexus.CrossChainAddress, recipient nexus.CrossChainAddress) {
	if mock.LinkAddressesFunc == nil {
		panic("NexusMock.LinkAddressesFunc: method is nil but Nexus.LinkAddresses was just called")
	}
	callInfo := struct {
		Ctx       sdk.Context
		Sender    nexus.CrossChainAddress
		Recipient nexus.CrossChainAddress
	}{
		Ctx:       ctx,
		Sender:    sender,
		Recipient: recipient,
	}
	mock.lockLinkAddresses.Lock()
	mock.calls.LinkAddresses = append(mock.calls.LinkAddresses, callInfo)
	mock.lockLinkAddresses.Unlock()
	mock.LinkAddressesFunc(ctx, sender, recipient)
}

// LinkAddressesCalls gets all the calls that were made to LinkAddresses.
// Check the length with:
//     len(mockedNexus.LinkAddressesCalls())
func (mock *NexusMock) LinkAddressesCalls() []struct {
	Ctx       sdk.Context
	Sender    nexus.CrossChainAddress
	Recipient nexus.CrossChainAddress
} {
	var calls []struct {
		Ctx       sdk.Context
		Sender    nexus.CrossChainAddress
		Recipient nexus.CrossChainAddress
	}
	mock.lockLinkAddresses.RLock()
	calls = mock.calls.LinkAddresses
	mock.lockLinkAddresses.RUnlock()
	return calls
}

// Ensure, that SnapshotterMock does implement types.Snapshotter.
// If this is not the case, regenerate this file with moq.
var _ types.Snapshotter = &SnapshotterMock{}

// SnapshotterMock is a mock implementation of types.Snapshotter.
//
// 	func TestSomethingThatUsesSnapshotter(t *testing.T) {
//
// 		// make and configure a mocked types.Snapshotter
// 		mockedSnapshotter := &SnapshotterMock{
// 			GetSnapshotFunc: func(ctx sdk.Context, counter int64) (snapshot.Snapshot, bool) {
// 				panic("mock out the GetSnapshot method")
// 			},
// 		}
//
// 		// use mockedSnapshotter in code that requires types.Snapshotter
// 		// and then make assertions.
//
// 	}
type SnapshotterMock struct {
	// GetSnapshotFunc mocks the GetSnapshot method.
	GetSnapshotFunc func(ctx sdk.Context, counter int64) (snapshot.Snapshot, bool)

	// calls tracks calls to the methods.
	calls struct {
		// GetSnapshot holds details about calls to the GetSnapshot method.
		GetSnapshot []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Counter is the counter argument value.
			Counter int64
		}
	}
	lockGetSnapshot sync.RWMutex
}

// GetSnapshot calls GetSnapshotFunc.
func (mock *SnapshotterMock) GetSnapshot(ctx sdk.Context, counter int64) (snapshot.Snapshot, bool) {
	if mock.GetSnapshotFunc == nil {
		panic("SnapshotterMock.GetSnapshotFunc: method is nil but Snapshotter.GetSnapshot was just called")
	}
	callInfo := struct {
		Ctx     sdk.Context
		Counter int64
	}{
		Ctx:     ctx,
		Counter: counter,
	}
	mock.lockGetSnapshot.Lock()
	mock.calls.GetSnapshot = append(mock.calls.GetSnapshot, callInfo)
	mock.lockGetSnapshot.Unlock()
	return mock.GetSnapshotFunc(ctx, counter)
}

// GetSnapshotCalls gets all the calls that were made to GetSnapshot.
// Check the length with:
//     len(mockedSnapshotter.GetSnapshotCalls())
func (mock *SnapshotterMock) GetSnapshotCalls() []struct {
	Ctx     sdk.Context
	Counter int64
} {
	var calls []struct {
		Ctx     sdk.Context
		Counter int64
	}
	mock.lockGetSnapshot.RLock()
	calls = mock.calls.GetSnapshot
	mock.lockGetSnapshot.RUnlock()
	return calls
}

// Ensure, that BTCKeeperMock does implement types.BTCKeeper.
// If this is not the case, regenerate this file with moq.
var _ types.BTCKeeper = &BTCKeeperMock{}

// BTCKeeperMock is a mock implementation of types.BTCKeeper.
//
// 	func TestSomethingThatUsesBTCKeeper(t *testing.T) {
//
// 		// make and configure a mocked types.BTCKeeper
// 		mockedBTCKeeper := &BTCKeeperMock{
// 			CodecFunc: func() *codec.LegacyAmino {
// 				panic("mock out the Codec method")
// 			},
// 			DeleteOutpointInfoFunc: func(ctx sdk.Context, outPoint wire.OutPoint)  {
// 				panic("mock out the DeleteOutpointInfo method")
// 			},
// 			DeletePendingOutPointInfoFunc: func(ctx sdk.Context, poll exported.PollMeta)  {
// 				panic("mock out the DeletePendingOutPointInfo method")
// 			},
// 			DeleteSignedTxFunc: func(ctx sdk.Context)  {
// 				panic("mock out the DeleteSignedTx method")
// 			},
// 			DeleteUnsignedTxFunc: func(ctx sdk.Context)  {
// 				panic("mock out the DeleteUnsignedTx method")
// 			},
// 			GetAddressFunc: func(ctx sdk.Context, encodedAddress string) (types.AddressInfo, bool) {
// 				panic("mock out the GetAddress method")
// 			},
// 			GetConfirmedOutPointInfosFunc: func(ctx sdk.Context) []types.OutPointInfo {
// 				panic("mock out the GetConfirmedOutPointInfos method")
// 			},
// 			GetMasterKeyVoutFunc: func(ctx sdk.Context) (uint32, bool) {
// 				panic("mock out the GetMasterKeyVout method")
// 			},
// 			GetNetworkFunc: func(ctx sdk.Context) types.Network {
// 				panic("mock out the GetNetwork method")
// 			},
// 			GetOutPointInfoFunc: func(ctx sdk.Context, outPoint wire.OutPoint) (types.OutPointInfo, types.OutPointState, bool) {
// 				panic("mock out the GetOutPointInfo method")
// 			},
// 			GetParamsFunc: func(ctx sdk.Context) types.Params {
// 				panic("mock out the GetParams method")
// 			},
// 			GetPendingOutPointInfoFunc: func(ctx sdk.Context, poll exported.PollMeta) (types.OutPointInfo, bool) {
// 				panic("mock out the GetPendingOutPointInfo method")
// 			},
// 			GetRequiredConfirmationHeightFunc: func(ctx sdk.Context) uint64 {
// 				panic("mock out the GetRequiredConfirmationHeight method")
// 			},
// 			GetRevoteLockingPeriodFunc: func(ctx sdk.Context) int64 {
// 				panic("mock out the GetRevoteLockingPeriod method")
// 			},
// 			GetSigCheckIntervalFunc: func(ctx sdk.Context) int64 {
// 				panic("mock out the GetSigCheckInterval method")
// 			},
// 			GetSignedTxFunc: func(ctx sdk.Context) (*wire.MsgTx, bool) {
// 				panic("mock out the GetSignedTx method")
// 			},
// 			GetUnsignedTxFunc: func(ctx sdk.Context) (*wire.MsgTx, bool) {
// 				panic("mock out the GetUnsignedTx method")
// 			},
// 			LoggerFunc: func(ctx sdk.Context) log.Logger {
// 				panic("mock out the Logger method")
// 			},
// 			SetAddressFunc: func(ctx sdk.Context, address types.AddressInfo)  {
// 				panic("mock out the SetAddress method")
// 			},
// 			SetMasterKeyVoutFunc: func(ctx sdk.Context, vout uint32)  {
// 				panic("mock out the SetMasterKeyVout method")
// 			},
// 			SetOutpointInfoFunc: func(ctx sdk.Context, info types.OutPointInfo, state types.OutPointState)  {
// 				panic("mock out the SetOutpointInfo method")
// 			},
// 			SetParamsFunc: func(ctx sdk.Context, p types.Params)  {
// 				panic("mock out the SetParams method")
// 			},
// 			SetPendingOutpointInfoFunc: func(ctx sdk.Context, poll exported.PollMeta, info types.OutPointInfo)  {
// 				panic("mock out the SetPendingOutpointInfo method")
// 			},
// 			SetSignedTxFunc: func(ctx sdk.Context, tx *wire.MsgTx)  {
// 				panic("mock out the SetSignedTx method")
// 			},
// 			SetUnsignedTxFunc: func(ctx sdk.Context, tx *wire.MsgTx)  {
// 				panic("mock out the SetUnsignedTx method")
// 			},
// 		}
//
// 		// use mockedBTCKeeper in code that requires types.BTCKeeper
// 		// and then make assertions.
//
// 	}
type BTCKeeperMock struct {
	// CodecFunc mocks the Codec method.
	CodecFunc func() *codec.LegacyAmino

	// DeleteOutpointInfoFunc mocks the DeleteOutpointInfo method.
	DeleteOutpointInfoFunc func(ctx sdk.Context, outPoint wire.OutPoint)

	// DeletePendingOutPointInfoFunc mocks the DeletePendingOutPointInfo method.
	DeletePendingOutPointInfoFunc func(ctx sdk.Context, poll exported.PollMeta)

	// DeleteSignedTxFunc mocks the DeleteSignedTx method.
	DeleteSignedTxFunc func(ctx sdk.Context)

	// DeleteUnsignedTxFunc mocks the DeleteUnsignedTx method.
	DeleteUnsignedTxFunc func(ctx sdk.Context)

	// GetAddressFunc mocks the GetAddress method.
	GetAddressFunc func(ctx sdk.Context, encodedAddress string) (types.AddressInfo, bool)

	// GetConfirmedOutPointInfosFunc mocks the GetConfirmedOutPointInfos method.
	GetConfirmedOutPointInfosFunc func(ctx sdk.Context) []types.OutPointInfo

	// GetMasterKeyVoutFunc mocks the GetMasterKeyVout method.
	GetMasterKeyVoutFunc func(ctx sdk.Context) (uint32, bool)

	// GetNetworkFunc mocks the GetNetwork method.
	GetNetworkFunc func(ctx sdk.Context) types.Network

	// GetOutPointInfoFunc mocks the GetOutPointInfo method.
	GetOutPointInfoFunc func(ctx sdk.Context, outPoint wire.OutPoint) (types.OutPointInfo, types.OutPointState, bool)

	// GetParamsFunc mocks the GetParams method.
	GetParamsFunc func(ctx sdk.Context) types.Params

	// GetPendingOutPointInfoFunc mocks the GetPendingOutPointInfo method.
	GetPendingOutPointInfoFunc func(ctx sdk.Context, poll exported.PollMeta) (types.OutPointInfo, bool)

	// GetRequiredConfirmationHeightFunc mocks the GetRequiredConfirmationHeight method.
	GetRequiredConfirmationHeightFunc func(ctx sdk.Context) uint64

	// GetRevoteLockingPeriodFunc mocks the GetRevoteLockingPeriod method.
	GetRevoteLockingPeriodFunc func(ctx sdk.Context) int64

	// GetSigCheckIntervalFunc mocks the GetSigCheckInterval method.
	GetSigCheckIntervalFunc func(ctx sdk.Context) int64

	// GetSignedTxFunc mocks the GetSignedTx method.
	GetSignedTxFunc func(ctx sdk.Context) (*wire.MsgTx, bool)

	// GetUnsignedTxFunc mocks the GetUnsignedTx method.
	GetUnsignedTxFunc func(ctx sdk.Context) (*wire.MsgTx, bool)

	// LoggerFunc mocks the Logger method.
	LoggerFunc func(ctx sdk.Context) log.Logger

	// SetAddressFunc mocks the SetAddress method.
	SetAddressFunc func(ctx sdk.Context, address types.AddressInfo)

	// SetMasterKeyVoutFunc mocks the SetMasterKeyVout method.
	SetMasterKeyVoutFunc func(ctx sdk.Context, vout uint32)

	// SetOutpointInfoFunc mocks the SetOutpointInfo method.
	SetOutpointInfoFunc func(ctx sdk.Context, info types.OutPointInfo, state types.OutPointState)

	// SetParamsFunc mocks the SetParams method.
	SetParamsFunc func(ctx sdk.Context, p types.Params)

	// SetPendingOutpointInfoFunc mocks the SetPendingOutpointInfo method.
	SetPendingOutpointInfoFunc func(ctx sdk.Context, poll exported.PollMeta, info types.OutPointInfo)

	// SetSignedTxFunc mocks the SetSignedTx method.
	SetSignedTxFunc func(ctx sdk.Context, tx *wire.MsgTx)

	// SetUnsignedTxFunc mocks the SetUnsignedTx method.
	SetUnsignedTxFunc func(ctx sdk.Context, tx *wire.MsgTx)

	// calls tracks calls to the methods.
	calls struct {
		// Codec holds details about calls to the Codec method.
		Codec []struct {
		}
		// DeleteOutpointInfo holds details about calls to the DeleteOutpointInfo method.
		DeleteOutpointInfo []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// OutPoint is the outPoint argument value.
			OutPoint wire.OutPoint
		}
		// DeletePendingOutPointInfo holds details about calls to the DeletePendingOutPointInfo method.
		DeletePendingOutPointInfo []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Poll is the poll argument value.
			Poll exported.PollMeta
		}
		// DeleteSignedTx holds details about calls to the DeleteSignedTx method.
		DeleteSignedTx []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// DeleteUnsignedTx holds details about calls to the DeleteUnsignedTx method.
		DeleteUnsignedTx []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetAddress holds details about calls to the GetAddress method.
		GetAddress []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// EncodedAddress is the encodedAddress argument value.
			EncodedAddress string
		}
		// GetConfirmedOutPointInfos holds details about calls to the GetConfirmedOutPointInfos method.
		GetConfirmedOutPointInfos []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetMasterKeyVout holds details about calls to the GetMasterKeyVout method.
		GetMasterKeyVout []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetNetwork holds details about calls to the GetNetwork method.
		GetNetwork []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetOutPointInfo holds details about calls to the GetOutPointInfo method.
		GetOutPointInfo []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// OutPoint is the outPoint argument value.
			OutPoint wire.OutPoint
		}
		// GetParams holds details about calls to the GetParams method.
		GetParams []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetPendingOutPointInfo holds details about calls to the GetPendingOutPointInfo method.
		GetPendingOutPointInfo []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Poll is the poll argument value.
			Poll exported.PollMeta
		}
		// GetRequiredConfirmationHeight holds details about calls to the GetRequiredConfirmationHeight method.
		GetRequiredConfirmationHeight []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetRevoteLockingPeriod holds details about calls to the GetRevoteLockingPeriod method.
		GetRevoteLockingPeriod []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetSigCheckInterval holds details about calls to the GetSigCheckInterval method.
		GetSigCheckInterval []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetSignedTx holds details about calls to the GetSignedTx method.
		GetSignedTx []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetUnsignedTx holds details about calls to the GetUnsignedTx method.
		GetUnsignedTx []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// Logger holds details about calls to the Logger method.
		Logger []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// SetAddress holds details about calls to the SetAddress method.
		SetAddress []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Address is the address argument value.
			Address types.AddressInfo
		}
		// SetMasterKeyVout holds details about calls to the SetMasterKeyVout method.
		SetMasterKeyVout []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Vout is the vout argument value.
			Vout uint32
		}
		// SetOutpointInfo holds details about calls to the SetOutpointInfo method.
		SetOutpointInfo []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Info is the info argument value.
			Info types.OutPointInfo
			// State is the state argument value.
			State types.OutPointState
		}
		// SetParams holds details about calls to the SetParams method.
		SetParams []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// P is the p argument value.
			P types.Params
		}
		// SetPendingOutpointInfo holds details about calls to the SetPendingOutpointInfo method.
		SetPendingOutpointInfo []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Poll is the poll argument value.
			Poll exported.PollMeta
			// Info is the info argument value.
			Info types.OutPointInfo
		}
		// SetSignedTx holds details about calls to the SetSignedTx method.
		SetSignedTx []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Tx is the tx argument value.
			Tx *wire.MsgTx
		}
		// SetUnsignedTx holds details about calls to the SetUnsignedTx method.
		SetUnsignedTx []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Tx is the tx argument value.
			Tx *wire.MsgTx
		}
	}
	lockCodec                         sync.RWMutex
	lockDeleteOutpointInfo            sync.RWMutex
	lockDeletePendingOutPointInfo     sync.RWMutex
	lockDeleteSignedTx                sync.RWMutex
	lockDeleteUnsignedTx              sync.RWMutex
	lockGetAddress                    sync.RWMutex
	lockGetConfirmedOutPointInfos     sync.RWMutex
	lockGetMasterKeyVout              sync.RWMutex
	lockGetNetwork                    sync.RWMutex
	lockGetOutPointInfo               sync.RWMutex
	lockGetParams                     sync.RWMutex
	lockGetPendingOutPointInfo        sync.RWMutex
	lockGetRequiredConfirmationHeight sync.RWMutex
	lockGetRevoteLockingPeriod        sync.RWMutex
	lockGetSigCheckInterval           sync.RWMutex
	lockGetSignedTx                   sync.RWMutex
	lockGetUnsignedTx                 sync.RWMutex
	lockLogger                        sync.RWMutex
	lockSetAddress                    sync.RWMutex
	lockSetMasterKeyVout              sync.RWMutex
	lockSetOutpointInfo               sync.RWMutex
	lockSetParams                     sync.RWMutex
	lockSetPendingOutpointInfo        sync.RWMutex
	lockSetSignedTx                   sync.RWMutex
	lockSetUnsignedTx                 sync.RWMutex
}

// Codec calls CodecFunc.
func (mock *BTCKeeperMock) Codec() *codec.LegacyAmino {
	if mock.CodecFunc == nil {
		panic("BTCKeeperMock.CodecFunc: method is nil but BTCKeeper.Codec was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCodec.Lock()
	mock.calls.Codec = append(mock.calls.Codec, callInfo)
	mock.lockCodec.Unlock()
	return mock.CodecFunc()
}

// CodecCalls gets all the calls that were made to Codec.
// Check the length with:
//     len(mockedBTCKeeper.CodecCalls())
func (mock *BTCKeeperMock) CodecCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCodec.RLock()
	calls = mock.calls.Codec
	mock.lockCodec.RUnlock()
	return calls
}

// DeleteOutpointInfo calls DeleteOutpointInfoFunc.
func (mock *BTCKeeperMock) DeleteOutpointInfo(ctx sdk.Context, outPoint wire.OutPoint) {
	if mock.DeleteOutpointInfoFunc == nil {
		panic("BTCKeeperMock.DeleteOutpointInfoFunc: method is nil but BTCKeeper.DeleteOutpointInfo was just called")
	}
	callInfo := struct {
		Ctx      sdk.Context
		OutPoint wire.OutPoint
	}{
		Ctx:      ctx,
		OutPoint: outPoint,
	}
	mock.lockDeleteOutpointInfo.Lock()
	mock.calls.DeleteOutpointInfo = append(mock.calls.DeleteOutpointInfo, callInfo)
	mock.lockDeleteOutpointInfo.Unlock()
	mock.DeleteOutpointInfoFunc(ctx, outPoint)
}

// DeleteOutpointInfoCalls gets all the calls that were made to DeleteOutpointInfo.
// Check the length with:
//     len(mockedBTCKeeper.DeleteOutpointInfoCalls())
func (mock *BTCKeeperMock) DeleteOutpointInfoCalls() []struct {
	Ctx      sdk.Context
	OutPoint wire.OutPoint
} {
	var calls []struct {
		Ctx      sdk.Context
		OutPoint wire.OutPoint
	}
	mock.lockDeleteOutpointInfo.RLock()
	calls = mock.calls.DeleteOutpointInfo
	mock.lockDeleteOutpointInfo.RUnlock()
	return calls
}

// DeletePendingOutPointInfo calls DeletePendingOutPointInfoFunc.
func (mock *BTCKeeperMock) DeletePendingOutPointInfo(ctx sdk.Context, poll exported.PollMeta) {
	if mock.DeletePendingOutPointInfoFunc == nil {
		panic("BTCKeeperMock.DeletePendingOutPointInfoFunc: method is nil but BTCKeeper.DeletePendingOutPointInfo was just called")
	}
	callInfo := struct {
		Ctx  sdk.Context
		Poll exported.PollMeta
	}{
		Ctx:  ctx,
		Poll: poll,
	}
	mock.lockDeletePendingOutPointInfo.Lock()
	mock.calls.DeletePendingOutPointInfo = append(mock.calls.DeletePendingOutPointInfo, callInfo)
	mock.lockDeletePendingOutPointInfo.Unlock()
	mock.DeletePendingOutPointInfoFunc(ctx, poll)
}

// DeletePendingOutPointInfoCalls gets all the calls that were made to DeletePendingOutPointInfo.
// Check the length with:
//     len(mockedBTCKeeper.DeletePendingOutPointInfoCalls())
func (mock *BTCKeeperMock) DeletePendingOutPointInfoCalls() []struct {
	Ctx  sdk.Context
	Poll exported.PollMeta
} {
	var calls []struct {
		Ctx  sdk.Context
		Poll exported.PollMeta
	}
	mock.lockDeletePendingOutPointInfo.RLock()
	calls = mock.calls.DeletePendingOutPointInfo
	mock.lockDeletePendingOutPointInfo.RUnlock()
	return calls
}

// DeleteSignedTx calls DeleteSignedTxFunc.
func (mock *BTCKeeperMock) DeleteSignedTx(ctx sdk.Context) {
	if mock.DeleteSignedTxFunc == nil {
		panic("BTCKeeperMock.DeleteSignedTxFunc: method is nil but BTCKeeper.DeleteSignedTx was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockDeleteSignedTx.Lock()
	mock.calls.DeleteSignedTx = append(mock.calls.DeleteSignedTx, callInfo)
	mock.lockDeleteSignedTx.Unlock()
	mock.DeleteSignedTxFunc(ctx)
}

// DeleteSignedTxCalls gets all the calls that were made to DeleteSignedTx.
// Check the length with:
//     len(mockedBTCKeeper.DeleteSignedTxCalls())
func (mock *BTCKeeperMock) DeleteSignedTxCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockDeleteSignedTx.RLock()
	calls = mock.calls.DeleteSignedTx
	mock.lockDeleteSignedTx.RUnlock()
	return calls
}

// DeleteUnsignedTx calls DeleteUnsignedTxFunc.
func (mock *BTCKeeperMock) DeleteUnsignedTx(ctx sdk.Context) {
	if mock.DeleteUnsignedTxFunc == nil {
		panic("BTCKeeperMock.DeleteUnsignedTxFunc: method is nil but BTCKeeper.DeleteUnsignedTx was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockDeleteUnsignedTx.Lock()
	mock.calls.DeleteUnsignedTx = append(mock.calls.DeleteUnsignedTx, callInfo)
	mock.lockDeleteUnsignedTx.Unlock()
	mock.DeleteUnsignedTxFunc(ctx)
}

// DeleteUnsignedTxCalls gets all the calls that were made to DeleteUnsignedTx.
// Check the length with:
//     len(mockedBTCKeeper.DeleteUnsignedTxCalls())
func (mock *BTCKeeperMock) DeleteUnsignedTxCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockDeleteUnsignedTx.RLock()
	calls = mock.calls.DeleteUnsignedTx
	mock.lockDeleteUnsignedTx.RUnlock()
	return calls
}

// GetAddress calls GetAddressFunc.
func (mock *BTCKeeperMock) GetAddress(ctx sdk.Context, encodedAddress string) (types.AddressInfo, bool) {
	if mock.GetAddressFunc == nil {
		panic("BTCKeeperMock.GetAddressFunc: method is nil but BTCKeeper.GetAddress was just called")
	}
	callInfo := struct {
		Ctx            sdk.Context
		EncodedAddress string
	}{
		Ctx:            ctx,
		EncodedAddress: encodedAddress,
	}
	mock.lockGetAddress.Lock()
	mock.calls.GetAddress = append(mock.calls.GetAddress, callInfo)
	mock.lockGetAddress.Unlock()
	return mock.GetAddressFunc(ctx, encodedAddress)
}

// GetAddressCalls gets all the calls that were made to GetAddress.
// Check the length with:
//     len(mockedBTCKeeper.GetAddressCalls())
func (mock *BTCKeeperMock) GetAddressCalls() []struct {
	Ctx            sdk.Context
	EncodedAddress string
} {
	var calls []struct {
		Ctx            sdk.Context
		EncodedAddress string
	}
	mock.lockGetAddress.RLock()
	calls = mock.calls.GetAddress
	mock.lockGetAddress.RUnlock()
	return calls
}

// GetConfirmedOutPointInfos calls GetConfirmedOutPointInfosFunc.
func (mock *BTCKeeperMock) GetConfirmedOutPointInfos(ctx sdk.Context) []types.OutPointInfo {
	if mock.GetConfirmedOutPointInfosFunc == nil {
		panic("BTCKeeperMock.GetConfirmedOutPointInfosFunc: method is nil but BTCKeeper.GetConfirmedOutPointInfos was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetConfirmedOutPointInfos.Lock()
	mock.calls.GetConfirmedOutPointInfos = append(mock.calls.GetConfirmedOutPointInfos, callInfo)
	mock.lockGetConfirmedOutPointInfos.Unlock()
	return mock.GetConfirmedOutPointInfosFunc(ctx)
}

// GetConfirmedOutPointInfosCalls gets all the calls that were made to GetConfirmedOutPointInfos.
// Check the length with:
//     len(mockedBTCKeeper.GetConfirmedOutPointInfosCalls())
func (mock *BTCKeeperMock) GetConfirmedOutPointInfosCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetConfirmedOutPointInfos.RLock()
	calls = mock.calls.GetConfirmedOutPointInfos
	mock.lockGetConfirmedOutPointInfos.RUnlock()
	return calls
}

// GetMasterKeyVout calls GetMasterKeyVoutFunc.
func (mock *BTCKeeperMock) GetMasterKeyVout(ctx sdk.Context) (uint32, bool) {
	if mock.GetMasterKeyVoutFunc == nil {
		panic("BTCKeeperMock.GetMasterKeyVoutFunc: method is nil but BTCKeeper.GetMasterKeyVout was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetMasterKeyVout.Lock()
	mock.calls.GetMasterKeyVout = append(mock.calls.GetMasterKeyVout, callInfo)
	mock.lockGetMasterKeyVout.Unlock()
	return mock.GetMasterKeyVoutFunc(ctx)
}

// GetMasterKeyVoutCalls gets all the calls that were made to GetMasterKeyVout.
// Check the length with:
//     len(mockedBTCKeeper.GetMasterKeyVoutCalls())
func (mock *BTCKeeperMock) GetMasterKeyVoutCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetMasterKeyVout.RLock()
	calls = mock.calls.GetMasterKeyVout
	mock.lockGetMasterKeyVout.RUnlock()
	return calls
}

// GetNetwork calls GetNetworkFunc.
func (mock *BTCKeeperMock) GetNetwork(ctx sdk.Context) types.Network {
	if mock.GetNetworkFunc == nil {
		panic("BTCKeeperMock.GetNetworkFunc: method is nil but BTCKeeper.GetNetwork was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetNetwork.Lock()
	mock.calls.GetNetwork = append(mock.calls.GetNetwork, callInfo)
	mock.lockGetNetwork.Unlock()
	return mock.GetNetworkFunc(ctx)
}

// GetNetworkCalls gets all the calls that were made to GetNetwork.
// Check the length with:
//     len(mockedBTCKeeper.GetNetworkCalls())
func (mock *BTCKeeperMock) GetNetworkCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetNetwork.RLock()
	calls = mock.calls.GetNetwork
	mock.lockGetNetwork.RUnlock()
	return calls
}

// GetOutPointInfo calls GetOutPointInfoFunc.
func (mock *BTCKeeperMock) GetOutPointInfo(ctx sdk.Context, outPoint wire.OutPoint) (types.OutPointInfo, types.OutPointState, bool) {
	if mock.GetOutPointInfoFunc == nil {
		panic("BTCKeeperMock.GetOutPointInfoFunc: method is nil but BTCKeeper.GetOutPointInfo was just called")
	}
	callInfo := struct {
		Ctx      sdk.Context
		OutPoint wire.OutPoint
	}{
		Ctx:      ctx,
		OutPoint: outPoint,
	}
	mock.lockGetOutPointInfo.Lock()
	mock.calls.GetOutPointInfo = append(mock.calls.GetOutPointInfo, callInfo)
	mock.lockGetOutPointInfo.Unlock()
	return mock.GetOutPointInfoFunc(ctx, outPoint)
}

// GetOutPointInfoCalls gets all the calls that were made to GetOutPointInfo.
// Check the length with:
//     len(mockedBTCKeeper.GetOutPointInfoCalls())
func (mock *BTCKeeperMock) GetOutPointInfoCalls() []struct {
	Ctx      sdk.Context
	OutPoint wire.OutPoint
} {
	var calls []struct {
		Ctx      sdk.Context
		OutPoint wire.OutPoint
	}
	mock.lockGetOutPointInfo.RLock()
	calls = mock.calls.GetOutPointInfo
	mock.lockGetOutPointInfo.RUnlock()
	return calls
}

// GetParams calls GetParamsFunc.
func (mock *BTCKeeperMock) GetParams(ctx sdk.Context) types.Params {
	if mock.GetParamsFunc == nil {
		panic("BTCKeeperMock.GetParamsFunc: method is nil but BTCKeeper.GetParams was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetParams.Lock()
	mock.calls.GetParams = append(mock.calls.GetParams, callInfo)
	mock.lockGetParams.Unlock()
	return mock.GetParamsFunc(ctx)
}

// GetParamsCalls gets all the calls that were made to GetParams.
// Check the length with:
//     len(mockedBTCKeeper.GetParamsCalls())
func (mock *BTCKeeperMock) GetParamsCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetParams.RLock()
	calls = mock.calls.GetParams
	mock.lockGetParams.RUnlock()
	return calls
}

// GetPendingOutPointInfo calls GetPendingOutPointInfoFunc.
func (mock *BTCKeeperMock) GetPendingOutPointInfo(ctx sdk.Context, poll exported.PollMeta) (types.OutPointInfo, bool) {
	if mock.GetPendingOutPointInfoFunc == nil {
		panic("BTCKeeperMock.GetPendingOutPointInfoFunc: method is nil but BTCKeeper.GetPendingOutPointInfo was just called")
	}
	callInfo := struct {
		Ctx  sdk.Context
		Poll exported.PollMeta
	}{
		Ctx:  ctx,
		Poll: poll,
	}
	mock.lockGetPendingOutPointInfo.Lock()
	mock.calls.GetPendingOutPointInfo = append(mock.calls.GetPendingOutPointInfo, callInfo)
	mock.lockGetPendingOutPointInfo.Unlock()
	return mock.GetPendingOutPointInfoFunc(ctx, poll)
}

// GetPendingOutPointInfoCalls gets all the calls that were made to GetPendingOutPointInfo.
// Check the length with:
//     len(mockedBTCKeeper.GetPendingOutPointInfoCalls())
func (mock *BTCKeeperMock) GetPendingOutPointInfoCalls() []struct {
	Ctx  sdk.Context
	Poll exported.PollMeta
} {
	var calls []struct {
		Ctx  sdk.Context
		Poll exported.PollMeta
	}
	mock.lockGetPendingOutPointInfo.RLock()
	calls = mock.calls.GetPendingOutPointInfo
	mock.lockGetPendingOutPointInfo.RUnlock()
	return calls
}

// GetRequiredConfirmationHeight calls GetRequiredConfirmationHeightFunc.
func (mock *BTCKeeperMock) GetRequiredConfirmationHeight(ctx sdk.Context) uint64 {
	if mock.GetRequiredConfirmationHeightFunc == nil {
		panic("BTCKeeperMock.GetRequiredConfirmationHeightFunc: method is nil but BTCKeeper.GetRequiredConfirmationHeight was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetRequiredConfirmationHeight.Lock()
	mock.calls.GetRequiredConfirmationHeight = append(mock.calls.GetRequiredConfirmationHeight, callInfo)
	mock.lockGetRequiredConfirmationHeight.Unlock()
	return mock.GetRequiredConfirmationHeightFunc(ctx)
}

// GetRequiredConfirmationHeightCalls gets all the calls that were made to GetRequiredConfirmationHeight.
// Check the length with:
//     len(mockedBTCKeeper.GetRequiredConfirmationHeightCalls())
func (mock *BTCKeeperMock) GetRequiredConfirmationHeightCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetRequiredConfirmationHeight.RLock()
	calls = mock.calls.GetRequiredConfirmationHeight
	mock.lockGetRequiredConfirmationHeight.RUnlock()
	return calls
}

// GetRevoteLockingPeriod calls GetRevoteLockingPeriodFunc.
func (mock *BTCKeeperMock) GetRevoteLockingPeriod(ctx sdk.Context) int64 {
	if mock.GetRevoteLockingPeriodFunc == nil {
		panic("BTCKeeperMock.GetRevoteLockingPeriodFunc: method is nil but BTCKeeper.GetRevoteLockingPeriod was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetRevoteLockingPeriod.Lock()
	mock.calls.GetRevoteLockingPeriod = append(mock.calls.GetRevoteLockingPeriod, callInfo)
	mock.lockGetRevoteLockingPeriod.Unlock()
	return mock.GetRevoteLockingPeriodFunc(ctx)
}

// GetRevoteLockingPeriodCalls gets all the calls that were made to GetRevoteLockingPeriod.
// Check the length with:
//     len(mockedBTCKeeper.GetRevoteLockingPeriodCalls())
func (mock *BTCKeeperMock) GetRevoteLockingPeriodCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetRevoteLockingPeriod.RLock()
	calls = mock.calls.GetRevoteLockingPeriod
	mock.lockGetRevoteLockingPeriod.RUnlock()
	return calls
}

// GetSigCheckInterval calls GetSigCheckIntervalFunc.
func (mock *BTCKeeperMock) GetSigCheckInterval(ctx sdk.Context) int64 {
	if mock.GetSigCheckIntervalFunc == nil {
		panic("BTCKeeperMock.GetSigCheckIntervalFunc: method is nil but BTCKeeper.GetSigCheckInterval was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetSigCheckInterval.Lock()
	mock.calls.GetSigCheckInterval = append(mock.calls.GetSigCheckInterval, callInfo)
	mock.lockGetSigCheckInterval.Unlock()
	return mock.GetSigCheckIntervalFunc(ctx)
}

// GetSigCheckIntervalCalls gets all the calls that were made to GetSigCheckInterval.
// Check the length with:
//     len(mockedBTCKeeper.GetSigCheckIntervalCalls())
func (mock *BTCKeeperMock) GetSigCheckIntervalCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetSigCheckInterval.RLock()
	calls = mock.calls.GetSigCheckInterval
	mock.lockGetSigCheckInterval.RUnlock()
	return calls
}

// GetSignedTx calls GetSignedTxFunc.
func (mock *BTCKeeperMock) GetSignedTx(ctx sdk.Context) (*wire.MsgTx, bool) {
	if mock.GetSignedTxFunc == nil {
		panic("BTCKeeperMock.GetSignedTxFunc: method is nil but BTCKeeper.GetSignedTx was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetSignedTx.Lock()
	mock.calls.GetSignedTx = append(mock.calls.GetSignedTx, callInfo)
	mock.lockGetSignedTx.Unlock()
	return mock.GetSignedTxFunc(ctx)
}

// GetSignedTxCalls gets all the calls that were made to GetSignedTx.
// Check the length with:
//     len(mockedBTCKeeper.GetSignedTxCalls())
func (mock *BTCKeeperMock) GetSignedTxCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetSignedTx.RLock()
	calls = mock.calls.GetSignedTx
	mock.lockGetSignedTx.RUnlock()
	return calls
}

// GetUnsignedTx calls GetUnsignedTxFunc.
func (mock *BTCKeeperMock) GetUnsignedTx(ctx sdk.Context) (*wire.MsgTx, bool) {
	if mock.GetUnsignedTxFunc == nil {
		panic("BTCKeeperMock.GetUnsignedTxFunc: method is nil but BTCKeeper.GetUnsignedTx was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetUnsignedTx.Lock()
	mock.calls.GetUnsignedTx = append(mock.calls.GetUnsignedTx, callInfo)
	mock.lockGetUnsignedTx.Unlock()
	return mock.GetUnsignedTxFunc(ctx)
}

// GetUnsignedTxCalls gets all the calls that were made to GetUnsignedTx.
// Check the length with:
//     len(mockedBTCKeeper.GetUnsignedTxCalls())
func (mock *BTCKeeperMock) GetUnsignedTxCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetUnsignedTx.RLock()
	calls = mock.calls.GetUnsignedTx
	mock.lockGetUnsignedTx.RUnlock()
	return calls
}

// Logger calls LoggerFunc.
func (mock *BTCKeeperMock) Logger(ctx sdk.Context) log.Logger {
	if mock.LoggerFunc == nil {
		panic("BTCKeeperMock.LoggerFunc: method is nil but BTCKeeper.Logger was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockLogger.Lock()
	mock.calls.Logger = append(mock.calls.Logger, callInfo)
	mock.lockLogger.Unlock()
	return mock.LoggerFunc(ctx)
}

// LoggerCalls gets all the calls that were made to Logger.
// Check the length with:
//     len(mockedBTCKeeper.LoggerCalls())
func (mock *BTCKeeperMock) LoggerCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockLogger.RLock()
	calls = mock.calls.Logger
	mock.lockLogger.RUnlock()
	return calls
}

// SetAddress calls SetAddressFunc.
func (mock *BTCKeeperMock) SetAddress(ctx sdk.Context, address types.AddressInfo) {
	if mock.SetAddressFunc == nil {
		panic("BTCKeeperMock.SetAddressFunc: method is nil but BTCKeeper.SetAddress was just called")
	}
	callInfo := struct {
		Ctx     sdk.Context
		Address types.AddressInfo
	}{
		Ctx:     ctx,
		Address: address,
	}
	mock.lockSetAddress.Lock()
	mock.calls.SetAddress = append(mock.calls.SetAddress, callInfo)
	mock.lockSetAddress.Unlock()
	mock.SetAddressFunc(ctx, address)
}

// SetAddressCalls gets all the calls that were made to SetAddress.
// Check the length with:
//     len(mockedBTCKeeper.SetAddressCalls())
func (mock *BTCKeeperMock) SetAddressCalls() []struct {
	Ctx     sdk.Context
	Address types.AddressInfo
} {
	var calls []struct {
		Ctx     sdk.Context
		Address types.AddressInfo
	}
	mock.lockSetAddress.RLock()
	calls = mock.calls.SetAddress
	mock.lockSetAddress.RUnlock()
	return calls
}

// SetMasterKeyVout calls SetMasterKeyVoutFunc.
func (mock *BTCKeeperMock) SetMasterKeyVout(ctx sdk.Context, vout uint32) {
	if mock.SetMasterKeyVoutFunc == nil {
		panic("BTCKeeperMock.SetMasterKeyVoutFunc: method is nil but BTCKeeper.SetMasterKeyVout was just called")
	}
	callInfo := struct {
		Ctx  sdk.Context
		Vout uint32
	}{
		Ctx:  ctx,
		Vout: vout,
	}
	mock.lockSetMasterKeyVout.Lock()
	mock.calls.SetMasterKeyVout = append(mock.calls.SetMasterKeyVout, callInfo)
	mock.lockSetMasterKeyVout.Unlock()
	mock.SetMasterKeyVoutFunc(ctx, vout)
}

// SetMasterKeyVoutCalls gets all the calls that were made to SetMasterKeyVout.
// Check the length with:
//     len(mockedBTCKeeper.SetMasterKeyVoutCalls())
func (mock *BTCKeeperMock) SetMasterKeyVoutCalls() []struct {
	Ctx  sdk.Context
	Vout uint32
} {
	var calls []struct {
		Ctx  sdk.Context
		Vout uint32
	}
	mock.lockSetMasterKeyVout.RLock()
	calls = mock.calls.SetMasterKeyVout
	mock.lockSetMasterKeyVout.RUnlock()
	return calls
}

// SetOutpointInfo calls SetOutpointInfoFunc.
func (mock *BTCKeeperMock) SetOutpointInfo(ctx sdk.Context, info types.OutPointInfo, state types.OutPointState) {
	if mock.SetOutpointInfoFunc == nil {
		panic("BTCKeeperMock.SetOutpointInfoFunc: method is nil but BTCKeeper.SetOutpointInfo was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		Info  types.OutPointInfo
		State types.OutPointState
	}{
		Ctx:   ctx,
		Info:  info,
		State: state,
	}
	mock.lockSetOutpointInfo.Lock()
	mock.calls.SetOutpointInfo = append(mock.calls.SetOutpointInfo, callInfo)
	mock.lockSetOutpointInfo.Unlock()
	mock.SetOutpointInfoFunc(ctx, info, state)
}

// SetOutpointInfoCalls gets all the calls that were made to SetOutpointInfo.
// Check the length with:
//     len(mockedBTCKeeper.SetOutpointInfoCalls())
func (mock *BTCKeeperMock) SetOutpointInfoCalls() []struct {
	Ctx   sdk.Context
	Info  types.OutPointInfo
	State types.OutPointState
} {
	var calls []struct {
		Ctx   sdk.Context
		Info  types.OutPointInfo
		State types.OutPointState
	}
	mock.lockSetOutpointInfo.RLock()
	calls = mock.calls.SetOutpointInfo
	mock.lockSetOutpointInfo.RUnlock()
	return calls
}

// SetParams calls SetParamsFunc.
func (mock *BTCKeeperMock) SetParams(ctx sdk.Context, p types.Params) {
	if mock.SetParamsFunc == nil {
		panic("BTCKeeperMock.SetParamsFunc: method is nil but BTCKeeper.SetParams was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
		P   types.Params
	}{
		Ctx: ctx,
		P:   p,
	}
	mock.lockSetParams.Lock()
	mock.calls.SetParams = append(mock.calls.SetParams, callInfo)
	mock.lockSetParams.Unlock()
	mock.SetParamsFunc(ctx, p)
}

// SetParamsCalls gets all the calls that were made to SetParams.
// Check the length with:
//     len(mockedBTCKeeper.SetParamsCalls())
func (mock *BTCKeeperMock) SetParamsCalls() []struct {
	Ctx sdk.Context
	P   types.Params
} {
	var calls []struct {
		Ctx sdk.Context
		P   types.Params
	}
	mock.lockSetParams.RLock()
	calls = mock.calls.SetParams
	mock.lockSetParams.RUnlock()
	return calls
}

// SetPendingOutpointInfo calls SetPendingOutpointInfoFunc.
func (mock *BTCKeeperMock) SetPendingOutpointInfo(ctx sdk.Context, poll exported.PollMeta, info types.OutPointInfo) {
	if mock.SetPendingOutpointInfoFunc == nil {
		panic("BTCKeeperMock.SetPendingOutpointInfoFunc: method is nil but BTCKeeper.SetPendingOutpointInfo was just called")
	}
	callInfo := struct {
		Ctx  sdk.Context
		Poll exported.PollMeta
		Info types.OutPointInfo
	}{
		Ctx:  ctx,
		Poll: poll,
		Info: info,
	}
	mock.lockSetPendingOutpointInfo.Lock()
	mock.calls.SetPendingOutpointInfo = append(mock.calls.SetPendingOutpointInfo, callInfo)
	mock.lockSetPendingOutpointInfo.Unlock()
	mock.SetPendingOutpointInfoFunc(ctx, poll, info)
}

// SetPendingOutpointInfoCalls gets all the calls that were made to SetPendingOutpointInfo.
// Check the length with:
//     len(mockedBTCKeeper.SetPendingOutpointInfoCalls())
func (mock *BTCKeeperMock) SetPendingOutpointInfoCalls() []struct {
	Ctx  sdk.Context
	Poll exported.PollMeta
	Info types.OutPointInfo
} {
	var calls []struct {
		Ctx  sdk.Context
		Poll exported.PollMeta
		Info types.OutPointInfo
	}
	mock.lockSetPendingOutpointInfo.RLock()
	calls = mock.calls.SetPendingOutpointInfo
	mock.lockSetPendingOutpointInfo.RUnlock()
	return calls
}

// SetSignedTx calls SetSignedTxFunc.
func (mock *BTCKeeperMock) SetSignedTx(ctx sdk.Context, tx *wire.MsgTx) {
	if mock.SetSignedTxFunc == nil {
		panic("BTCKeeperMock.SetSignedTxFunc: method is nil but BTCKeeper.SetSignedTx was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
		Tx  *wire.MsgTx
	}{
		Ctx: ctx,
		Tx:  tx,
	}
	mock.lockSetSignedTx.Lock()
	mock.calls.SetSignedTx = append(mock.calls.SetSignedTx, callInfo)
	mock.lockSetSignedTx.Unlock()
	mock.SetSignedTxFunc(ctx, tx)
}

// SetSignedTxCalls gets all the calls that were made to SetSignedTx.
// Check the length with:
//     len(mockedBTCKeeper.SetSignedTxCalls())
func (mock *BTCKeeperMock) SetSignedTxCalls() []struct {
	Ctx sdk.Context
	Tx  *wire.MsgTx
} {
	var calls []struct {
		Ctx sdk.Context
		Tx  *wire.MsgTx
	}
	mock.lockSetSignedTx.RLock()
	calls = mock.calls.SetSignedTx
	mock.lockSetSignedTx.RUnlock()
	return calls
}

// SetUnsignedTx calls SetUnsignedTxFunc.
func (mock *BTCKeeperMock) SetUnsignedTx(ctx sdk.Context, tx *wire.MsgTx) {
	if mock.SetUnsignedTxFunc == nil {
		panic("BTCKeeperMock.SetUnsignedTxFunc: method is nil but BTCKeeper.SetUnsignedTx was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
		Tx  *wire.MsgTx
	}{
		Ctx: ctx,
		Tx:  tx,
	}
	mock.lockSetUnsignedTx.Lock()
	mock.calls.SetUnsignedTx = append(mock.calls.SetUnsignedTx, callInfo)
	mock.lockSetUnsignedTx.Unlock()
	mock.SetUnsignedTxFunc(ctx, tx)
}

// SetUnsignedTxCalls gets all the calls that were made to SetUnsignedTx.
// Check the length with:
//     len(mockedBTCKeeper.SetUnsignedTxCalls())
func (mock *BTCKeeperMock) SetUnsignedTxCalls() []struct {
	Ctx sdk.Context
	Tx  *wire.MsgTx
} {
	var calls []struct {
		Ctx sdk.Context
		Tx  *wire.MsgTx
	}
	mock.lockSetUnsignedTx.RLock()
	calls = mock.calls.SetUnsignedTx
	mock.lockSetUnsignedTx.RUnlock()
	return calls
}
