// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"github.com/axelarnetwork/axelar-core/x/multisig/exported"
	"github.com/cosmos/cosmos-sdk/codec"
	sdk "github.com/cosmos/cosmos-sdk/types"
	"sync"
)

// Ensure, that SigHandlerMock does implement exported.SigHandler.
// If this is not the case, regenerate this file with moq.
var _ exported.SigHandler = &SigHandlerMock{}

// SigHandlerMock is a mock implementation of exported.SigHandler.
//
// 	func TestSomethingThatUsesSigHandler(t *testing.T) {
//
// 		// make and configure a mocked exported.SigHandler
// 		mockedSigHandler := &SigHandlerMock{
// 			HandleCompletedFunc: func(ctx sdk.Context, sig codec.ProtoMarshaler, moduleMetadata codec.ProtoMarshaler) error {
// 				panic("mock out the HandleCompleted method")
// 			},
// 			HandleFailedFunc: func(ctx sdk.Context, moduleMetadata codec.ProtoMarshaler) error {
// 				panic("mock out the HandleFailed method")
// 			},
// 		}
//
// 		// use mockedSigHandler in code that requires exported.SigHandler
// 		// and then make assertions.
//
// 	}
type SigHandlerMock struct {
	// HandleCompletedFunc mocks the HandleCompleted method.
	HandleCompletedFunc func(ctx sdk.Context, sig codec.ProtoMarshaler, moduleMetadata codec.ProtoMarshaler) error

	// HandleFailedFunc mocks the HandleFailed method.
	HandleFailedFunc func(ctx sdk.Context, moduleMetadata codec.ProtoMarshaler) error

	// calls tracks calls to the methods.
	calls struct {
		// HandleCompleted holds details about calls to the HandleCompleted method.
		HandleCompleted []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Sig is the sig argument value.
			Sig codec.ProtoMarshaler
			// ModuleMetadata is the moduleMetadata argument value.
			ModuleMetadata codec.ProtoMarshaler
		}
		// HandleFailed holds details about calls to the HandleFailed method.
		HandleFailed []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// ModuleMetadata is the moduleMetadata argument value.
			ModuleMetadata codec.ProtoMarshaler
		}
	}
	lockHandleCompleted sync.RWMutex
	lockHandleFailed    sync.RWMutex
}

// HandleCompleted calls HandleCompletedFunc.
func (mock *SigHandlerMock) HandleCompleted(ctx sdk.Context, sig codec.ProtoMarshaler, moduleMetadata codec.ProtoMarshaler) error {
	if mock.HandleCompletedFunc == nil {
		panic("SigHandlerMock.HandleCompletedFunc: method is nil but SigHandler.HandleCompleted was just called")
	}
	callInfo := struct {
		Ctx            sdk.Context
		Sig            codec.ProtoMarshaler
		ModuleMetadata codec.ProtoMarshaler
	}{
		Ctx:            ctx,
		Sig:            sig,
		ModuleMetadata: moduleMetadata,
	}
	mock.lockHandleCompleted.Lock()
	mock.calls.HandleCompleted = append(mock.calls.HandleCompleted, callInfo)
	mock.lockHandleCompleted.Unlock()
	return mock.HandleCompletedFunc(ctx, sig, moduleMetadata)
}

// HandleCompletedCalls gets all the calls that were made to HandleCompleted.
// Check the length with:
//     len(mockedSigHandler.HandleCompletedCalls())
func (mock *SigHandlerMock) HandleCompletedCalls() []struct {
	Ctx            sdk.Context
	Sig            codec.ProtoMarshaler
	ModuleMetadata codec.ProtoMarshaler
} {
	var calls []struct {
		Ctx            sdk.Context
		Sig            codec.ProtoMarshaler
		ModuleMetadata codec.ProtoMarshaler
	}
	mock.lockHandleCompleted.RLock()
	calls = mock.calls.HandleCompleted
	mock.lockHandleCompleted.RUnlock()
	return calls
}

// HandleFailed calls HandleFailedFunc.
func (mock *SigHandlerMock) HandleFailed(ctx sdk.Context, moduleMetadata codec.ProtoMarshaler) error {
	if mock.HandleFailedFunc == nil {
		panic("SigHandlerMock.HandleFailedFunc: method is nil but SigHandler.HandleFailed was just called")
	}
	callInfo := struct {
		Ctx            sdk.Context
		ModuleMetadata codec.ProtoMarshaler
	}{
		Ctx:            ctx,
		ModuleMetadata: moduleMetadata,
	}
	mock.lockHandleFailed.Lock()
	mock.calls.HandleFailed = append(mock.calls.HandleFailed, callInfo)
	mock.lockHandleFailed.Unlock()
	return mock.HandleFailedFunc(ctx, moduleMetadata)
}

// HandleFailedCalls gets all the calls that were made to HandleFailed.
// Check the length with:
//     len(mockedSigHandler.HandleFailedCalls())
func (mock *SigHandlerMock) HandleFailedCalls() []struct {
	Ctx            sdk.Context
	ModuleMetadata codec.ProtoMarshaler
} {
	var calls []struct {
		Ctx            sdk.Context
		ModuleMetadata codec.ProtoMarshaler
	}
	mock.lockHandleFailed.RLock()
	calls = mock.calls.HandleFailed
	mock.lockHandleFailed.RUnlock()
	return calls
}
