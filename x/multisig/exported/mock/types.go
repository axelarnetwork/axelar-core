// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"github.com/axelarnetwork/axelar-core/x/multisig/exported"
	"github.com/cosmos/cosmos-sdk/codec"
	sdk "github.com/cosmos/cosmos-sdk/types"
	"sync"
)

// Ensure, that SigHandlerMock does implement exported.SigHandler.
// If this is not the case, regenerate this file with moq.
var _ exported.SigHandler = &SigHandlerMock{}

// SigHandlerMock is a mock implementation of exported.SigHandler.
//
// 	func TestSomethingThatUsesSigHandler(t *testing.T) {
//
// 		// make and configure a mocked exported.SigHandler
// 		mockedSigHandler := &SigHandlerMock{
// 			HandleCompletedFunc: func(ctx sdk.Context, sig codec.ProtoMarshaler, moduleMetadata codec.ProtoMarshaler) error {
// 				panic("mock out the HandleCompleted method")
// 			},
// 			HandleFailedFunc: func(ctx sdk.Context, moduleMetadata codec.ProtoMarshaler) error {
// 				panic("mock out the HandleFailed method")
// 			},
// 		}
//
// 		// use mockedSigHandler in code that requires exported.SigHandler
// 		// and then make assertions.
//
// 	}
type SigHandlerMock struct {
	// HandleCompletedFunc mocks the HandleCompleted method.
	HandleCompletedFunc func(ctx sdk.Context, sig codec.ProtoMarshaler, moduleMetadata codec.ProtoMarshaler) error

	// HandleFailedFunc mocks the HandleFailed method.
	HandleFailedFunc func(ctx sdk.Context, moduleMetadata codec.ProtoMarshaler) error

	// calls tracks calls to the methods.
	calls struct {
		// HandleCompleted holds details about calls to the HandleCompleted method.
		HandleCompleted []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Sig is the sig argument value.
			Sig codec.ProtoMarshaler
			// ModuleMetadata is the moduleMetadata argument value.
			ModuleMetadata codec.ProtoMarshaler
		}
		// HandleFailed holds details about calls to the HandleFailed method.
		HandleFailed []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// ModuleMetadata is the moduleMetadata argument value.
			ModuleMetadata codec.ProtoMarshaler
		}
	}
	lockHandleCompleted sync.RWMutex
	lockHandleFailed    sync.RWMutex
}

// HandleCompleted calls HandleCompletedFunc.
func (mock *SigHandlerMock) HandleCompleted(ctx sdk.Context, sig codec.ProtoMarshaler, moduleMetadata codec.ProtoMarshaler) error {
	if mock.HandleCompletedFunc == nil {
		panic("SigHandlerMock.HandleCompletedFunc: method is nil but SigHandler.HandleCompleted was just called")
	}
	callInfo := struct {
		Ctx            sdk.Context
		Sig            codec.ProtoMarshaler
		ModuleMetadata codec.ProtoMarshaler
	}{
		Ctx:            ctx,
		Sig:            sig,
		ModuleMetadata: moduleMetadata,
	}
	mock.lockHandleCompleted.Lock()
	mock.calls.HandleCompleted = append(mock.calls.HandleCompleted, callInfo)
	mock.lockHandleCompleted.Unlock()
	return mock.HandleCompletedFunc(ctx, sig, moduleMetadata)
}

// HandleCompletedCalls gets all the calls that were made to HandleCompleted.
// Check the length with:
//     len(mockedSigHandler.HandleCompletedCalls())
func (mock *SigHandlerMock) HandleCompletedCalls() []struct {
	Ctx            sdk.Context
	Sig            codec.ProtoMarshaler
	ModuleMetadata codec.ProtoMarshaler
} {
	var calls []struct {
		Ctx            sdk.Context
		Sig            codec.ProtoMarshaler
		ModuleMetadata codec.ProtoMarshaler
	}
	mock.lockHandleCompleted.RLock()
	calls = mock.calls.HandleCompleted
	mock.lockHandleCompleted.RUnlock()
	return calls
}

// HandleFailed calls HandleFailedFunc.
func (mock *SigHandlerMock) HandleFailed(ctx sdk.Context, moduleMetadata codec.ProtoMarshaler) error {
	if mock.HandleFailedFunc == nil {
		panic("SigHandlerMock.HandleFailedFunc: method is nil but SigHandler.HandleFailed was just called")
	}
	callInfo := struct {
		Ctx            sdk.Context
		ModuleMetadata codec.ProtoMarshaler
	}{
		Ctx:            ctx,
		ModuleMetadata: moduleMetadata,
	}
	mock.lockHandleFailed.Lock()
	mock.calls.HandleFailed = append(mock.calls.HandleFailed, callInfo)
	mock.lockHandleFailed.Unlock()
	return mock.HandleFailedFunc(ctx, moduleMetadata)
}

// HandleFailedCalls gets all the calls that were made to HandleFailed.
// Check the length with:
//     len(mockedSigHandler.HandleFailedCalls())
func (mock *SigHandlerMock) HandleFailedCalls() []struct {
	Ctx            sdk.Context
	ModuleMetadata codec.ProtoMarshaler
} {
	var calls []struct {
		Ctx            sdk.Context
		ModuleMetadata codec.ProtoMarshaler
	}
	mock.lockHandleFailed.RLock()
	calls = mock.calls.HandleFailed
	mock.lockHandleFailed.RUnlock()
	return calls
}

// Ensure, that KeyMock does implement exported.Key.
// If this is not the case, regenerate this file with moq.
var _ exported.Key = &KeyMock{}

// KeyMock is a mock implementation of exported.Key.
//
// 	func TestSomethingThatUsesKey(t *testing.T) {
//
// 		// make and configure a mocked exported.Key
// 		mockedKey := &KeyMock{
// 			GetKeyIDFunc: func() exported.KeyID {
// 				panic("mock out the GetKeyID method")
// 			},
// 			GetMinPassingWeightFunc: func() sdk.Uint {
// 				panic("mock out the GetMinPassingWeight method")
// 			},
// 			GetParticipantsFunc: func() []sdk.ValAddress {
// 				panic("mock out the GetParticipants method")
// 			},
// 			GetPubKeyFunc: func(valAddress sdk.ValAddress) (exported.PublicKey, bool) {
// 				panic("mock out the GetPubKey method")
// 			},
// 			GetWeightFunc: func(valAddress sdk.ValAddress) sdk.Uint {
// 				panic("mock out the GetWeight method")
// 			},
// 		}
//
// 		// use mockedKey in code that requires exported.Key
// 		// and then make assertions.
//
// 	}
type KeyMock struct {
	// GetKeyIDFunc mocks the GetKeyID method.
	GetKeyIDFunc func() exported.KeyID

	// GetMinPassingWeightFunc mocks the GetMinPassingWeight method.
	GetMinPassingWeightFunc func() sdk.Uint

	// GetParticipantsFunc mocks the GetParticipants method.
	GetParticipantsFunc func() []sdk.ValAddress

	// GetPubKeyFunc mocks the GetPubKey method.
	GetPubKeyFunc func(valAddress sdk.ValAddress) (exported.PublicKey, bool)

	// GetWeightFunc mocks the GetWeight method.
	GetWeightFunc func(valAddress sdk.ValAddress) sdk.Uint

	// calls tracks calls to the methods.
	calls struct {
		// GetKeyID holds details about calls to the GetKeyID method.
		GetKeyID []struct {
		}
		// GetMinPassingWeight holds details about calls to the GetMinPassingWeight method.
		GetMinPassingWeight []struct {
		}
		// GetParticipants holds details about calls to the GetParticipants method.
		GetParticipants []struct {
		}
		// GetPubKey holds details about calls to the GetPubKey method.
		GetPubKey []struct {
			// ValAddress is the valAddress argument value.
			ValAddress sdk.ValAddress
		}
		// GetWeight holds details about calls to the GetWeight method.
		GetWeight []struct {
			// ValAddress is the valAddress argument value.
			ValAddress sdk.ValAddress
		}
	}
	lockGetKeyID            sync.RWMutex
	lockGetMinPassingWeight sync.RWMutex
	lockGetParticipants     sync.RWMutex
	lockGetPubKey           sync.RWMutex
	lockGetWeight           sync.RWMutex
}

// GetKeyID calls GetKeyIDFunc.
func (mock *KeyMock) GetKeyID() exported.KeyID {
	if mock.GetKeyIDFunc == nil {
		panic("KeyMock.GetKeyIDFunc: method is nil but Key.GetKeyID was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetKeyID.Lock()
	mock.calls.GetKeyID = append(mock.calls.GetKeyID, callInfo)
	mock.lockGetKeyID.Unlock()
	return mock.GetKeyIDFunc()
}

// GetKeyIDCalls gets all the calls that were made to GetKeyID.
// Check the length with:
//     len(mockedKey.GetKeyIDCalls())
func (mock *KeyMock) GetKeyIDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetKeyID.RLock()
	calls = mock.calls.GetKeyID
	mock.lockGetKeyID.RUnlock()
	return calls
}

// GetMinPassingWeight calls GetMinPassingWeightFunc.
func (mock *KeyMock) GetMinPassingWeight() sdk.Uint {
	if mock.GetMinPassingWeightFunc == nil {
		panic("KeyMock.GetMinPassingWeightFunc: method is nil but Key.GetMinPassingWeight was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetMinPassingWeight.Lock()
	mock.calls.GetMinPassingWeight = append(mock.calls.GetMinPassingWeight, callInfo)
	mock.lockGetMinPassingWeight.Unlock()
	return mock.GetMinPassingWeightFunc()
}

// GetMinPassingWeightCalls gets all the calls that were made to GetMinPassingWeight.
// Check the length with:
//     len(mockedKey.GetMinPassingWeightCalls())
func (mock *KeyMock) GetMinPassingWeightCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetMinPassingWeight.RLock()
	calls = mock.calls.GetMinPassingWeight
	mock.lockGetMinPassingWeight.RUnlock()
	return calls
}

// GetParticipants calls GetParticipantsFunc.
func (mock *KeyMock) GetParticipants() []sdk.ValAddress {
	if mock.GetParticipantsFunc == nil {
		panic("KeyMock.GetParticipantsFunc: method is nil but Key.GetParticipants was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetParticipants.Lock()
	mock.calls.GetParticipants = append(mock.calls.GetParticipants, callInfo)
	mock.lockGetParticipants.Unlock()
	return mock.GetParticipantsFunc()
}

// GetParticipantsCalls gets all the calls that were made to GetParticipants.
// Check the length with:
//     len(mockedKey.GetParticipantsCalls())
func (mock *KeyMock) GetParticipantsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetParticipants.RLock()
	calls = mock.calls.GetParticipants
	mock.lockGetParticipants.RUnlock()
	return calls
}

// GetPubKey calls GetPubKeyFunc.
func (mock *KeyMock) GetPubKey(valAddress sdk.ValAddress) (exported.PublicKey, bool) {
	if mock.GetPubKeyFunc == nil {
		panic("KeyMock.GetPubKeyFunc: method is nil but Key.GetPubKey was just called")
	}
	callInfo := struct {
		ValAddress sdk.ValAddress
	}{
		ValAddress: valAddress,
	}
	mock.lockGetPubKey.Lock()
	mock.calls.GetPubKey = append(mock.calls.GetPubKey, callInfo)
	mock.lockGetPubKey.Unlock()
	return mock.GetPubKeyFunc(valAddress)
}

// GetPubKeyCalls gets all the calls that were made to GetPubKey.
// Check the length with:
//     len(mockedKey.GetPubKeyCalls())
func (mock *KeyMock) GetPubKeyCalls() []struct {
	ValAddress sdk.ValAddress
} {
	var calls []struct {
		ValAddress sdk.ValAddress
	}
	mock.lockGetPubKey.RLock()
	calls = mock.calls.GetPubKey
	mock.lockGetPubKey.RUnlock()
	return calls
}

// GetWeight calls GetWeightFunc.
func (mock *KeyMock) GetWeight(valAddress sdk.ValAddress) sdk.Uint {
	if mock.GetWeightFunc == nil {
		panic("KeyMock.GetWeightFunc: method is nil but Key.GetWeight was just called")
	}
	callInfo := struct {
		ValAddress sdk.ValAddress
	}{
		ValAddress: valAddress,
	}
	mock.lockGetWeight.Lock()
	mock.calls.GetWeight = append(mock.calls.GetWeight, callInfo)
	mock.lockGetWeight.Unlock()
	return mock.GetWeightFunc(valAddress)
}

// GetWeightCalls gets all the calls that were made to GetWeight.
// Check the length with:
//     len(mockedKey.GetWeightCalls())
func (mock *KeyMock) GetWeightCalls() []struct {
	ValAddress sdk.ValAddress
} {
	var calls []struct {
		ValAddress sdk.ValAddress
	}
	mock.lockGetWeight.RLock()
	calls = mock.calls.GetWeight
	mock.lockGetWeight.RUnlock()
	return calls
}
