// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	utils "github.com/axelarnetwork/axelar-core/utils"
	"github.com/axelarnetwork/axelar-core/x/multisig/types"
	exported "github.com/axelarnetwork/axelar-core/x/snapshot/exported"
	sdk "github.com/cosmos/cosmos-sdk/types"
	stakingTypes "github.com/cosmos/cosmos-sdk/x/staking/types"
	"sync"
)

// Ensure, that SnapshotterMock does implement types.Snapshotter.
// If this is not the case, regenerate this file with moq.
var _ types.Snapshotter = &SnapshotterMock{}

// SnapshotterMock is a mock implementation of types.Snapshotter.
//
// 	func TestSomethingThatUsesSnapshotter(t *testing.T) {
//
// 		// make and configure a mocked types.Snapshotter
// 		mockedSnapshotter := &SnapshotterMock{
// 			CreateSnapshotFunc: func(ctx sdk.Context, candidates []sdk.ValAddress, filterFunc func(exported.ValidatorI) bool, weightFunc func(consensusPower sdk.Uint) sdk.Uint, threshold utils.Threshold) (exported.Snapshot, error) {
// 				panic("mock out the CreateSnapshot method")
// 			},
// 			GetOperatorFunc: func(ctx sdk.Context, proxy sdk.AccAddress) sdk.ValAddress {
// 				panic("mock out the GetOperator method")
// 			},
// 			GetProxyFunc: func(ctx sdk.Context, operator sdk.ValAddress) (sdk.AccAddress, bool) {
// 				panic("mock out the GetProxy method")
// 			},
// 		}
//
// 		// use mockedSnapshotter in code that requires types.Snapshotter
// 		// and then make assertions.
//
// 	}
type SnapshotterMock struct {
	// CreateSnapshotFunc mocks the CreateSnapshot method.
	CreateSnapshotFunc func(ctx sdk.Context, candidates []sdk.ValAddress, filterFunc func(exported.ValidatorI) bool, weightFunc func(consensusPower sdk.Uint) sdk.Uint, threshold utils.Threshold) (exported.Snapshot, error)

	// GetOperatorFunc mocks the GetOperator method.
	GetOperatorFunc func(ctx sdk.Context, proxy sdk.AccAddress) sdk.ValAddress

	// GetProxyFunc mocks the GetProxy method.
	GetProxyFunc func(ctx sdk.Context, operator sdk.ValAddress) (sdk.AccAddress, bool)

	// calls tracks calls to the methods.
	calls struct {
		// CreateSnapshot holds details about calls to the CreateSnapshot method.
		CreateSnapshot []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Candidates is the candidates argument value.
			Candidates []sdk.ValAddress
			// FilterFunc is the filterFunc argument value.
			FilterFunc func(exported.ValidatorI) bool
			// WeightFunc is the weightFunc argument value.
			WeightFunc func(consensusPower sdk.Uint) sdk.Uint
			// Threshold is the threshold argument value.
			Threshold utils.Threshold
		}
		// GetOperator holds details about calls to the GetOperator method.
		GetOperator []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Proxy is the proxy argument value.
			Proxy sdk.AccAddress
		}
		// GetProxy holds details about calls to the GetProxy method.
		GetProxy []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Operator is the operator argument value.
			Operator sdk.ValAddress
		}
	}
	lockCreateSnapshot sync.RWMutex
	lockGetOperator    sync.RWMutex
	lockGetProxy       sync.RWMutex
}

// CreateSnapshot calls CreateSnapshotFunc.
func (mock *SnapshotterMock) CreateSnapshot(ctx sdk.Context, candidates []sdk.ValAddress, filterFunc func(exported.ValidatorI) bool, weightFunc func(consensusPower sdk.Uint) sdk.Uint, threshold utils.Threshold) (exported.Snapshot, error) {
	if mock.CreateSnapshotFunc == nil {
		panic("SnapshotterMock.CreateSnapshotFunc: method is nil but Snapshotter.CreateSnapshot was just called")
	}
	callInfo := struct {
		Ctx        sdk.Context
		Candidates []sdk.ValAddress
		FilterFunc func(exported.ValidatorI) bool
		WeightFunc func(consensusPower sdk.Uint) sdk.Uint
		Threshold  utils.Threshold
	}{
		Ctx:        ctx,
		Candidates: candidates,
		FilterFunc: filterFunc,
		WeightFunc: weightFunc,
		Threshold:  threshold,
	}
	mock.lockCreateSnapshot.Lock()
	mock.calls.CreateSnapshot = append(mock.calls.CreateSnapshot, callInfo)
	mock.lockCreateSnapshot.Unlock()
	return mock.CreateSnapshotFunc(ctx, candidates, filterFunc, weightFunc, threshold)
}

// CreateSnapshotCalls gets all the calls that were made to CreateSnapshot.
// Check the length with:
//     len(mockedSnapshotter.CreateSnapshotCalls())
func (mock *SnapshotterMock) CreateSnapshotCalls() []struct {
	Ctx        sdk.Context
	Candidates []sdk.ValAddress
	FilterFunc func(exported.ValidatorI) bool
	WeightFunc func(consensusPower sdk.Uint) sdk.Uint
	Threshold  utils.Threshold
} {
	var calls []struct {
		Ctx        sdk.Context
		Candidates []sdk.ValAddress
		FilterFunc func(exported.ValidatorI) bool
		WeightFunc func(consensusPower sdk.Uint) sdk.Uint
		Threshold  utils.Threshold
	}
	mock.lockCreateSnapshot.RLock()
	calls = mock.calls.CreateSnapshot
	mock.lockCreateSnapshot.RUnlock()
	return calls
}

// GetOperator calls GetOperatorFunc.
func (mock *SnapshotterMock) GetOperator(ctx sdk.Context, proxy sdk.AccAddress) sdk.ValAddress {
	if mock.GetOperatorFunc == nil {
		panic("SnapshotterMock.GetOperatorFunc: method is nil but Snapshotter.GetOperator was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		Proxy sdk.AccAddress
	}{
		Ctx:   ctx,
		Proxy: proxy,
	}
	mock.lockGetOperator.Lock()
	mock.calls.GetOperator = append(mock.calls.GetOperator, callInfo)
	mock.lockGetOperator.Unlock()
	return mock.GetOperatorFunc(ctx, proxy)
}

// GetOperatorCalls gets all the calls that were made to GetOperator.
// Check the length with:
//     len(mockedSnapshotter.GetOperatorCalls())
func (mock *SnapshotterMock) GetOperatorCalls() []struct {
	Ctx   sdk.Context
	Proxy sdk.AccAddress
} {
	var calls []struct {
		Ctx   sdk.Context
		Proxy sdk.AccAddress
	}
	mock.lockGetOperator.RLock()
	calls = mock.calls.GetOperator
	mock.lockGetOperator.RUnlock()
	return calls
}

// GetProxy calls GetProxyFunc.
func (mock *SnapshotterMock) GetProxy(ctx sdk.Context, operator sdk.ValAddress) (sdk.AccAddress, bool) {
	if mock.GetProxyFunc == nil {
		panic("SnapshotterMock.GetProxyFunc: method is nil but Snapshotter.GetProxy was just called")
	}
	callInfo := struct {
		Ctx      sdk.Context
		Operator sdk.ValAddress
	}{
		Ctx:      ctx,
		Operator: operator,
	}
	mock.lockGetProxy.Lock()
	mock.calls.GetProxy = append(mock.calls.GetProxy, callInfo)
	mock.lockGetProxy.Unlock()
	return mock.GetProxyFunc(ctx, operator)
}

// GetProxyCalls gets all the calls that were made to GetProxy.
// Check the length with:
//     len(mockedSnapshotter.GetProxyCalls())
func (mock *SnapshotterMock) GetProxyCalls() []struct {
	Ctx      sdk.Context
	Operator sdk.ValAddress
} {
	var calls []struct {
		Ctx      sdk.Context
		Operator sdk.ValAddress
	}
	mock.lockGetProxy.RLock()
	calls = mock.calls.GetProxy
	mock.lockGetProxy.RUnlock()
	return calls
}

// Ensure, that StakerMock does implement types.Staker.
// If this is not the case, regenerate this file with moq.
var _ types.Staker = &StakerMock{}

// StakerMock is a mock implementation of types.Staker.
//
// 	func TestSomethingThatUsesStaker(t *testing.T) {
//
// 		// make and configure a mocked types.Staker
// 		mockedStaker := &StakerMock{
// 			GetBondedValidatorsByPowerFunc: func(ctx sdk.Context) []stakingTypes.Validator {
// 				panic("mock out the GetBondedValidatorsByPower method")
// 			},
// 		}
//
// 		// use mockedStaker in code that requires types.Staker
// 		// and then make assertions.
//
// 	}
type StakerMock struct {
	// GetBondedValidatorsByPowerFunc mocks the GetBondedValidatorsByPower method.
	GetBondedValidatorsByPowerFunc func(ctx sdk.Context) []stakingTypes.Validator

	// calls tracks calls to the methods.
	calls struct {
		// GetBondedValidatorsByPower holds details about calls to the GetBondedValidatorsByPower method.
		GetBondedValidatorsByPower []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
	}
	lockGetBondedValidatorsByPower sync.RWMutex
}

// GetBondedValidatorsByPower calls GetBondedValidatorsByPowerFunc.
func (mock *StakerMock) GetBondedValidatorsByPower(ctx sdk.Context) []stakingTypes.Validator {
	if mock.GetBondedValidatorsByPowerFunc == nil {
		panic("StakerMock.GetBondedValidatorsByPowerFunc: method is nil but Staker.GetBondedValidatorsByPower was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetBondedValidatorsByPower.Lock()
	mock.calls.GetBondedValidatorsByPower = append(mock.calls.GetBondedValidatorsByPower, callInfo)
	mock.lockGetBondedValidatorsByPower.Unlock()
	return mock.GetBondedValidatorsByPowerFunc(ctx)
}

// GetBondedValidatorsByPowerCalls gets all the calls that were made to GetBondedValidatorsByPower.
// Check the length with:
//     len(mockedStaker.GetBondedValidatorsByPowerCalls())
func (mock *StakerMock) GetBondedValidatorsByPowerCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetBondedValidatorsByPower.RLock()
	calls = mock.calls.GetBondedValidatorsByPower
	mock.lockGetBondedValidatorsByPower.RUnlock()
	return calls
}

// Ensure, that SlasherMock does implement types.Slasher.
// If this is not the case, regenerate this file with moq.
var _ types.Slasher = &SlasherMock{}

// SlasherMock is a mock implementation of types.Slasher.
//
// 	func TestSomethingThatUsesSlasher(t *testing.T) {
//
// 		// make and configure a mocked types.Slasher
// 		mockedSlasher := &SlasherMock{
// 			IsTombstonedFunc: func(ctx sdk.Context, consAddr sdk.ConsAddress) bool {
// 				panic("mock out the IsTombstoned method")
// 			},
// 		}
//
// 		// use mockedSlasher in code that requires types.Slasher
// 		// and then make assertions.
//
// 	}
type SlasherMock struct {
	// IsTombstonedFunc mocks the IsTombstoned method.
	IsTombstonedFunc func(ctx sdk.Context, consAddr sdk.ConsAddress) bool

	// calls tracks calls to the methods.
	calls struct {
		// IsTombstoned holds details about calls to the IsTombstoned method.
		IsTombstoned []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// ConsAddr is the consAddr argument value.
			ConsAddr sdk.ConsAddress
		}
	}
	lockIsTombstoned sync.RWMutex
}

// IsTombstoned calls IsTombstonedFunc.
func (mock *SlasherMock) IsTombstoned(ctx sdk.Context, consAddr sdk.ConsAddress) bool {
	if mock.IsTombstonedFunc == nil {
		panic("SlasherMock.IsTombstonedFunc: method is nil but Slasher.IsTombstoned was just called")
	}
	callInfo := struct {
		Ctx      sdk.Context
		ConsAddr sdk.ConsAddress
	}{
		Ctx:      ctx,
		ConsAddr: consAddr,
	}
	mock.lockIsTombstoned.Lock()
	mock.calls.IsTombstoned = append(mock.calls.IsTombstoned, callInfo)
	mock.lockIsTombstoned.Unlock()
	return mock.IsTombstonedFunc(ctx, consAddr)
}

// IsTombstonedCalls gets all the calls that were made to IsTombstoned.
// Check the length with:
//     len(mockedSlasher.IsTombstonedCalls())
func (mock *SlasherMock) IsTombstonedCalls() []struct {
	Ctx      sdk.Context
	ConsAddr sdk.ConsAddress
} {
	var calls []struct {
		Ctx      sdk.Context
		ConsAddr sdk.ConsAddress
	}
	mock.lockIsTombstoned.RLock()
	calls = mock.calls.IsTombstoned
	mock.lockIsTombstoned.RUnlock()
	return calls
}
