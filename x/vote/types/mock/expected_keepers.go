// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	utils "github.com/axelarnetwork/axelar-core/utils"
	reward "github.com/axelarnetwork/axelar-core/x/reward/exported"
	snapshot "github.com/axelarnetwork/axelar-core/x/snapshot/exported"
	github_com_axelarnetwork_axelar_core_x_vote_exported "github.com/axelarnetwork/axelar-core/x/vote/exported"
	"github.com/axelarnetwork/axelar-core/x/vote/types"
	sdk "github.com/cosmos/cosmos-sdk/types"
	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
	"github.com/tendermint/tendermint/libs/log"
	"sync"
)

// Ensure, that VoterMock does implement types.Voter.
// If this is not the case, regenerate this file with moq.
var _ types.Voter = &VoterMock{}

// VoterMock is a mock implementation of types.Voter.
//
// 	func TestSomethingThatUsesVoter(t *testing.T) {
//
// 		// make and configure a mocked types.Voter
// 		mockedVoter := &VoterMock{
// 			DeletePollFunc: func(ctx sdk.Context, pollID github_com_axelarnetwork_axelar_core_x_vote_exported.PollID)  {
// 				panic("mock out the DeletePoll method")
// 			},
// 			GetParamsFunc: func(ctx sdk.Context) types.Params {
// 				panic("mock out the GetParams method")
// 			},
// 			GetPollFunc: func(ctx sdk.Context, id github_com_axelarnetwork_axelar_core_x_vote_exported.PollID) (github_com_axelarnetwork_axelar_core_x_vote_exported.Poll, bool) {
// 				panic("mock out the GetPoll method")
// 			},
// 			GetPollQueueFunc: func(ctx sdk.Context) utils.KVQueue {
// 				panic("mock out the GetPollQueue method")
// 			},
// 			GetVoteRouterFunc: func() types.VoteRouter {
// 				panic("mock out the GetVoteRouter method")
// 			},
// 			LoggerFunc: func(ctx sdk.Context) log.Logger {
// 				panic("mock out the Logger method")
// 			},
// 		}
//
// 		// use mockedVoter in code that requires types.Voter
// 		// and then make assertions.
//
// 	}
type VoterMock struct {
	// DeletePollFunc mocks the DeletePoll method.
	DeletePollFunc func(ctx sdk.Context, pollID github_com_axelarnetwork_axelar_core_x_vote_exported.PollID)

	// GetParamsFunc mocks the GetParams method.
	GetParamsFunc func(ctx sdk.Context) types.Params

	// GetPollFunc mocks the GetPoll method.
	GetPollFunc func(ctx sdk.Context, id github_com_axelarnetwork_axelar_core_x_vote_exported.PollID) (github_com_axelarnetwork_axelar_core_x_vote_exported.Poll, bool)

	// GetPollQueueFunc mocks the GetPollQueue method.
	GetPollQueueFunc func(ctx sdk.Context) utils.KVQueue

	// GetVoteRouterFunc mocks the GetVoteRouter method.
	GetVoteRouterFunc func() types.VoteRouter

	// LoggerFunc mocks the Logger method.
	LoggerFunc func(ctx sdk.Context) log.Logger

	// calls tracks calls to the methods.
	calls struct {
		// DeletePoll holds details about calls to the DeletePoll method.
		DeletePoll []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// PollID is the pollID argument value.
			PollID github_com_axelarnetwork_axelar_core_x_vote_exported.PollID
		}
		// GetParams holds details about calls to the GetParams method.
		GetParams []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetPoll holds details about calls to the GetPoll method.
		GetPoll []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// ID is the id argument value.
			ID github_com_axelarnetwork_axelar_core_x_vote_exported.PollID
		}
		// GetPollQueue holds details about calls to the GetPollQueue method.
		GetPollQueue []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetVoteRouter holds details about calls to the GetVoteRouter method.
		GetVoteRouter []struct {
		}
		// Logger holds details about calls to the Logger method.
		Logger []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
	}
	lockDeletePoll    sync.RWMutex
	lockGetParams     sync.RWMutex
	lockGetPoll       sync.RWMutex
	lockGetPollQueue  sync.RWMutex
	lockGetVoteRouter sync.RWMutex
	lockLogger        sync.RWMutex
}

// DeletePoll calls DeletePollFunc.
func (mock *VoterMock) DeletePoll(ctx sdk.Context, pollID github_com_axelarnetwork_axelar_core_x_vote_exported.PollID) {
	if mock.DeletePollFunc == nil {
		panic("VoterMock.DeletePollFunc: method is nil but Voter.DeletePoll was just called")
	}
	callInfo := struct {
		Ctx    sdk.Context
		PollID github_com_axelarnetwork_axelar_core_x_vote_exported.PollID
	}{
		Ctx:    ctx,
		PollID: pollID,
	}
	mock.lockDeletePoll.Lock()
	mock.calls.DeletePoll = append(mock.calls.DeletePoll, callInfo)
	mock.lockDeletePoll.Unlock()
	mock.DeletePollFunc(ctx, pollID)
}

// DeletePollCalls gets all the calls that were made to DeletePoll.
// Check the length with:
//     len(mockedVoter.DeletePollCalls())
func (mock *VoterMock) DeletePollCalls() []struct {
	Ctx    sdk.Context
	PollID github_com_axelarnetwork_axelar_core_x_vote_exported.PollID
} {
	var calls []struct {
		Ctx    sdk.Context
		PollID github_com_axelarnetwork_axelar_core_x_vote_exported.PollID
	}
	mock.lockDeletePoll.RLock()
	calls = mock.calls.DeletePoll
	mock.lockDeletePoll.RUnlock()
	return calls
}

// GetParams calls GetParamsFunc.
func (mock *VoterMock) GetParams(ctx sdk.Context) types.Params {
	if mock.GetParamsFunc == nil {
		panic("VoterMock.GetParamsFunc: method is nil but Voter.GetParams was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetParams.Lock()
	mock.calls.GetParams = append(mock.calls.GetParams, callInfo)
	mock.lockGetParams.Unlock()
	return mock.GetParamsFunc(ctx)
}

// GetParamsCalls gets all the calls that were made to GetParams.
// Check the length with:
//     len(mockedVoter.GetParamsCalls())
func (mock *VoterMock) GetParamsCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetParams.RLock()
	calls = mock.calls.GetParams
	mock.lockGetParams.RUnlock()
	return calls
}

// GetPoll calls GetPollFunc.
func (mock *VoterMock) GetPoll(ctx sdk.Context, id github_com_axelarnetwork_axelar_core_x_vote_exported.PollID) (github_com_axelarnetwork_axelar_core_x_vote_exported.Poll, bool) {
	if mock.GetPollFunc == nil {
		panic("VoterMock.GetPollFunc: method is nil but Voter.GetPoll was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
		ID  github_com_axelarnetwork_axelar_core_x_vote_exported.PollID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetPoll.Lock()
	mock.calls.GetPoll = append(mock.calls.GetPoll, callInfo)
	mock.lockGetPoll.Unlock()
	return mock.GetPollFunc(ctx, id)
}

// GetPollCalls gets all the calls that were made to GetPoll.
// Check the length with:
//     len(mockedVoter.GetPollCalls())
func (mock *VoterMock) GetPollCalls() []struct {
	Ctx sdk.Context
	ID  github_com_axelarnetwork_axelar_core_x_vote_exported.PollID
} {
	var calls []struct {
		Ctx sdk.Context
		ID  github_com_axelarnetwork_axelar_core_x_vote_exported.PollID
	}
	mock.lockGetPoll.RLock()
	calls = mock.calls.GetPoll
	mock.lockGetPoll.RUnlock()
	return calls
}

// GetPollQueue calls GetPollQueueFunc.
func (mock *VoterMock) GetPollQueue(ctx sdk.Context) utils.KVQueue {
	if mock.GetPollQueueFunc == nil {
		panic("VoterMock.GetPollQueueFunc: method is nil but Voter.GetPollQueue was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetPollQueue.Lock()
	mock.calls.GetPollQueue = append(mock.calls.GetPollQueue, callInfo)
	mock.lockGetPollQueue.Unlock()
	return mock.GetPollQueueFunc(ctx)
}

// GetPollQueueCalls gets all the calls that were made to GetPollQueue.
// Check the length with:
//     len(mockedVoter.GetPollQueueCalls())
func (mock *VoterMock) GetPollQueueCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetPollQueue.RLock()
	calls = mock.calls.GetPollQueue
	mock.lockGetPollQueue.RUnlock()
	return calls
}

// GetVoteRouter calls GetVoteRouterFunc.
func (mock *VoterMock) GetVoteRouter() types.VoteRouter {
	if mock.GetVoteRouterFunc == nil {
		panic("VoterMock.GetVoteRouterFunc: method is nil but Voter.GetVoteRouter was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetVoteRouter.Lock()
	mock.calls.GetVoteRouter = append(mock.calls.GetVoteRouter, callInfo)
	mock.lockGetVoteRouter.Unlock()
	return mock.GetVoteRouterFunc()
}

// GetVoteRouterCalls gets all the calls that were made to GetVoteRouter.
// Check the length with:
//     len(mockedVoter.GetVoteRouterCalls())
func (mock *VoterMock) GetVoteRouterCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetVoteRouter.RLock()
	calls = mock.calls.GetVoteRouter
	mock.lockGetVoteRouter.RUnlock()
	return calls
}

// Logger calls LoggerFunc.
func (mock *VoterMock) Logger(ctx sdk.Context) log.Logger {
	if mock.LoggerFunc == nil {
		panic("VoterMock.LoggerFunc: method is nil but Voter.Logger was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockLogger.Lock()
	mock.calls.Logger = append(mock.calls.Logger, callInfo)
	mock.lockLogger.Unlock()
	return mock.LoggerFunc(ctx)
}

// LoggerCalls gets all the calls that were made to Logger.
// Check the length with:
//     len(mockedVoter.LoggerCalls())
func (mock *VoterMock) LoggerCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockLogger.RLock()
	calls = mock.calls.Logger
	mock.lockLogger.RUnlock()
	return calls
}

// Ensure, that SnapshotterMock does implement types.Snapshotter.
// If this is not the case, regenerate this file with moq.
var _ types.Snapshotter = &SnapshotterMock{}

// SnapshotterMock is a mock implementation of types.Snapshotter.
//
// 	func TestSomethingThatUsesSnapshotter(t *testing.T) {
//
// 		// make and configure a mocked types.Snapshotter
// 		mockedSnapshotter := &SnapshotterMock{
// 			GetOperatorFunc: func(ctx sdk.Context, proxy sdk.AccAddress) sdk.ValAddress {
// 				panic("mock out the GetOperator method")
// 			},
// 			GetSnapshotFunc: func(context sdk.Context, n int64) (snapshot.Snapshot, bool) {
// 				panic("mock out the GetSnapshot method")
// 			},
// 		}
//
// 		// use mockedSnapshotter in code that requires types.Snapshotter
// 		// and then make assertions.
//
// 	}
type SnapshotterMock struct {
	// GetOperatorFunc mocks the GetOperator method.
	GetOperatorFunc func(ctx sdk.Context, proxy sdk.AccAddress) sdk.ValAddress

	// GetSnapshotFunc mocks the GetSnapshot method.
	GetSnapshotFunc func(context sdk.Context, n int64) (snapshot.Snapshot, bool)

	// calls tracks calls to the methods.
	calls struct {
		// GetOperator holds details about calls to the GetOperator method.
		GetOperator []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Proxy is the proxy argument value.
			Proxy sdk.AccAddress
		}
		// GetSnapshot holds details about calls to the GetSnapshot method.
		GetSnapshot []struct {
			// Context is the context argument value.
			Context sdk.Context
			// N is the n argument value.
			N int64
		}
	}
	lockGetOperator sync.RWMutex
	lockGetSnapshot sync.RWMutex
}

// GetOperator calls GetOperatorFunc.
func (mock *SnapshotterMock) GetOperator(ctx sdk.Context, proxy sdk.AccAddress) sdk.ValAddress {
	if mock.GetOperatorFunc == nil {
		panic("SnapshotterMock.GetOperatorFunc: method is nil but Snapshotter.GetOperator was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		Proxy sdk.AccAddress
	}{
		Ctx:   ctx,
		Proxy: proxy,
	}
	mock.lockGetOperator.Lock()
	mock.calls.GetOperator = append(mock.calls.GetOperator, callInfo)
	mock.lockGetOperator.Unlock()
	return mock.GetOperatorFunc(ctx, proxy)
}

// GetOperatorCalls gets all the calls that were made to GetOperator.
// Check the length with:
//     len(mockedSnapshotter.GetOperatorCalls())
func (mock *SnapshotterMock) GetOperatorCalls() []struct {
	Ctx   sdk.Context
	Proxy sdk.AccAddress
} {
	var calls []struct {
		Ctx   sdk.Context
		Proxy sdk.AccAddress
	}
	mock.lockGetOperator.RLock()
	calls = mock.calls.GetOperator
	mock.lockGetOperator.RUnlock()
	return calls
}

// GetSnapshot calls GetSnapshotFunc.
func (mock *SnapshotterMock) GetSnapshot(context sdk.Context, n int64) (snapshot.Snapshot, bool) {
	if mock.GetSnapshotFunc == nil {
		panic("SnapshotterMock.GetSnapshotFunc: method is nil but Snapshotter.GetSnapshot was just called")
	}
	callInfo := struct {
		Context sdk.Context
		N       int64
	}{
		Context: context,
		N:       n,
	}
	mock.lockGetSnapshot.Lock()
	mock.calls.GetSnapshot = append(mock.calls.GetSnapshot, callInfo)
	mock.lockGetSnapshot.Unlock()
	return mock.GetSnapshotFunc(context, n)
}

// GetSnapshotCalls gets all the calls that were made to GetSnapshot.
// Check the length with:
//     len(mockedSnapshotter.GetSnapshotCalls())
func (mock *SnapshotterMock) GetSnapshotCalls() []struct {
	Context sdk.Context
	N       int64
} {
	var calls []struct {
		Context sdk.Context
		N       int64
	}
	mock.lockGetSnapshot.RLock()
	calls = mock.calls.GetSnapshot
	mock.lockGetSnapshot.RUnlock()
	return calls
}

// Ensure, that StakingKeeperMock does implement types.StakingKeeper.
// If this is not the case, regenerate this file with moq.
var _ types.StakingKeeper = &StakingKeeperMock{}

// StakingKeeperMock is a mock implementation of types.StakingKeeper.
//
// 	func TestSomethingThatUsesStakingKeeper(t *testing.T) {
//
// 		// make and configure a mocked types.StakingKeeper
// 		mockedStakingKeeper := &StakingKeeperMock{
// 			GetLastTotalPowerFunc: func(context sdk.Context) sdk.Int {
// 				panic("mock out the GetLastTotalPower method")
// 			},
// 			PowerReductionFunc: func(context sdk.Context) sdk.Int {
// 				panic("mock out the PowerReduction method")
// 			},
// 			ValidatorFunc: func(ctx sdk.Context, addr sdk.ValAddress) stakingtypes.ValidatorI {
// 				panic("mock out the Validator method")
// 			},
// 		}
//
// 		// use mockedStakingKeeper in code that requires types.StakingKeeper
// 		// and then make assertions.
//
// 	}
type StakingKeeperMock struct {
	// GetLastTotalPowerFunc mocks the GetLastTotalPower method.
	GetLastTotalPowerFunc func(context sdk.Context) sdk.Int

	// PowerReductionFunc mocks the PowerReduction method.
	PowerReductionFunc func(context sdk.Context) sdk.Int

	// ValidatorFunc mocks the Validator method.
	ValidatorFunc func(ctx sdk.Context, addr sdk.ValAddress) stakingtypes.ValidatorI

	// calls tracks calls to the methods.
	calls struct {
		// GetLastTotalPower holds details about calls to the GetLastTotalPower method.
		GetLastTotalPower []struct {
			// Context is the context argument value.
			Context sdk.Context
		}
		// PowerReduction holds details about calls to the PowerReduction method.
		PowerReduction []struct {
			// Context is the context argument value.
			Context sdk.Context
		}
		// Validator holds details about calls to the Validator method.
		Validator []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Addr is the addr argument value.
			Addr sdk.ValAddress
		}
	}
	lockGetLastTotalPower sync.RWMutex
	lockPowerReduction    sync.RWMutex
	lockValidator         sync.RWMutex
}

// GetLastTotalPower calls GetLastTotalPowerFunc.
func (mock *StakingKeeperMock) GetLastTotalPower(context sdk.Context) sdk.Int {
	if mock.GetLastTotalPowerFunc == nil {
		panic("StakingKeeperMock.GetLastTotalPowerFunc: method is nil but StakingKeeper.GetLastTotalPower was just called")
	}
	callInfo := struct {
		Context sdk.Context
	}{
		Context: context,
	}
	mock.lockGetLastTotalPower.Lock()
	mock.calls.GetLastTotalPower = append(mock.calls.GetLastTotalPower, callInfo)
	mock.lockGetLastTotalPower.Unlock()
	return mock.GetLastTotalPowerFunc(context)
}

// GetLastTotalPowerCalls gets all the calls that were made to GetLastTotalPower.
// Check the length with:
//     len(mockedStakingKeeper.GetLastTotalPowerCalls())
func (mock *StakingKeeperMock) GetLastTotalPowerCalls() []struct {
	Context sdk.Context
} {
	var calls []struct {
		Context sdk.Context
	}
	mock.lockGetLastTotalPower.RLock()
	calls = mock.calls.GetLastTotalPower
	mock.lockGetLastTotalPower.RUnlock()
	return calls
}

// PowerReduction calls PowerReductionFunc.
func (mock *StakingKeeperMock) PowerReduction(context sdk.Context) sdk.Int {
	if mock.PowerReductionFunc == nil {
		panic("StakingKeeperMock.PowerReductionFunc: method is nil but StakingKeeper.PowerReduction was just called")
	}
	callInfo := struct {
		Context sdk.Context
	}{
		Context: context,
	}
	mock.lockPowerReduction.Lock()
	mock.calls.PowerReduction = append(mock.calls.PowerReduction, callInfo)
	mock.lockPowerReduction.Unlock()
	return mock.PowerReductionFunc(context)
}

// PowerReductionCalls gets all the calls that were made to PowerReduction.
// Check the length with:
//     len(mockedStakingKeeper.PowerReductionCalls())
func (mock *StakingKeeperMock) PowerReductionCalls() []struct {
	Context sdk.Context
} {
	var calls []struct {
		Context sdk.Context
	}
	mock.lockPowerReduction.RLock()
	calls = mock.calls.PowerReduction
	mock.lockPowerReduction.RUnlock()
	return calls
}

// Validator calls ValidatorFunc.
func (mock *StakingKeeperMock) Validator(ctx sdk.Context, addr sdk.ValAddress) stakingtypes.ValidatorI {
	if mock.ValidatorFunc == nil {
		panic("StakingKeeperMock.ValidatorFunc: method is nil but StakingKeeper.Validator was just called")
	}
	callInfo := struct {
		Ctx  sdk.Context
		Addr sdk.ValAddress
	}{
		Ctx:  ctx,
		Addr: addr,
	}
	mock.lockValidator.Lock()
	mock.calls.Validator = append(mock.calls.Validator, callInfo)
	mock.lockValidator.Unlock()
	return mock.ValidatorFunc(ctx, addr)
}

// ValidatorCalls gets all the calls that were made to Validator.
// Check the length with:
//     len(mockedStakingKeeper.ValidatorCalls())
func (mock *StakingKeeperMock) ValidatorCalls() []struct {
	Ctx  sdk.Context
	Addr sdk.ValAddress
} {
	var calls []struct {
		Ctx  sdk.Context
		Addr sdk.ValAddress
	}
	mock.lockValidator.RLock()
	calls = mock.calls.Validator
	mock.lockValidator.RUnlock()
	return calls
}

// Ensure, that RewarderMock does implement types.Rewarder.
// If this is not the case, regenerate this file with moq.
var _ types.Rewarder = &RewarderMock{}

// RewarderMock is a mock implementation of types.Rewarder.
//
// 	func TestSomethingThatUsesRewarder(t *testing.T) {
//
// 		// make and configure a mocked types.Rewarder
// 		mockedRewarder := &RewarderMock{
// 			GetPoolFunc: func(ctx sdk.Context, name string) reward.RewardPool {
// 				panic("mock out the GetPool method")
// 			},
// 		}
//
// 		// use mockedRewarder in code that requires types.Rewarder
// 		// and then make assertions.
//
// 	}
type RewarderMock struct {
	// GetPoolFunc mocks the GetPool method.
	GetPoolFunc func(ctx sdk.Context, name string) reward.RewardPool

	// calls tracks calls to the methods.
	calls struct {
		// GetPool holds details about calls to the GetPool method.
		GetPool []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Name is the name argument value.
			Name string
		}
	}
	lockGetPool sync.RWMutex
}

// GetPool calls GetPoolFunc.
func (mock *RewarderMock) GetPool(ctx sdk.Context, name string) reward.RewardPool {
	if mock.GetPoolFunc == nil {
		panic("RewarderMock.GetPoolFunc: method is nil but Rewarder.GetPool was just called")
	}
	callInfo := struct {
		Ctx  sdk.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockGetPool.Lock()
	mock.calls.GetPool = append(mock.calls.GetPool, callInfo)
	mock.lockGetPool.Unlock()
	return mock.GetPoolFunc(ctx, name)
}

// GetPoolCalls gets all the calls that were made to GetPool.
// Check the length with:
//     len(mockedRewarder.GetPoolCalls())
func (mock *RewarderMock) GetPoolCalls() []struct {
	Ctx  sdk.Context
	Name string
} {
	var calls []struct {
		Ctx  sdk.Context
		Name string
	}
	mock.lockGetPool.RLock()
	calls = mock.calls.GetPool
	mock.lockGetPool.RUnlock()
	return calls
}
