// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	context "context"
	"crypto/ecdsa"
	nexus "github.com/axelarnetwork/axelar-core/x/nexus/exported"
	snapshot "github.com/axelarnetwork/axelar-core/x/snapshot/exported"
	exported "github.com/axelarnetwork/axelar-core/x/tss/exported"
	tofnd "github.com/axelarnetwork/axelar-core/x/tss/tofnd"
	tsstypes "github.com/axelarnetwork/axelar-core/x/tss/types"
	exported1 "github.com/axelarnetwork/axelar-core/x/vote/exported"
	sdk "github.com/cosmos/cosmos-sdk/types"
	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
	"github.com/tendermint/tendermint/libs/log"
	grpc "google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
	"sync"
)

// Ensure, that TofndClientMock does implement tsstypes.TofndClient.
// If this is not the case, regenerate this file with moq.
var _ tsstypes.TofndClient = &TofndClientMock{}

// TofndClientMock is a mock implementation of tsstypes.TofndClient.
//
// 	func TestSomethingThatUsesTofndClient(t *testing.T) {
//
// 		// make and configure a mocked tsstypes.TofndClient
// 		mockedTofndClient := &TofndClientMock{
// 			KeyPresenceFunc: func(ctx context.Context, in *tofnd.KeyPresenceRequest, opts ...grpc.CallOption) (*tofnd.KeyPresenceResponse, error) {
// 				panic("mock out the KeyPresence method")
// 			},
// 			KeygenFunc: func(ctx context.Context, opts ...grpc.CallOption) (tofnd.GG20_KeygenClient, error) {
// 				panic("mock out the Keygen method")
// 			},
// 			RecoverFunc: func(ctx context.Context, in *tofnd.RecoverRequest, opts ...grpc.CallOption) (*tofnd.RecoverResponse, error) {
// 				panic("mock out the Recover method")
// 			},
// 			SignFunc: func(ctx context.Context, opts ...grpc.CallOption) (tofnd.GG20_SignClient, error) {
// 				panic("mock out the Sign method")
// 			},
// 		}
//
// 		// use mockedTofndClient in code that requires tsstypes.TofndClient
// 		// and then make assertions.
//
// 	}
type TofndClientMock struct {
	// KeyPresenceFunc mocks the KeyPresence method.
	KeyPresenceFunc func(ctx context.Context, in *tofnd.KeyPresenceRequest, opts ...grpc.CallOption) (*tofnd.KeyPresenceResponse, error)

	// KeygenFunc mocks the Keygen method.
	KeygenFunc func(ctx context.Context, opts ...grpc.CallOption) (tofnd.GG20_KeygenClient, error)

	// RecoverFunc mocks the Recover method.
	RecoverFunc func(ctx context.Context, in *tofnd.RecoverRequest, opts ...grpc.CallOption) (*tofnd.RecoverResponse, error)

	// SignFunc mocks the Sign method.
	SignFunc func(ctx context.Context, opts ...grpc.CallOption) (tofnd.GG20_SignClient, error)

	// calls tracks calls to the methods.
	calls struct {
		// KeyPresence holds details about calls to the KeyPresence method.
		KeyPresence []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *tofnd.KeyPresenceRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Keygen holds details about calls to the Keygen method.
		Keygen []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Recover holds details about calls to the Recover method.
		Recover []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *tofnd.RecoverRequest
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Sign holds details about calls to the Sign method.
		Sign []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
	}
	lockKeyPresence sync.RWMutex
	lockKeygen      sync.RWMutex
	lockRecover     sync.RWMutex
	lockSign        sync.RWMutex
}

// KeyPresence calls KeyPresenceFunc.
func (mock *TofndClientMock) KeyPresence(ctx context.Context, in *tofnd.KeyPresenceRequest, opts ...grpc.CallOption) (*tofnd.KeyPresenceResponse, error) {
	if mock.KeyPresenceFunc == nil {
		panic("TofndClientMock.KeyPresenceFunc: method is nil but TofndClient.KeyPresence was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *tofnd.KeyPresenceRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockKeyPresence.Lock()
	mock.calls.KeyPresence = append(mock.calls.KeyPresence, callInfo)
	mock.lockKeyPresence.Unlock()
	return mock.KeyPresenceFunc(ctx, in, opts...)
}

// KeyPresenceCalls gets all the calls that were made to KeyPresence.
// Check the length with:
//     len(mockedTofndClient.KeyPresenceCalls())
func (mock *TofndClientMock) KeyPresenceCalls() []struct {
	Ctx  context.Context
	In   *tofnd.KeyPresenceRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *tofnd.KeyPresenceRequest
		Opts []grpc.CallOption
	}
	mock.lockKeyPresence.RLock()
	calls = mock.calls.KeyPresence
	mock.lockKeyPresence.RUnlock()
	return calls
}

// Keygen calls KeygenFunc.
func (mock *TofndClientMock) Keygen(ctx context.Context, opts ...grpc.CallOption) (tofnd.GG20_KeygenClient, error) {
	if mock.KeygenFunc == nil {
		panic("TofndClientMock.KeygenFunc: method is nil but TofndClient.Keygen was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockKeygen.Lock()
	mock.calls.Keygen = append(mock.calls.Keygen, callInfo)
	mock.lockKeygen.Unlock()
	return mock.KeygenFunc(ctx, opts...)
}

// KeygenCalls gets all the calls that were made to Keygen.
// Check the length with:
//     len(mockedTofndClient.KeygenCalls())
func (mock *TofndClientMock) KeygenCalls() []struct {
	Ctx  context.Context
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		Opts []grpc.CallOption
	}
	mock.lockKeygen.RLock()
	calls = mock.calls.Keygen
	mock.lockKeygen.RUnlock()
	return calls
}

// Recover calls RecoverFunc.
func (mock *TofndClientMock) Recover(ctx context.Context, in *tofnd.RecoverRequest, opts ...grpc.CallOption) (*tofnd.RecoverResponse, error) {
	if mock.RecoverFunc == nil {
		panic("TofndClientMock.RecoverFunc: method is nil but TofndClient.Recover was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *tofnd.RecoverRequest
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockRecover.Lock()
	mock.calls.Recover = append(mock.calls.Recover, callInfo)
	mock.lockRecover.Unlock()
	return mock.RecoverFunc(ctx, in, opts...)
}

// RecoverCalls gets all the calls that were made to Recover.
// Check the length with:
//     len(mockedTofndClient.RecoverCalls())
func (mock *TofndClientMock) RecoverCalls() []struct {
	Ctx  context.Context
	In   *tofnd.RecoverRequest
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *tofnd.RecoverRequest
		Opts []grpc.CallOption
	}
	mock.lockRecover.RLock()
	calls = mock.calls.Recover
	mock.lockRecover.RUnlock()
	return calls
}

// Sign calls SignFunc.
func (mock *TofndClientMock) Sign(ctx context.Context, opts ...grpc.CallOption) (tofnd.GG20_SignClient, error) {
	if mock.SignFunc == nil {
		panic("TofndClientMock.SignFunc: method is nil but TofndClient.Sign was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockSign.Lock()
	mock.calls.Sign = append(mock.calls.Sign, callInfo)
	mock.lockSign.Unlock()
	return mock.SignFunc(ctx, opts...)
}

// SignCalls gets all the calls that were made to Sign.
// Check the length with:
//     len(mockedTofndClient.SignCalls())
func (mock *TofndClientMock) SignCalls() []struct {
	Ctx  context.Context
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		Opts []grpc.CallOption
	}
	mock.lockSign.RLock()
	calls = mock.calls.Sign
	mock.lockSign.RUnlock()
	return calls
}

// Ensure, that TofndKeyGenClientMock does implement tsstypes.TofndKeyGenClient.
// If this is not the case, regenerate this file with moq.
var _ tsstypes.TofndKeyGenClient = &TofndKeyGenClientMock{}

// TofndKeyGenClientMock is a mock implementation of tsstypes.TofndKeyGenClient.
//
// 	func TestSomethingThatUsesTofndKeyGenClient(t *testing.T) {
//
// 		// make and configure a mocked tsstypes.TofndKeyGenClient
// 		mockedTofndKeyGenClient := &TofndKeyGenClientMock{
// 			CloseSendFunc: func() error {
// 				panic("mock out the CloseSend method")
// 			},
// 			ContextFunc: func() context.Context {
// 				panic("mock out the Context method")
// 			},
// 			HeaderFunc: func() (metadata.MD, error) {
// 				panic("mock out the Header method")
// 			},
// 			RecvFunc: func() (*tofnd.MessageOut, error) {
// 				panic("mock out the Recv method")
// 			},
// 			RecvMsgFunc: func(m interface{}) error {
// 				panic("mock out the RecvMsg method")
// 			},
// 			SendFunc: func(messageIn *tofnd.MessageIn) error {
// 				panic("mock out the Send method")
// 			},
// 			SendMsgFunc: func(m interface{}) error {
// 				panic("mock out the SendMsg method")
// 			},
// 			TrailerFunc: func() metadata.MD {
// 				panic("mock out the Trailer method")
// 			},
// 		}
//
// 		// use mockedTofndKeyGenClient in code that requires tsstypes.TofndKeyGenClient
// 		// and then make assertions.
//
// 	}
type TofndKeyGenClientMock struct {
	// CloseSendFunc mocks the CloseSend method.
	CloseSendFunc func() error

	// ContextFunc mocks the Context method.
	ContextFunc func() context.Context

	// HeaderFunc mocks the Header method.
	HeaderFunc func() (metadata.MD, error)

	// RecvFunc mocks the Recv method.
	RecvFunc func() (*tofnd.MessageOut, error)

	// RecvMsgFunc mocks the RecvMsg method.
	RecvMsgFunc func(m interface{}) error

	// SendFunc mocks the Send method.
	SendFunc func(messageIn *tofnd.MessageIn) error

	// SendMsgFunc mocks the SendMsg method.
	SendMsgFunc func(m interface{}) error

	// TrailerFunc mocks the Trailer method.
	TrailerFunc func() metadata.MD

	// calls tracks calls to the methods.
	calls struct {
		// CloseSend holds details about calls to the CloseSend method.
		CloseSend []struct {
		}
		// Context holds details about calls to the Context method.
		Context []struct {
		}
		// Header holds details about calls to the Header method.
		Header []struct {
		}
		// Recv holds details about calls to the Recv method.
		Recv []struct {
		}
		// RecvMsg holds details about calls to the RecvMsg method.
		RecvMsg []struct {
			// M is the m argument value.
			M interface{}
		}
		// Send holds details about calls to the Send method.
		Send []struct {
			// MessageIn is the messageIn argument value.
			MessageIn *tofnd.MessageIn
		}
		// SendMsg holds details about calls to the SendMsg method.
		SendMsg []struct {
			// M is the m argument value.
			M interface{}
		}
		// Trailer holds details about calls to the Trailer method.
		Trailer []struct {
		}
	}
	lockCloseSend sync.RWMutex
	lockContext   sync.RWMutex
	lockHeader    sync.RWMutex
	lockRecv      sync.RWMutex
	lockRecvMsg   sync.RWMutex
	lockSend      sync.RWMutex
	lockSendMsg   sync.RWMutex
	lockTrailer   sync.RWMutex
}

// CloseSend calls CloseSendFunc.
func (mock *TofndKeyGenClientMock) CloseSend() error {
	if mock.CloseSendFunc == nil {
		panic("TofndKeyGenClientMock.CloseSendFunc: method is nil but TofndKeyGenClient.CloseSend was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCloseSend.Lock()
	mock.calls.CloseSend = append(mock.calls.CloseSend, callInfo)
	mock.lockCloseSend.Unlock()
	return mock.CloseSendFunc()
}

// CloseSendCalls gets all the calls that were made to CloseSend.
// Check the length with:
//     len(mockedTofndKeyGenClient.CloseSendCalls())
func (mock *TofndKeyGenClientMock) CloseSendCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCloseSend.RLock()
	calls = mock.calls.CloseSend
	mock.lockCloseSend.RUnlock()
	return calls
}

// Context calls ContextFunc.
func (mock *TofndKeyGenClientMock) Context() context.Context {
	if mock.ContextFunc == nil {
		panic("TofndKeyGenClientMock.ContextFunc: method is nil but TofndKeyGenClient.Context was just called")
	}
	callInfo := struct {
	}{}
	mock.lockContext.Lock()
	mock.calls.Context = append(mock.calls.Context, callInfo)
	mock.lockContext.Unlock()
	return mock.ContextFunc()
}

// ContextCalls gets all the calls that were made to Context.
// Check the length with:
//     len(mockedTofndKeyGenClient.ContextCalls())
func (mock *TofndKeyGenClientMock) ContextCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockContext.RLock()
	calls = mock.calls.Context
	mock.lockContext.RUnlock()
	return calls
}

// Header calls HeaderFunc.
func (mock *TofndKeyGenClientMock) Header() (metadata.MD, error) {
	if mock.HeaderFunc == nil {
		panic("TofndKeyGenClientMock.HeaderFunc: method is nil but TofndKeyGenClient.Header was just called")
	}
	callInfo := struct {
	}{}
	mock.lockHeader.Lock()
	mock.calls.Header = append(mock.calls.Header, callInfo)
	mock.lockHeader.Unlock()
	return mock.HeaderFunc()
}

// HeaderCalls gets all the calls that were made to Header.
// Check the length with:
//     len(mockedTofndKeyGenClient.HeaderCalls())
func (mock *TofndKeyGenClientMock) HeaderCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockHeader.RLock()
	calls = mock.calls.Header
	mock.lockHeader.RUnlock()
	return calls
}

// Recv calls RecvFunc.
func (mock *TofndKeyGenClientMock) Recv() (*tofnd.MessageOut, error) {
	if mock.RecvFunc == nil {
		panic("TofndKeyGenClientMock.RecvFunc: method is nil but TofndKeyGenClient.Recv was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRecv.Lock()
	mock.calls.Recv = append(mock.calls.Recv, callInfo)
	mock.lockRecv.Unlock()
	return mock.RecvFunc()
}

// RecvCalls gets all the calls that were made to Recv.
// Check the length with:
//     len(mockedTofndKeyGenClient.RecvCalls())
func (mock *TofndKeyGenClientMock) RecvCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRecv.RLock()
	calls = mock.calls.Recv
	mock.lockRecv.RUnlock()
	return calls
}

// RecvMsg calls RecvMsgFunc.
func (mock *TofndKeyGenClientMock) RecvMsg(m interface{}) error {
	if mock.RecvMsgFunc == nil {
		panic("TofndKeyGenClientMock.RecvMsgFunc: method is nil but TofndKeyGenClient.RecvMsg was just called")
	}
	callInfo := struct {
		M interface{}
	}{
		M: m,
	}
	mock.lockRecvMsg.Lock()
	mock.calls.RecvMsg = append(mock.calls.RecvMsg, callInfo)
	mock.lockRecvMsg.Unlock()
	return mock.RecvMsgFunc(m)
}

// RecvMsgCalls gets all the calls that were made to RecvMsg.
// Check the length with:
//     len(mockedTofndKeyGenClient.RecvMsgCalls())
func (mock *TofndKeyGenClientMock) RecvMsgCalls() []struct {
	M interface{}
} {
	var calls []struct {
		M interface{}
	}
	mock.lockRecvMsg.RLock()
	calls = mock.calls.RecvMsg
	mock.lockRecvMsg.RUnlock()
	return calls
}

// Send calls SendFunc.
func (mock *TofndKeyGenClientMock) Send(messageIn *tofnd.MessageIn) error {
	if mock.SendFunc == nil {
		panic("TofndKeyGenClientMock.SendFunc: method is nil but TofndKeyGenClient.Send was just called")
	}
	callInfo := struct {
		MessageIn *tofnd.MessageIn
	}{
		MessageIn: messageIn,
	}
	mock.lockSend.Lock()
	mock.calls.Send = append(mock.calls.Send, callInfo)
	mock.lockSend.Unlock()
	return mock.SendFunc(messageIn)
}

// SendCalls gets all the calls that were made to Send.
// Check the length with:
//     len(mockedTofndKeyGenClient.SendCalls())
func (mock *TofndKeyGenClientMock) SendCalls() []struct {
	MessageIn *tofnd.MessageIn
} {
	var calls []struct {
		MessageIn *tofnd.MessageIn
	}
	mock.lockSend.RLock()
	calls = mock.calls.Send
	mock.lockSend.RUnlock()
	return calls
}

// SendMsg calls SendMsgFunc.
func (mock *TofndKeyGenClientMock) SendMsg(m interface{}) error {
	if mock.SendMsgFunc == nil {
		panic("TofndKeyGenClientMock.SendMsgFunc: method is nil but TofndKeyGenClient.SendMsg was just called")
	}
	callInfo := struct {
		M interface{}
	}{
		M: m,
	}
	mock.lockSendMsg.Lock()
	mock.calls.SendMsg = append(mock.calls.SendMsg, callInfo)
	mock.lockSendMsg.Unlock()
	return mock.SendMsgFunc(m)
}

// SendMsgCalls gets all the calls that were made to SendMsg.
// Check the length with:
//     len(mockedTofndKeyGenClient.SendMsgCalls())
func (mock *TofndKeyGenClientMock) SendMsgCalls() []struct {
	M interface{}
} {
	var calls []struct {
		M interface{}
	}
	mock.lockSendMsg.RLock()
	calls = mock.calls.SendMsg
	mock.lockSendMsg.RUnlock()
	return calls
}

// Trailer calls TrailerFunc.
func (mock *TofndKeyGenClientMock) Trailer() metadata.MD {
	if mock.TrailerFunc == nil {
		panic("TofndKeyGenClientMock.TrailerFunc: method is nil but TofndKeyGenClient.Trailer was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTrailer.Lock()
	mock.calls.Trailer = append(mock.calls.Trailer, callInfo)
	mock.lockTrailer.Unlock()
	return mock.TrailerFunc()
}

// TrailerCalls gets all the calls that were made to Trailer.
// Check the length with:
//     len(mockedTofndKeyGenClient.TrailerCalls())
func (mock *TofndKeyGenClientMock) TrailerCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTrailer.RLock()
	calls = mock.calls.Trailer
	mock.lockTrailer.RUnlock()
	return calls
}

// Ensure, that TofndSignClientMock does implement tsstypes.TofndSignClient.
// If this is not the case, regenerate this file with moq.
var _ tsstypes.TofndSignClient = &TofndSignClientMock{}

// TofndSignClientMock is a mock implementation of tsstypes.TofndSignClient.
//
// 	func TestSomethingThatUsesTofndSignClient(t *testing.T) {
//
// 		// make and configure a mocked tsstypes.TofndSignClient
// 		mockedTofndSignClient := &TofndSignClientMock{
// 			CloseSendFunc: func() error {
// 				panic("mock out the CloseSend method")
// 			},
// 			ContextFunc: func() context.Context {
// 				panic("mock out the Context method")
// 			},
// 			HeaderFunc: func() (metadata.MD, error) {
// 				panic("mock out the Header method")
// 			},
// 			RecvFunc: func() (*tofnd.MessageOut, error) {
// 				panic("mock out the Recv method")
// 			},
// 			RecvMsgFunc: func(m interface{}) error {
// 				panic("mock out the RecvMsg method")
// 			},
// 			SendFunc: func(messageIn *tofnd.MessageIn) error {
// 				panic("mock out the Send method")
// 			},
// 			SendMsgFunc: func(m interface{}) error {
// 				panic("mock out the SendMsg method")
// 			},
// 			TrailerFunc: func() metadata.MD {
// 				panic("mock out the Trailer method")
// 			},
// 		}
//
// 		// use mockedTofndSignClient in code that requires tsstypes.TofndSignClient
// 		// and then make assertions.
//
// 	}
type TofndSignClientMock struct {
	// CloseSendFunc mocks the CloseSend method.
	CloseSendFunc func() error

	// ContextFunc mocks the Context method.
	ContextFunc func() context.Context

	// HeaderFunc mocks the Header method.
	HeaderFunc func() (metadata.MD, error)

	// RecvFunc mocks the Recv method.
	RecvFunc func() (*tofnd.MessageOut, error)

	// RecvMsgFunc mocks the RecvMsg method.
	RecvMsgFunc func(m interface{}) error

	// SendFunc mocks the Send method.
	SendFunc func(messageIn *tofnd.MessageIn) error

	// SendMsgFunc mocks the SendMsg method.
	SendMsgFunc func(m interface{}) error

	// TrailerFunc mocks the Trailer method.
	TrailerFunc func() metadata.MD

	// calls tracks calls to the methods.
	calls struct {
		// CloseSend holds details about calls to the CloseSend method.
		CloseSend []struct {
		}
		// Context holds details about calls to the Context method.
		Context []struct {
		}
		// Header holds details about calls to the Header method.
		Header []struct {
		}
		// Recv holds details about calls to the Recv method.
		Recv []struct {
		}
		// RecvMsg holds details about calls to the RecvMsg method.
		RecvMsg []struct {
			// M is the m argument value.
			M interface{}
		}
		// Send holds details about calls to the Send method.
		Send []struct {
			// MessageIn is the messageIn argument value.
			MessageIn *tofnd.MessageIn
		}
		// SendMsg holds details about calls to the SendMsg method.
		SendMsg []struct {
			// M is the m argument value.
			M interface{}
		}
		// Trailer holds details about calls to the Trailer method.
		Trailer []struct {
		}
	}
	lockCloseSend sync.RWMutex
	lockContext   sync.RWMutex
	lockHeader    sync.RWMutex
	lockRecv      sync.RWMutex
	lockRecvMsg   sync.RWMutex
	lockSend      sync.RWMutex
	lockSendMsg   sync.RWMutex
	lockTrailer   sync.RWMutex
}

// CloseSend calls CloseSendFunc.
func (mock *TofndSignClientMock) CloseSend() error {
	if mock.CloseSendFunc == nil {
		panic("TofndSignClientMock.CloseSendFunc: method is nil but TofndSignClient.CloseSend was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCloseSend.Lock()
	mock.calls.CloseSend = append(mock.calls.CloseSend, callInfo)
	mock.lockCloseSend.Unlock()
	return mock.CloseSendFunc()
}

// CloseSendCalls gets all the calls that were made to CloseSend.
// Check the length with:
//     len(mockedTofndSignClient.CloseSendCalls())
func (mock *TofndSignClientMock) CloseSendCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCloseSend.RLock()
	calls = mock.calls.CloseSend
	mock.lockCloseSend.RUnlock()
	return calls
}

// Context calls ContextFunc.
func (mock *TofndSignClientMock) Context() context.Context {
	if mock.ContextFunc == nil {
		panic("TofndSignClientMock.ContextFunc: method is nil but TofndSignClient.Context was just called")
	}
	callInfo := struct {
	}{}
	mock.lockContext.Lock()
	mock.calls.Context = append(mock.calls.Context, callInfo)
	mock.lockContext.Unlock()
	return mock.ContextFunc()
}

// ContextCalls gets all the calls that were made to Context.
// Check the length with:
//     len(mockedTofndSignClient.ContextCalls())
func (mock *TofndSignClientMock) ContextCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockContext.RLock()
	calls = mock.calls.Context
	mock.lockContext.RUnlock()
	return calls
}

// Header calls HeaderFunc.
func (mock *TofndSignClientMock) Header() (metadata.MD, error) {
	if mock.HeaderFunc == nil {
		panic("TofndSignClientMock.HeaderFunc: method is nil but TofndSignClient.Header was just called")
	}
	callInfo := struct {
	}{}
	mock.lockHeader.Lock()
	mock.calls.Header = append(mock.calls.Header, callInfo)
	mock.lockHeader.Unlock()
	return mock.HeaderFunc()
}

// HeaderCalls gets all the calls that were made to Header.
// Check the length with:
//     len(mockedTofndSignClient.HeaderCalls())
func (mock *TofndSignClientMock) HeaderCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockHeader.RLock()
	calls = mock.calls.Header
	mock.lockHeader.RUnlock()
	return calls
}

// Recv calls RecvFunc.
func (mock *TofndSignClientMock) Recv() (*tofnd.MessageOut, error) {
	if mock.RecvFunc == nil {
		panic("TofndSignClientMock.RecvFunc: method is nil but TofndSignClient.Recv was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRecv.Lock()
	mock.calls.Recv = append(mock.calls.Recv, callInfo)
	mock.lockRecv.Unlock()
	return mock.RecvFunc()
}

// RecvCalls gets all the calls that were made to Recv.
// Check the length with:
//     len(mockedTofndSignClient.RecvCalls())
func (mock *TofndSignClientMock) RecvCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRecv.RLock()
	calls = mock.calls.Recv
	mock.lockRecv.RUnlock()
	return calls
}

// RecvMsg calls RecvMsgFunc.
func (mock *TofndSignClientMock) RecvMsg(m interface{}) error {
	if mock.RecvMsgFunc == nil {
		panic("TofndSignClientMock.RecvMsgFunc: method is nil but TofndSignClient.RecvMsg was just called")
	}
	callInfo := struct {
		M interface{}
	}{
		M: m,
	}
	mock.lockRecvMsg.Lock()
	mock.calls.RecvMsg = append(mock.calls.RecvMsg, callInfo)
	mock.lockRecvMsg.Unlock()
	return mock.RecvMsgFunc(m)
}

// RecvMsgCalls gets all the calls that were made to RecvMsg.
// Check the length with:
//     len(mockedTofndSignClient.RecvMsgCalls())
func (mock *TofndSignClientMock) RecvMsgCalls() []struct {
	M interface{}
} {
	var calls []struct {
		M interface{}
	}
	mock.lockRecvMsg.RLock()
	calls = mock.calls.RecvMsg
	mock.lockRecvMsg.RUnlock()
	return calls
}

// Send calls SendFunc.
func (mock *TofndSignClientMock) Send(messageIn *tofnd.MessageIn) error {
	if mock.SendFunc == nil {
		panic("TofndSignClientMock.SendFunc: method is nil but TofndSignClient.Send was just called")
	}
	callInfo := struct {
		MessageIn *tofnd.MessageIn
	}{
		MessageIn: messageIn,
	}
	mock.lockSend.Lock()
	mock.calls.Send = append(mock.calls.Send, callInfo)
	mock.lockSend.Unlock()
	return mock.SendFunc(messageIn)
}

// SendCalls gets all the calls that were made to Send.
// Check the length with:
//     len(mockedTofndSignClient.SendCalls())
func (mock *TofndSignClientMock) SendCalls() []struct {
	MessageIn *tofnd.MessageIn
} {
	var calls []struct {
		MessageIn *tofnd.MessageIn
	}
	mock.lockSend.RLock()
	calls = mock.calls.Send
	mock.lockSend.RUnlock()
	return calls
}

// SendMsg calls SendMsgFunc.
func (mock *TofndSignClientMock) SendMsg(m interface{}) error {
	if mock.SendMsgFunc == nil {
		panic("TofndSignClientMock.SendMsgFunc: method is nil but TofndSignClient.SendMsg was just called")
	}
	callInfo := struct {
		M interface{}
	}{
		M: m,
	}
	mock.lockSendMsg.Lock()
	mock.calls.SendMsg = append(mock.calls.SendMsg, callInfo)
	mock.lockSendMsg.Unlock()
	return mock.SendMsgFunc(m)
}

// SendMsgCalls gets all the calls that were made to SendMsg.
// Check the length with:
//     len(mockedTofndSignClient.SendMsgCalls())
func (mock *TofndSignClientMock) SendMsgCalls() []struct {
	M interface{}
} {
	var calls []struct {
		M interface{}
	}
	mock.lockSendMsg.RLock()
	calls = mock.calls.SendMsg
	mock.lockSendMsg.RUnlock()
	return calls
}

// Trailer calls TrailerFunc.
func (mock *TofndSignClientMock) Trailer() metadata.MD {
	if mock.TrailerFunc == nil {
		panic("TofndSignClientMock.TrailerFunc: method is nil but TofndSignClient.Trailer was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTrailer.Lock()
	mock.calls.Trailer = append(mock.calls.Trailer, callInfo)
	mock.lockTrailer.Unlock()
	return mock.TrailerFunc()
}

// TrailerCalls gets all the calls that were made to Trailer.
// Check the length with:
//     len(mockedTofndSignClient.TrailerCalls())
func (mock *TofndSignClientMock) TrailerCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTrailer.RLock()
	calls = mock.calls.Trailer
	mock.lockTrailer.RUnlock()
	return calls
}

// Ensure, that VoterMock does implement tsstypes.Voter.
// If this is not the case, regenerate this file with moq.
var _ tsstypes.Voter = &VoterMock{}

// VoterMock is a mock implementation of tsstypes.Voter.
//
// 	func TestSomethingThatUsesVoter(t *testing.T) {
//
// 		// make and configure a mocked tsstypes.Voter
// 		mockedVoter := &VoterMock{
// 			GetPollFunc: func(ctx sdk.Context, pollKey exported1.PollKey) exported1.Poll {
// 				panic("mock out the GetPoll method")
// 			},
// 			InitializePollFunc: func(ctx sdk.Context, key exported1.PollKey, snapshotSeqNo int64, pollProperties ...exported1.PollProperty) error {
// 				panic("mock out the InitializePoll method")
// 			},
// 		}
//
// 		// use mockedVoter in code that requires tsstypes.Voter
// 		// and then make assertions.
//
// 	}
type VoterMock struct {
	// GetPollFunc mocks the GetPoll method.
	GetPollFunc func(ctx sdk.Context, pollKey exported1.PollKey) exported1.Poll

	// InitializePollFunc mocks the InitializePoll method.
	InitializePollFunc func(ctx sdk.Context, key exported1.PollKey, snapshotSeqNo int64, pollProperties ...exported1.PollProperty) error

	// calls tracks calls to the methods.
	calls struct {
		// GetPoll holds details about calls to the GetPoll method.
		GetPoll []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// PollKey is the pollKey argument value.
			PollKey exported1.PollKey
		}
		// InitializePoll holds details about calls to the InitializePoll method.
		InitializePoll []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Key is the key argument value.
			Key exported1.PollKey
			// SnapshotSeqNo is the snapshotSeqNo argument value.
			SnapshotSeqNo int64
			// PollProperties is the pollProperties argument value.
			PollProperties []exported1.PollProperty
		}
	}
	lockGetPoll        sync.RWMutex
	lockInitializePoll sync.RWMutex
}

// GetPoll calls GetPollFunc.
func (mock *VoterMock) GetPoll(ctx sdk.Context, pollKey exported1.PollKey) exported1.Poll {
	if mock.GetPollFunc == nil {
		panic("VoterMock.GetPollFunc: method is nil but Voter.GetPoll was just called")
	}
	callInfo := struct {
		Ctx     sdk.Context
		PollKey exported1.PollKey
	}{
		Ctx:     ctx,
		PollKey: pollKey,
	}
	mock.lockGetPoll.Lock()
	mock.calls.GetPoll = append(mock.calls.GetPoll, callInfo)
	mock.lockGetPoll.Unlock()
	return mock.GetPollFunc(ctx, pollKey)
}

// GetPollCalls gets all the calls that were made to GetPoll.
// Check the length with:
//     len(mockedVoter.GetPollCalls())
func (mock *VoterMock) GetPollCalls() []struct {
	Ctx     sdk.Context
	PollKey exported1.PollKey
} {
	var calls []struct {
		Ctx     sdk.Context
		PollKey exported1.PollKey
	}
	mock.lockGetPoll.RLock()
	calls = mock.calls.GetPoll
	mock.lockGetPoll.RUnlock()
	return calls
}

// InitializePoll calls InitializePollFunc.
func (mock *VoterMock) InitializePoll(ctx sdk.Context, key exported1.PollKey, snapshotSeqNo int64, pollProperties ...exported1.PollProperty) error {
	if mock.InitializePollFunc == nil {
		panic("VoterMock.InitializePollFunc: method is nil but Voter.InitializePoll was just called")
	}
	callInfo := struct {
		Ctx            sdk.Context
		Key            exported1.PollKey
		SnapshotSeqNo  int64
		PollProperties []exported1.PollProperty
	}{
		Ctx:            ctx,
		Key:            key,
		SnapshotSeqNo:  snapshotSeqNo,
		PollProperties: pollProperties,
	}
	mock.lockInitializePoll.Lock()
	mock.calls.InitializePoll = append(mock.calls.InitializePoll, callInfo)
	mock.lockInitializePoll.Unlock()
	return mock.InitializePollFunc(ctx, key, snapshotSeqNo, pollProperties...)
}

// InitializePollCalls gets all the calls that were made to InitializePoll.
// Check the length with:
//     len(mockedVoter.InitializePollCalls())
func (mock *VoterMock) InitializePollCalls() []struct {
	Ctx            sdk.Context
	Key            exported1.PollKey
	SnapshotSeqNo  int64
	PollProperties []exported1.PollProperty
} {
	var calls []struct {
		Ctx            sdk.Context
		Key            exported1.PollKey
		SnapshotSeqNo  int64
		PollProperties []exported1.PollProperty
	}
	mock.lockInitializePoll.RLock()
	calls = mock.calls.InitializePoll
	mock.lockInitializePoll.RUnlock()
	return calls
}

// Ensure, that StakingKeeperMock does implement tsstypes.StakingKeeper.
// If this is not the case, regenerate this file with moq.
var _ tsstypes.StakingKeeper = &StakingKeeperMock{}

// StakingKeeperMock is a mock implementation of tsstypes.StakingKeeper.
//
// 	func TestSomethingThatUsesStakingKeeper(t *testing.T) {
//
// 		// make and configure a mocked tsstypes.StakingKeeper
// 		mockedStakingKeeper := &StakingKeeperMock{
// 			GetLastTotalPowerFunc: func(ctx sdk.Context) sdk.Int {
// 				panic("mock out the GetLastTotalPower method")
// 			},
// 			GetValidatorFunc: func(ctx sdk.Context, addr sdk.ValAddress) (stakingtypes.Validator, bool) {
// 				panic("mock out the GetValidator method")
// 			},
// 		}
//
// 		// use mockedStakingKeeper in code that requires tsstypes.StakingKeeper
// 		// and then make assertions.
//
// 	}
type StakingKeeperMock struct {
	// GetLastTotalPowerFunc mocks the GetLastTotalPower method.
	GetLastTotalPowerFunc func(ctx sdk.Context) sdk.Int

	// GetValidatorFunc mocks the GetValidator method.
	GetValidatorFunc func(ctx sdk.Context, addr sdk.ValAddress) (stakingtypes.Validator, bool)

	// calls tracks calls to the methods.
	calls struct {
		// GetLastTotalPower holds details about calls to the GetLastTotalPower method.
		GetLastTotalPower []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetValidator holds details about calls to the GetValidator method.
		GetValidator []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Addr is the addr argument value.
			Addr sdk.ValAddress
		}
	}
	lockGetLastTotalPower sync.RWMutex
	lockGetValidator      sync.RWMutex
}

// GetLastTotalPower calls GetLastTotalPowerFunc.
func (mock *StakingKeeperMock) GetLastTotalPower(ctx sdk.Context) sdk.Int {
	if mock.GetLastTotalPowerFunc == nil {
		panic("StakingKeeperMock.GetLastTotalPowerFunc: method is nil but StakingKeeper.GetLastTotalPower was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetLastTotalPower.Lock()
	mock.calls.GetLastTotalPower = append(mock.calls.GetLastTotalPower, callInfo)
	mock.lockGetLastTotalPower.Unlock()
	return mock.GetLastTotalPowerFunc(ctx)
}

// GetLastTotalPowerCalls gets all the calls that were made to GetLastTotalPower.
// Check the length with:
//     len(mockedStakingKeeper.GetLastTotalPowerCalls())
func (mock *StakingKeeperMock) GetLastTotalPowerCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetLastTotalPower.RLock()
	calls = mock.calls.GetLastTotalPower
	mock.lockGetLastTotalPower.RUnlock()
	return calls
}

// GetValidator calls GetValidatorFunc.
func (mock *StakingKeeperMock) GetValidator(ctx sdk.Context, addr sdk.ValAddress) (stakingtypes.Validator, bool) {
	if mock.GetValidatorFunc == nil {
		panic("StakingKeeperMock.GetValidatorFunc: method is nil but StakingKeeper.GetValidator was just called")
	}
	callInfo := struct {
		Ctx  sdk.Context
		Addr sdk.ValAddress
	}{
		Ctx:  ctx,
		Addr: addr,
	}
	mock.lockGetValidator.Lock()
	mock.calls.GetValidator = append(mock.calls.GetValidator, callInfo)
	mock.lockGetValidator.Unlock()
	return mock.GetValidatorFunc(ctx, addr)
}

// GetValidatorCalls gets all the calls that were made to GetValidator.
// Check the length with:
//     len(mockedStakingKeeper.GetValidatorCalls())
func (mock *StakingKeeperMock) GetValidatorCalls() []struct {
	Ctx  sdk.Context
	Addr sdk.ValAddress
} {
	var calls []struct {
		Ctx  sdk.Context
		Addr sdk.ValAddress
	}
	mock.lockGetValidator.RLock()
	calls = mock.calls.GetValidator
	mock.lockGetValidator.RUnlock()
	return calls
}

// Ensure, that TSSKeeperMock does implement tsstypes.TSSKeeper.
// If this is not the case, regenerate this file with moq.
var _ tsstypes.TSSKeeper = &TSSKeeperMock{}

// TSSKeeperMock is a mock implementation of tsstypes.TSSKeeper.
//
// 	func TestSomethingThatUsesTSSKeeper(t *testing.T) {
//
// 		// make and configure a mocked tsstypes.TSSKeeper
// 		mockedTSSKeeper := &TSSKeeperMock{
// 			AssertMatchesRequirementsFunc: func(ctx sdk.Context, snapshotter snapshot.Snapshotter, chain nexus.Chain, keyID string, keyRole exported.KeyRole) error {
// 				panic("mock out the AssertMatchesRequirements method")
// 			},
// 			AssignNextKeyFunc: func(ctx sdk.Context, chain nexus.Chain, keyRole exported.KeyRole, keyID string) error {
// 				panic("mock out the AssignNextKey method")
// 			},
// 			DeleteAllRecoveryInfosFunc: func(ctx sdk.Context, keyID string)  {
// 				panic("mock out the DeleteAllRecoveryInfos method")
// 			},
// 			DeleteAvailableOperatorsFunc: func(ctx sdk.Context, ID string, ackType exported.AckType)  {
// 				panic("mock out the DeleteAvailableOperators method")
// 			},
// 			DeleteKeyIDForSigFunc: func(ctx sdk.Context, sigID string)  {
// 				panic("mock out the DeleteKeyIDForSig method")
// 			},
// 			DeleteKeygenStartFunc: func(ctx sdk.Context, keyID string)  {
// 				panic("mock out the DeleteKeygenStart method")
// 			},
// 			DeleteParticipantsInKeygenFunc: func(ctx sdk.Context, keyID string)  {
// 				panic("mock out the DeleteParticipantsInKeygen method")
// 			},
// 			DeleteScheduledKeygenFunc: func(ctx sdk.Context, ID string)  {
// 				panic("mock out the DeleteScheduledKeygen method")
// 			},
// 			DeleteScheduledSignFunc: func(ctx sdk.Context, ID string)  {
// 				panic("mock out the DeleteScheduledSign method")
// 			},
// 			DeleteSnapshotCounterForKeyIDFunc: func(ctx sdk.Context, keyID string)  {
// 				panic("mock out the DeleteSnapshotCounterForKeyID method")
// 			},
// 			DoesValidatorParticipateInKeygenFunc: func(ctx sdk.Context, keyID string, validator sdk.ValAddress) bool {
// 				panic("mock out the DoesValidatorParticipateInKeygen method")
// 			},
// 			DoesValidatorParticipateInSignFunc: func(ctx sdk.Context, sigID string, validator sdk.ValAddress) bool {
// 				panic("mock out the DoesValidatorParticipateInSign method")
// 			},
// 			GetAllKeygenRequestsAtCurrentHeightFunc: func(ctx sdk.Context) []tsstypes.StartKeygenRequest {
// 				panic("mock out the GetAllKeygenRequestsAtCurrentHeight method")
// 			},
// 			GetAllRecoveryInfosFunc: func(ctx sdk.Context, keyID string) [][]byte {
// 				panic("mock out the GetAllRecoveryInfos method")
// 			},
// 			GetAvailableOperatorsFunc: func(ctx sdk.Context, ID string, ackType exported.AckType, heightLimit int64) []sdk.ValAddress {
// 				panic("mock out the GetAvailableOperators method")
// 			},
// 			GetCurrentKeyFunc: func(ctx sdk.Context, chain nexus.Chain, keyRole exported.KeyRole) (exported.Key, bool) {
// 				panic("mock out the GetCurrentKey method")
// 			},
// 			GetCurrentKeyIDFunc: func(ctx sdk.Context, chain nexus.Chain, keyRole exported.KeyRole) (string, bool) {
// 				panic("mock out the GetCurrentKeyID method")
// 			},
// 			GetKeyFunc: func(ctx sdk.Context, keyID string) (exported.Key, bool) {
// 				panic("mock out the GetKey method")
// 			},
// 			GetKeyForSigIDFunc: func(ctx sdk.Context, sigID string) (exported.Key, bool) {
// 				panic("mock out the GetKeyForSigID method")
// 			},
// 			GetKeyRequirementFunc: func(ctx sdk.Context, keyRole exported.KeyRole) (exported.KeyRequirement, bool) {
// 				panic("mock out the GetKeyRequirement method")
// 			},
// 			GetNextKeyFunc: func(ctx sdk.Context, chain nexus.Chain, keyRole exported.KeyRole) (exported.Key, bool) {
// 				panic("mock out the GetNextKey method")
// 			},
// 			GetNextKeyIDFunc: func(ctx sdk.Context, chain nexus.Chain, keyRole exported.KeyRole) (string, bool) {
// 				panic("mock out the GetNextKeyID method")
// 			},
// 			GetParamsFunc: func(ctx sdk.Context) tsstypes.Params {
// 				panic("mock out the GetParams method")
// 			},
// 			GetSigFunc: func(ctx sdk.Context, sigID string) (exported.Signature, exported.SigStatus) {
// 				panic("mock out the GetSig method")
// 			},
// 			GetSignParticipantsFunc: func(ctx sdk.Context, sigID string) []string {
// 				panic("mock out the GetSignParticipants method")
// 			},
// 			GetSignParticipantsAsJSONFunc: func(ctx sdk.Context, sigID string) []byte {
// 				panic("mock out the GetSignParticipantsAsJSON method")
// 			},
// 			GetSnapshotCounterForKeyIDFunc: func(ctx sdk.Context, keyID string) (int64, bool) {
// 				panic("mock out the GetSnapshotCounterForKeyID method")
// 			},
// 			GetTotalShareCountFunc: func(ctx sdk.Context, sigID string) int64 {
// 				panic("mock out the GetTotalShareCount method")
// 			},
// 			GetTssSuspendedUntilFunc: func(ctx sdk.Context, validator sdk.ValAddress) int64 {
// 				panic("mock out the GetTssSuspendedUntil method")
// 			},
// 			HasKeygenStartedFunc: func(ctx sdk.Context, keyID string) bool {
// 				panic("mock out the HasKeygenStarted method")
// 			},
// 			HasRecoveryInfosFunc: func(ctx sdk.Context, sender sdk.ValAddress, keyID string) bool {
// 				panic("mock out the HasRecoveryInfos method")
// 			},
// 			IsOperatorAvailableFunc: func(ctx sdk.Context, ID string, ackType exported.AckType, validator sdk.ValAddress) bool {
// 				panic("mock out the IsOperatorAvailable method")
// 			},
// 			LinkAvailableOperatorsToSnapshotFunc: func(ctx sdk.Context, ID string, ackType exported.AckType, counter int64)  {
// 				panic("mock out the LinkAvailableOperatorsToSnapshot method")
// 			},
// 			LoggerFunc: func(ctx sdk.Context) log.Logger {
// 				panic("mock out the Logger method")
// 			},
// 			MeetsThresholdFunc: func(ctx sdk.Context, sigID string, threshold int64) bool {
// 				panic("mock out the MeetsThreshold method")
// 			},
// 			OperatorIsAvailableForCounterFunc: func(ctx sdk.Context, counter int64, validator sdk.ValAddress) bool {
// 				panic("mock out the OperatorIsAvailableForCounter method")
// 			},
// 			PenalizeCriminalFunc: func(ctx sdk.Context, criminal sdk.ValAddress, crimeType tofnd.MessageOut_CriminalList_Criminal_CrimeType)  {
// 				panic("mock out the PenalizeCriminal method")
// 			},
// 			RotateKeyFunc: func(ctx sdk.Context, chain nexus.Chain, keyRole exported.KeyRole) error {
// 				panic("mock out the RotateKey method")
// 			},
// 			ScheduleKeygenFunc: func(ctx sdk.Context, req tsstypes.StartKeygenRequest) (int64, error) {
// 				panic("mock out the ScheduleKeygen method")
// 			},
// 			ScheduleSignFunc: func(ctx sdk.Context, info exported.SignInfo) (int64, error) {
// 				panic("mock out the ScheduleSign method")
// 			},
// 			SelectSignParticipantsFunc: func(ctx sdk.Context, snapshotter snapshot.Snapshotter, sigID string, validators []snapshot.Validator) error {
// 				panic("mock out the SelectSignParticipants method")
// 			},
// 			SetAvailableOperatorFunc: func(ctx sdk.Context, ID string, ackType exported.AckType, validator sdk.ValAddress) error {
// 				panic("mock out the SetAvailableOperator method")
// 			},
// 			SetKeyFunc: func(ctx sdk.Context, keyID string, key ecdsa.PublicKey)  {
// 				panic("mock out the SetKey method")
// 			},
// 			SetKeyIDForSigFunc: func(ctx sdk.Context, sigID string, keyID string)  {
// 				panic("mock out the SetKeyIDForSig method")
// 			},
// 			SetParamsFunc: func(ctx sdk.Context, p tsstypes.Params)  {
// 				panic("mock out the SetParams method")
// 			},
// 			SetRecoveryInfosFunc: func(ctx sdk.Context, sender sdk.ValAddress, keyID string, infos [][]byte)  {
// 				panic("mock out the SetRecoveryInfos method")
// 			},
// 			SetSigFunc: func(ctx sdk.Context, sigID string, signature []byte)  {
// 				panic("mock out the SetSig method")
// 			},
// 			SetSigStatusFunc: func(ctx sdk.Context, sigID string, status exported.SigStatus)  {
// 				panic("mock out the SetSigStatus method")
// 			},
// 			StartKeygenFunc: func(ctx sdk.Context, voter tsstypes.Voter, keyID string, keyRole exported.KeyRole, snapshotMoqParam snapshot.Snapshot) error {
// 				panic("mock out the StartKeygen method")
// 			},
// 		}
//
// 		// use mockedTSSKeeper in code that requires tsstypes.TSSKeeper
// 		// and then make assertions.
//
// 	}
type TSSKeeperMock struct {
	// AssertMatchesRequirementsFunc mocks the AssertMatchesRequirements method.
	AssertMatchesRequirementsFunc func(ctx sdk.Context, snapshotter snapshot.Snapshotter, chain nexus.Chain, keyID string, keyRole exported.KeyRole) error

	// AssignNextKeyFunc mocks the AssignNextKey method.
	AssignNextKeyFunc func(ctx sdk.Context, chain nexus.Chain, keyRole exported.KeyRole, keyID string) error

	// DeleteAllRecoveryInfosFunc mocks the DeleteAllRecoveryInfos method.
	DeleteAllRecoveryInfosFunc func(ctx sdk.Context, keyID string)

	// DeleteAvailableOperatorsFunc mocks the DeleteAvailableOperators method.
	DeleteAvailableOperatorsFunc func(ctx sdk.Context, ID string, ackType exported.AckType)

	// DeleteKeyIDForSigFunc mocks the DeleteKeyIDForSig method.
	DeleteKeyIDForSigFunc func(ctx sdk.Context, sigID string)

	// DeleteKeygenStartFunc mocks the DeleteKeygenStart method.
	DeleteKeygenStartFunc func(ctx sdk.Context, keyID string)

	// DeleteParticipantsInKeygenFunc mocks the DeleteParticipantsInKeygen method.
	DeleteParticipantsInKeygenFunc func(ctx sdk.Context, keyID string)

	// DeleteScheduledKeygenFunc mocks the DeleteScheduledKeygen method.
	DeleteScheduledKeygenFunc func(ctx sdk.Context, ID string)

	// DeleteScheduledSignFunc mocks the DeleteScheduledSign method.
	DeleteScheduledSignFunc func(ctx sdk.Context, ID string)

	// DeleteSnapshotCounterForKeyIDFunc mocks the DeleteSnapshotCounterForKeyID method.
	DeleteSnapshotCounterForKeyIDFunc func(ctx sdk.Context, keyID string)

	// DoesValidatorParticipateInKeygenFunc mocks the DoesValidatorParticipateInKeygen method.
	DoesValidatorParticipateInKeygenFunc func(ctx sdk.Context, keyID string, validator sdk.ValAddress) bool

	// DoesValidatorParticipateInSignFunc mocks the DoesValidatorParticipateInSign method.
	DoesValidatorParticipateInSignFunc func(ctx sdk.Context, sigID string, validator sdk.ValAddress) bool

	// GetAllKeygenRequestsAtCurrentHeightFunc mocks the GetAllKeygenRequestsAtCurrentHeight method.
	GetAllKeygenRequestsAtCurrentHeightFunc func(ctx sdk.Context) []tsstypes.StartKeygenRequest

	// GetAllRecoveryInfosFunc mocks the GetAllRecoveryInfos method.
	GetAllRecoveryInfosFunc func(ctx sdk.Context, keyID string) [][]byte

	// GetAvailableOperatorsFunc mocks the GetAvailableOperators method.
	GetAvailableOperatorsFunc func(ctx sdk.Context, ID string, ackType exported.AckType, heightLimit int64) []sdk.ValAddress

	// GetCurrentKeyFunc mocks the GetCurrentKey method.
	GetCurrentKeyFunc func(ctx sdk.Context, chain nexus.Chain, keyRole exported.KeyRole) (exported.Key, bool)

	// GetCurrentKeyIDFunc mocks the GetCurrentKeyID method.
	GetCurrentKeyIDFunc func(ctx sdk.Context, chain nexus.Chain, keyRole exported.KeyRole) (string, bool)

	// GetKeyFunc mocks the GetKey method.
	GetKeyFunc func(ctx sdk.Context, keyID string) (exported.Key, bool)

	// GetKeyForSigIDFunc mocks the GetKeyForSigID method.
	GetKeyForSigIDFunc func(ctx sdk.Context, sigID string) (exported.Key, bool)

	// GetKeyRequirementFunc mocks the GetKeyRequirement method.
	GetKeyRequirementFunc func(ctx sdk.Context, keyRole exported.KeyRole) (exported.KeyRequirement, bool)

	// GetNextKeyFunc mocks the GetNextKey method.
	GetNextKeyFunc func(ctx sdk.Context, chain nexus.Chain, keyRole exported.KeyRole) (exported.Key, bool)

	// GetNextKeyIDFunc mocks the GetNextKeyID method.
	GetNextKeyIDFunc func(ctx sdk.Context, chain nexus.Chain, keyRole exported.KeyRole) (string, bool)

	// GetParamsFunc mocks the GetParams method.
	GetParamsFunc func(ctx sdk.Context) tsstypes.Params

	// GetSigFunc mocks the GetSig method.
	GetSigFunc func(ctx sdk.Context, sigID string) (exported.Signature, exported.SigStatus)

	// GetSignParticipantsFunc mocks the GetSignParticipants method.
	GetSignParticipantsFunc func(ctx sdk.Context, sigID string) []string

	// GetSignParticipantsAsJSONFunc mocks the GetSignParticipantsAsJSON method.
	GetSignParticipantsAsJSONFunc func(ctx sdk.Context, sigID string) []byte

	// GetSnapshotCounterForKeyIDFunc mocks the GetSnapshotCounterForKeyID method.
	GetSnapshotCounterForKeyIDFunc func(ctx sdk.Context, keyID string) (int64, bool)

	// GetTotalShareCountFunc mocks the GetTotalShareCount method.
	GetTotalShareCountFunc func(ctx sdk.Context, sigID string) int64

	// GetTssSuspendedUntilFunc mocks the GetTssSuspendedUntil method.
	GetTssSuspendedUntilFunc func(ctx sdk.Context, validator sdk.ValAddress) int64

	// HasKeygenStartedFunc mocks the HasKeygenStarted method.
	HasKeygenStartedFunc func(ctx sdk.Context, keyID string) bool

	// HasRecoveryInfosFunc mocks the HasRecoveryInfos method.
	HasRecoveryInfosFunc func(ctx sdk.Context, sender sdk.ValAddress, keyID string) bool

	// IsOperatorAvailableFunc mocks the IsOperatorAvailable method.
	IsOperatorAvailableFunc func(ctx sdk.Context, ID string, ackType exported.AckType, validator sdk.ValAddress) bool

	// LinkAvailableOperatorsToSnapshotFunc mocks the LinkAvailableOperatorsToSnapshot method.
	LinkAvailableOperatorsToSnapshotFunc func(ctx sdk.Context, ID string, ackType exported.AckType, counter int64)

	// LoggerFunc mocks the Logger method.
	LoggerFunc func(ctx sdk.Context) log.Logger

	// MeetsThresholdFunc mocks the MeetsThreshold method.
	MeetsThresholdFunc func(ctx sdk.Context, sigID string, threshold int64) bool

	// OperatorIsAvailableForCounterFunc mocks the OperatorIsAvailableForCounter method.
	OperatorIsAvailableForCounterFunc func(ctx sdk.Context, counter int64, validator sdk.ValAddress) bool

	// PenalizeCriminalFunc mocks the PenalizeCriminal method.
	PenalizeCriminalFunc func(ctx sdk.Context, criminal sdk.ValAddress, crimeType tofnd.MessageOut_CriminalList_Criminal_CrimeType)

	// RotateKeyFunc mocks the RotateKey method.
	RotateKeyFunc func(ctx sdk.Context, chain nexus.Chain, keyRole exported.KeyRole) error

	// ScheduleKeygenFunc mocks the ScheduleKeygen method.
	ScheduleKeygenFunc func(ctx sdk.Context, req tsstypes.StartKeygenRequest) (int64, error)

	// ScheduleSignFunc mocks the ScheduleSign method.
	ScheduleSignFunc func(ctx sdk.Context, info exported.SignInfo) (int64, error)

	// SelectSignParticipantsFunc mocks the SelectSignParticipants method.
	SelectSignParticipantsFunc func(ctx sdk.Context, snapshotter snapshot.Snapshotter, sigID string, validators []snapshot.Validator) error

	// SetAvailableOperatorFunc mocks the SetAvailableOperator method.
	SetAvailableOperatorFunc func(ctx sdk.Context, ID string, ackType exported.AckType, validator sdk.ValAddress) error

	// SetKeyFunc mocks the SetKey method.
	SetKeyFunc func(ctx sdk.Context, keyID string, key ecdsa.PublicKey)

	// SetKeyIDForSigFunc mocks the SetKeyIDForSig method.
	SetKeyIDForSigFunc func(ctx sdk.Context, sigID string, keyID string)

	// SetParamsFunc mocks the SetParams method.
	SetParamsFunc func(ctx sdk.Context, p tsstypes.Params)

	// SetRecoveryInfosFunc mocks the SetRecoveryInfos method.
	SetRecoveryInfosFunc func(ctx sdk.Context, sender sdk.ValAddress, keyID string, infos [][]byte)

	// SetSigFunc mocks the SetSig method.
	SetSigFunc func(ctx sdk.Context, sigID string, signature []byte)

	// SetSigStatusFunc mocks the SetSigStatus method.
	SetSigStatusFunc func(ctx sdk.Context, sigID string, status exported.SigStatus)

	// StartKeygenFunc mocks the StartKeygen method.
	StartKeygenFunc func(ctx sdk.Context, voter tsstypes.Voter, keyID string, keyRole exported.KeyRole, snapshotMoqParam snapshot.Snapshot) error

	// calls tracks calls to the methods.
	calls struct {
		// AssertMatchesRequirements holds details about calls to the AssertMatchesRequirements method.
		AssertMatchesRequirements []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Snapshotter is the snapshotter argument value.
			Snapshotter snapshot.Snapshotter
			// Chain is the chain argument value.
			Chain nexus.Chain
			// KeyID is the keyID argument value.
			KeyID string
			// KeyRole is the keyRole argument value.
			KeyRole exported.KeyRole
		}
		// AssignNextKey holds details about calls to the AssignNextKey method.
		AssignNextKey []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Chain is the chain argument value.
			Chain nexus.Chain
			// KeyRole is the keyRole argument value.
			KeyRole exported.KeyRole
			// KeyID is the keyID argument value.
			KeyID string
		}
		// DeleteAllRecoveryInfos holds details about calls to the DeleteAllRecoveryInfos method.
		DeleteAllRecoveryInfos []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// KeyID is the keyID argument value.
			KeyID string
		}
		// DeleteAvailableOperators holds details about calls to the DeleteAvailableOperators method.
		DeleteAvailableOperators []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// ID is the ID argument value.
			ID string
			// AckType is the ackType argument value.
			AckType exported.AckType
		}
		// DeleteKeyIDForSig holds details about calls to the DeleteKeyIDForSig method.
		DeleteKeyIDForSig []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// SigID is the sigID argument value.
			SigID string
		}
		// DeleteKeygenStart holds details about calls to the DeleteKeygenStart method.
		DeleteKeygenStart []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// KeyID is the keyID argument value.
			KeyID string
		}
		// DeleteParticipantsInKeygen holds details about calls to the DeleteParticipantsInKeygen method.
		DeleteParticipantsInKeygen []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// KeyID is the keyID argument value.
			KeyID string
		}
		// DeleteScheduledKeygen holds details about calls to the DeleteScheduledKeygen method.
		DeleteScheduledKeygen []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// ID is the ID argument value.
			ID string
		}
		// DeleteScheduledSign holds details about calls to the DeleteScheduledSign method.
		DeleteScheduledSign []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// ID is the ID argument value.
			ID string
		}
		// DeleteSnapshotCounterForKeyID holds details about calls to the DeleteSnapshotCounterForKeyID method.
		DeleteSnapshotCounterForKeyID []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// KeyID is the keyID argument value.
			KeyID string
		}
		// DoesValidatorParticipateInKeygen holds details about calls to the DoesValidatorParticipateInKeygen method.
		DoesValidatorParticipateInKeygen []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// KeyID is the keyID argument value.
			KeyID string
			// Validator is the validator argument value.
			Validator sdk.ValAddress
		}
		// DoesValidatorParticipateInSign holds details about calls to the DoesValidatorParticipateInSign method.
		DoesValidatorParticipateInSign []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// SigID is the sigID argument value.
			SigID string
			// Validator is the validator argument value.
			Validator sdk.ValAddress
		}
		// GetAllKeygenRequestsAtCurrentHeight holds details about calls to the GetAllKeygenRequestsAtCurrentHeight method.
		GetAllKeygenRequestsAtCurrentHeight []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetAllRecoveryInfos holds details about calls to the GetAllRecoveryInfos method.
		GetAllRecoveryInfos []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// KeyID is the keyID argument value.
			KeyID string
		}
		// GetAvailableOperators holds details about calls to the GetAvailableOperators method.
		GetAvailableOperators []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// ID is the ID argument value.
			ID string
			// AckType is the ackType argument value.
			AckType exported.AckType
			// HeightLimit is the heightLimit argument value.
			HeightLimit int64
		}
		// GetCurrentKey holds details about calls to the GetCurrentKey method.
		GetCurrentKey []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Chain is the chain argument value.
			Chain nexus.Chain
			// KeyRole is the keyRole argument value.
			KeyRole exported.KeyRole
		}
		// GetCurrentKeyID holds details about calls to the GetCurrentKeyID method.
		GetCurrentKeyID []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Chain is the chain argument value.
			Chain nexus.Chain
			// KeyRole is the keyRole argument value.
			KeyRole exported.KeyRole
		}
		// GetKey holds details about calls to the GetKey method.
		GetKey []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// KeyID is the keyID argument value.
			KeyID string
		}
		// GetKeyForSigID holds details about calls to the GetKeyForSigID method.
		GetKeyForSigID []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// SigID is the sigID argument value.
			SigID string
		}
		// GetKeyRequirement holds details about calls to the GetKeyRequirement method.
		GetKeyRequirement []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// KeyRole is the keyRole argument value.
			KeyRole exported.KeyRole
		}
		// GetNextKey holds details about calls to the GetNextKey method.
		GetNextKey []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Chain is the chain argument value.
			Chain nexus.Chain
			// KeyRole is the keyRole argument value.
			KeyRole exported.KeyRole
		}
		// GetNextKeyID holds details about calls to the GetNextKeyID method.
		GetNextKeyID []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Chain is the chain argument value.
			Chain nexus.Chain
			// KeyRole is the keyRole argument value.
			KeyRole exported.KeyRole
		}
		// GetParams holds details about calls to the GetParams method.
		GetParams []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetSig holds details about calls to the GetSig method.
		GetSig []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// SigID is the sigID argument value.
			SigID string
		}
		// GetSignParticipants holds details about calls to the GetSignParticipants method.
		GetSignParticipants []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// SigID is the sigID argument value.
			SigID string
		}
		// GetSignParticipantsAsJSON holds details about calls to the GetSignParticipantsAsJSON method.
		GetSignParticipantsAsJSON []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// SigID is the sigID argument value.
			SigID string
		}
		// GetSnapshotCounterForKeyID holds details about calls to the GetSnapshotCounterForKeyID method.
		GetSnapshotCounterForKeyID []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// KeyID is the keyID argument value.
			KeyID string
		}
		// GetTotalShareCount holds details about calls to the GetTotalShareCount method.
		GetTotalShareCount []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// SigID is the sigID argument value.
			SigID string
		}
		// GetTssSuspendedUntil holds details about calls to the GetTssSuspendedUntil method.
		GetTssSuspendedUntil []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Validator is the validator argument value.
			Validator sdk.ValAddress
		}
		// HasKeygenStarted holds details about calls to the HasKeygenStarted method.
		HasKeygenStarted []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// KeyID is the keyID argument value.
			KeyID string
		}
		// HasRecoveryInfos holds details about calls to the HasRecoveryInfos method.
		HasRecoveryInfos []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Sender is the sender argument value.
			Sender sdk.ValAddress
			// KeyID is the keyID argument value.
			KeyID string
		}
		// IsOperatorAvailable holds details about calls to the IsOperatorAvailable method.
		IsOperatorAvailable []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// ID is the ID argument value.
			ID string
			// AckType is the ackType argument value.
			AckType exported.AckType
			// Validator is the validator argument value.
			Validator sdk.ValAddress
		}
		// LinkAvailableOperatorsToSnapshot holds details about calls to the LinkAvailableOperatorsToSnapshot method.
		LinkAvailableOperatorsToSnapshot []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// ID is the ID argument value.
			ID string
			// AckType is the ackType argument value.
			AckType exported.AckType
			// Counter is the counter argument value.
			Counter int64
		}
		// Logger holds details about calls to the Logger method.
		Logger []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// MeetsThreshold holds details about calls to the MeetsThreshold method.
		MeetsThreshold []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// SigID is the sigID argument value.
			SigID string
			// Threshold is the threshold argument value.
			Threshold int64
		}
		// OperatorIsAvailableForCounter holds details about calls to the OperatorIsAvailableForCounter method.
		OperatorIsAvailableForCounter []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Counter is the counter argument value.
			Counter int64
			// Validator is the validator argument value.
			Validator sdk.ValAddress
		}
		// PenalizeCriminal holds details about calls to the PenalizeCriminal method.
		PenalizeCriminal []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Criminal is the criminal argument value.
			Criminal sdk.ValAddress
			// CrimeType is the crimeType argument value.
			CrimeType tofnd.MessageOut_CriminalList_Criminal_CrimeType
		}
		// RotateKey holds details about calls to the RotateKey method.
		RotateKey []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Chain is the chain argument value.
			Chain nexus.Chain
			// KeyRole is the keyRole argument value.
			KeyRole exported.KeyRole
		}
		// ScheduleKeygen holds details about calls to the ScheduleKeygen method.
		ScheduleKeygen []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Req is the req argument value.
			Req tsstypes.StartKeygenRequest
		}
		// ScheduleSign holds details about calls to the ScheduleSign method.
		ScheduleSign []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Info is the info argument value.
			Info exported.SignInfo
		}
		// SelectSignParticipants holds details about calls to the SelectSignParticipants method.
		SelectSignParticipants []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Snapshotter is the snapshotter argument value.
			Snapshotter snapshot.Snapshotter
			// SigID is the sigID argument value.
			SigID string
			// Validators is the validators argument value.
			Validators []snapshot.Validator
		}
		// SetAvailableOperator holds details about calls to the SetAvailableOperator method.
		SetAvailableOperator []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// ID is the ID argument value.
			ID string
			// AckType is the ackType argument value.
			AckType exported.AckType
			// Validator is the validator argument value.
			Validator sdk.ValAddress
		}
		// SetKey holds details about calls to the SetKey method.
		SetKey []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// KeyID is the keyID argument value.
			KeyID string
			// Key is the key argument value.
			Key ecdsa.PublicKey
		}
		// SetKeyIDForSig holds details about calls to the SetKeyIDForSig method.
		SetKeyIDForSig []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// SigID is the sigID argument value.
			SigID string
			// KeyID is the keyID argument value.
			KeyID string
		}
		// SetParams holds details about calls to the SetParams method.
		SetParams []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// P is the p argument value.
			P tsstypes.Params
		}
		// SetRecoveryInfos holds details about calls to the SetRecoveryInfos method.
		SetRecoveryInfos []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Sender is the sender argument value.
			Sender sdk.ValAddress
			// KeyID is the keyID argument value.
			KeyID string
			// Infos is the infos argument value.
			Infos [][]byte
		}
		// SetSig holds details about calls to the SetSig method.
		SetSig []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// SigID is the sigID argument value.
			SigID string
			// Signature is the signature argument value.
			Signature []byte
		}
		// SetSigStatus holds details about calls to the SetSigStatus method.
		SetSigStatus []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// SigID is the sigID argument value.
			SigID string
			// Status is the status argument value.
			Status exported.SigStatus
		}
		// StartKeygen holds details about calls to the StartKeygen method.
		StartKeygen []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Voter is the voter argument value.
			Voter tsstypes.Voter
			// KeyID is the keyID argument value.
			KeyID string
			// KeyRole is the keyRole argument value.
			KeyRole exported.KeyRole
			// SnapshotMoqParam is the snapshotMoqParam argument value.
			SnapshotMoqParam snapshot.Snapshot
		}
	}
	lockAssertMatchesRequirements           sync.RWMutex
	lockAssignNextKey                       sync.RWMutex
	lockDeleteAllRecoveryInfos              sync.RWMutex
	lockDeleteAvailableOperators            sync.RWMutex
	lockDeleteKeyIDForSig                   sync.RWMutex
	lockDeleteKeygenStart                   sync.RWMutex
	lockDeleteParticipantsInKeygen          sync.RWMutex
	lockDeleteScheduledKeygen               sync.RWMutex
	lockDeleteScheduledSign                 sync.RWMutex
	lockDeleteSnapshotCounterForKeyID       sync.RWMutex
	lockDoesValidatorParticipateInKeygen    sync.RWMutex
	lockDoesValidatorParticipateInSign      sync.RWMutex
	lockGetAllKeygenRequestsAtCurrentHeight sync.RWMutex
	lockGetAllRecoveryInfos                 sync.RWMutex
	lockGetAvailableOperators               sync.RWMutex
	lockGetCurrentKey                       sync.RWMutex
	lockGetCurrentKeyID                     sync.RWMutex
	lockGetKey                              sync.RWMutex
	lockGetKeyForSigID                      sync.RWMutex
	lockGetKeyRequirement                   sync.RWMutex
	lockGetNextKey                          sync.RWMutex
	lockGetNextKeyID                        sync.RWMutex
	lockGetParams                           sync.RWMutex
	lockGetSig                              sync.RWMutex
	lockGetSignParticipants                 sync.RWMutex
	lockGetSignParticipantsAsJSON           sync.RWMutex
	lockGetSnapshotCounterForKeyID          sync.RWMutex
	lockGetTotalShareCount                  sync.RWMutex
	lockGetTssSuspendedUntil                sync.RWMutex
	lockHasKeygenStarted                    sync.RWMutex
	lockHasRecoveryInfos                    sync.RWMutex
	lockIsOperatorAvailable                 sync.RWMutex
	lockLinkAvailableOperatorsToSnapshot    sync.RWMutex
	lockLogger                              sync.RWMutex
	lockMeetsThreshold                      sync.RWMutex
	lockOperatorIsAvailableForCounter       sync.RWMutex
	lockPenalizeCriminal                    sync.RWMutex
	lockRotateKey                           sync.RWMutex
	lockScheduleKeygen                      sync.RWMutex
	lockScheduleSign                        sync.RWMutex
	lockSelectSignParticipants              sync.RWMutex
	lockSetAvailableOperator                sync.RWMutex
	lockSetKey                              sync.RWMutex
	lockSetKeyIDForSig                      sync.RWMutex
	lockSetParams                           sync.RWMutex
	lockSetRecoveryInfos                    sync.RWMutex
	lockSetSig                              sync.RWMutex
	lockSetSigStatus                        sync.RWMutex
	lockStartKeygen                         sync.RWMutex
}

// AssertMatchesRequirements calls AssertMatchesRequirementsFunc.
func (mock *TSSKeeperMock) AssertMatchesRequirements(ctx sdk.Context, snapshotter snapshot.Snapshotter, chain nexus.Chain, keyID string, keyRole exported.KeyRole) error {
	if mock.AssertMatchesRequirementsFunc == nil {
		panic("TSSKeeperMock.AssertMatchesRequirementsFunc: method is nil but TSSKeeper.AssertMatchesRequirements was just called")
	}
	callInfo := struct {
		Ctx         sdk.Context
		Snapshotter snapshot.Snapshotter
		Chain       nexus.Chain
		KeyID       string
		KeyRole     exported.KeyRole
	}{
		Ctx:         ctx,
		Snapshotter: snapshotter,
		Chain:       chain,
		KeyID:       keyID,
		KeyRole:     keyRole,
	}
	mock.lockAssertMatchesRequirements.Lock()
	mock.calls.AssertMatchesRequirements = append(mock.calls.AssertMatchesRequirements, callInfo)
	mock.lockAssertMatchesRequirements.Unlock()
	return mock.AssertMatchesRequirementsFunc(ctx, snapshotter, chain, keyID, keyRole)
}

// AssertMatchesRequirementsCalls gets all the calls that were made to AssertMatchesRequirements.
// Check the length with:
//     len(mockedTSSKeeper.AssertMatchesRequirementsCalls())
func (mock *TSSKeeperMock) AssertMatchesRequirementsCalls() []struct {
	Ctx         sdk.Context
	Snapshotter snapshot.Snapshotter
	Chain       nexus.Chain
	KeyID       string
	KeyRole     exported.KeyRole
} {
	var calls []struct {
		Ctx         sdk.Context
		Snapshotter snapshot.Snapshotter
		Chain       nexus.Chain
		KeyID       string
		KeyRole     exported.KeyRole
	}
	mock.lockAssertMatchesRequirements.RLock()
	calls = mock.calls.AssertMatchesRequirements
	mock.lockAssertMatchesRequirements.RUnlock()
	return calls
}

// AssignNextKey calls AssignNextKeyFunc.
func (mock *TSSKeeperMock) AssignNextKey(ctx sdk.Context, chain nexus.Chain, keyRole exported.KeyRole, keyID string) error {
	if mock.AssignNextKeyFunc == nil {
		panic("TSSKeeperMock.AssignNextKeyFunc: method is nil but TSSKeeper.AssignNextKey was just called")
	}
	callInfo := struct {
		Ctx     sdk.Context
		Chain   nexus.Chain
		KeyRole exported.KeyRole
		KeyID   string
	}{
		Ctx:     ctx,
		Chain:   chain,
		KeyRole: keyRole,
		KeyID:   keyID,
	}
	mock.lockAssignNextKey.Lock()
	mock.calls.AssignNextKey = append(mock.calls.AssignNextKey, callInfo)
	mock.lockAssignNextKey.Unlock()
	return mock.AssignNextKeyFunc(ctx, chain, keyRole, keyID)
}

// AssignNextKeyCalls gets all the calls that were made to AssignNextKey.
// Check the length with:
//     len(mockedTSSKeeper.AssignNextKeyCalls())
func (mock *TSSKeeperMock) AssignNextKeyCalls() []struct {
	Ctx     sdk.Context
	Chain   nexus.Chain
	KeyRole exported.KeyRole
	KeyID   string
} {
	var calls []struct {
		Ctx     sdk.Context
		Chain   nexus.Chain
		KeyRole exported.KeyRole
		KeyID   string
	}
	mock.lockAssignNextKey.RLock()
	calls = mock.calls.AssignNextKey
	mock.lockAssignNextKey.RUnlock()
	return calls
}

// DeleteAllRecoveryInfos calls DeleteAllRecoveryInfosFunc.
func (mock *TSSKeeperMock) DeleteAllRecoveryInfos(ctx sdk.Context, keyID string) {
	if mock.DeleteAllRecoveryInfosFunc == nil {
		panic("TSSKeeperMock.DeleteAllRecoveryInfosFunc: method is nil but TSSKeeper.DeleteAllRecoveryInfos was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		KeyID string
	}{
		Ctx:   ctx,
		KeyID: keyID,
	}
	mock.lockDeleteAllRecoveryInfos.Lock()
	mock.calls.DeleteAllRecoveryInfos = append(mock.calls.DeleteAllRecoveryInfos, callInfo)
	mock.lockDeleteAllRecoveryInfos.Unlock()
	mock.DeleteAllRecoveryInfosFunc(ctx, keyID)
}

// DeleteAllRecoveryInfosCalls gets all the calls that were made to DeleteAllRecoveryInfos.
// Check the length with:
//     len(mockedTSSKeeper.DeleteAllRecoveryInfosCalls())
func (mock *TSSKeeperMock) DeleteAllRecoveryInfosCalls() []struct {
	Ctx   sdk.Context
	KeyID string
} {
	var calls []struct {
		Ctx   sdk.Context
		KeyID string
	}
	mock.lockDeleteAllRecoveryInfos.RLock()
	calls = mock.calls.DeleteAllRecoveryInfos
	mock.lockDeleteAllRecoveryInfos.RUnlock()
	return calls
}

// DeleteAvailableOperators calls DeleteAvailableOperatorsFunc.
func (mock *TSSKeeperMock) DeleteAvailableOperators(ctx sdk.Context, ID string, ackType exported.AckType) {
	if mock.DeleteAvailableOperatorsFunc == nil {
		panic("TSSKeeperMock.DeleteAvailableOperatorsFunc: method is nil but TSSKeeper.DeleteAvailableOperators was just called")
	}
	callInfo := struct {
		Ctx     sdk.Context
		ID      string
		AckType exported.AckType
	}{
		Ctx:     ctx,
		ID:      ID,
		AckType: ackType,
	}
	mock.lockDeleteAvailableOperators.Lock()
	mock.calls.DeleteAvailableOperators = append(mock.calls.DeleteAvailableOperators, callInfo)
	mock.lockDeleteAvailableOperators.Unlock()
	mock.DeleteAvailableOperatorsFunc(ctx, ID, ackType)
}

// DeleteAvailableOperatorsCalls gets all the calls that were made to DeleteAvailableOperators.
// Check the length with:
//     len(mockedTSSKeeper.DeleteAvailableOperatorsCalls())
func (mock *TSSKeeperMock) DeleteAvailableOperatorsCalls() []struct {
	Ctx     sdk.Context
	ID      string
	AckType exported.AckType
} {
	var calls []struct {
		Ctx     sdk.Context
		ID      string
		AckType exported.AckType
	}
	mock.lockDeleteAvailableOperators.RLock()
	calls = mock.calls.DeleteAvailableOperators
	mock.lockDeleteAvailableOperators.RUnlock()
	return calls
}

// DeleteKeyIDForSig calls DeleteKeyIDForSigFunc.
func (mock *TSSKeeperMock) DeleteKeyIDForSig(ctx sdk.Context, sigID string) {
	if mock.DeleteKeyIDForSigFunc == nil {
		panic("TSSKeeperMock.DeleteKeyIDForSigFunc: method is nil but TSSKeeper.DeleteKeyIDForSig was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		SigID string
	}{
		Ctx:   ctx,
		SigID: sigID,
	}
	mock.lockDeleteKeyIDForSig.Lock()
	mock.calls.DeleteKeyIDForSig = append(mock.calls.DeleteKeyIDForSig, callInfo)
	mock.lockDeleteKeyIDForSig.Unlock()
	mock.DeleteKeyIDForSigFunc(ctx, sigID)
}

// DeleteKeyIDForSigCalls gets all the calls that were made to DeleteKeyIDForSig.
// Check the length with:
//     len(mockedTSSKeeper.DeleteKeyIDForSigCalls())
func (mock *TSSKeeperMock) DeleteKeyIDForSigCalls() []struct {
	Ctx   sdk.Context
	SigID string
} {
	var calls []struct {
		Ctx   sdk.Context
		SigID string
	}
	mock.lockDeleteKeyIDForSig.RLock()
	calls = mock.calls.DeleteKeyIDForSig
	mock.lockDeleteKeyIDForSig.RUnlock()
	return calls
}

// DeleteKeygenStart calls DeleteKeygenStartFunc.
func (mock *TSSKeeperMock) DeleteKeygenStart(ctx sdk.Context, keyID string) {
	if mock.DeleteKeygenStartFunc == nil {
		panic("TSSKeeperMock.DeleteKeygenStartFunc: method is nil but TSSKeeper.DeleteKeygenStart was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		KeyID string
	}{
		Ctx:   ctx,
		KeyID: keyID,
	}
	mock.lockDeleteKeygenStart.Lock()
	mock.calls.DeleteKeygenStart = append(mock.calls.DeleteKeygenStart, callInfo)
	mock.lockDeleteKeygenStart.Unlock()
	mock.DeleteKeygenStartFunc(ctx, keyID)
}

// DeleteKeygenStartCalls gets all the calls that were made to DeleteKeygenStart.
// Check the length with:
//     len(mockedTSSKeeper.DeleteKeygenStartCalls())
func (mock *TSSKeeperMock) DeleteKeygenStartCalls() []struct {
	Ctx   sdk.Context
	KeyID string
} {
	var calls []struct {
		Ctx   sdk.Context
		KeyID string
	}
	mock.lockDeleteKeygenStart.RLock()
	calls = mock.calls.DeleteKeygenStart
	mock.lockDeleteKeygenStart.RUnlock()
	return calls
}

// DeleteParticipantsInKeygen calls DeleteParticipantsInKeygenFunc.
func (mock *TSSKeeperMock) DeleteParticipantsInKeygen(ctx sdk.Context, keyID string) {
	if mock.DeleteParticipantsInKeygenFunc == nil {
		panic("TSSKeeperMock.DeleteParticipantsInKeygenFunc: method is nil but TSSKeeper.DeleteParticipantsInKeygen was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		KeyID string
	}{
		Ctx:   ctx,
		KeyID: keyID,
	}
	mock.lockDeleteParticipantsInKeygen.Lock()
	mock.calls.DeleteParticipantsInKeygen = append(mock.calls.DeleteParticipantsInKeygen, callInfo)
	mock.lockDeleteParticipantsInKeygen.Unlock()
	mock.DeleteParticipantsInKeygenFunc(ctx, keyID)
}

// DeleteParticipantsInKeygenCalls gets all the calls that were made to DeleteParticipantsInKeygen.
// Check the length with:
//     len(mockedTSSKeeper.DeleteParticipantsInKeygenCalls())
func (mock *TSSKeeperMock) DeleteParticipantsInKeygenCalls() []struct {
	Ctx   sdk.Context
	KeyID string
} {
	var calls []struct {
		Ctx   sdk.Context
		KeyID string
	}
	mock.lockDeleteParticipantsInKeygen.RLock()
	calls = mock.calls.DeleteParticipantsInKeygen
	mock.lockDeleteParticipantsInKeygen.RUnlock()
	return calls
}

// DeleteScheduledKeygen calls DeleteScheduledKeygenFunc.
func (mock *TSSKeeperMock) DeleteScheduledKeygen(ctx sdk.Context, ID string) {
	if mock.DeleteScheduledKeygenFunc == nil {
		panic("TSSKeeperMock.DeleteScheduledKeygenFunc: method is nil but TSSKeeper.DeleteScheduledKeygen was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  ID,
	}
	mock.lockDeleteScheduledKeygen.Lock()
	mock.calls.DeleteScheduledKeygen = append(mock.calls.DeleteScheduledKeygen, callInfo)
	mock.lockDeleteScheduledKeygen.Unlock()
	mock.DeleteScheduledKeygenFunc(ctx, ID)
}

// DeleteScheduledKeygenCalls gets all the calls that were made to DeleteScheduledKeygen.
// Check the length with:
//     len(mockedTSSKeeper.DeleteScheduledKeygenCalls())
func (mock *TSSKeeperMock) DeleteScheduledKeygenCalls() []struct {
	Ctx sdk.Context
	ID  string
} {
	var calls []struct {
		Ctx sdk.Context
		ID  string
	}
	mock.lockDeleteScheduledKeygen.RLock()
	calls = mock.calls.DeleteScheduledKeygen
	mock.lockDeleteScheduledKeygen.RUnlock()
	return calls
}

// DeleteScheduledSign calls DeleteScheduledSignFunc.
func (mock *TSSKeeperMock) DeleteScheduledSign(ctx sdk.Context, ID string) {
	if mock.DeleteScheduledSignFunc == nil {
		panic("TSSKeeperMock.DeleteScheduledSignFunc: method is nil but TSSKeeper.DeleteScheduledSign was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  ID,
	}
	mock.lockDeleteScheduledSign.Lock()
	mock.calls.DeleteScheduledSign = append(mock.calls.DeleteScheduledSign, callInfo)
	mock.lockDeleteScheduledSign.Unlock()
	mock.DeleteScheduledSignFunc(ctx, ID)
}

// DeleteScheduledSignCalls gets all the calls that were made to DeleteScheduledSign.
// Check the length with:
//     len(mockedTSSKeeper.DeleteScheduledSignCalls())
func (mock *TSSKeeperMock) DeleteScheduledSignCalls() []struct {
	Ctx sdk.Context
	ID  string
} {
	var calls []struct {
		Ctx sdk.Context
		ID  string
	}
	mock.lockDeleteScheduledSign.RLock()
	calls = mock.calls.DeleteScheduledSign
	mock.lockDeleteScheduledSign.RUnlock()
	return calls
}

// DeleteSnapshotCounterForKeyID calls DeleteSnapshotCounterForKeyIDFunc.
func (mock *TSSKeeperMock) DeleteSnapshotCounterForKeyID(ctx sdk.Context, keyID string) {
	if mock.DeleteSnapshotCounterForKeyIDFunc == nil {
		panic("TSSKeeperMock.DeleteSnapshotCounterForKeyIDFunc: method is nil but TSSKeeper.DeleteSnapshotCounterForKeyID was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		KeyID string
	}{
		Ctx:   ctx,
		KeyID: keyID,
	}
	mock.lockDeleteSnapshotCounterForKeyID.Lock()
	mock.calls.DeleteSnapshotCounterForKeyID = append(mock.calls.DeleteSnapshotCounterForKeyID, callInfo)
	mock.lockDeleteSnapshotCounterForKeyID.Unlock()
	mock.DeleteSnapshotCounterForKeyIDFunc(ctx, keyID)
}

// DeleteSnapshotCounterForKeyIDCalls gets all the calls that were made to DeleteSnapshotCounterForKeyID.
// Check the length with:
//     len(mockedTSSKeeper.DeleteSnapshotCounterForKeyIDCalls())
func (mock *TSSKeeperMock) DeleteSnapshotCounterForKeyIDCalls() []struct {
	Ctx   sdk.Context
	KeyID string
} {
	var calls []struct {
		Ctx   sdk.Context
		KeyID string
	}
	mock.lockDeleteSnapshotCounterForKeyID.RLock()
	calls = mock.calls.DeleteSnapshotCounterForKeyID
	mock.lockDeleteSnapshotCounterForKeyID.RUnlock()
	return calls
}

// DoesValidatorParticipateInKeygen calls DoesValidatorParticipateInKeygenFunc.
func (mock *TSSKeeperMock) DoesValidatorParticipateInKeygen(ctx sdk.Context, keyID string, validator sdk.ValAddress) bool {
	if mock.DoesValidatorParticipateInKeygenFunc == nil {
		panic("TSSKeeperMock.DoesValidatorParticipateInKeygenFunc: method is nil but TSSKeeper.DoesValidatorParticipateInKeygen was just called")
	}
	callInfo := struct {
		Ctx       sdk.Context
		KeyID     string
		Validator sdk.ValAddress
	}{
		Ctx:       ctx,
		KeyID:     keyID,
		Validator: validator,
	}
	mock.lockDoesValidatorParticipateInKeygen.Lock()
	mock.calls.DoesValidatorParticipateInKeygen = append(mock.calls.DoesValidatorParticipateInKeygen, callInfo)
	mock.lockDoesValidatorParticipateInKeygen.Unlock()
	return mock.DoesValidatorParticipateInKeygenFunc(ctx, keyID, validator)
}

// DoesValidatorParticipateInKeygenCalls gets all the calls that were made to DoesValidatorParticipateInKeygen.
// Check the length with:
//     len(mockedTSSKeeper.DoesValidatorParticipateInKeygenCalls())
func (mock *TSSKeeperMock) DoesValidatorParticipateInKeygenCalls() []struct {
	Ctx       sdk.Context
	KeyID     string
	Validator sdk.ValAddress
} {
	var calls []struct {
		Ctx       sdk.Context
		KeyID     string
		Validator sdk.ValAddress
	}
	mock.lockDoesValidatorParticipateInKeygen.RLock()
	calls = mock.calls.DoesValidatorParticipateInKeygen
	mock.lockDoesValidatorParticipateInKeygen.RUnlock()
	return calls
}

// DoesValidatorParticipateInSign calls DoesValidatorParticipateInSignFunc.
func (mock *TSSKeeperMock) DoesValidatorParticipateInSign(ctx sdk.Context, sigID string, validator sdk.ValAddress) bool {
	if mock.DoesValidatorParticipateInSignFunc == nil {
		panic("TSSKeeperMock.DoesValidatorParticipateInSignFunc: method is nil but TSSKeeper.DoesValidatorParticipateInSign was just called")
	}
	callInfo := struct {
		Ctx       sdk.Context
		SigID     string
		Validator sdk.ValAddress
	}{
		Ctx:       ctx,
		SigID:     sigID,
		Validator: validator,
	}
	mock.lockDoesValidatorParticipateInSign.Lock()
	mock.calls.DoesValidatorParticipateInSign = append(mock.calls.DoesValidatorParticipateInSign, callInfo)
	mock.lockDoesValidatorParticipateInSign.Unlock()
	return mock.DoesValidatorParticipateInSignFunc(ctx, sigID, validator)
}

// DoesValidatorParticipateInSignCalls gets all the calls that were made to DoesValidatorParticipateInSign.
// Check the length with:
//     len(mockedTSSKeeper.DoesValidatorParticipateInSignCalls())
func (mock *TSSKeeperMock) DoesValidatorParticipateInSignCalls() []struct {
	Ctx       sdk.Context
	SigID     string
	Validator sdk.ValAddress
} {
	var calls []struct {
		Ctx       sdk.Context
		SigID     string
		Validator sdk.ValAddress
	}
	mock.lockDoesValidatorParticipateInSign.RLock()
	calls = mock.calls.DoesValidatorParticipateInSign
	mock.lockDoesValidatorParticipateInSign.RUnlock()
	return calls
}

// GetAllKeygenRequestsAtCurrentHeight calls GetAllKeygenRequestsAtCurrentHeightFunc.
func (mock *TSSKeeperMock) GetAllKeygenRequestsAtCurrentHeight(ctx sdk.Context) []tsstypes.StartKeygenRequest {
	if mock.GetAllKeygenRequestsAtCurrentHeightFunc == nil {
		panic("TSSKeeperMock.GetAllKeygenRequestsAtCurrentHeightFunc: method is nil but TSSKeeper.GetAllKeygenRequestsAtCurrentHeight was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAllKeygenRequestsAtCurrentHeight.Lock()
	mock.calls.GetAllKeygenRequestsAtCurrentHeight = append(mock.calls.GetAllKeygenRequestsAtCurrentHeight, callInfo)
	mock.lockGetAllKeygenRequestsAtCurrentHeight.Unlock()
	return mock.GetAllKeygenRequestsAtCurrentHeightFunc(ctx)
}

// GetAllKeygenRequestsAtCurrentHeightCalls gets all the calls that were made to GetAllKeygenRequestsAtCurrentHeight.
// Check the length with:
//     len(mockedTSSKeeper.GetAllKeygenRequestsAtCurrentHeightCalls())
func (mock *TSSKeeperMock) GetAllKeygenRequestsAtCurrentHeightCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetAllKeygenRequestsAtCurrentHeight.RLock()
	calls = mock.calls.GetAllKeygenRequestsAtCurrentHeight
	mock.lockGetAllKeygenRequestsAtCurrentHeight.RUnlock()
	return calls
}

// GetAllRecoveryInfos calls GetAllRecoveryInfosFunc.
func (mock *TSSKeeperMock) GetAllRecoveryInfos(ctx sdk.Context, keyID string) [][]byte {
	if mock.GetAllRecoveryInfosFunc == nil {
		panic("TSSKeeperMock.GetAllRecoveryInfosFunc: method is nil but TSSKeeper.GetAllRecoveryInfos was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		KeyID string
	}{
		Ctx:   ctx,
		KeyID: keyID,
	}
	mock.lockGetAllRecoveryInfos.Lock()
	mock.calls.GetAllRecoveryInfos = append(mock.calls.GetAllRecoveryInfos, callInfo)
	mock.lockGetAllRecoveryInfos.Unlock()
	return mock.GetAllRecoveryInfosFunc(ctx, keyID)
}

// GetAllRecoveryInfosCalls gets all the calls that were made to GetAllRecoveryInfos.
// Check the length with:
//     len(mockedTSSKeeper.GetAllRecoveryInfosCalls())
func (mock *TSSKeeperMock) GetAllRecoveryInfosCalls() []struct {
	Ctx   sdk.Context
	KeyID string
} {
	var calls []struct {
		Ctx   sdk.Context
		KeyID string
	}
	mock.lockGetAllRecoveryInfos.RLock()
	calls = mock.calls.GetAllRecoveryInfos
	mock.lockGetAllRecoveryInfos.RUnlock()
	return calls
}

// GetAvailableOperators calls GetAvailableOperatorsFunc.
func (mock *TSSKeeperMock) GetAvailableOperators(ctx sdk.Context, ID string, ackType exported.AckType, heightLimit int64) []sdk.ValAddress {
	if mock.GetAvailableOperatorsFunc == nil {
		panic("TSSKeeperMock.GetAvailableOperatorsFunc: method is nil but TSSKeeper.GetAvailableOperators was just called")
	}
	callInfo := struct {
		Ctx         sdk.Context
		ID          string
		AckType     exported.AckType
		HeightLimit int64
	}{
		Ctx:         ctx,
		ID:          ID,
		AckType:     ackType,
		HeightLimit: heightLimit,
	}
	mock.lockGetAvailableOperators.Lock()
	mock.calls.GetAvailableOperators = append(mock.calls.GetAvailableOperators, callInfo)
	mock.lockGetAvailableOperators.Unlock()
	return mock.GetAvailableOperatorsFunc(ctx, ID, ackType, heightLimit)
}

// GetAvailableOperatorsCalls gets all the calls that were made to GetAvailableOperators.
// Check the length with:
//     len(mockedTSSKeeper.GetAvailableOperatorsCalls())
func (mock *TSSKeeperMock) GetAvailableOperatorsCalls() []struct {
	Ctx         sdk.Context
	ID          string
	AckType     exported.AckType
	HeightLimit int64
} {
	var calls []struct {
		Ctx         sdk.Context
		ID          string
		AckType     exported.AckType
		HeightLimit int64
	}
	mock.lockGetAvailableOperators.RLock()
	calls = mock.calls.GetAvailableOperators
	mock.lockGetAvailableOperators.RUnlock()
	return calls
}

// GetCurrentKey calls GetCurrentKeyFunc.
func (mock *TSSKeeperMock) GetCurrentKey(ctx sdk.Context, chain nexus.Chain, keyRole exported.KeyRole) (exported.Key, bool) {
	if mock.GetCurrentKeyFunc == nil {
		panic("TSSKeeperMock.GetCurrentKeyFunc: method is nil but TSSKeeper.GetCurrentKey was just called")
	}
	callInfo := struct {
		Ctx     sdk.Context
		Chain   nexus.Chain
		KeyRole exported.KeyRole
	}{
		Ctx:     ctx,
		Chain:   chain,
		KeyRole: keyRole,
	}
	mock.lockGetCurrentKey.Lock()
	mock.calls.GetCurrentKey = append(mock.calls.GetCurrentKey, callInfo)
	mock.lockGetCurrentKey.Unlock()
	return mock.GetCurrentKeyFunc(ctx, chain, keyRole)
}

// GetCurrentKeyCalls gets all the calls that were made to GetCurrentKey.
// Check the length with:
//     len(mockedTSSKeeper.GetCurrentKeyCalls())
func (mock *TSSKeeperMock) GetCurrentKeyCalls() []struct {
	Ctx     sdk.Context
	Chain   nexus.Chain
	KeyRole exported.KeyRole
} {
	var calls []struct {
		Ctx     sdk.Context
		Chain   nexus.Chain
		KeyRole exported.KeyRole
	}
	mock.lockGetCurrentKey.RLock()
	calls = mock.calls.GetCurrentKey
	mock.lockGetCurrentKey.RUnlock()
	return calls
}

// GetCurrentKeyID calls GetCurrentKeyIDFunc.
func (mock *TSSKeeperMock) GetCurrentKeyID(ctx sdk.Context, chain nexus.Chain, keyRole exported.KeyRole) (string, bool) {
	if mock.GetCurrentKeyIDFunc == nil {
		panic("TSSKeeperMock.GetCurrentKeyIDFunc: method is nil but TSSKeeper.GetCurrentKeyID was just called")
	}
	callInfo := struct {
		Ctx     sdk.Context
		Chain   nexus.Chain
		KeyRole exported.KeyRole
	}{
		Ctx:     ctx,
		Chain:   chain,
		KeyRole: keyRole,
	}
	mock.lockGetCurrentKeyID.Lock()
	mock.calls.GetCurrentKeyID = append(mock.calls.GetCurrentKeyID, callInfo)
	mock.lockGetCurrentKeyID.Unlock()
	return mock.GetCurrentKeyIDFunc(ctx, chain, keyRole)
}

// GetCurrentKeyIDCalls gets all the calls that were made to GetCurrentKeyID.
// Check the length with:
//     len(mockedTSSKeeper.GetCurrentKeyIDCalls())
func (mock *TSSKeeperMock) GetCurrentKeyIDCalls() []struct {
	Ctx     sdk.Context
	Chain   nexus.Chain
	KeyRole exported.KeyRole
} {
	var calls []struct {
		Ctx     sdk.Context
		Chain   nexus.Chain
		KeyRole exported.KeyRole
	}
	mock.lockGetCurrentKeyID.RLock()
	calls = mock.calls.GetCurrentKeyID
	mock.lockGetCurrentKeyID.RUnlock()
	return calls
}

// GetKey calls GetKeyFunc.
func (mock *TSSKeeperMock) GetKey(ctx sdk.Context, keyID string) (exported.Key, bool) {
	if mock.GetKeyFunc == nil {
		panic("TSSKeeperMock.GetKeyFunc: method is nil but TSSKeeper.GetKey was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		KeyID string
	}{
		Ctx:   ctx,
		KeyID: keyID,
	}
	mock.lockGetKey.Lock()
	mock.calls.GetKey = append(mock.calls.GetKey, callInfo)
	mock.lockGetKey.Unlock()
	return mock.GetKeyFunc(ctx, keyID)
}

// GetKeyCalls gets all the calls that were made to GetKey.
// Check the length with:
//     len(mockedTSSKeeper.GetKeyCalls())
func (mock *TSSKeeperMock) GetKeyCalls() []struct {
	Ctx   sdk.Context
	KeyID string
} {
	var calls []struct {
		Ctx   sdk.Context
		KeyID string
	}
	mock.lockGetKey.RLock()
	calls = mock.calls.GetKey
	mock.lockGetKey.RUnlock()
	return calls
}

// GetKeyForSigID calls GetKeyForSigIDFunc.
func (mock *TSSKeeperMock) GetKeyForSigID(ctx sdk.Context, sigID string) (exported.Key, bool) {
	if mock.GetKeyForSigIDFunc == nil {
		panic("TSSKeeperMock.GetKeyForSigIDFunc: method is nil but TSSKeeper.GetKeyForSigID was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		SigID string
	}{
		Ctx:   ctx,
		SigID: sigID,
	}
	mock.lockGetKeyForSigID.Lock()
	mock.calls.GetKeyForSigID = append(mock.calls.GetKeyForSigID, callInfo)
	mock.lockGetKeyForSigID.Unlock()
	return mock.GetKeyForSigIDFunc(ctx, sigID)
}

// GetKeyForSigIDCalls gets all the calls that were made to GetKeyForSigID.
// Check the length with:
//     len(mockedTSSKeeper.GetKeyForSigIDCalls())
func (mock *TSSKeeperMock) GetKeyForSigIDCalls() []struct {
	Ctx   sdk.Context
	SigID string
} {
	var calls []struct {
		Ctx   sdk.Context
		SigID string
	}
	mock.lockGetKeyForSigID.RLock()
	calls = mock.calls.GetKeyForSigID
	mock.lockGetKeyForSigID.RUnlock()
	return calls
}

// GetKeyRequirement calls GetKeyRequirementFunc.
func (mock *TSSKeeperMock) GetKeyRequirement(ctx sdk.Context, keyRole exported.KeyRole) (exported.KeyRequirement, bool) {
	if mock.GetKeyRequirementFunc == nil {
		panic("TSSKeeperMock.GetKeyRequirementFunc: method is nil but TSSKeeper.GetKeyRequirement was just called")
	}
	callInfo := struct {
		Ctx     sdk.Context
		KeyRole exported.KeyRole
	}{
		Ctx:     ctx,
		KeyRole: keyRole,
	}
	mock.lockGetKeyRequirement.Lock()
	mock.calls.GetKeyRequirement = append(mock.calls.GetKeyRequirement, callInfo)
	mock.lockGetKeyRequirement.Unlock()
	return mock.GetKeyRequirementFunc(ctx, keyRole)
}

// GetKeyRequirementCalls gets all the calls that were made to GetKeyRequirement.
// Check the length with:
//     len(mockedTSSKeeper.GetKeyRequirementCalls())
func (mock *TSSKeeperMock) GetKeyRequirementCalls() []struct {
	Ctx     sdk.Context
	KeyRole exported.KeyRole
} {
	var calls []struct {
		Ctx     sdk.Context
		KeyRole exported.KeyRole
	}
	mock.lockGetKeyRequirement.RLock()
	calls = mock.calls.GetKeyRequirement
	mock.lockGetKeyRequirement.RUnlock()
	return calls
}

// GetNextKey calls GetNextKeyFunc.
func (mock *TSSKeeperMock) GetNextKey(ctx sdk.Context, chain nexus.Chain, keyRole exported.KeyRole) (exported.Key, bool) {
	if mock.GetNextKeyFunc == nil {
		panic("TSSKeeperMock.GetNextKeyFunc: method is nil but TSSKeeper.GetNextKey was just called")
	}
	callInfo := struct {
		Ctx     sdk.Context
		Chain   nexus.Chain
		KeyRole exported.KeyRole
	}{
		Ctx:     ctx,
		Chain:   chain,
		KeyRole: keyRole,
	}
	mock.lockGetNextKey.Lock()
	mock.calls.GetNextKey = append(mock.calls.GetNextKey, callInfo)
	mock.lockGetNextKey.Unlock()
	return mock.GetNextKeyFunc(ctx, chain, keyRole)
}

// GetNextKeyCalls gets all the calls that were made to GetNextKey.
// Check the length with:
//     len(mockedTSSKeeper.GetNextKeyCalls())
func (mock *TSSKeeperMock) GetNextKeyCalls() []struct {
	Ctx     sdk.Context
	Chain   nexus.Chain
	KeyRole exported.KeyRole
} {
	var calls []struct {
		Ctx     sdk.Context
		Chain   nexus.Chain
		KeyRole exported.KeyRole
	}
	mock.lockGetNextKey.RLock()
	calls = mock.calls.GetNextKey
	mock.lockGetNextKey.RUnlock()
	return calls
}

// GetNextKeyID calls GetNextKeyIDFunc.
func (mock *TSSKeeperMock) GetNextKeyID(ctx sdk.Context, chain nexus.Chain, keyRole exported.KeyRole) (string, bool) {
	if mock.GetNextKeyIDFunc == nil {
		panic("TSSKeeperMock.GetNextKeyIDFunc: method is nil but TSSKeeper.GetNextKeyID was just called")
	}
	callInfo := struct {
		Ctx     sdk.Context
		Chain   nexus.Chain
		KeyRole exported.KeyRole
	}{
		Ctx:     ctx,
		Chain:   chain,
		KeyRole: keyRole,
	}
	mock.lockGetNextKeyID.Lock()
	mock.calls.GetNextKeyID = append(mock.calls.GetNextKeyID, callInfo)
	mock.lockGetNextKeyID.Unlock()
	return mock.GetNextKeyIDFunc(ctx, chain, keyRole)
}

// GetNextKeyIDCalls gets all the calls that were made to GetNextKeyID.
// Check the length with:
//     len(mockedTSSKeeper.GetNextKeyIDCalls())
func (mock *TSSKeeperMock) GetNextKeyIDCalls() []struct {
	Ctx     sdk.Context
	Chain   nexus.Chain
	KeyRole exported.KeyRole
} {
	var calls []struct {
		Ctx     sdk.Context
		Chain   nexus.Chain
		KeyRole exported.KeyRole
	}
	mock.lockGetNextKeyID.RLock()
	calls = mock.calls.GetNextKeyID
	mock.lockGetNextKeyID.RUnlock()
	return calls
}

// GetParams calls GetParamsFunc.
func (mock *TSSKeeperMock) GetParams(ctx sdk.Context) tsstypes.Params {
	if mock.GetParamsFunc == nil {
		panic("TSSKeeperMock.GetParamsFunc: method is nil but TSSKeeper.GetParams was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetParams.Lock()
	mock.calls.GetParams = append(mock.calls.GetParams, callInfo)
	mock.lockGetParams.Unlock()
	return mock.GetParamsFunc(ctx)
}

// GetParamsCalls gets all the calls that were made to GetParams.
// Check the length with:
//     len(mockedTSSKeeper.GetParamsCalls())
func (mock *TSSKeeperMock) GetParamsCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetParams.RLock()
	calls = mock.calls.GetParams
	mock.lockGetParams.RUnlock()
	return calls
}

// GetSig calls GetSigFunc.
func (mock *TSSKeeperMock) GetSig(ctx sdk.Context, sigID string) (exported.Signature, exported.SigStatus) {
	if mock.GetSigFunc == nil {
		panic("TSSKeeperMock.GetSigFunc: method is nil but TSSKeeper.GetSig was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		SigID string
	}{
		Ctx:   ctx,
		SigID: sigID,
	}
	mock.lockGetSig.Lock()
	mock.calls.GetSig = append(mock.calls.GetSig, callInfo)
	mock.lockGetSig.Unlock()
	return mock.GetSigFunc(ctx, sigID)
}

// GetSigCalls gets all the calls that were made to GetSig.
// Check the length with:
//     len(mockedTSSKeeper.GetSigCalls())
func (mock *TSSKeeperMock) GetSigCalls() []struct {
	Ctx   sdk.Context
	SigID string
} {
	var calls []struct {
		Ctx   sdk.Context
		SigID string
	}
	mock.lockGetSig.RLock()
	calls = mock.calls.GetSig
	mock.lockGetSig.RUnlock()
	return calls
}

// GetSignParticipants calls GetSignParticipantsFunc.
func (mock *TSSKeeperMock) GetSignParticipants(ctx sdk.Context, sigID string) []string {
	if mock.GetSignParticipantsFunc == nil {
		panic("TSSKeeperMock.GetSignParticipantsFunc: method is nil but TSSKeeper.GetSignParticipants was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		SigID string
	}{
		Ctx:   ctx,
		SigID: sigID,
	}
	mock.lockGetSignParticipants.Lock()
	mock.calls.GetSignParticipants = append(mock.calls.GetSignParticipants, callInfo)
	mock.lockGetSignParticipants.Unlock()
	return mock.GetSignParticipantsFunc(ctx, sigID)
}

// GetSignParticipantsCalls gets all the calls that were made to GetSignParticipants.
// Check the length with:
//     len(mockedTSSKeeper.GetSignParticipantsCalls())
func (mock *TSSKeeperMock) GetSignParticipantsCalls() []struct {
	Ctx   sdk.Context
	SigID string
} {
	var calls []struct {
		Ctx   sdk.Context
		SigID string
	}
	mock.lockGetSignParticipants.RLock()
	calls = mock.calls.GetSignParticipants
	mock.lockGetSignParticipants.RUnlock()
	return calls
}

// GetSignParticipantsAsJSON calls GetSignParticipantsAsJSONFunc.
func (mock *TSSKeeperMock) GetSignParticipantsAsJSON(ctx sdk.Context, sigID string) []byte {
	if mock.GetSignParticipantsAsJSONFunc == nil {
		panic("TSSKeeperMock.GetSignParticipantsAsJSONFunc: method is nil but TSSKeeper.GetSignParticipantsAsJSON was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		SigID string
	}{
		Ctx:   ctx,
		SigID: sigID,
	}
	mock.lockGetSignParticipantsAsJSON.Lock()
	mock.calls.GetSignParticipantsAsJSON = append(mock.calls.GetSignParticipantsAsJSON, callInfo)
	mock.lockGetSignParticipantsAsJSON.Unlock()
	return mock.GetSignParticipantsAsJSONFunc(ctx, sigID)
}

// GetSignParticipantsAsJSONCalls gets all the calls that were made to GetSignParticipantsAsJSON.
// Check the length with:
//     len(mockedTSSKeeper.GetSignParticipantsAsJSONCalls())
func (mock *TSSKeeperMock) GetSignParticipantsAsJSONCalls() []struct {
	Ctx   sdk.Context
	SigID string
} {
	var calls []struct {
		Ctx   sdk.Context
		SigID string
	}
	mock.lockGetSignParticipantsAsJSON.RLock()
	calls = mock.calls.GetSignParticipantsAsJSON
	mock.lockGetSignParticipantsAsJSON.RUnlock()
	return calls
}

// GetSnapshotCounterForKeyID calls GetSnapshotCounterForKeyIDFunc.
func (mock *TSSKeeperMock) GetSnapshotCounterForKeyID(ctx sdk.Context, keyID string) (int64, bool) {
	if mock.GetSnapshotCounterForKeyIDFunc == nil {
		panic("TSSKeeperMock.GetSnapshotCounterForKeyIDFunc: method is nil but TSSKeeper.GetSnapshotCounterForKeyID was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		KeyID string
	}{
		Ctx:   ctx,
		KeyID: keyID,
	}
	mock.lockGetSnapshotCounterForKeyID.Lock()
	mock.calls.GetSnapshotCounterForKeyID = append(mock.calls.GetSnapshotCounterForKeyID, callInfo)
	mock.lockGetSnapshotCounterForKeyID.Unlock()
	return mock.GetSnapshotCounterForKeyIDFunc(ctx, keyID)
}

// GetSnapshotCounterForKeyIDCalls gets all the calls that were made to GetSnapshotCounterForKeyID.
// Check the length with:
//     len(mockedTSSKeeper.GetSnapshotCounterForKeyIDCalls())
func (mock *TSSKeeperMock) GetSnapshotCounterForKeyIDCalls() []struct {
	Ctx   sdk.Context
	KeyID string
} {
	var calls []struct {
		Ctx   sdk.Context
		KeyID string
	}
	mock.lockGetSnapshotCounterForKeyID.RLock()
	calls = mock.calls.GetSnapshotCounterForKeyID
	mock.lockGetSnapshotCounterForKeyID.RUnlock()
	return calls
}

// GetTotalShareCount calls GetTotalShareCountFunc.
func (mock *TSSKeeperMock) GetTotalShareCount(ctx sdk.Context, sigID string) int64 {
	if mock.GetTotalShareCountFunc == nil {
		panic("TSSKeeperMock.GetTotalShareCountFunc: method is nil but TSSKeeper.GetTotalShareCount was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		SigID string
	}{
		Ctx:   ctx,
		SigID: sigID,
	}
	mock.lockGetTotalShareCount.Lock()
	mock.calls.GetTotalShareCount = append(mock.calls.GetTotalShareCount, callInfo)
	mock.lockGetTotalShareCount.Unlock()
	return mock.GetTotalShareCountFunc(ctx, sigID)
}

// GetTotalShareCountCalls gets all the calls that were made to GetTotalShareCount.
// Check the length with:
//     len(mockedTSSKeeper.GetTotalShareCountCalls())
func (mock *TSSKeeperMock) GetTotalShareCountCalls() []struct {
	Ctx   sdk.Context
	SigID string
} {
	var calls []struct {
		Ctx   sdk.Context
		SigID string
	}
	mock.lockGetTotalShareCount.RLock()
	calls = mock.calls.GetTotalShareCount
	mock.lockGetTotalShareCount.RUnlock()
	return calls
}

// GetTssSuspendedUntil calls GetTssSuspendedUntilFunc.
func (mock *TSSKeeperMock) GetTssSuspendedUntil(ctx sdk.Context, validator sdk.ValAddress) int64 {
	if mock.GetTssSuspendedUntilFunc == nil {
		panic("TSSKeeperMock.GetTssSuspendedUntilFunc: method is nil but TSSKeeper.GetTssSuspendedUntil was just called")
	}
	callInfo := struct {
		Ctx       sdk.Context
		Validator sdk.ValAddress
	}{
		Ctx:       ctx,
		Validator: validator,
	}
	mock.lockGetTssSuspendedUntil.Lock()
	mock.calls.GetTssSuspendedUntil = append(mock.calls.GetTssSuspendedUntil, callInfo)
	mock.lockGetTssSuspendedUntil.Unlock()
	return mock.GetTssSuspendedUntilFunc(ctx, validator)
}

// GetTssSuspendedUntilCalls gets all the calls that were made to GetTssSuspendedUntil.
// Check the length with:
//     len(mockedTSSKeeper.GetTssSuspendedUntilCalls())
func (mock *TSSKeeperMock) GetTssSuspendedUntilCalls() []struct {
	Ctx       sdk.Context
	Validator sdk.ValAddress
} {
	var calls []struct {
		Ctx       sdk.Context
		Validator sdk.ValAddress
	}
	mock.lockGetTssSuspendedUntil.RLock()
	calls = mock.calls.GetTssSuspendedUntil
	mock.lockGetTssSuspendedUntil.RUnlock()
	return calls
}

// HasKeygenStarted calls HasKeygenStartedFunc.
func (mock *TSSKeeperMock) HasKeygenStarted(ctx sdk.Context, keyID string) bool {
	if mock.HasKeygenStartedFunc == nil {
		panic("TSSKeeperMock.HasKeygenStartedFunc: method is nil but TSSKeeper.HasKeygenStarted was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		KeyID string
	}{
		Ctx:   ctx,
		KeyID: keyID,
	}
	mock.lockHasKeygenStarted.Lock()
	mock.calls.HasKeygenStarted = append(mock.calls.HasKeygenStarted, callInfo)
	mock.lockHasKeygenStarted.Unlock()
	return mock.HasKeygenStartedFunc(ctx, keyID)
}

// HasKeygenStartedCalls gets all the calls that were made to HasKeygenStarted.
// Check the length with:
//     len(mockedTSSKeeper.HasKeygenStartedCalls())
func (mock *TSSKeeperMock) HasKeygenStartedCalls() []struct {
	Ctx   sdk.Context
	KeyID string
} {
	var calls []struct {
		Ctx   sdk.Context
		KeyID string
	}
	mock.lockHasKeygenStarted.RLock()
	calls = mock.calls.HasKeygenStarted
	mock.lockHasKeygenStarted.RUnlock()
	return calls
}

// HasRecoveryInfos calls HasRecoveryInfosFunc.
func (mock *TSSKeeperMock) HasRecoveryInfos(ctx sdk.Context, sender sdk.ValAddress, keyID string) bool {
	if mock.HasRecoveryInfosFunc == nil {
		panic("TSSKeeperMock.HasRecoveryInfosFunc: method is nil but TSSKeeper.HasRecoveryInfos was just called")
	}
	callInfo := struct {
		Ctx    sdk.Context
		Sender sdk.ValAddress
		KeyID  string
	}{
		Ctx:    ctx,
		Sender: sender,
		KeyID:  keyID,
	}
	mock.lockHasRecoveryInfos.Lock()
	mock.calls.HasRecoveryInfos = append(mock.calls.HasRecoveryInfos, callInfo)
	mock.lockHasRecoveryInfos.Unlock()
	return mock.HasRecoveryInfosFunc(ctx, sender, keyID)
}

// HasRecoveryInfosCalls gets all the calls that were made to HasRecoveryInfos.
// Check the length with:
//     len(mockedTSSKeeper.HasRecoveryInfosCalls())
func (mock *TSSKeeperMock) HasRecoveryInfosCalls() []struct {
	Ctx    sdk.Context
	Sender sdk.ValAddress
	KeyID  string
} {
	var calls []struct {
		Ctx    sdk.Context
		Sender sdk.ValAddress
		KeyID  string
	}
	mock.lockHasRecoveryInfos.RLock()
	calls = mock.calls.HasRecoveryInfos
	mock.lockHasRecoveryInfos.RUnlock()
	return calls
}

// IsOperatorAvailable calls IsOperatorAvailableFunc.
func (mock *TSSKeeperMock) IsOperatorAvailable(ctx sdk.Context, ID string, ackType exported.AckType, validator sdk.ValAddress) bool {
	if mock.IsOperatorAvailableFunc == nil {
		panic("TSSKeeperMock.IsOperatorAvailableFunc: method is nil but TSSKeeper.IsOperatorAvailable was just called")
	}
	callInfo := struct {
		Ctx       sdk.Context
		ID        string
		AckType   exported.AckType
		Validator sdk.ValAddress
	}{
		Ctx:       ctx,
		ID:        ID,
		AckType:   ackType,
		Validator: validator,
	}
	mock.lockIsOperatorAvailable.Lock()
	mock.calls.IsOperatorAvailable = append(mock.calls.IsOperatorAvailable, callInfo)
	mock.lockIsOperatorAvailable.Unlock()
	return mock.IsOperatorAvailableFunc(ctx, ID, ackType, validator)
}

// IsOperatorAvailableCalls gets all the calls that were made to IsOperatorAvailable.
// Check the length with:
//     len(mockedTSSKeeper.IsOperatorAvailableCalls())
func (mock *TSSKeeperMock) IsOperatorAvailableCalls() []struct {
	Ctx       sdk.Context
	ID        string
	AckType   exported.AckType
	Validator sdk.ValAddress
} {
	var calls []struct {
		Ctx       sdk.Context
		ID        string
		AckType   exported.AckType
		Validator sdk.ValAddress
	}
	mock.lockIsOperatorAvailable.RLock()
	calls = mock.calls.IsOperatorAvailable
	mock.lockIsOperatorAvailable.RUnlock()
	return calls
}

// LinkAvailableOperatorsToSnapshot calls LinkAvailableOperatorsToSnapshotFunc.
func (mock *TSSKeeperMock) LinkAvailableOperatorsToSnapshot(ctx sdk.Context, ID string, ackType exported.AckType, counter int64) {
	if mock.LinkAvailableOperatorsToSnapshotFunc == nil {
		panic("TSSKeeperMock.LinkAvailableOperatorsToSnapshotFunc: method is nil but TSSKeeper.LinkAvailableOperatorsToSnapshot was just called")
	}
	callInfo := struct {
		Ctx     sdk.Context
		ID      string
		AckType exported.AckType
		Counter int64
	}{
		Ctx:     ctx,
		ID:      ID,
		AckType: ackType,
		Counter: counter,
	}
	mock.lockLinkAvailableOperatorsToSnapshot.Lock()
	mock.calls.LinkAvailableOperatorsToSnapshot = append(mock.calls.LinkAvailableOperatorsToSnapshot, callInfo)
	mock.lockLinkAvailableOperatorsToSnapshot.Unlock()
	mock.LinkAvailableOperatorsToSnapshotFunc(ctx, ID, ackType, counter)
}

// LinkAvailableOperatorsToSnapshotCalls gets all the calls that were made to LinkAvailableOperatorsToSnapshot.
// Check the length with:
//     len(mockedTSSKeeper.LinkAvailableOperatorsToSnapshotCalls())
func (mock *TSSKeeperMock) LinkAvailableOperatorsToSnapshotCalls() []struct {
	Ctx     sdk.Context
	ID      string
	AckType exported.AckType
	Counter int64
} {
	var calls []struct {
		Ctx     sdk.Context
		ID      string
		AckType exported.AckType
		Counter int64
	}
	mock.lockLinkAvailableOperatorsToSnapshot.RLock()
	calls = mock.calls.LinkAvailableOperatorsToSnapshot
	mock.lockLinkAvailableOperatorsToSnapshot.RUnlock()
	return calls
}

// Logger calls LoggerFunc.
func (mock *TSSKeeperMock) Logger(ctx sdk.Context) log.Logger {
	if mock.LoggerFunc == nil {
		panic("TSSKeeperMock.LoggerFunc: method is nil but TSSKeeper.Logger was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockLogger.Lock()
	mock.calls.Logger = append(mock.calls.Logger, callInfo)
	mock.lockLogger.Unlock()
	return mock.LoggerFunc(ctx)
}

// LoggerCalls gets all the calls that were made to Logger.
// Check the length with:
//     len(mockedTSSKeeper.LoggerCalls())
func (mock *TSSKeeperMock) LoggerCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockLogger.RLock()
	calls = mock.calls.Logger
	mock.lockLogger.RUnlock()
	return calls
}

// MeetsThreshold calls MeetsThresholdFunc.
func (mock *TSSKeeperMock) MeetsThreshold(ctx sdk.Context, sigID string, threshold int64) bool {
	if mock.MeetsThresholdFunc == nil {
		panic("TSSKeeperMock.MeetsThresholdFunc: method is nil but TSSKeeper.MeetsThreshold was just called")
	}
	callInfo := struct {
		Ctx       sdk.Context
		SigID     string
		Threshold int64
	}{
		Ctx:       ctx,
		SigID:     sigID,
		Threshold: threshold,
	}
	mock.lockMeetsThreshold.Lock()
	mock.calls.MeetsThreshold = append(mock.calls.MeetsThreshold, callInfo)
	mock.lockMeetsThreshold.Unlock()
	return mock.MeetsThresholdFunc(ctx, sigID, threshold)
}

// MeetsThresholdCalls gets all the calls that were made to MeetsThreshold.
// Check the length with:
//     len(mockedTSSKeeper.MeetsThresholdCalls())
func (mock *TSSKeeperMock) MeetsThresholdCalls() []struct {
	Ctx       sdk.Context
	SigID     string
	Threshold int64
} {
	var calls []struct {
		Ctx       sdk.Context
		SigID     string
		Threshold int64
	}
	mock.lockMeetsThreshold.RLock()
	calls = mock.calls.MeetsThreshold
	mock.lockMeetsThreshold.RUnlock()
	return calls
}

// OperatorIsAvailableForCounter calls OperatorIsAvailableForCounterFunc.
func (mock *TSSKeeperMock) OperatorIsAvailableForCounter(ctx sdk.Context, counter int64, validator sdk.ValAddress) bool {
	if mock.OperatorIsAvailableForCounterFunc == nil {
		panic("TSSKeeperMock.OperatorIsAvailableForCounterFunc: method is nil but TSSKeeper.OperatorIsAvailableForCounter was just called")
	}
	callInfo := struct {
		Ctx       sdk.Context
		Counter   int64
		Validator sdk.ValAddress
	}{
		Ctx:       ctx,
		Counter:   counter,
		Validator: validator,
	}
	mock.lockOperatorIsAvailableForCounter.Lock()
	mock.calls.OperatorIsAvailableForCounter = append(mock.calls.OperatorIsAvailableForCounter, callInfo)
	mock.lockOperatorIsAvailableForCounter.Unlock()
	return mock.OperatorIsAvailableForCounterFunc(ctx, counter, validator)
}

// OperatorIsAvailableForCounterCalls gets all the calls that were made to OperatorIsAvailableForCounter.
// Check the length with:
//     len(mockedTSSKeeper.OperatorIsAvailableForCounterCalls())
func (mock *TSSKeeperMock) OperatorIsAvailableForCounterCalls() []struct {
	Ctx       sdk.Context
	Counter   int64
	Validator sdk.ValAddress
} {
	var calls []struct {
		Ctx       sdk.Context
		Counter   int64
		Validator sdk.ValAddress
	}
	mock.lockOperatorIsAvailableForCounter.RLock()
	calls = mock.calls.OperatorIsAvailableForCounter
	mock.lockOperatorIsAvailableForCounter.RUnlock()
	return calls
}

// PenalizeCriminal calls PenalizeCriminalFunc.
func (mock *TSSKeeperMock) PenalizeCriminal(ctx sdk.Context, criminal sdk.ValAddress, crimeType tofnd.MessageOut_CriminalList_Criminal_CrimeType) {
	if mock.PenalizeCriminalFunc == nil {
		panic("TSSKeeperMock.PenalizeCriminalFunc: method is nil but TSSKeeper.PenalizeCriminal was just called")
	}
	callInfo := struct {
		Ctx       sdk.Context
		Criminal  sdk.ValAddress
		CrimeType tofnd.MessageOut_CriminalList_Criminal_CrimeType
	}{
		Ctx:       ctx,
		Criminal:  criminal,
		CrimeType: crimeType,
	}
	mock.lockPenalizeCriminal.Lock()
	mock.calls.PenalizeCriminal = append(mock.calls.PenalizeCriminal, callInfo)
	mock.lockPenalizeCriminal.Unlock()
	mock.PenalizeCriminalFunc(ctx, criminal, crimeType)
}

// PenalizeCriminalCalls gets all the calls that were made to PenalizeCriminal.
// Check the length with:
//     len(mockedTSSKeeper.PenalizeCriminalCalls())
func (mock *TSSKeeperMock) PenalizeCriminalCalls() []struct {
	Ctx       sdk.Context
	Criminal  sdk.ValAddress
	CrimeType tofnd.MessageOut_CriminalList_Criminal_CrimeType
} {
	var calls []struct {
		Ctx       sdk.Context
		Criminal  sdk.ValAddress
		CrimeType tofnd.MessageOut_CriminalList_Criminal_CrimeType
	}
	mock.lockPenalizeCriminal.RLock()
	calls = mock.calls.PenalizeCriminal
	mock.lockPenalizeCriminal.RUnlock()
	return calls
}

// RotateKey calls RotateKeyFunc.
func (mock *TSSKeeperMock) RotateKey(ctx sdk.Context, chain nexus.Chain, keyRole exported.KeyRole) error {
	if mock.RotateKeyFunc == nil {
		panic("TSSKeeperMock.RotateKeyFunc: method is nil but TSSKeeper.RotateKey was just called")
	}
	callInfo := struct {
		Ctx     sdk.Context
		Chain   nexus.Chain
		KeyRole exported.KeyRole
	}{
		Ctx:     ctx,
		Chain:   chain,
		KeyRole: keyRole,
	}
	mock.lockRotateKey.Lock()
	mock.calls.RotateKey = append(mock.calls.RotateKey, callInfo)
	mock.lockRotateKey.Unlock()
	return mock.RotateKeyFunc(ctx, chain, keyRole)
}

// RotateKeyCalls gets all the calls that were made to RotateKey.
// Check the length with:
//     len(mockedTSSKeeper.RotateKeyCalls())
func (mock *TSSKeeperMock) RotateKeyCalls() []struct {
	Ctx     sdk.Context
	Chain   nexus.Chain
	KeyRole exported.KeyRole
} {
	var calls []struct {
		Ctx     sdk.Context
		Chain   nexus.Chain
		KeyRole exported.KeyRole
	}
	mock.lockRotateKey.RLock()
	calls = mock.calls.RotateKey
	mock.lockRotateKey.RUnlock()
	return calls
}

// ScheduleKeygen calls ScheduleKeygenFunc.
func (mock *TSSKeeperMock) ScheduleKeygen(ctx sdk.Context, req tsstypes.StartKeygenRequest) (int64, error) {
	if mock.ScheduleKeygenFunc == nil {
		panic("TSSKeeperMock.ScheduleKeygenFunc: method is nil but TSSKeeper.ScheduleKeygen was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
		Req tsstypes.StartKeygenRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockScheduleKeygen.Lock()
	mock.calls.ScheduleKeygen = append(mock.calls.ScheduleKeygen, callInfo)
	mock.lockScheduleKeygen.Unlock()
	return mock.ScheduleKeygenFunc(ctx, req)
}

// ScheduleKeygenCalls gets all the calls that were made to ScheduleKeygen.
// Check the length with:
//     len(mockedTSSKeeper.ScheduleKeygenCalls())
func (mock *TSSKeeperMock) ScheduleKeygenCalls() []struct {
	Ctx sdk.Context
	Req tsstypes.StartKeygenRequest
} {
	var calls []struct {
		Ctx sdk.Context
		Req tsstypes.StartKeygenRequest
	}
	mock.lockScheduleKeygen.RLock()
	calls = mock.calls.ScheduleKeygen
	mock.lockScheduleKeygen.RUnlock()
	return calls
}

// ScheduleSign calls ScheduleSignFunc.
func (mock *TSSKeeperMock) ScheduleSign(ctx sdk.Context, info exported.SignInfo) (int64, error) {
	if mock.ScheduleSignFunc == nil {
		panic("TSSKeeperMock.ScheduleSignFunc: method is nil but TSSKeeper.ScheduleSign was just called")
	}
	callInfo := struct {
		Ctx  sdk.Context
		Info exported.SignInfo
	}{
		Ctx:  ctx,
		Info: info,
	}
	mock.lockScheduleSign.Lock()
	mock.calls.ScheduleSign = append(mock.calls.ScheduleSign, callInfo)
	mock.lockScheduleSign.Unlock()
	return mock.ScheduleSignFunc(ctx, info)
}

// ScheduleSignCalls gets all the calls that were made to ScheduleSign.
// Check the length with:
//     len(mockedTSSKeeper.ScheduleSignCalls())
func (mock *TSSKeeperMock) ScheduleSignCalls() []struct {
	Ctx  sdk.Context
	Info exported.SignInfo
} {
	var calls []struct {
		Ctx  sdk.Context
		Info exported.SignInfo
	}
	mock.lockScheduleSign.RLock()
	calls = mock.calls.ScheduleSign
	mock.lockScheduleSign.RUnlock()
	return calls
}

// SelectSignParticipants calls SelectSignParticipantsFunc.
func (mock *TSSKeeperMock) SelectSignParticipants(ctx sdk.Context, snapshotter snapshot.Snapshotter, sigID string, validators []snapshot.Validator) error {
	if mock.SelectSignParticipantsFunc == nil {
		panic("TSSKeeperMock.SelectSignParticipantsFunc: method is nil but TSSKeeper.SelectSignParticipants was just called")
	}
	callInfo := struct {
		Ctx         sdk.Context
		Snapshotter snapshot.Snapshotter
		SigID       string
		Validators  []snapshot.Validator
	}{
		Ctx:         ctx,
		Snapshotter: snapshotter,
		SigID:       sigID,
		Validators:  validators,
	}
	mock.lockSelectSignParticipants.Lock()
	mock.calls.SelectSignParticipants = append(mock.calls.SelectSignParticipants, callInfo)
	mock.lockSelectSignParticipants.Unlock()
	return mock.SelectSignParticipantsFunc(ctx, snapshotter, sigID, validators)
}

// SelectSignParticipantsCalls gets all the calls that were made to SelectSignParticipants.
// Check the length with:
//     len(mockedTSSKeeper.SelectSignParticipantsCalls())
func (mock *TSSKeeperMock) SelectSignParticipantsCalls() []struct {
	Ctx         sdk.Context
	Snapshotter snapshot.Snapshotter
	SigID       string
	Validators  []snapshot.Validator
} {
	var calls []struct {
		Ctx         sdk.Context
		Snapshotter snapshot.Snapshotter
		SigID       string
		Validators  []snapshot.Validator
	}
	mock.lockSelectSignParticipants.RLock()
	calls = mock.calls.SelectSignParticipants
	mock.lockSelectSignParticipants.RUnlock()
	return calls
}

// SetAvailableOperator calls SetAvailableOperatorFunc.
func (mock *TSSKeeperMock) SetAvailableOperator(ctx sdk.Context, ID string, ackType exported.AckType, validator sdk.ValAddress) error {
	if mock.SetAvailableOperatorFunc == nil {
		panic("TSSKeeperMock.SetAvailableOperatorFunc: method is nil but TSSKeeper.SetAvailableOperator was just called")
	}
	callInfo := struct {
		Ctx       sdk.Context
		ID        string
		AckType   exported.AckType
		Validator sdk.ValAddress
	}{
		Ctx:       ctx,
		ID:        ID,
		AckType:   ackType,
		Validator: validator,
	}
	mock.lockSetAvailableOperator.Lock()
	mock.calls.SetAvailableOperator = append(mock.calls.SetAvailableOperator, callInfo)
	mock.lockSetAvailableOperator.Unlock()
	return mock.SetAvailableOperatorFunc(ctx, ID, ackType, validator)
}

// SetAvailableOperatorCalls gets all the calls that were made to SetAvailableOperator.
// Check the length with:
//     len(mockedTSSKeeper.SetAvailableOperatorCalls())
func (mock *TSSKeeperMock) SetAvailableOperatorCalls() []struct {
	Ctx       sdk.Context
	ID        string
	AckType   exported.AckType
	Validator sdk.ValAddress
} {
	var calls []struct {
		Ctx       sdk.Context
		ID        string
		AckType   exported.AckType
		Validator sdk.ValAddress
	}
	mock.lockSetAvailableOperator.RLock()
	calls = mock.calls.SetAvailableOperator
	mock.lockSetAvailableOperator.RUnlock()
	return calls
}

// SetKey calls SetKeyFunc.
func (mock *TSSKeeperMock) SetKey(ctx sdk.Context, keyID string, key ecdsa.PublicKey) {
	if mock.SetKeyFunc == nil {
		panic("TSSKeeperMock.SetKeyFunc: method is nil but TSSKeeper.SetKey was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		KeyID string
		Key   ecdsa.PublicKey
	}{
		Ctx:   ctx,
		KeyID: keyID,
		Key:   key,
	}
	mock.lockSetKey.Lock()
	mock.calls.SetKey = append(mock.calls.SetKey, callInfo)
	mock.lockSetKey.Unlock()
	mock.SetKeyFunc(ctx, keyID, key)
}

// SetKeyCalls gets all the calls that were made to SetKey.
// Check the length with:
//     len(mockedTSSKeeper.SetKeyCalls())
func (mock *TSSKeeperMock) SetKeyCalls() []struct {
	Ctx   sdk.Context
	KeyID string
	Key   ecdsa.PublicKey
} {
	var calls []struct {
		Ctx   sdk.Context
		KeyID string
		Key   ecdsa.PublicKey
	}
	mock.lockSetKey.RLock()
	calls = mock.calls.SetKey
	mock.lockSetKey.RUnlock()
	return calls
}

// SetKeyIDForSig calls SetKeyIDForSigFunc.
func (mock *TSSKeeperMock) SetKeyIDForSig(ctx sdk.Context, sigID string, keyID string) {
	if mock.SetKeyIDForSigFunc == nil {
		panic("TSSKeeperMock.SetKeyIDForSigFunc: method is nil but TSSKeeper.SetKeyIDForSig was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		SigID string
		KeyID string
	}{
		Ctx:   ctx,
		SigID: sigID,
		KeyID: keyID,
	}
	mock.lockSetKeyIDForSig.Lock()
	mock.calls.SetKeyIDForSig = append(mock.calls.SetKeyIDForSig, callInfo)
	mock.lockSetKeyIDForSig.Unlock()
	mock.SetKeyIDForSigFunc(ctx, sigID, keyID)
}

// SetKeyIDForSigCalls gets all the calls that were made to SetKeyIDForSig.
// Check the length with:
//     len(mockedTSSKeeper.SetKeyIDForSigCalls())
func (mock *TSSKeeperMock) SetKeyIDForSigCalls() []struct {
	Ctx   sdk.Context
	SigID string
	KeyID string
} {
	var calls []struct {
		Ctx   sdk.Context
		SigID string
		KeyID string
	}
	mock.lockSetKeyIDForSig.RLock()
	calls = mock.calls.SetKeyIDForSig
	mock.lockSetKeyIDForSig.RUnlock()
	return calls
}

// SetParams calls SetParamsFunc.
func (mock *TSSKeeperMock) SetParams(ctx sdk.Context, p tsstypes.Params) {
	if mock.SetParamsFunc == nil {
		panic("TSSKeeperMock.SetParamsFunc: method is nil but TSSKeeper.SetParams was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
		P   tsstypes.Params
	}{
		Ctx: ctx,
		P:   p,
	}
	mock.lockSetParams.Lock()
	mock.calls.SetParams = append(mock.calls.SetParams, callInfo)
	mock.lockSetParams.Unlock()
	mock.SetParamsFunc(ctx, p)
}

// SetParamsCalls gets all the calls that were made to SetParams.
// Check the length with:
//     len(mockedTSSKeeper.SetParamsCalls())
func (mock *TSSKeeperMock) SetParamsCalls() []struct {
	Ctx sdk.Context
	P   tsstypes.Params
} {
	var calls []struct {
		Ctx sdk.Context
		P   tsstypes.Params
	}
	mock.lockSetParams.RLock()
	calls = mock.calls.SetParams
	mock.lockSetParams.RUnlock()
	return calls
}

// SetRecoveryInfos calls SetRecoveryInfosFunc.
func (mock *TSSKeeperMock) SetRecoveryInfos(ctx sdk.Context, sender sdk.ValAddress, keyID string, infos [][]byte) {
	if mock.SetRecoveryInfosFunc == nil {
		panic("TSSKeeperMock.SetRecoveryInfosFunc: method is nil but TSSKeeper.SetRecoveryInfos was just called")
	}
	callInfo := struct {
		Ctx    sdk.Context
		Sender sdk.ValAddress
		KeyID  string
		Infos  [][]byte
	}{
		Ctx:    ctx,
		Sender: sender,
		KeyID:  keyID,
		Infos:  infos,
	}
	mock.lockSetRecoveryInfos.Lock()
	mock.calls.SetRecoveryInfos = append(mock.calls.SetRecoveryInfos, callInfo)
	mock.lockSetRecoveryInfos.Unlock()
	mock.SetRecoveryInfosFunc(ctx, sender, keyID, infos)
}

// SetRecoveryInfosCalls gets all the calls that were made to SetRecoveryInfos.
// Check the length with:
//     len(mockedTSSKeeper.SetRecoveryInfosCalls())
func (mock *TSSKeeperMock) SetRecoveryInfosCalls() []struct {
	Ctx    sdk.Context
	Sender sdk.ValAddress
	KeyID  string
	Infos  [][]byte
} {
	var calls []struct {
		Ctx    sdk.Context
		Sender sdk.ValAddress
		KeyID  string
		Infos  [][]byte
	}
	mock.lockSetRecoveryInfos.RLock()
	calls = mock.calls.SetRecoveryInfos
	mock.lockSetRecoveryInfos.RUnlock()
	return calls
}

// SetSig calls SetSigFunc.
func (mock *TSSKeeperMock) SetSig(ctx sdk.Context, sigID string, signature []byte) {
	if mock.SetSigFunc == nil {
		panic("TSSKeeperMock.SetSigFunc: method is nil but TSSKeeper.SetSig was just called")
	}
	callInfo := struct {
		Ctx       sdk.Context
		SigID     string
		Signature []byte
	}{
		Ctx:       ctx,
		SigID:     sigID,
		Signature: signature,
	}
	mock.lockSetSig.Lock()
	mock.calls.SetSig = append(mock.calls.SetSig, callInfo)
	mock.lockSetSig.Unlock()
	mock.SetSigFunc(ctx, sigID, signature)
}

// SetSigCalls gets all the calls that were made to SetSig.
// Check the length with:
//     len(mockedTSSKeeper.SetSigCalls())
func (mock *TSSKeeperMock) SetSigCalls() []struct {
	Ctx       sdk.Context
	SigID     string
	Signature []byte
} {
	var calls []struct {
		Ctx       sdk.Context
		SigID     string
		Signature []byte
	}
	mock.lockSetSig.RLock()
	calls = mock.calls.SetSig
	mock.lockSetSig.RUnlock()
	return calls
}

// SetSigStatus calls SetSigStatusFunc.
func (mock *TSSKeeperMock) SetSigStatus(ctx sdk.Context, sigID string, status exported.SigStatus) {
	if mock.SetSigStatusFunc == nil {
		panic("TSSKeeperMock.SetSigStatusFunc: method is nil but TSSKeeper.SetSigStatus was just called")
	}
	callInfo := struct {
		Ctx    sdk.Context
		SigID  string
		Status exported.SigStatus
	}{
		Ctx:    ctx,
		SigID:  sigID,
		Status: status,
	}
	mock.lockSetSigStatus.Lock()
	mock.calls.SetSigStatus = append(mock.calls.SetSigStatus, callInfo)
	mock.lockSetSigStatus.Unlock()
	mock.SetSigStatusFunc(ctx, sigID, status)
}

// SetSigStatusCalls gets all the calls that were made to SetSigStatus.
// Check the length with:
//     len(mockedTSSKeeper.SetSigStatusCalls())
func (mock *TSSKeeperMock) SetSigStatusCalls() []struct {
	Ctx    sdk.Context
	SigID  string
	Status exported.SigStatus
} {
	var calls []struct {
		Ctx    sdk.Context
		SigID  string
		Status exported.SigStatus
	}
	mock.lockSetSigStatus.RLock()
	calls = mock.calls.SetSigStatus
	mock.lockSetSigStatus.RUnlock()
	return calls
}

// StartKeygen calls StartKeygenFunc.
func (mock *TSSKeeperMock) StartKeygen(ctx sdk.Context, voter tsstypes.Voter, keyID string, keyRole exported.KeyRole, snapshotMoqParam snapshot.Snapshot) error {
	if mock.StartKeygenFunc == nil {
		panic("TSSKeeperMock.StartKeygenFunc: method is nil but TSSKeeper.StartKeygen was just called")
	}
	callInfo := struct {
		Ctx              sdk.Context
		Voter            tsstypes.Voter
		KeyID            string
		KeyRole          exported.KeyRole
		SnapshotMoqParam snapshot.Snapshot
	}{
		Ctx:              ctx,
		Voter:            voter,
		KeyID:            keyID,
		KeyRole:          keyRole,
		SnapshotMoqParam: snapshotMoqParam,
	}
	mock.lockStartKeygen.Lock()
	mock.calls.StartKeygen = append(mock.calls.StartKeygen, callInfo)
	mock.lockStartKeygen.Unlock()
	return mock.StartKeygenFunc(ctx, voter, keyID, keyRole, snapshotMoqParam)
}

// StartKeygenCalls gets all the calls that were made to StartKeygen.
// Check the length with:
//     len(mockedTSSKeeper.StartKeygenCalls())
func (mock *TSSKeeperMock) StartKeygenCalls() []struct {
	Ctx              sdk.Context
	Voter            tsstypes.Voter
	KeyID            string
	KeyRole          exported.KeyRole
	SnapshotMoqParam snapshot.Snapshot
} {
	var calls []struct {
		Ctx              sdk.Context
		Voter            tsstypes.Voter
		KeyID            string
		KeyRole          exported.KeyRole
		SnapshotMoqParam snapshot.Snapshot
	}
	mock.lockStartKeygen.RLock()
	calls = mock.calls.StartKeygen
	mock.lockStartKeygen.RUnlock()
	return calls
}

// Ensure, that SnapshotterMock does implement tsstypes.Snapshotter.
// If this is not the case, regenerate this file with moq.
var _ tsstypes.Snapshotter = &SnapshotterMock{}

// SnapshotterMock is a mock implementation of tsstypes.Snapshotter.
//
// 	func TestSomethingThatUsesSnapshotter(t *testing.T) {
//
// 		// make and configure a mocked tsstypes.Snapshotter
// 		mockedSnapshotter := &SnapshotterMock{
// 			GetLatestCounterFunc: func(ctx sdk.Context) int64 {
// 				panic("mock out the GetLatestCounter method")
// 			},
// 			GetLatestSnapshotFunc: func(ctx sdk.Context) (snapshot.Snapshot, bool) {
// 				panic("mock out the GetLatestSnapshot method")
// 			},
// 			GetOperatorFunc: func(ctx sdk.Context, proxy sdk.AccAddress) sdk.ValAddress {
// 				panic("mock out the GetOperator method")
// 			},
// 			GetProxyFunc: func(ctx sdk.Context, principal sdk.ValAddress) (sdk.AccAddress, bool) {
// 				panic("mock out the GetProxy method")
// 			},
// 			GetSnapshotFunc: func(ctx sdk.Context, seqNo int64) (snapshot.Snapshot, bool) {
// 				panic("mock out the GetSnapshot method")
// 			},
// 			GetValidatorIllegibilityFunc: func(ctx sdk.Context, validator snapshot.SDKValidator) (snapshot.ValidatorIllegibility, error) {
// 				panic("mock out the GetValidatorIllegibility method")
// 			},
// 			TakeSnapshotFunc: func(ctx sdk.Context, keyRequirement exported.KeyRequirement) (snapshot.Snapshot, error) {
// 				panic("mock out the TakeSnapshot method")
// 			},
// 		}
//
// 		// use mockedSnapshotter in code that requires tsstypes.Snapshotter
// 		// and then make assertions.
//
// 	}
type SnapshotterMock struct {
	// GetLatestCounterFunc mocks the GetLatestCounter method.
	GetLatestCounterFunc func(ctx sdk.Context) int64

	// GetLatestSnapshotFunc mocks the GetLatestSnapshot method.
	GetLatestSnapshotFunc func(ctx sdk.Context) (snapshot.Snapshot, bool)

	// GetOperatorFunc mocks the GetOperator method.
	GetOperatorFunc func(ctx sdk.Context, proxy sdk.AccAddress) sdk.ValAddress

	// GetProxyFunc mocks the GetProxy method.
	GetProxyFunc func(ctx sdk.Context, principal sdk.ValAddress) (sdk.AccAddress, bool)

	// GetSnapshotFunc mocks the GetSnapshot method.
	GetSnapshotFunc func(ctx sdk.Context, seqNo int64) (snapshot.Snapshot, bool)

	// GetValidatorIllegibilityFunc mocks the GetValidatorIllegibility method.
	GetValidatorIllegibilityFunc func(ctx sdk.Context, validator snapshot.SDKValidator) (snapshot.ValidatorIllegibility, error)

	// TakeSnapshotFunc mocks the TakeSnapshot method.
	TakeSnapshotFunc func(ctx sdk.Context, keyRequirement exported.KeyRequirement) (snapshot.Snapshot, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetLatestCounter holds details about calls to the GetLatestCounter method.
		GetLatestCounter []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetLatestSnapshot holds details about calls to the GetLatestSnapshot method.
		GetLatestSnapshot []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetOperator holds details about calls to the GetOperator method.
		GetOperator []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Proxy is the proxy argument value.
			Proxy sdk.AccAddress
		}
		// GetProxy holds details about calls to the GetProxy method.
		GetProxy []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Principal is the principal argument value.
			Principal sdk.ValAddress
		}
		// GetSnapshot holds details about calls to the GetSnapshot method.
		GetSnapshot []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// SeqNo is the seqNo argument value.
			SeqNo int64
		}
		// GetValidatorIllegibility holds details about calls to the GetValidatorIllegibility method.
		GetValidatorIllegibility []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Validator is the validator argument value.
			Validator snapshot.SDKValidator
		}
		// TakeSnapshot holds details about calls to the TakeSnapshot method.
		TakeSnapshot []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// KeyRequirement is the keyRequirement argument value.
			KeyRequirement exported.KeyRequirement
		}
	}
	lockGetLatestCounter         sync.RWMutex
	lockGetLatestSnapshot        sync.RWMutex
	lockGetOperator              sync.RWMutex
	lockGetProxy                 sync.RWMutex
	lockGetSnapshot              sync.RWMutex
	lockGetValidatorIllegibility sync.RWMutex
	lockTakeSnapshot             sync.RWMutex
}

// GetLatestCounter calls GetLatestCounterFunc.
func (mock *SnapshotterMock) GetLatestCounter(ctx sdk.Context) int64 {
	if mock.GetLatestCounterFunc == nil {
		panic("SnapshotterMock.GetLatestCounterFunc: method is nil but Snapshotter.GetLatestCounter was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetLatestCounter.Lock()
	mock.calls.GetLatestCounter = append(mock.calls.GetLatestCounter, callInfo)
	mock.lockGetLatestCounter.Unlock()
	return mock.GetLatestCounterFunc(ctx)
}

// GetLatestCounterCalls gets all the calls that were made to GetLatestCounter.
// Check the length with:
//     len(mockedSnapshotter.GetLatestCounterCalls())
func (mock *SnapshotterMock) GetLatestCounterCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetLatestCounter.RLock()
	calls = mock.calls.GetLatestCounter
	mock.lockGetLatestCounter.RUnlock()
	return calls
}

// GetLatestSnapshot calls GetLatestSnapshotFunc.
func (mock *SnapshotterMock) GetLatestSnapshot(ctx sdk.Context) (snapshot.Snapshot, bool) {
	if mock.GetLatestSnapshotFunc == nil {
		panic("SnapshotterMock.GetLatestSnapshotFunc: method is nil but Snapshotter.GetLatestSnapshot was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetLatestSnapshot.Lock()
	mock.calls.GetLatestSnapshot = append(mock.calls.GetLatestSnapshot, callInfo)
	mock.lockGetLatestSnapshot.Unlock()
	return mock.GetLatestSnapshotFunc(ctx)
}

// GetLatestSnapshotCalls gets all the calls that were made to GetLatestSnapshot.
// Check the length with:
//     len(mockedSnapshotter.GetLatestSnapshotCalls())
func (mock *SnapshotterMock) GetLatestSnapshotCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetLatestSnapshot.RLock()
	calls = mock.calls.GetLatestSnapshot
	mock.lockGetLatestSnapshot.RUnlock()
	return calls
}

// GetOperator calls GetOperatorFunc.
func (mock *SnapshotterMock) GetOperator(ctx sdk.Context, proxy sdk.AccAddress) sdk.ValAddress {
	if mock.GetOperatorFunc == nil {
		panic("SnapshotterMock.GetOperatorFunc: method is nil but Snapshotter.GetOperator was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		Proxy sdk.AccAddress
	}{
		Ctx:   ctx,
		Proxy: proxy,
	}
	mock.lockGetOperator.Lock()
	mock.calls.GetOperator = append(mock.calls.GetOperator, callInfo)
	mock.lockGetOperator.Unlock()
	return mock.GetOperatorFunc(ctx, proxy)
}

// GetOperatorCalls gets all the calls that were made to GetOperator.
// Check the length with:
//     len(mockedSnapshotter.GetOperatorCalls())
func (mock *SnapshotterMock) GetOperatorCalls() []struct {
	Ctx   sdk.Context
	Proxy sdk.AccAddress
} {
	var calls []struct {
		Ctx   sdk.Context
		Proxy sdk.AccAddress
	}
	mock.lockGetOperator.RLock()
	calls = mock.calls.GetOperator
	mock.lockGetOperator.RUnlock()
	return calls
}

// GetProxy calls GetProxyFunc.
func (mock *SnapshotterMock) GetProxy(ctx sdk.Context, principal sdk.ValAddress) (sdk.AccAddress, bool) {
	if mock.GetProxyFunc == nil {
		panic("SnapshotterMock.GetProxyFunc: method is nil but Snapshotter.GetProxy was just called")
	}
	callInfo := struct {
		Ctx       sdk.Context
		Principal sdk.ValAddress
	}{
		Ctx:       ctx,
		Principal: principal,
	}
	mock.lockGetProxy.Lock()
	mock.calls.GetProxy = append(mock.calls.GetProxy, callInfo)
	mock.lockGetProxy.Unlock()
	return mock.GetProxyFunc(ctx, principal)
}

// GetProxyCalls gets all the calls that were made to GetProxy.
// Check the length with:
//     len(mockedSnapshotter.GetProxyCalls())
func (mock *SnapshotterMock) GetProxyCalls() []struct {
	Ctx       sdk.Context
	Principal sdk.ValAddress
} {
	var calls []struct {
		Ctx       sdk.Context
		Principal sdk.ValAddress
	}
	mock.lockGetProxy.RLock()
	calls = mock.calls.GetProxy
	mock.lockGetProxy.RUnlock()
	return calls
}

// GetSnapshot calls GetSnapshotFunc.
func (mock *SnapshotterMock) GetSnapshot(ctx sdk.Context, seqNo int64) (snapshot.Snapshot, bool) {
	if mock.GetSnapshotFunc == nil {
		panic("SnapshotterMock.GetSnapshotFunc: method is nil but Snapshotter.GetSnapshot was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		SeqNo int64
	}{
		Ctx:   ctx,
		SeqNo: seqNo,
	}
	mock.lockGetSnapshot.Lock()
	mock.calls.GetSnapshot = append(mock.calls.GetSnapshot, callInfo)
	mock.lockGetSnapshot.Unlock()
	return mock.GetSnapshotFunc(ctx, seqNo)
}

// GetSnapshotCalls gets all the calls that were made to GetSnapshot.
// Check the length with:
//     len(mockedSnapshotter.GetSnapshotCalls())
func (mock *SnapshotterMock) GetSnapshotCalls() []struct {
	Ctx   sdk.Context
	SeqNo int64
} {
	var calls []struct {
		Ctx   sdk.Context
		SeqNo int64
	}
	mock.lockGetSnapshot.RLock()
	calls = mock.calls.GetSnapshot
	mock.lockGetSnapshot.RUnlock()
	return calls
}

// GetValidatorIllegibility calls GetValidatorIllegibilityFunc.
func (mock *SnapshotterMock) GetValidatorIllegibility(ctx sdk.Context, validator snapshot.SDKValidator) (snapshot.ValidatorIllegibility, error) {
	if mock.GetValidatorIllegibilityFunc == nil {
		panic("SnapshotterMock.GetValidatorIllegibilityFunc: method is nil but Snapshotter.GetValidatorIllegibility was just called")
	}
	callInfo := struct {
		Ctx       sdk.Context
		Validator snapshot.SDKValidator
	}{
		Ctx:       ctx,
		Validator: validator,
	}
	mock.lockGetValidatorIllegibility.Lock()
	mock.calls.GetValidatorIllegibility = append(mock.calls.GetValidatorIllegibility, callInfo)
	mock.lockGetValidatorIllegibility.Unlock()
	return mock.GetValidatorIllegibilityFunc(ctx, validator)
}

// GetValidatorIllegibilityCalls gets all the calls that were made to GetValidatorIllegibility.
// Check the length with:
//     len(mockedSnapshotter.GetValidatorIllegibilityCalls())
func (mock *SnapshotterMock) GetValidatorIllegibilityCalls() []struct {
	Ctx       sdk.Context
	Validator snapshot.SDKValidator
} {
	var calls []struct {
		Ctx       sdk.Context
		Validator snapshot.SDKValidator
	}
	mock.lockGetValidatorIllegibility.RLock()
	calls = mock.calls.GetValidatorIllegibility
	mock.lockGetValidatorIllegibility.RUnlock()
	return calls
}

// TakeSnapshot calls TakeSnapshotFunc.
func (mock *SnapshotterMock) TakeSnapshot(ctx sdk.Context, keyRequirement exported.KeyRequirement) (snapshot.Snapshot, error) {
	if mock.TakeSnapshotFunc == nil {
		panic("SnapshotterMock.TakeSnapshotFunc: method is nil but Snapshotter.TakeSnapshot was just called")
	}
	callInfo := struct {
		Ctx            sdk.Context
		KeyRequirement exported.KeyRequirement
	}{
		Ctx:            ctx,
		KeyRequirement: keyRequirement,
	}
	mock.lockTakeSnapshot.Lock()
	mock.calls.TakeSnapshot = append(mock.calls.TakeSnapshot, callInfo)
	mock.lockTakeSnapshot.Unlock()
	return mock.TakeSnapshotFunc(ctx, keyRequirement)
}

// TakeSnapshotCalls gets all the calls that were made to TakeSnapshot.
// Check the length with:
//     len(mockedSnapshotter.TakeSnapshotCalls())
func (mock *SnapshotterMock) TakeSnapshotCalls() []struct {
	Ctx            sdk.Context
	KeyRequirement exported.KeyRequirement
} {
	var calls []struct {
		Ctx            sdk.Context
		KeyRequirement exported.KeyRequirement
	}
	mock.lockTakeSnapshot.RLock()
	calls = mock.calls.TakeSnapshot
	mock.lockTakeSnapshot.RUnlock()
	return calls
}

// Ensure, that NexusMock does implement tsstypes.Nexus.
// If this is not the case, regenerate this file with moq.
var _ tsstypes.Nexus = &NexusMock{}

// NexusMock is a mock implementation of tsstypes.Nexus.
//
// 	func TestSomethingThatUsesNexus(t *testing.T) {
//
// 		// make and configure a mocked tsstypes.Nexus
// 		mockedNexus := &NexusMock{
// 			GetChainFunc: func(ctx sdk.Context, chain string) (nexus.Chain, bool) {
// 				panic("mock out the GetChain method")
// 			},
// 			GetChainsFunc: func(ctx sdk.Context) []nexus.Chain {
// 				panic("mock out the GetChains method")
// 			},
// 		}
//
// 		// use mockedNexus in code that requires tsstypes.Nexus
// 		// and then make assertions.
//
// 	}
type NexusMock struct {
	// GetChainFunc mocks the GetChain method.
	GetChainFunc func(ctx sdk.Context, chain string) (nexus.Chain, bool)

	// GetChainsFunc mocks the GetChains method.
	GetChainsFunc func(ctx sdk.Context) []nexus.Chain

	// calls tracks calls to the methods.
	calls struct {
		// GetChain holds details about calls to the GetChain method.
		GetChain []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Chain is the chain argument value.
			Chain string
		}
		// GetChains holds details about calls to the GetChains method.
		GetChains []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
	}
	lockGetChain  sync.RWMutex
	lockGetChains sync.RWMutex
}

// GetChain calls GetChainFunc.
func (mock *NexusMock) GetChain(ctx sdk.Context, chain string) (nexus.Chain, bool) {
	if mock.GetChainFunc == nil {
		panic("NexusMock.GetChainFunc: method is nil but Nexus.GetChain was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		Chain string
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockGetChain.Lock()
	mock.calls.GetChain = append(mock.calls.GetChain, callInfo)
	mock.lockGetChain.Unlock()
	return mock.GetChainFunc(ctx, chain)
}

// GetChainCalls gets all the calls that were made to GetChain.
// Check the length with:
//     len(mockedNexus.GetChainCalls())
func (mock *NexusMock) GetChainCalls() []struct {
	Ctx   sdk.Context
	Chain string
} {
	var calls []struct {
		Ctx   sdk.Context
		Chain string
	}
	mock.lockGetChain.RLock()
	calls = mock.calls.GetChain
	mock.lockGetChain.RUnlock()
	return calls
}

// GetChains calls GetChainsFunc.
func (mock *NexusMock) GetChains(ctx sdk.Context) []nexus.Chain {
	if mock.GetChainsFunc == nil {
		panic("NexusMock.GetChainsFunc: method is nil but Nexus.GetChains was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetChains.Lock()
	mock.calls.GetChains = append(mock.calls.GetChains, callInfo)
	mock.lockGetChains.Unlock()
	return mock.GetChainsFunc(ctx)
}

// GetChainsCalls gets all the calls that were made to GetChains.
// Check the length with:
//     len(mockedNexus.GetChainsCalls())
func (mock *NexusMock) GetChainsCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetChains.RLock()
	calls = mock.calls.GetChains
	mock.lockGetChains.RUnlock()
	return calls
}
