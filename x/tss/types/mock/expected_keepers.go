// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/axelarnetwork/axelar-core/x/tss/tofnd"
	"github.com/axelarnetwork/axelar-core/x/tss/types"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
	"sync"
)

// Ensure, that TSSDClientMock does implement types.TSSDClient.
// If this is not the case, regenerate this file with moq.
var _ types.TSSDClient = &TSSDClientMock{}

// TSSDClientMock is a mock implementation of types.TSSDClient.
//
// 	func TestSomethingThatUsesTSSDClient(t *testing.T) {
//
//         // make and configure a mocked types.TSSDClient
//         mockedTSSDClient := &TSSDClientMock{
//             GetKeyFunc: func(ctx context.Context, in *tofnd.Uid, opts ...grpc.CallOption) (*tofnd.Bytes, error) {
// 	               panic("mock out the GetKey method")
//             },
//             GetSigFunc: func(ctx context.Context, in *tofnd.Uid, opts ...grpc.CallOption) (*tofnd.Bytes, error) {
// 	               panic("mock out the GetSig method")
//             },
//             KeygenFunc: func(ctx context.Context, opts ...grpc.CallOption) (tofnd.GG20_KeygenClient, error) {
// 	               panic("mock out the Keygen method")
//             },
//             SignFunc: func(ctx context.Context, opts ...grpc.CallOption) (tofnd.GG20_SignClient, error) {
// 	               panic("mock out the Sign method")
//             },
//         }
//
// 		// use mockedTSSDClient in code that requires types.TSSDClient
// 		// and then make assertions.
//
// 	}
type TSSDClientMock struct {
	// GetKeyFunc mocks the GetKey method.
	GetKeyFunc func(ctx context.Context, in *tofnd.Uid, opts ...grpc.CallOption) (*tofnd.Bytes, error)

	// GetSigFunc mocks the GetSig method.
	GetSigFunc func(ctx context.Context, in *tofnd.Uid, opts ...grpc.CallOption) (*tofnd.Bytes, error)

	// KeygenFunc mocks the Keygen method.
	KeygenFunc func(ctx context.Context, opts ...grpc.CallOption) (tofnd.GG20_KeygenClient, error)

	// SignFunc mocks the Sign method.
	SignFunc func(ctx context.Context, opts ...grpc.CallOption) (tofnd.GG20_SignClient, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetKey holds details about calls to the GetKey method.
		GetKey []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *tofnd.Uid
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// GetSig holds details about calls to the GetSig method.
		GetSig []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// In is the in argument value.
			In *tofnd.Uid
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Keygen holds details about calls to the Keygen method.
		Keygen []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
		// Sign holds details about calls to the Sign method.
		Sign []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts []grpc.CallOption
		}
	}
	lockGetKey sync.RWMutex
	lockGetSig sync.RWMutex
	lockKeygen sync.RWMutex
	lockSign   sync.RWMutex
}

// GetKey calls GetKeyFunc.
func (mock *TSSDClientMock) GetKey(ctx context.Context, in *tofnd.Uid, opts ...grpc.CallOption) (*tofnd.Bytes, error) {
	if mock.GetKeyFunc == nil {
		panic("TSSDClientMock.GetKeyFunc: method is nil but TSSDClient.GetKey was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *tofnd.Uid
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockGetKey.Lock()
	mock.calls.GetKey = append(mock.calls.GetKey, callInfo)
	mock.lockGetKey.Unlock()
	return mock.GetKeyFunc(ctx, in, opts...)
}

// GetKeyCalls gets all the calls that were made to GetKey.
// Check the length with:
//     len(mockedTSSDClient.GetKeyCalls())
func (mock *TSSDClientMock) GetKeyCalls() []struct {
	Ctx  context.Context
	In   *tofnd.Uid
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *tofnd.Uid
		Opts []grpc.CallOption
	}
	mock.lockGetKey.RLock()
	calls = mock.calls.GetKey
	mock.lockGetKey.RUnlock()
	return calls
}

// GetSig calls GetSigFunc.
func (mock *TSSDClientMock) GetSig(ctx context.Context, in *tofnd.Uid, opts ...grpc.CallOption) (*tofnd.Bytes, error) {
	if mock.GetSigFunc == nil {
		panic("TSSDClientMock.GetSigFunc: method is nil but TSSDClient.GetSig was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		In   *tofnd.Uid
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		In:   in,
		Opts: opts,
	}
	mock.lockGetSig.Lock()
	mock.calls.GetSig = append(mock.calls.GetSig, callInfo)
	mock.lockGetSig.Unlock()
	return mock.GetSigFunc(ctx, in, opts...)
}

// GetSigCalls gets all the calls that were made to GetSig.
// Check the length with:
//     len(mockedTSSDClient.GetSigCalls())
func (mock *TSSDClientMock) GetSigCalls() []struct {
	Ctx  context.Context
	In   *tofnd.Uid
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		In   *tofnd.Uid
		Opts []grpc.CallOption
	}
	mock.lockGetSig.RLock()
	calls = mock.calls.GetSig
	mock.lockGetSig.RUnlock()
	return calls
}

// Keygen calls KeygenFunc.
func (mock *TSSDClientMock) Keygen(ctx context.Context, opts ...grpc.CallOption) (tofnd.GG20_KeygenClient, error) {
	if mock.KeygenFunc == nil {
		panic("TSSDClientMock.KeygenFunc: method is nil but TSSDClient.Keygen was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockKeygen.Lock()
	mock.calls.Keygen = append(mock.calls.Keygen, callInfo)
	mock.lockKeygen.Unlock()
	return mock.KeygenFunc(ctx, opts...)
}

// KeygenCalls gets all the calls that were made to Keygen.
// Check the length with:
//     len(mockedTSSDClient.KeygenCalls())
func (mock *TSSDClientMock) KeygenCalls() []struct {
	Ctx  context.Context
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		Opts []grpc.CallOption
	}
	mock.lockKeygen.RLock()
	calls = mock.calls.Keygen
	mock.lockKeygen.RUnlock()
	return calls
}

// Sign calls SignFunc.
func (mock *TSSDClientMock) Sign(ctx context.Context, opts ...grpc.CallOption) (tofnd.GG20_SignClient, error) {
	if mock.SignFunc == nil {
		panic("TSSDClientMock.SignFunc: method is nil but TSSDClient.Sign was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts []grpc.CallOption
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockSign.Lock()
	mock.calls.Sign = append(mock.calls.Sign, callInfo)
	mock.lockSign.Unlock()
	return mock.SignFunc(ctx, opts...)
}

// SignCalls gets all the calls that were made to Sign.
// Check the length with:
//     len(mockedTSSDClient.SignCalls())
func (mock *TSSDClientMock) SignCalls() []struct {
	Ctx  context.Context
	Opts []grpc.CallOption
} {
	var calls []struct {
		Ctx  context.Context
		Opts []grpc.CallOption
	}
	mock.lockSign.RLock()
	calls = mock.calls.Sign
	mock.lockSign.RUnlock()
	return calls
}

// Ensure, that TSSDKeyGenClientMock does implement types.TSSDKeyGenClient.
// If this is not the case, regenerate this file with moq.
var _ types.TSSDKeyGenClient = &TSSDKeyGenClientMock{}

// TSSDKeyGenClientMock is a mock implementation of types.TSSDKeyGenClient.
//
// 	func TestSomethingThatUsesTSSDKeyGenClient(t *testing.T) {
//
//         // make and configure a mocked types.TSSDKeyGenClient
//         mockedTSSDKeyGenClient := &TSSDKeyGenClientMock{
//             CloseSendFunc: func() error {
// 	               panic("mock out the CloseSend method")
//             },
//             ContextFunc: func() context.Context {
// 	               panic("mock out the Context method")
//             },
//             HeaderFunc: func() (metadata.MD, error) {
// 	               panic("mock out the Header method")
//             },
//             RecvFunc: func() (*tofnd.MessageOut, error) {
// 	               panic("mock out the Recv method")
//             },
//             RecvMsgFunc: func(m interface{}) error {
// 	               panic("mock out the RecvMsg method")
//             },
//             SendFunc: func(messageIn *tofnd.MessageIn) error {
// 	               panic("mock out the Send method")
//             },
//             SendMsgFunc: func(m interface{}) error {
// 	               panic("mock out the SendMsg method")
//             },
//             TrailerFunc: func() metadata.MD {
// 	               panic("mock out the Trailer method")
//             },
//         }
//
// 		// use mockedTSSDKeyGenClient in code that requires types.TSSDKeyGenClient
// 		// and then make assertions.
//
// 	}
type TSSDKeyGenClientMock struct {
	// CloseSendFunc mocks the CloseSend method.
	CloseSendFunc func() error

	// ContextFunc mocks the Context method.
	ContextFunc func() context.Context

	// HeaderFunc mocks the Header method.
	HeaderFunc func() (metadata.MD, error)

	// RecvFunc mocks the Recv method.
	RecvFunc func() (*tofnd.MessageOut, error)

	// RecvMsgFunc mocks the RecvMsg method.
	RecvMsgFunc func(m interface{}) error

	// SendFunc mocks the Send method.
	SendFunc func(messageIn *tofnd.MessageIn) error

	// SendMsgFunc mocks the SendMsg method.
	SendMsgFunc func(m interface{}) error

	// TrailerFunc mocks the Trailer method.
	TrailerFunc func() metadata.MD

	// calls tracks calls to the methods.
	calls struct {
		// CloseSend holds details about calls to the CloseSend method.
		CloseSend []struct {
		}
		// Context holds details about calls to the Context method.
		Context []struct {
		}
		// Header holds details about calls to the Header method.
		Header []struct {
		}
		// Recv holds details about calls to the Recv method.
		Recv []struct {
		}
		// RecvMsg holds details about calls to the RecvMsg method.
		RecvMsg []struct {
			// M is the m argument value.
			M interface{}
		}
		// Send holds details about calls to the Send method.
		Send []struct {
			// MessageIn is the messageIn argument value.
			MessageIn *tofnd.MessageIn
		}
		// SendMsg holds details about calls to the SendMsg method.
		SendMsg []struct {
			// M is the m argument value.
			M interface{}
		}
		// Trailer holds details about calls to the Trailer method.
		Trailer []struct {
		}
	}
	lockCloseSend sync.RWMutex
	lockContext   sync.RWMutex
	lockHeader    sync.RWMutex
	lockRecv      sync.RWMutex
	lockRecvMsg   sync.RWMutex
	lockSend      sync.RWMutex
	lockSendMsg   sync.RWMutex
	lockTrailer   sync.RWMutex
}

// CloseSend calls CloseSendFunc.
func (mock *TSSDKeyGenClientMock) CloseSend() error {
	if mock.CloseSendFunc == nil {
		panic("TSSDKeyGenClientMock.CloseSendFunc: method is nil but TSSDKeyGenClient.CloseSend was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCloseSend.Lock()
	mock.calls.CloseSend = append(mock.calls.CloseSend, callInfo)
	mock.lockCloseSend.Unlock()
	return mock.CloseSendFunc()
}

// CloseSendCalls gets all the calls that were made to CloseSend.
// Check the length with:
//     len(mockedTSSDKeyGenClient.CloseSendCalls())
func (mock *TSSDKeyGenClientMock) CloseSendCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCloseSend.RLock()
	calls = mock.calls.CloseSend
	mock.lockCloseSend.RUnlock()
	return calls
}

// Context calls ContextFunc.
func (mock *TSSDKeyGenClientMock) Context() context.Context {
	if mock.ContextFunc == nil {
		panic("TSSDKeyGenClientMock.ContextFunc: method is nil but TSSDKeyGenClient.Context was just called")
	}
	callInfo := struct {
	}{}
	mock.lockContext.Lock()
	mock.calls.Context = append(mock.calls.Context, callInfo)
	mock.lockContext.Unlock()
	return mock.ContextFunc()
}

// ContextCalls gets all the calls that were made to Context.
// Check the length with:
//     len(mockedTSSDKeyGenClient.ContextCalls())
func (mock *TSSDKeyGenClientMock) ContextCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockContext.RLock()
	calls = mock.calls.Context
	mock.lockContext.RUnlock()
	return calls
}

// Header calls HeaderFunc.
func (mock *TSSDKeyGenClientMock) Header() (metadata.MD, error) {
	if mock.HeaderFunc == nil {
		panic("TSSDKeyGenClientMock.HeaderFunc: method is nil but TSSDKeyGenClient.Header was just called")
	}
	callInfo := struct {
	}{}
	mock.lockHeader.Lock()
	mock.calls.Header = append(mock.calls.Header, callInfo)
	mock.lockHeader.Unlock()
	return mock.HeaderFunc()
}

// HeaderCalls gets all the calls that were made to Header.
// Check the length with:
//     len(mockedTSSDKeyGenClient.HeaderCalls())
func (mock *TSSDKeyGenClientMock) HeaderCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockHeader.RLock()
	calls = mock.calls.Header
	mock.lockHeader.RUnlock()
	return calls
}

// Recv calls RecvFunc.
func (mock *TSSDKeyGenClientMock) Recv() (*tofnd.MessageOut, error) {
	if mock.RecvFunc == nil {
		panic("TSSDKeyGenClientMock.RecvFunc: method is nil but TSSDKeyGenClient.Recv was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRecv.Lock()
	mock.calls.Recv = append(mock.calls.Recv, callInfo)
	mock.lockRecv.Unlock()
	return mock.RecvFunc()
}

// RecvCalls gets all the calls that were made to Recv.
// Check the length with:
//     len(mockedTSSDKeyGenClient.RecvCalls())
func (mock *TSSDKeyGenClientMock) RecvCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRecv.RLock()
	calls = mock.calls.Recv
	mock.lockRecv.RUnlock()
	return calls
}

// RecvMsg calls RecvMsgFunc.
func (mock *TSSDKeyGenClientMock) RecvMsg(m interface{}) error {
	if mock.RecvMsgFunc == nil {
		panic("TSSDKeyGenClientMock.RecvMsgFunc: method is nil but TSSDKeyGenClient.RecvMsg was just called")
	}
	callInfo := struct {
		M interface{}
	}{
		M: m,
	}
	mock.lockRecvMsg.Lock()
	mock.calls.RecvMsg = append(mock.calls.RecvMsg, callInfo)
	mock.lockRecvMsg.Unlock()
	return mock.RecvMsgFunc(m)
}

// RecvMsgCalls gets all the calls that were made to RecvMsg.
// Check the length with:
//     len(mockedTSSDKeyGenClient.RecvMsgCalls())
func (mock *TSSDKeyGenClientMock) RecvMsgCalls() []struct {
	M interface{}
} {
	var calls []struct {
		M interface{}
	}
	mock.lockRecvMsg.RLock()
	calls = mock.calls.RecvMsg
	mock.lockRecvMsg.RUnlock()
	return calls
}

// Send calls SendFunc.
func (mock *TSSDKeyGenClientMock) Send(messageIn *tofnd.MessageIn) error {
	if mock.SendFunc == nil {
		panic("TSSDKeyGenClientMock.SendFunc: method is nil but TSSDKeyGenClient.Send was just called")
	}
	callInfo := struct {
		MessageIn *tofnd.MessageIn
	}{
		MessageIn: messageIn,
	}
	mock.lockSend.Lock()
	mock.calls.Send = append(mock.calls.Send, callInfo)
	mock.lockSend.Unlock()
	return mock.SendFunc(messageIn)
}

// SendCalls gets all the calls that were made to Send.
// Check the length with:
//     len(mockedTSSDKeyGenClient.SendCalls())
func (mock *TSSDKeyGenClientMock) SendCalls() []struct {
	MessageIn *tofnd.MessageIn
} {
	var calls []struct {
		MessageIn *tofnd.MessageIn
	}
	mock.lockSend.RLock()
	calls = mock.calls.Send
	mock.lockSend.RUnlock()
	return calls
}

// SendMsg calls SendMsgFunc.
func (mock *TSSDKeyGenClientMock) SendMsg(m interface{}) error {
	if mock.SendMsgFunc == nil {
		panic("TSSDKeyGenClientMock.SendMsgFunc: method is nil but TSSDKeyGenClient.SendMsg was just called")
	}
	callInfo := struct {
		M interface{}
	}{
		M: m,
	}
	mock.lockSendMsg.Lock()
	mock.calls.SendMsg = append(mock.calls.SendMsg, callInfo)
	mock.lockSendMsg.Unlock()
	return mock.SendMsgFunc(m)
}

// SendMsgCalls gets all the calls that were made to SendMsg.
// Check the length with:
//     len(mockedTSSDKeyGenClient.SendMsgCalls())
func (mock *TSSDKeyGenClientMock) SendMsgCalls() []struct {
	M interface{}
} {
	var calls []struct {
		M interface{}
	}
	mock.lockSendMsg.RLock()
	calls = mock.calls.SendMsg
	mock.lockSendMsg.RUnlock()
	return calls
}

// Trailer calls TrailerFunc.
func (mock *TSSDKeyGenClientMock) Trailer() metadata.MD {
	if mock.TrailerFunc == nil {
		panic("TSSDKeyGenClientMock.TrailerFunc: method is nil but TSSDKeyGenClient.Trailer was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTrailer.Lock()
	mock.calls.Trailer = append(mock.calls.Trailer, callInfo)
	mock.lockTrailer.Unlock()
	return mock.TrailerFunc()
}

// TrailerCalls gets all the calls that were made to Trailer.
// Check the length with:
//     len(mockedTSSDKeyGenClient.TrailerCalls())
func (mock *TSSDKeyGenClientMock) TrailerCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTrailer.RLock()
	calls = mock.calls.Trailer
	mock.lockTrailer.RUnlock()
	return calls
}

// Ensure, that TSSDSignClientMock does implement types.TSSDSignClient.
// If this is not the case, regenerate this file with moq.
var _ types.TSSDSignClient = &TSSDSignClientMock{}

// TSSDSignClientMock is a mock implementation of types.TSSDSignClient.
//
// 	func TestSomethingThatUsesTSSDSignClient(t *testing.T) {
//
//         // make and configure a mocked types.TSSDSignClient
//         mockedTSSDSignClient := &TSSDSignClientMock{
//             CloseSendFunc: func() error {
// 	               panic("mock out the CloseSend method")
//             },
//             ContextFunc: func() context.Context {
// 	               panic("mock out the Context method")
//             },
//             HeaderFunc: func() (metadata.MD, error) {
// 	               panic("mock out the Header method")
//             },
//             RecvFunc: func() (*tofnd.MessageOut, error) {
// 	               panic("mock out the Recv method")
//             },
//             RecvMsgFunc: func(m interface{}) error {
// 	               panic("mock out the RecvMsg method")
//             },
//             SendFunc: func(messageIn *tofnd.MessageIn) error {
// 	               panic("mock out the Send method")
//             },
//             SendMsgFunc: func(m interface{}) error {
// 	               panic("mock out the SendMsg method")
//             },
//             TrailerFunc: func() metadata.MD {
// 	               panic("mock out the Trailer method")
//             },
//         }
//
// 		// use mockedTSSDSignClient in code that requires types.TSSDSignClient
// 		// and then make assertions.
//
// 	}
type TSSDSignClientMock struct {
	// CloseSendFunc mocks the CloseSend method.
	CloseSendFunc func() error

	// ContextFunc mocks the Context method.
	ContextFunc func() context.Context

	// HeaderFunc mocks the Header method.
	HeaderFunc func() (metadata.MD, error)

	// RecvFunc mocks the Recv method.
	RecvFunc func() (*tofnd.MessageOut, error)

	// RecvMsgFunc mocks the RecvMsg method.
	RecvMsgFunc func(m interface{}) error

	// SendFunc mocks the Send method.
	SendFunc func(messageIn *tofnd.MessageIn) error

	// SendMsgFunc mocks the SendMsg method.
	SendMsgFunc func(m interface{}) error

	// TrailerFunc mocks the Trailer method.
	TrailerFunc func() metadata.MD

	// calls tracks calls to the methods.
	calls struct {
		// CloseSend holds details about calls to the CloseSend method.
		CloseSend []struct {
		}
		// Context holds details about calls to the Context method.
		Context []struct {
		}
		// Header holds details about calls to the Header method.
		Header []struct {
		}
		// Recv holds details about calls to the Recv method.
		Recv []struct {
		}
		// RecvMsg holds details about calls to the RecvMsg method.
		RecvMsg []struct {
			// M is the m argument value.
			M interface{}
		}
		// Send holds details about calls to the Send method.
		Send []struct {
			// MessageIn is the messageIn argument value.
			MessageIn *tofnd.MessageIn
		}
		// SendMsg holds details about calls to the SendMsg method.
		SendMsg []struct {
			// M is the m argument value.
			M interface{}
		}
		// Trailer holds details about calls to the Trailer method.
		Trailer []struct {
		}
	}
	lockCloseSend sync.RWMutex
	lockContext   sync.RWMutex
	lockHeader    sync.RWMutex
	lockRecv      sync.RWMutex
	lockRecvMsg   sync.RWMutex
	lockSend      sync.RWMutex
	lockSendMsg   sync.RWMutex
	lockTrailer   sync.RWMutex
}

// CloseSend calls CloseSendFunc.
func (mock *TSSDSignClientMock) CloseSend() error {
	if mock.CloseSendFunc == nil {
		panic("TSSDSignClientMock.CloseSendFunc: method is nil but TSSDSignClient.CloseSend was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCloseSend.Lock()
	mock.calls.CloseSend = append(mock.calls.CloseSend, callInfo)
	mock.lockCloseSend.Unlock()
	return mock.CloseSendFunc()
}

// CloseSendCalls gets all the calls that were made to CloseSend.
// Check the length with:
//     len(mockedTSSDSignClient.CloseSendCalls())
func (mock *TSSDSignClientMock) CloseSendCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCloseSend.RLock()
	calls = mock.calls.CloseSend
	mock.lockCloseSend.RUnlock()
	return calls
}

// Context calls ContextFunc.
func (mock *TSSDSignClientMock) Context() context.Context {
	if mock.ContextFunc == nil {
		panic("TSSDSignClientMock.ContextFunc: method is nil but TSSDSignClient.Context was just called")
	}
	callInfo := struct {
	}{}
	mock.lockContext.Lock()
	mock.calls.Context = append(mock.calls.Context, callInfo)
	mock.lockContext.Unlock()
	return mock.ContextFunc()
}

// ContextCalls gets all the calls that were made to Context.
// Check the length with:
//     len(mockedTSSDSignClient.ContextCalls())
func (mock *TSSDSignClientMock) ContextCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockContext.RLock()
	calls = mock.calls.Context
	mock.lockContext.RUnlock()
	return calls
}

// Header calls HeaderFunc.
func (mock *TSSDSignClientMock) Header() (metadata.MD, error) {
	if mock.HeaderFunc == nil {
		panic("TSSDSignClientMock.HeaderFunc: method is nil but TSSDSignClient.Header was just called")
	}
	callInfo := struct {
	}{}
	mock.lockHeader.Lock()
	mock.calls.Header = append(mock.calls.Header, callInfo)
	mock.lockHeader.Unlock()
	return mock.HeaderFunc()
}

// HeaderCalls gets all the calls that were made to Header.
// Check the length with:
//     len(mockedTSSDSignClient.HeaderCalls())
func (mock *TSSDSignClientMock) HeaderCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockHeader.RLock()
	calls = mock.calls.Header
	mock.lockHeader.RUnlock()
	return calls
}

// Recv calls RecvFunc.
func (mock *TSSDSignClientMock) Recv() (*tofnd.MessageOut, error) {
	if mock.RecvFunc == nil {
		panic("TSSDSignClientMock.RecvFunc: method is nil but TSSDSignClient.Recv was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRecv.Lock()
	mock.calls.Recv = append(mock.calls.Recv, callInfo)
	mock.lockRecv.Unlock()
	return mock.RecvFunc()
}

// RecvCalls gets all the calls that were made to Recv.
// Check the length with:
//     len(mockedTSSDSignClient.RecvCalls())
func (mock *TSSDSignClientMock) RecvCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRecv.RLock()
	calls = mock.calls.Recv
	mock.lockRecv.RUnlock()
	return calls
}

// RecvMsg calls RecvMsgFunc.
func (mock *TSSDSignClientMock) RecvMsg(m interface{}) error {
	if mock.RecvMsgFunc == nil {
		panic("TSSDSignClientMock.RecvMsgFunc: method is nil but TSSDSignClient.RecvMsg was just called")
	}
	callInfo := struct {
		M interface{}
	}{
		M: m,
	}
	mock.lockRecvMsg.Lock()
	mock.calls.RecvMsg = append(mock.calls.RecvMsg, callInfo)
	mock.lockRecvMsg.Unlock()
	return mock.RecvMsgFunc(m)
}

// RecvMsgCalls gets all the calls that were made to RecvMsg.
// Check the length with:
//     len(mockedTSSDSignClient.RecvMsgCalls())
func (mock *TSSDSignClientMock) RecvMsgCalls() []struct {
	M interface{}
} {
	var calls []struct {
		M interface{}
	}
	mock.lockRecvMsg.RLock()
	calls = mock.calls.RecvMsg
	mock.lockRecvMsg.RUnlock()
	return calls
}

// Send calls SendFunc.
func (mock *TSSDSignClientMock) Send(messageIn *tofnd.MessageIn) error {
	if mock.SendFunc == nil {
		panic("TSSDSignClientMock.SendFunc: method is nil but TSSDSignClient.Send was just called")
	}
	callInfo := struct {
		MessageIn *tofnd.MessageIn
	}{
		MessageIn: messageIn,
	}
	mock.lockSend.Lock()
	mock.calls.Send = append(mock.calls.Send, callInfo)
	mock.lockSend.Unlock()
	return mock.SendFunc(messageIn)
}

// SendCalls gets all the calls that were made to Send.
// Check the length with:
//     len(mockedTSSDSignClient.SendCalls())
func (mock *TSSDSignClientMock) SendCalls() []struct {
	MessageIn *tofnd.MessageIn
} {
	var calls []struct {
		MessageIn *tofnd.MessageIn
	}
	mock.lockSend.RLock()
	calls = mock.calls.Send
	mock.lockSend.RUnlock()
	return calls
}

// SendMsg calls SendMsgFunc.
func (mock *TSSDSignClientMock) SendMsg(m interface{}) error {
	if mock.SendMsgFunc == nil {
		panic("TSSDSignClientMock.SendMsgFunc: method is nil but TSSDSignClient.SendMsg was just called")
	}
	callInfo := struct {
		M interface{}
	}{
		M: m,
	}
	mock.lockSendMsg.Lock()
	mock.calls.SendMsg = append(mock.calls.SendMsg, callInfo)
	mock.lockSendMsg.Unlock()
	return mock.SendMsgFunc(m)
}

// SendMsgCalls gets all the calls that were made to SendMsg.
// Check the length with:
//     len(mockedTSSDSignClient.SendMsgCalls())
func (mock *TSSDSignClientMock) SendMsgCalls() []struct {
	M interface{}
} {
	var calls []struct {
		M interface{}
	}
	mock.lockSendMsg.RLock()
	calls = mock.calls.SendMsg
	mock.lockSendMsg.RUnlock()
	return calls
}

// Trailer calls TrailerFunc.
func (mock *TSSDSignClientMock) Trailer() metadata.MD {
	if mock.TrailerFunc == nil {
		panic("TSSDSignClientMock.TrailerFunc: method is nil but TSSDSignClient.Trailer was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTrailer.Lock()
	mock.calls.Trailer = append(mock.calls.Trailer, callInfo)
	mock.lockTrailer.Unlock()
	return mock.TrailerFunc()
}

// TrailerCalls gets all the calls that were made to Trailer.
// Check the length with:
//     len(mockedTSSDSignClient.TrailerCalls())
func (mock *TSSDSignClientMock) TrailerCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTrailer.RLock()
	calls = mock.calls.Trailer
	mock.lockTrailer.RUnlock()
	return calls
}
