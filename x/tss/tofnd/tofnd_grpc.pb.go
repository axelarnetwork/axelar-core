// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package tofnd

import (
	"context"

	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// GG20Client is the client API for GG20 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GG20Client interface {
	Keygen(ctx context.Context, opts ...grpc.CallOption) (GG20_KeygenClient, error)
	Sign(ctx context.Context, opts ...grpc.CallOption) (GG20_SignClient, error)
	GetKey(ctx context.Context, in *Uid, opts ...grpc.CallOption) (*Bytes, error)
	GetSig(ctx context.Context, in *Uid, opts ...grpc.CallOption) (*Bytes, error)
}

type gG20Client struct {
	cc grpc.ClientConnInterface
}

func NewGG20Client(cc grpc.ClientConnInterface) GG20Client {
	return &gG20Client{cc}
}

var gG20KeygenStreamDesc = &grpc.StreamDesc{
	StreamName:    "Keygen",
	ServerStreams: true,
	ClientStreams: true,
}

func (c *gG20Client) Keygen(ctx context.Context, opts ...grpc.CallOption) (GG20_KeygenClient, error) {
	stream, err := c.cc.NewStream(ctx, gG20KeygenStreamDesc, "/tss.tofnd.v1beta1.GG20/Keygen", opts...)
	if err != nil {
		return nil, err
	}
	x := &gG20KeygenClient{stream}
	return x, nil
}

type GG20_KeygenClient interface {
	Send(*MessageIn) error
	Recv() (*MessageOut, error)
	grpc.ClientStream
}

type gG20KeygenClient struct {
	grpc.ClientStream
}

func (x *gG20KeygenClient) Send(m *MessageIn) error {
	return x.ClientStream.SendMsg(m)
}

func (x *gG20KeygenClient) Recv() (*MessageOut, error) {
	m := new(MessageOut)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var gG20SignStreamDesc = &grpc.StreamDesc{
	StreamName:    "Sign",
	ServerStreams: true,
	ClientStreams: true,
}

func (c *gG20Client) Sign(ctx context.Context, opts ...grpc.CallOption) (GG20_SignClient, error) {
	stream, err := c.cc.NewStream(ctx, gG20SignStreamDesc, "/tss.tofnd.v1beta1.GG20/Sign", opts...)
	if err != nil {
		return nil, err
	}
	x := &gG20SignClient{stream}
	return x, nil
}

type GG20_SignClient interface {
	Send(*MessageIn) error
	Recv() (*MessageOut, error)
	grpc.ClientStream
}

type gG20SignClient struct {
	grpc.ClientStream
}

func (x *gG20SignClient) Send(m *MessageIn) error {
	return x.ClientStream.SendMsg(m)
}

func (x *gG20SignClient) Recv() (*MessageOut, error) {
	m := new(MessageOut)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var gG20GetKeyStreamDesc = &grpc.StreamDesc{
	StreamName: "GetKey",
}

func (c *gG20Client) GetKey(ctx context.Context, in *Uid, opts ...grpc.CallOption) (*Bytes, error) {
	out := new(Bytes)
	err := c.cc.Invoke(ctx, "/tss.tofnd.v1beta1.GG20/GetKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var gG20GetSigStreamDesc = &grpc.StreamDesc{
	StreamName: "GetSig",
}

func (c *gG20Client) GetSig(ctx context.Context, in *Uid, opts ...grpc.CallOption) (*Bytes, error) {
	out := new(Bytes)
	err := c.cc.Invoke(ctx, "/tss.tofnd.v1beta1.GG20/GetSig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GG20Service is the service API for GG20 service.
// Fields should be assigned to their respective handler implementations only before
// RegisterGG20Service is called.  Any unassigned fields will result in the
// handler for that method returning an Unimplemented error.
type GG20Service struct {
	Keygen func(GG20_KeygenServer) error
	Sign   func(GG20_SignServer) error
	GetKey func(context.Context, *Uid) (*Bytes, error)
	GetSig func(context.Context, *Uid) (*Bytes, error)
}

func (s *GG20Service) keygen(_ interface{}, stream grpc.ServerStream) error {
	return s.Keygen(&gG20KeygenServer{stream})
}
func (s *GG20Service) sign(_ interface{}, stream grpc.ServerStream) error {
	return s.Sign(&gG20SignServer{stream})
}
func (s *GG20Service) getKey(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Uid)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.GetKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/tss.tofnd.v1beta1.GG20/GetKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.GetKey(ctx, req.(*Uid))
	}
	return interceptor(ctx, in, info, handler)
}
func (s *GG20Service) getSig(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Uid)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return s.GetSig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     s,
		FullMethod: "/tss.tofnd.v1beta1.GG20/GetSig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return s.GetSig(ctx, req.(*Uid))
	}
	return interceptor(ctx, in, info, handler)
}

type GG20_KeygenServer interface {
	Send(*MessageOut) error
	Recv() (*MessageIn, error)
	grpc.ServerStream
}

type gG20KeygenServer struct {
	grpc.ServerStream
}

func (x *gG20KeygenServer) Send(m *MessageOut) error {
	return x.ServerStream.SendMsg(m)
}

func (x *gG20KeygenServer) Recv() (*MessageIn, error) {
	m := new(MessageIn)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

type GG20_SignServer interface {
	Send(*MessageOut) error
	Recv() (*MessageIn, error)
	grpc.ServerStream
}

type gG20SignServer struct {
	grpc.ServerStream
}

func (x *gG20SignServer) Send(m *MessageOut) error {
	return x.ServerStream.SendMsg(m)
}

func (x *gG20SignServer) Recv() (*MessageIn, error) {
	m := new(MessageIn)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RegisterGG20Service registers a service implementation with a gRPC server.
func RegisterGG20Service(s grpc.ServiceRegistrar, srv *GG20Service) {
	srvCopy := *srv
	if srvCopy.Keygen == nil {
		srvCopy.Keygen = func(GG20_KeygenServer) error {
			return status.Errorf(codes.Unimplemented, "method Keygen not implemented")
		}
	}
	if srvCopy.Sign == nil {
		srvCopy.Sign = func(GG20_SignServer) error {
			return status.Errorf(codes.Unimplemented, "method Sign not implemented")
		}
	}
	if srvCopy.GetKey == nil {
		srvCopy.GetKey = func(context.Context, *Uid) (*Bytes, error) {
			return nil, status.Errorf(codes.Unimplemented, "method GetKey not implemented")
		}
	}
	if srvCopy.GetSig == nil {
		srvCopy.GetSig = func(context.Context, *Uid) (*Bytes, error) {
			return nil, status.Errorf(codes.Unimplemented, "method GetSig not implemented")
		}
	}
	sd := grpc.ServiceDesc{
		ServiceName: "tss.tofnd.v1beta1.GG20",
		Methods: []grpc.MethodDesc{
			{
				MethodName: "GetKey",
				Handler:    srvCopy.getKey,
			},
			{
				MethodName: "GetSig",
				Handler:    srvCopy.getSig,
			},
		},
		Streams: []grpc.StreamDesc{
			{
				StreamName:    "Keygen",
				Handler:       srvCopy.keygen,
				ServerStreams: true,
				ClientStreams: true,
			},
			{
				StreamName:    "Sign",
				Handler:       srvCopy.sign,
				ServerStreams: true,
				ClientStreams: true,
			},
		},
		Metadata: "proto/tss/tofnd/v1beta1/tofnd.proto",
	}

	s.RegisterService(&sd, nil)
}

// NewGG20Service creates a new GG20Service containing the
// implemented methods of the GG20 service in s.  Any unimplemented
// methods will result in the gRPC server returning an UNIMPLEMENTED status to the client.
// This includes situations where the method handler is misspelled or has the wrong
// signature.  For this reason, this function should be used with great care and
// is not recommended to be used by most users.
func NewGG20Service(s interface{}) *GG20Service {
	ns := &GG20Service{}
	if h, ok := s.(interface{ Keygen(GG20_KeygenServer) error }); ok {
		ns.Keygen = h.Keygen
	}
	if h, ok := s.(interface{ Sign(GG20_SignServer) error }); ok {
		ns.Sign = h.Sign
	}
	if h, ok := s.(interface {
		GetKey(context.Context, *Uid) (*Bytes, error)
	}); ok {
		ns.GetKey = h.GetKey
	}
	if h, ok := s.(interface {
		GetSig(context.Context, *Uid) (*Bytes, error)
	}); ok {
		ns.GetSig = h.GetSig
	}
	return ns
}

// UnstableGG20Service is the service API for GG20 service.
// New methods may be added to this interface if they are added to the service
// definition, which is not a backward-compatible change.  For this reason,
// use of this type is not recommended.
type UnstableGG20Service interface {
	Keygen(GG20_KeygenServer) error
	Sign(GG20_SignServer) error
	GetKey(context.Context, *Uid) (*Bytes, error)
	GetSig(context.Context, *Uid) (*Bytes, error)
}
