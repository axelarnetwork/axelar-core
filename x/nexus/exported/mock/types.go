// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"github.com/axelarnetwork/axelar-core/x/nexus/exported"
	types "github.com/cosmos/cosmos-sdk/types"
	"sync"
)

// Ensure, that MaintainerStateMock does implement exported.MaintainerState.
// If this is not the case, regenerate this file with moq.
var _ exported.MaintainerState = &MaintainerStateMock{}

// MaintainerStateMock is a mock implementation of exported.MaintainerState.
//
// 	func TestSomethingThatUsesMaintainerState(t *testing.T) {
//
// 		// make and configure a mocked exported.MaintainerState
// 		mockedMaintainerState := &MaintainerStateMock{
// 			CountIncorrectVotesFunc: func(window int) uint64 {
// 				panic("mock out the CountIncorrectVotes method")
// 			},
// 			CountMissingVotesFunc: func(window int) uint64 {
// 				panic("mock out the CountMissingVotes method")
// 			},
// 			GetAddressFunc: func() types.ValAddress {
// 				panic("mock out the GetAddress method")
// 			},
// 			MarkIncorrectVoteFunc: func(incorrectVote bool)  {
// 				panic("mock out the MarkIncorrectVote method")
// 			},
// 			MarkMissingVoteFunc: func(missingVote bool)  {
// 				panic("mock out the MarkMissingVote method")
// 			},
// 			MarshalFunc: func() ([]byte, error) {
// 				panic("mock out the Marshal method")
// 			},
// 			MarshalToFunc: func(data []byte) (int, error) {
// 				panic("mock out the MarshalTo method")
// 			},
// 			MarshalToSizedBufferFunc: func(dAtA []byte) (int, error) {
// 				panic("mock out the MarshalToSizedBuffer method")
// 			},
// 			ProtoMessageFunc: func()  {
// 				panic("mock out the ProtoMessage method")
// 			},
// 			ResetFunc: func()  {
// 				panic("mock out the Reset method")
// 			},
// 			SizeFunc: func() int {
// 				panic("mock out the Size method")
// 			},
// 			StringFunc: func() string {
// 				panic("mock out the String method")
// 			},
// 			UnmarshalFunc: func(data []byte) error {
// 				panic("mock out the Unmarshal method")
// 			},
// 		}
//
// 		// use mockedMaintainerState in code that requires exported.MaintainerState
// 		// and then make assertions.
//
// 	}
type MaintainerStateMock struct {
	// CountIncorrectVotesFunc mocks the CountIncorrectVotes method.
	CountIncorrectVotesFunc func(window int) uint64

	// CountMissingVotesFunc mocks the CountMissingVotes method.
	CountMissingVotesFunc func(window int) uint64

	// GetAddressFunc mocks the GetAddress method.
	GetAddressFunc func() types.ValAddress

	// MarkIncorrectVoteFunc mocks the MarkIncorrectVote method.
	MarkIncorrectVoteFunc func(incorrectVote bool)

	// MarkMissingVoteFunc mocks the MarkMissingVote method.
	MarkMissingVoteFunc func(missingVote bool)

	// MarshalFunc mocks the Marshal method.
	MarshalFunc func() ([]byte, error)

	// MarshalToFunc mocks the MarshalTo method.
	MarshalToFunc func(data []byte) (int, error)

	// MarshalToSizedBufferFunc mocks the MarshalToSizedBuffer method.
	MarshalToSizedBufferFunc func(dAtA []byte) (int, error)

	// ProtoMessageFunc mocks the ProtoMessage method.
	ProtoMessageFunc func()

	// ResetFunc mocks the Reset method.
	ResetFunc func()

	// SizeFunc mocks the Size method.
	SizeFunc func() int

	// StringFunc mocks the String method.
	StringFunc func() string

	// UnmarshalFunc mocks the Unmarshal method.
	UnmarshalFunc func(data []byte) error

	// calls tracks calls to the methods.
	calls struct {
		// CountIncorrectVotes holds details about calls to the CountIncorrectVotes method.
		CountIncorrectVotes []struct {
			// Window is the window argument value.
			Window int
		}
		// CountMissingVotes holds details about calls to the CountMissingVotes method.
		CountMissingVotes []struct {
			// Window is the window argument value.
			Window int
		}
		// GetAddress holds details about calls to the GetAddress method.
		GetAddress []struct {
		}
		// MarkIncorrectVote holds details about calls to the MarkIncorrectVote method.
		MarkIncorrectVote []struct {
			// IncorrectVote is the incorrectVote argument value.
			IncorrectVote bool
		}
		// MarkMissingVote holds details about calls to the MarkMissingVote method.
		MarkMissingVote []struct {
			// MissingVote is the missingVote argument value.
			MissingVote bool
		}
		// Marshal holds details about calls to the Marshal method.
		Marshal []struct {
		}
		// MarshalTo holds details about calls to the MarshalTo method.
		MarshalTo []struct {
			// Data is the data argument value.
			Data []byte
		}
		// MarshalToSizedBuffer holds details about calls to the MarshalToSizedBuffer method.
		MarshalToSizedBuffer []struct {
			// DAtA is the dAtA argument value.
			DAtA []byte
		}
		// ProtoMessage holds details about calls to the ProtoMessage method.
		ProtoMessage []struct {
		}
		// Reset holds details about calls to the Reset method.
		Reset []struct {
		}
		// Size holds details about calls to the Size method.
		Size []struct {
		}
		// String holds details about calls to the String method.
		String []struct {
		}
		// Unmarshal holds details about calls to the Unmarshal method.
		Unmarshal []struct {
			// Data is the data argument value.
			Data []byte
		}
	}
	lockCountIncorrectVotes  sync.RWMutex
	lockCountMissingVotes    sync.RWMutex
	lockGetAddress           sync.RWMutex
	lockMarkIncorrectVote    sync.RWMutex
	lockMarkMissingVote      sync.RWMutex
	lockMarshal              sync.RWMutex
	lockMarshalTo            sync.RWMutex
	lockMarshalToSizedBuffer sync.RWMutex
	lockProtoMessage         sync.RWMutex
	lockReset                sync.RWMutex
	lockSize                 sync.RWMutex
	lockString               sync.RWMutex
	lockUnmarshal            sync.RWMutex
}

// CountIncorrectVotes calls CountIncorrectVotesFunc.
func (mock *MaintainerStateMock) CountIncorrectVotes(window int) uint64 {
	if mock.CountIncorrectVotesFunc == nil {
		panic("MaintainerStateMock.CountIncorrectVotesFunc: method is nil but MaintainerState.CountIncorrectVotes was just called")
	}
	callInfo := struct {
		Window int
	}{
		Window: window,
	}
	mock.lockCountIncorrectVotes.Lock()
	mock.calls.CountIncorrectVotes = append(mock.calls.CountIncorrectVotes, callInfo)
	mock.lockCountIncorrectVotes.Unlock()
	return mock.CountIncorrectVotesFunc(window)
}

// CountIncorrectVotesCalls gets all the calls that were made to CountIncorrectVotes.
// Check the length with:
//     len(mockedMaintainerState.CountIncorrectVotesCalls())
func (mock *MaintainerStateMock) CountIncorrectVotesCalls() []struct {
	Window int
} {
	var calls []struct {
		Window int
	}
	mock.lockCountIncorrectVotes.RLock()
	calls = mock.calls.CountIncorrectVotes
	mock.lockCountIncorrectVotes.RUnlock()
	return calls
}

// CountMissingVotes calls CountMissingVotesFunc.
func (mock *MaintainerStateMock) CountMissingVotes(window int) uint64 {
	if mock.CountMissingVotesFunc == nil {
		panic("MaintainerStateMock.CountMissingVotesFunc: method is nil but MaintainerState.CountMissingVotes was just called")
	}
	callInfo := struct {
		Window int
	}{
		Window: window,
	}
	mock.lockCountMissingVotes.Lock()
	mock.calls.CountMissingVotes = append(mock.calls.CountMissingVotes, callInfo)
	mock.lockCountMissingVotes.Unlock()
	return mock.CountMissingVotesFunc(window)
}

// CountMissingVotesCalls gets all the calls that were made to CountMissingVotes.
// Check the length with:
//     len(mockedMaintainerState.CountMissingVotesCalls())
func (mock *MaintainerStateMock) CountMissingVotesCalls() []struct {
	Window int
} {
	var calls []struct {
		Window int
	}
	mock.lockCountMissingVotes.RLock()
	calls = mock.calls.CountMissingVotes
	mock.lockCountMissingVotes.RUnlock()
	return calls
}

// GetAddress calls GetAddressFunc.
func (mock *MaintainerStateMock) GetAddress() types.ValAddress {
	if mock.GetAddressFunc == nil {
		panic("MaintainerStateMock.GetAddressFunc: method is nil but MaintainerState.GetAddress was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetAddress.Lock()
	mock.calls.GetAddress = append(mock.calls.GetAddress, callInfo)
	mock.lockGetAddress.Unlock()
	return mock.GetAddressFunc()
}

// GetAddressCalls gets all the calls that were made to GetAddress.
// Check the length with:
//     len(mockedMaintainerState.GetAddressCalls())
func (mock *MaintainerStateMock) GetAddressCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetAddress.RLock()
	calls = mock.calls.GetAddress
	mock.lockGetAddress.RUnlock()
	return calls
}

// MarkIncorrectVote calls MarkIncorrectVoteFunc.
func (mock *MaintainerStateMock) MarkIncorrectVote(incorrectVote bool) {
	if mock.MarkIncorrectVoteFunc == nil {
		panic("MaintainerStateMock.MarkIncorrectVoteFunc: method is nil but MaintainerState.MarkIncorrectVote was just called")
	}
	callInfo := struct {
		IncorrectVote bool
	}{
		IncorrectVote: incorrectVote,
	}
	mock.lockMarkIncorrectVote.Lock()
	mock.calls.MarkIncorrectVote = append(mock.calls.MarkIncorrectVote, callInfo)
	mock.lockMarkIncorrectVote.Unlock()
	mock.MarkIncorrectVoteFunc(incorrectVote)
}

// MarkIncorrectVoteCalls gets all the calls that were made to MarkIncorrectVote.
// Check the length with:
//     len(mockedMaintainerState.MarkIncorrectVoteCalls())
func (mock *MaintainerStateMock) MarkIncorrectVoteCalls() []struct {
	IncorrectVote bool
} {
	var calls []struct {
		IncorrectVote bool
	}
	mock.lockMarkIncorrectVote.RLock()
	calls = mock.calls.MarkIncorrectVote
	mock.lockMarkIncorrectVote.RUnlock()
	return calls
}

// MarkMissingVote calls MarkMissingVoteFunc.
func (mock *MaintainerStateMock) MarkMissingVote(missingVote bool) {
	if mock.MarkMissingVoteFunc == nil {
		panic("MaintainerStateMock.MarkMissingVoteFunc: method is nil but MaintainerState.MarkMissingVote was just called")
	}
	callInfo := struct {
		MissingVote bool
	}{
		MissingVote: missingVote,
	}
	mock.lockMarkMissingVote.Lock()
	mock.calls.MarkMissingVote = append(mock.calls.MarkMissingVote, callInfo)
	mock.lockMarkMissingVote.Unlock()
	mock.MarkMissingVoteFunc(missingVote)
}

// MarkMissingVoteCalls gets all the calls that were made to MarkMissingVote.
// Check the length with:
//     len(mockedMaintainerState.MarkMissingVoteCalls())
func (mock *MaintainerStateMock) MarkMissingVoteCalls() []struct {
	MissingVote bool
} {
	var calls []struct {
		MissingVote bool
	}
	mock.lockMarkMissingVote.RLock()
	calls = mock.calls.MarkMissingVote
	mock.lockMarkMissingVote.RUnlock()
	return calls
}

// Marshal calls MarshalFunc.
func (mock *MaintainerStateMock) Marshal() ([]byte, error) {
	if mock.MarshalFunc == nil {
		panic("MaintainerStateMock.MarshalFunc: method is nil but MaintainerState.Marshal was just called")
	}
	callInfo := struct {
	}{}
	mock.lockMarshal.Lock()
	mock.calls.Marshal = append(mock.calls.Marshal, callInfo)
	mock.lockMarshal.Unlock()
	return mock.MarshalFunc()
}

// MarshalCalls gets all the calls that were made to Marshal.
// Check the length with:
//     len(mockedMaintainerState.MarshalCalls())
func (mock *MaintainerStateMock) MarshalCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockMarshal.RLock()
	calls = mock.calls.Marshal
	mock.lockMarshal.RUnlock()
	return calls
}

// MarshalTo calls MarshalToFunc.
func (mock *MaintainerStateMock) MarshalTo(data []byte) (int, error) {
	if mock.MarshalToFunc == nil {
		panic("MaintainerStateMock.MarshalToFunc: method is nil but MaintainerState.MarshalTo was just called")
	}
	callInfo := struct {
		Data []byte
	}{
		Data: data,
	}
	mock.lockMarshalTo.Lock()
	mock.calls.MarshalTo = append(mock.calls.MarshalTo, callInfo)
	mock.lockMarshalTo.Unlock()
	return mock.MarshalToFunc(data)
}

// MarshalToCalls gets all the calls that were made to MarshalTo.
// Check the length with:
//     len(mockedMaintainerState.MarshalToCalls())
func (mock *MaintainerStateMock) MarshalToCalls() []struct {
	Data []byte
} {
	var calls []struct {
		Data []byte
	}
	mock.lockMarshalTo.RLock()
	calls = mock.calls.MarshalTo
	mock.lockMarshalTo.RUnlock()
	return calls
}

// MarshalToSizedBuffer calls MarshalToSizedBufferFunc.
func (mock *MaintainerStateMock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if mock.MarshalToSizedBufferFunc == nil {
		panic("MaintainerStateMock.MarshalToSizedBufferFunc: method is nil but MaintainerState.MarshalToSizedBuffer was just called")
	}
	callInfo := struct {
		DAtA []byte
	}{
		DAtA: dAtA,
	}
	mock.lockMarshalToSizedBuffer.Lock()
	mock.calls.MarshalToSizedBuffer = append(mock.calls.MarshalToSizedBuffer, callInfo)
	mock.lockMarshalToSizedBuffer.Unlock()
	return mock.MarshalToSizedBufferFunc(dAtA)
}

// MarshalToSizedBufferCalls gets all the calls that were made to MarshalToSizedBuffer.
// Check the length with:
//     len(mockedMaintainerState.MarshalToSizedBufferCalls())
func (mock *MaintainerStateMock) MarshalToSizedBufferCalls() []struct {
	DAtA []byte
} {
	var calls []struct {
		DAtA []byte
	}
	mock.lockMarshalToSizedBuffer.RLock()
	calls = mock.calls.MarshalToSizedBuffer
	mock.lockMarshalToSizedBuffer.RUnlock()
	return calls
}

// ProtoMessage calls ProtoMessageFunc.
func (mock *MaintainerStateMock) ProtoMessage() {
	if mock.ProtoMessageFunc == nil {
		panic("MaintainerStateMock.ProtoMessageFunc: method is nil but MaintainerState.ProtoMessage was just called")
	}
	callInfo := struct {
	}{}
	mock.lockProtoMessage.Lock()
	mock.calls.ProtoMessage = append(mock.calls.ProtoMessage, callInfo)
	mock.lockProtoMessage.Unlock()
	mock.ProtoMessageFunc()
}

// ProtoMessageCalls gets all the calls that were made to ProtoMessage.
// Check the length with:
//     len(mockedMaintainerState.ProtoMessageCalls())
func (mock *MaintainerStateMock) ProtoMessageCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockProtoMessage.RLock()
	calls = mock.calls.ProtoMessage
	mock.lockProtoMessage.RUnlock()
	return calls
}

// Reset calls ResetFunc.
func (mock *MaintainerStateMock) Reset() {
	if mock.ResetFunc == nil {
		panic("MaintainerStateMock.ResetFunc: method is nil but MaintainerState.Reset was just called")
	}
	callInfo := struct {
	}{}
	mock.lockReset.Lock()
	mock.calls.Reset = append(mock.calls.Reset, callInfo)
	mock.lockReset.Unlock()
	mock.ResetFunc()
}

// ResetCalls gets all the calls that were made to Reset.
// Check the length with:
//     len(mockedMaintainerState.ResetCalls())
func (mock *MaintainerStateMock) ResetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockReset.RLock()
	calls = mock.calls.Reset
	mock.lockReset.RUnlock()
	return calls
}

// Size calls SizeFunc.
func (mock *MaintainerStateMock) Size() int {
	if mock.SizeFunc == nil {
		panic("MaintainerStateMock.SizeFunc: method is nil but MaintainerState.Size was just called")
	}
	callInfo := struct {
	}{}
	mock.lockSize.Lock()
	mock.calls.Size = append(mock.calls.Size, callInfo)
	mock.lockSize.Unlock()
	return mock.SizeFunc()
}

// SizeCalls gets all the calls that were made to Size.
// Check the length with:
//     len(mockedMaintainerState.SizeCalls())
func (mock *MaintainerStateMock) SizeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockSize.RLock()
	calls = mock.calls.Size
	mock.lockSize.RUnlock()
	return calls
}

// String calls StringFunc.
func (mock *MaintainerStateMock) String() string {
	if mock.StringFunc == nil {
		panic("MaintainerStateMock.StringFunc: method is nil but MaintainerState.String was just called")
	}
	callInfo := struct {
	}{}
	mock.lockString.Lock()
	mock.calls.String = append(mock.calls.String, callInfo)
	mock.lockString.Unlock()
	return mock.StringFunc()
}

// StringCalls gets all the calls that were made to String.
// Check the length with:
//     len(mockedMaintainerState.StringCalls())
func (mock *MaintainerStateMock) StringCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockString.RLock()
	calls = mock.calls.String
	mock.lockString.RUnlock()
	return calls
}

// Unmarshal calls UnmarshalFunc.
func (mock *MaintainerStateMock) Unmarshal(data []byte) error {
	if mock.UnmarshalFunc == nil {
		panic("MaintainerStateMock.UnmarshalFunc: method is nil but MaintainerState.Unmarshal was just called")
	}
	callInfo := struct {
		Data []byte
	}{
		Data: data,
	}
	mock.lockUnmarshal.Lock()
	mock.calls.Unmarshal = append(mock.calls.Unmarshal, callInfo)
	mock.lockUnmarshal.Unlock()
	return mock.UnmarshalFunc(data)
}

// UnmarshalCalls gets all the calls that were made to Unmarshal.
// Check the length with:
//     len(mockedMaintainerState.UnmarshalCalls())
func (mock *MaintainerStateMock) UnmarshalCalls() []struct {
	Data []byte
} {
	var calls []struct {
		Data []byte
	}
	mock.lockUnmarshal.RLock()
	calls = mock.calls.Unmarshal
	mock.lockUnmarshal.RUnlock()
	return calls
}
