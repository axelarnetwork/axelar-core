// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"github.com/axelarnetwork/axelar-core/x/nexus/exported"
	types "github.com/cosmos/cosmos-sdk/types"
	"sync"
)

// Ensure, that MaintainerStateMock does implement exported.MaintainerState.
// If this is not the case, regenerate this file with moq.
var _ exported.MaintainerState = &MaintainerStateMock{}

// MaintainerStateMock is a mock implementation of exported.MaintainerState.
//
//	func TestSomethingThatUsesMaintainerState(t *testing.T) {
//
//		// make and configure a mocked exported.MaintainerState
//		mockedMaintainerState := &MaintainerStateMock{
//			CountIncorrectVotesFunc: func(window int) uint64 {
//				panic("mock out the CountIncorrectVotes method")
//			},
//			CountMissingVotesFunc: func(window int) uint64 {
//				panic("mock out the CountMissingVotes method")
//			},
//			GetAddressFunc: func() types.ValAddress {
//				panic("mock out the GetAddress method")
//			},
//			MarkIncorrectVoteFunc: func(incorrectVote bool)  {
//				panic("mock out the MarkIncorrectVote method")
//			},
//			MarkMissingVoteFunc: func(missingVote bool)  {
//				panic("mock out the MarkMissingVote method")
//			},
//			MarshalFunc: func() ([]byte, error) {
//				panic("mock out the Marshal method")
//			},
//			MarshalToFunc: func(data []byte) (int, error) {
//				panic("mock out the MarshalTo method")
//			},
//			MarshalToSizedBufferFunc: func(dAtA []byte) (int, error) {
//				panic("mock out the MarshalToSizedBuffer method")
//			},
//			ProtoMessageFunc: func()  {
//				panic("mock out the ProtoMessage method")
//			},
//			ResetFunc: func()  {
//				panic("mock out the Reset method")
//			},
//			SizeFunc: func() int {
//				panic("mock out the Size method")
//			},
//			StringFunc: func() string {
//				panic("mock out the String method")
//			},
//			UnmarshalFunc: func(data []byte) error {
//				panic("mock out the Unmarshal method")
//			},
//		}
//
//		// use mockedMaintainerState in code that requires exported.MaintainerState
//		// and then make assertions.
//
//	}
type MaintainerStateMock struct {
	// CountIncorrectVotesFunc mocks the CountIncorrectVotes method.
	CountIncorrectVotesFunc func(window int) uint64

	// CountMissingVotesFunc mocks the CountMissingVotes method.
	CountMissingVotesFunc func(window int) uint64

	// GetAddressFunc mocks the GetAddress method.
	GetAddressFunc func() types.ValAddress

	// MarkIncorrectVoteFunc mocks the MarkIncorrectVote method.
	MarkIncorrectVoteFunc func(incorrectVote bool)

	// MarkMissingVoteFunc mocks the MarkMissingVote method.
	MarkMissingVoteFunc func(missingVote bool)

	// MarshalFunc mocks the Marshal method.
	MarshalFunc func() ([]byte, error)

	// MarshalToFunc mocks the MarshalTo method.
	MarshalToFunc func(data []byte) (int, error)

	// MarshalToSizedBufferFunc mocks the MarshalToSizedBuffer method.
	MarshalToSizedBufferFunc func(dAtA []byte) (int, error)

	// ProtoMessageFunc mocks the ProtoMessage method.
	ProtoMessageFunc func()

	// ResetFunc mocks the Reset method.
	ResetFunc func()

	// SizeFunc mocks the Size method.
	SizeFunc func() int

	// StringFunc mocks the String method.
	StringFunc func() string

	// UnmarshalFunc mocks the Unmarshal method.
	UnmarshalFunc func(data []byte) error

	// calls tracks calls to the methods.
	calls struct {
		// CountIncorrectVotes holds details about calls to the CountIncorrectVotes method.
		CountIncorrectVotes []struct {
			// Window is the window argument value.
			Window int
		}
		// CountMissingVotes holds details about calls to the CountMissingVotes method.
		CountMissingVotes []struct {
			// Window is the window argument value.
			Window int
		}
		// GetAddress holds details about calls to the GetAddress method.
		GetAddress []struct {
		}
		// MarkIncorrectVote holds details about calls to the MarkIncorrectVote method.
		MarkIncorrectVote []struct {
			// IncorrectVote is the incorrectVote argument value.
			IncorrectVote bool
		}
		// MarkMissingVote holds details about calls to the MarkMissingVote method.
		MarkMissingVote []struct {
			// MissingVote is the missingVote argument value.
			MissingVote bool
		}
		// Marshal holds details about calls to the Marshal method.
		Marshal []struct {
		}
		// MarshalTo holds details about calls to the MarshalTo method.
		MarshalTo []struct {
			// Data is the data argument value.
			Data []byte
		}
		// MarshalToSizedBuffer holds details about calls to the MarshalToSizedBuffer method.
		MarshalToSizedBuffer []struct {
			// DAtA is the dAtA argument value.
			DAtA []byte
		}
		// ProtoMessage holds details about calls to the ProtoMessage method.
		ProtoMessage []struct {
		}
		// Reset holds details about calls to the Reset method.
		Reset []struct {
		}
		// Size holds details about calls to the Size method.
		Size []struct {
		}
		// String holds details about calls to the String method.
		String []struct {
		}
		// Unmarshal holds details about calls to the Unmarshal method.
		Unmarshal []struct {
			// Data is the data argument value.
			Data []byte
		}
	}
	lockCountIncorrectVotes  sync.RWMutex
	lockCountMissingVotes    sync.RWMutex
	lockGetAddress           sync.RWMutex
	lockMarkIncorrectVote    sync.RWMutex
	lockMarkMissingVote      sync.RWMutex
	lockMarshal              sync.RWMutex
	lockMarshalTo            sync.RWMutex
	lockMarshalToSizedBuffer sync.RWMutex
	lockProtoMessage         sync.RWMutex
	lockReset                sync.RWMutex
	lockSize                 sync.RWMutex
	lockString               sync.RWMutex
	lockUnmarshal            sync.RWMutex
}

// CountIncorrectVotes calls CountIncorrectVotesFunc.
func (mock *MaintainerStateMock) CountIncorrectVotes(window int) uint64 {
	if mock.CountIncorrectVotesFunc == nil {
		panic("MaintainerStateMock.CountIncorrectVotesFunc: method is nil but MaintainerState.CountIncorrectVotes was just called")
	}
	callInfo := struct {
		Window int
	}{
		Window: window,
	}
	mock.lockCountIncorrectVotes.Lock()
	mock.calls.CountIncorrectVotes = append(mock.calls.CountIncorrectVotes, callInfo)
	mock.lockCountIncorrectVotes.Unlock()
	return mock.CountIncorrectVotesFunc(window)
}

// CountIncorrectVotesCalls gets all the calls that were made to CountIncorrectVotes.
// Check the length with:
//
//	len(mockedMaintainerState.CountIncorrectVotesCalls())
func (mock *MaintainerStateMock) CountIncorrectVotesCalls() []struct {
	Window int
} {
	var calls []struct {
		Window int
	}
	mock.lockCountIncorrectVotes.RLock()
	calls = mock.calls.CountIncorrectVotes
	mock.lockCountIncorrectVotes.RUnlock()
	return calls
}

// CountMissingVotes calls CountMissingVotesFunc.
func (mock *MaintainerStateMock) CountMissingVotes(window int) uint64 {
	if mock.CountMissingVotesFunc == nil {
		panic("MaintainerStateMock.CountMissingVotesFunc: method is nil but MaintainerState.CountMissingVotes was just called")
	}
	callInfo := struct {
		Window int
	}{
		Window: window,
	}
	mock.lockCountMissingVotes.Lock()
	mock.calls.CountMissingVotes = append(mock.calls.CountMissingVotes, callInfo)
	mock.lockCountMissingVotes.Unlock()
	return mock.CountMissingVotesFunc(window)
}

// CountMissingVotesCalls gets all the calls that were made to CountMissingVotes.
// Check the length with:
//
//	len(mockedMaintainerState.CountMissingVotesCalls())
func (mock *MaintainerStateMock) CountMissingVotesCalls() []struct {
	Window int
} {
	var calls []struct {
		Window int
	}
	mock.lockCountMissingVotes.RLock()
	calls = mock.calls.CountMissingVotes
	mock.lockCountMissingVotes.RUnlock()
	return calls
}

// GetAddress calls GetAddressFunc.
func (mock *MaintainerStateMock) GetAddress() types.ValAddress {
	if mock.GetAddressFunc == nil {
		panic("MaintainerStateMock.GetAddressFunc: method is nil but MaintainerState.GetAddress was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetAddress.Lock()
	mock.calls.GetAddress = append(mock.calls.GetAddress, callInfo)
	mock.lockGetAddress.Unlock()
	return mock.GetAddressFunc()
}

// GetAddressCalls gets all the calls that were made to GetAddress.
// Check the length with:
//
//	len(mockedMaintainerState.GetAddressCalls())
func (mock *MaintainerStateMock) GetAddressCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetAddress.RLock()
	calls = mock.calls.GetAddress
	mock.lockGetAddress.RUnlock()
	return calls
}

// MarkIncorrectVote calls MarkIncorrectVoteFunc.
func (mock *MaintainerStateMock) MarkIncorrectVote(incorrectVote bool) {
	if mock.MarkIncorrectVoteFunc == nil {
		panic("MaintainerStateMock.MarkIncorrectVoteFunc: method is nil but MaintainerState.MarkIncorrectVote was just called")
	}
	callInfo := struct {
		IncorrectVote bool
	}{
		IncorrectVote: incorrectVote,
	}
	mock.lockMarkIncorrectVote.Lock()
	mock.calls.MarkIncorrectVote = append(mock.calls.MarkIncorrectVote, callInfo)
	mock.lockMarkIncorrectVote.Unlock()
	mock.MarkIncorrectVoteFunc(incorrectVote)
}

// MarkIncorrectVoteCalls gets all the calls that were made to MarkIncorrectVote.
// Check the length with:
//
//	len(mockedMaintainerState.MarkIncorrectVoteCalls())
func (mock *MaintainerStateMock) MarkIncorrectVoteCalls() []struct {
	IncorrectVote bool
} {
	var calls []struct {
		IncorrectVote bool
	}
	mock.lockMarkIncorrectVote.RLock()
	calls = mock.calls.MarkIncorrectVote
	mock.lockMarkIncorrectVote.RUnlock()
	return calls
}

// MarkMissingVote calls MarkMissingVoteFunc.
func (mock *MaintainerStateMock) MarkMissingVote(missingVote bool) {
	if mock.MarkMissingVoteFunc == nil {
		panic("MaintainerStateMock.MarkMissingVoteFunc: method is nil but MaintainerState.MarkMissingVote was just called")
	}
	callInfo := struct {
		MissingVote bool
	}{
		MissingVote: missingVote,
	}
	mock.lockMarkMissingVote.Lock()
	mock.calls.MarkMissingVote = append(mock.calls.MarkMissingVote, callInfo)
	mock.lockMarkMissingVote.Unlock()
	mock.MarkMissingVoteFunc(missingVote)
}

// MarkMissingVoteCalls gets all the calls that were made to MarkMissingVote.
// Check the length with:
//
//	len(mockedMaintainerState.MarkMissingVoteCalls())
func (mock *MaintainerStateMock) MarkMissingVoteCalls() []struct {
	MissingVote bool
} {
	var calls []struct {
		MissingVote bool
	}
	mock.lockMarkMissingVote.RLock()
	calls = mock.calls.MarkMissingVote
	mock.lockMarkMissingVote.RUnlock()
	return calls
}

// Marshal calls MarshalFunc.
func (mock *MaintainerStateMock) Marshal() ([]byte, error) {
	if mock.MarshalFunc == nil {
		panic("MaintainerStateMock.MarshalFunc: method is nil but MaintainerState.Marshal was just called")
	}
	callInfo := struct {
	}{}
	mock.lockMarshal.Lock()
	mock.calls.Marshal = append(mock.calls.Marshal, callInfo)
	mock.lockMarshal.Unlock()
	return mock.MarshalFunc()
}

// MarshalCalls gets all the calls that were made to Marshal.
// Check the length with:
//
//	len(mockedMaintainerState.MarshalCalls())
func (mock *MaintainerStateMock) MarshalCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockMarshal.RLock()
	calls = mock.calls.Marshal
	mock.lockMarshal.RUnlock()
	return calls
}

// MarshalTo calls MarshalToFunc.
func (mock *MaintainerStateMock) MarshalTo(data []byte) (int, error) {
	if mock.MarshalToFunc == nil {
		panic("MaintainerStateMock.MarshalToFunc: method is nil but MaintainerState.MarshalTo was just called")
	}
	callInfo := struct {
		Data []byte
	}{
		Data: data,
	}
	mock.lockMarshalTo.Lock()
	mock.calls.MarshalTo = append(mock.calls.MarshalTo, callInfo)
	mock.lockMarshalTo.Unlock()
	return mock.MarshalToFunc(data)
}

// MarshalToCalls gets all the calls that were made to MarshalTo.
// Check the length with:
//
//	len(mockedMaintainerState.MarshalToCalls())
func (mock *MaintainerStateMock) MarshalToCalls() []struct {
	Data []byte
} {
	var calls []struct {
		Data []byte
	}
	mock.lockMarshalTo.RLock()
	calls = mock.calls.MarshalTo
	mock.lockMarshalTo.RUnlock()
	return calls
}

// MarshalToSizedBuffer calls MarshalToSizedBufferFunc.
func (mock *MaintainerStateMock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	if mock.MarshalToSizedBufferFunc == nil {
		panic("MaintainerStateMock.MarshalToSizedBufferFunc: method is nil but MaintainerState.MarshalToSizedBuffer was just called")
	}
	callInfo := struct {
		DAtA []byte
	}{
		DAtA: dAtA,
	}
	mock.lockMarshalToSizedBuffer.Lock()
	mock.calls.MarshalToSizedBuffer = append(mock.calls.MarshalToSizedBuffer, callInfo)
	mock.lockMarshalToSizedBuffer.Unlock()
	return mock.MarshalToSizedBufferFunc(dAtA)
}

// MarshalToSizedBufferCalls gets all the calls that were made to MarshalToSizedBuffer.
// Check the length with:
//
//	len(mockedMaintainerState.MarshalToSizedBufferCalls())
func (mock *MaintainerStateMock) MarshalToSizedBufferCalls() []struct {
	DAtA []byte
} {
	var calls []struct {
		DAtA []byte
	}
	mock.lockMarshalToSizedBuffer.RLock()
	calls = mock.calls.MarshalToSizedBuffer
	mock.lockMarshalToSizedBuffer.RUnlock()
	return calls
}

// ProtoMessage calls ProtoMessageFunc.
func (mock *MaintainerStateMock) ProtoMessage() {
	if mock.ProtoMessageFunc == nil {
		panic("MaintainerStateMock.ProtoMessageFunc: method is nil but MaintainerState.ProtoMessage was just called")
	}
	callInfo := struct {
	}{}
	mock.lockProtoMessage.Lock()
	mock.calls.ProtoMessage = append(mock.calls.ProtoMessage, callInfo)
	mock.lockProtoMessage.Unlock()
	mock.ProtoMessageFunc()
}

// ProtoMessageCalls gets all the calls that were made to ProtoMessage.
// Check the length with:
//
//	len(mockedMaintainerState.ProtoMessageCalls())
func (mock *MaintainerStateMock) ProtoMessageCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockProtoMessage.RLock()
	calls = mock.calls.ProtoMessage
	mock.lockProtoMessage.RUnlock()
	return calls
}

// Reset calls ResetFunc.
func (mock *MaintainerStateMock) Reset() {
	if mock.ResetFunc == nil {
		panic("MaintainerStateMock.ResetFunc: method is nil but MaintainerState.Reset was just called")
	}
	callInfo := struct {
	}{}
	mock.lockReset.Lock()
	mock.calls.Reset = append(mock.calls.Reset, callInfo)
	mock.lockReset.Unlock()
	mock.ResetFunc()
}

// ResetCalls gets all the calls that were made to Reset.
// Check the length with:
//
//	len(mockedMaintainerState.ResetCalls())
func (mock *MaintainerStateMock) ResetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockReset.RLock()
	calls = mock.calls.Reset
	mock.lockReset.RUnlock()
	return calls
}

// Size calls SizeFunc.
func (mock *MaintainerStateMock) Size() int {
	if mock.SizeFunc == nil {
		panic("MaintainerStateMock.SizeFunc: method is nil but MaintainerState.Size was just called")
	}
	callInfo := struct {
	}{}
	mock.lockSize.Lock()
	mock.calls.Size = append(mock.calls.Size, callInfo)
	mock.lockSize.Unlock()
	return mock.SizeFunc()
}

// SizeCalls gets all the calls that were made to Size.
// Check the length with:
//
//	len(mockedMaintainerState.SizeCalls())
func (mock *MaintainerStateMock) SizeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockSize.RLock()
	calls = mock.calls.Size
	mock.lockSize.RUnlock()
	return calls
}

// String calls StringFunc.
func (mock *MaintainerStateMock) String() string {
	if mock.StringFunc == nil {
		panic("MaintainerStateMock.StringFunc: method is nil but MaintainerState.String was just called")
	}
	callInfo := struct {
	}{}
	mock.lockString.Lock()
	mock.calls.String = append(mock.calls.String, callInfo)
	mock.lockString.Unlock()
	return mock.StringFunc()
}

// StringCalls gets all the calls that were made to String.
// Check the length with:
//
//	len(mockedMaintainerState.StringCalls())
func (mock *MaintainerStateMock) StringCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockString.RLock()
	calls = mock.calls.String
	mock.lockString.RUnlock()
	return calls
}

// Unmarshal calls UnmarshalFunc.
func (mock *MaintainerStateMock) Unmarshal(data []byte) error {
	if mock.UnmarshalFunc == nil {
		panic("MaintainerStateMock.UnmarshalFunc: method is nil but MaintainerState.Unmarshal was just called")
	}
	callInfo := struct {
		Data []byte
	}{
		Data: data,
	}
	mock.lockUnmarshal.Lock()
	mock.calls.Unmarshal = append(mock.calls.Unmarshal, callInfo)
	mock.lockUnmarshal.Unlock()
	return mock.UnmarshalFunc(data)
}

// UnmarshalCalls gets all the calls that were made to Unmarshal.
// Check the length with:
//
//	len(mockedMaintainerState.UnmarshalCalls())
func (mock *MaintainerStateMock) UnmarshalCalls() []struct {
	Data []byte
} {
	var calls []struct {
		Data []byte
	}
	mock.lockUnmarshal.RLock()
	calls = mock.calls.Unmarshal
	mock.lockUnmarshal.RUnlock()
	return calls
}

// Ensure, that LockableCoinMock does implement exported.LockableCoin.
// If this is not the case, regenerate this file with moq.
var _ exported.LockableCoin = &LockableCoinMock{}

// LockableCoinMock is a mock implementation of exported.LockableCoin.
//
//	func TestSomethingThatUsesLockableCoin(t *testing.T) {
//
//		// make and configure a mocked exported.LockableCoin
//		mockedLockableCoin := &LockableCoinMock{
//			GetCoinFunc: func() types.Coin {
//				panic("mock out the GetCoin method")
//			},
//			GetOriginalCoinFunc: func(ctx types.Context) types.Coin {
//				panic("mock out the GetOriginalCoin method")
//			},
//			LockFunc: func(ctx types.Context, fromAddr types.AccAddress) error {
//				panic("mock out the Lock method")
//			},
//			SubFunc: func(coin types.Coin) exported.LockableCoin {
//				panic("mock out the Sub method")
//			},
//			UnlockFunc: func(ctx types.Context, toAddr types.AccAddress) error {
//				panic("mock out the Unlock method")
//			},
//		}
//
//		// use mockedLockableCoin in code that requires exported.LockableCoin
//		// and then make assertions.
//
//	}
type LockableCoinMock struct {
	// GetCoinFunc mocks the GetCoin method.
	GetCoinFunc func() types.Coin

	// GetOriginalCoinFunc mocks the GetOriginalCoin method.
	GetOriginalCoinFunc func(ctx types.Context) types.Coin

	// LockFunc mocks the Lock method.
	LockFunc func(ctx types.Context, fromAddr types.AccAddress) error

	// SubFunc mocks the Sub method.
	SubFunc func(coin types.Coin) exported.LockableCoin

	// UnlockFunc mocks the Unlock method.
	UnlockFunc func(ctx types.Context, toAddr types.AccAddress) error

	// calls tracks calls to the methods.
	calls struct {
		// GetCoin holds details about calls to the GetCoin method.
		GetCoin []struct {
		}
		// GetOriginalCoin holds details about calls to the GetOriginalCoin method.
		GetOriginalCoin []struct {
			// Ctx is the ctx argument value.
			Ctx types.Context
		}
		// Lock holds details about calls to the Lock method.
		Lock []struct {
			// Ctx is the ctx argument value.
			Ctx types.Context
			// FromAddr is the fromAddr argument value.
			FromAddr types.AccAddress
		}
		// Sub holds details about calls to the Sub method.
		Sub []struct {
			// Coin is the coin argument value.
			Coin types.Coin
		}
		// Unlock holds details about calls to the Unlock method.
		Unlock []struct {
			// Ctx is the ctx argument value.
			Ctx types.Context
			// ToAddr is the toAddr argument value.
			ToAddr types.AccAddress
		}
	}
	lockGetCoin         sync.RWMutex
	lockGetOriginalCoin sync.RWMutex
	lockLock            sync.RWMutex
	lockSub             sync.RWMutex
	lockUnlock          sync.RWMutex
}

// GetCoin calls GetCoinFunc.
func (mock *LockableCoinMock) GetCoin() types.Coin {
	if mock.GetCoinFunc == nil {
		panic("LockableCoinMock.GetCoinFunc: method is nil but LockableCoin.GetCoin was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetCoin.Lock()
	mock.calls.GetCoin = append(mock.calls.GetCoin, callInfo)
	mock.lockGetCoin.Unlock()
	return mock.GetCoinFunc()
}

// GetCoinCalls gets all the calls that were made to GetCoin.
// Check the length with:
//
//	len(mockedLockableCoin.GetCoinCalls())
func (mock *LockableCoinMock) GetCoinCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetCoin.RLock()
	calls = mock.calls.GetCoin
	mock.lockGetCoin.RUnlock()
	return calls
}

// GetOriginalCoin calls GetOriginalCoinFunc.
func (mock *LockableCoinMock) GetOriginalCoin(ctx types.Context) types.Coin {
	if mock.GetOriginalCoinFunc == nil {
		panic("LockableCoinMock.GetOriginalCoinFunc: method is nil but LockableCoin.GetOriginalCoin was just called")
	}
	callInfo := struct {
		Ctx types.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetOriginalCoin.Lock()
	mock.calls.GetOriginalCoin = append(mock.calls.GetOriginalCoin, callInfo)
	mock.lockGetOriginalCoin.Unlock()
	return mock.GetOriginalCoinFunc(ctx)
}

// GetOriginalCoinCalls gets all the calls that were made to GetOriginalCoin.
// Check the length with:
//
//	len(mockedLockableCoin.GetOriginalCoinCalls())
func (mock *LockableCoinMock) GetOriginalCoinCalls() []struct {
	Ctx types.Context
} {
	var calls []struct {
		Ctx types.Context
	}
	mock.lockGetOriginalCoin.RLock()
	calls = mock.calls.GetOriginalCoin
	mock.lockGetOriginalCoin.RUnlock()
	return calls
}

// Lock calls LockFunc.
func (mock *LockableCoinMock) Lock(ctx types.Context, fromAddr types.AccAddress) error {
	if mock.LockFunc == nil {
		panic("LockableCoinMock.LockFunc: method is nil but LockableCoin.Lock was just called")
	}
	callInfo := struct {
		Ctx      types.Context
		FromAddr types.AccAddress
	}{
		Ctx:      ctx,
		FromAddr: fromAddr,
	}
	mock.lockLock.Lock()
	mock.calls.Lock = append(mock.calls.Lock, callInfo)
	mock.lockLock.Unlock()
	return mock.LockFunc(ctx, fromAddr)
}

// LockCalls gets all the calls that were made to Lock.
// Check the length with:
//
//	len(mockedLockableCoin.LockCalls())
func (mock *LockableCoinMock) LockCalls() []struct {
	Ctx      types.Context
	FromAddr types.AccAddress
} {
	var calls []struct {
		Ctx      types.Context
		FromAddr types.AccAddress
	}
	mock.lockLock.RLock()
	calls = mock.calls.Lock
	mock.lockLock.RUnlock()
	return calls
}

// Sub calls SubFunc.
func (mock *LockableCoinMock) Sub(coin types.Coin) exported.LockableCoin {
	if mock.SubFunc == nil {
		panic("LockableCoinMock.SubFunc: method is nil but LockableCoin.Sub was just called")
	}
	callInfo := struct {
		Coin types.Coin
	}{
		Coin: coin,
	}
	mock.lockSub.Lock()
	mock.calls.Sub = append(mock.calls.Sub, callInfo)
	mock.lockSub.Unlock()
	return mock.SubFunc(coin)
}

// SubCalls gets all the calls that were made to Sub.
// Check the length with:
//
//	len(mockedLockableCoin.SubCalls())
func (mock *LockableCoinMock) SubCalls() []struct {
	Coin types.Coin
} {
	var calls []struct {
		Coin types.Coin
	}
	mock.lockSub.RLock()
	calls = mock.calls.Sub
	mock.lockSub.RUnlock()
	return calls
}

// Unlock calls UnlockFunc.
func (mock *LockableCoinMock) Unlock(ctx types.Context, toAddr types.AccAddress) error {
	if mock.UnlockFunc == nil {
		panic("LockableCoinMock.UnlockFunc: method is nil but LockableCoin.Unlock was just called")
	}
	callInfo := struct {
		Ctx    types.Context
		ToAddr types.AccAddress
	}{
		Ctx:    ctx,
		ToAddr: toAddr,
	}
	mock.lockUnlock.Lock()
	mock.calls.Unlock = append(mock.calls.Unlock, callInfo)
	mock.lockUnlock.Unlock()
	return mock.UnlockFunc(ctx, toAddr)
}

// UnlockCalls gets all the calls that were made to Unlock.
// Check the length with:
//
//	len(mockedLockableCoin.UnlockCalls())
func (mock *LockableCoinMock) UnlockCalls() []struct {
	Ctx    types.Context
	ToAddr types.AccAddress
} {
	var calls []struct {
		Ctx    types.Context
		ToAddr types.AccAddress
	}
	mock.lockUnlock.RLock()
	calls = mock.calls.Unlock
	mock.lockUnlock.RUnlock()
	return calls
}
