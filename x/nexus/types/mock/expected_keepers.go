// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	wasmtypes "github.com/CosmWasm/wasmd/x/wasm/types"
	utils "github.com/axelarnetwork/axelar-core/utils"
	github_com_axelarnetwork_axelar_core_x_nexus_exported "github.com/axelarnetwork/axelar-core/x/nexus/exported"
	nexustypes "github.com/axelarnetwork/axelar-core/x/nexus/types"
	reward "github.com/axelarnetwork/axelar-core/x/reward/exported"
	snapshot "github.com/axelarnetwork/axelar-core/x/snapshot/exported"
	cosmossdktypes "github.com/cosmos/cosmos-sdk/types"
	"github.com/tendermint/tendermint/libs/log"
	"sync"
	time "time"
)

// Ensure, that NexusMock does implement nexustypes.Nexus.
// If this is not the case, regenerate this file with moq.
var _ nexustypes.Nexus = &NexusMock{}

// NexusMock is a mock implementation of nexustypes.Nexus.
//
//	func TestSomethingThatUsesNexus(t *testing.T) {
//
//		// make and configure a mocked nexustypes.Nexus
//		mockedNexus := &NexusMock{
//			ActivateChainFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain)  {
//				panic("mock out the ActivateChain method")
//			},
//			AddChainMaintainerFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, validator cosmossdktypes.ValAddress) error {
//				panic("mock out the AddChainMaintainer method")
//			},
//			DeactivateChainFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain)  {
//				panic("mock out the DeactivateChain method")
//			},
//			DequeueRouteMessageFunc: func(ctx cosmossdktypes.Context) (github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage, bool) {
//				panic("mock out the DequeueRouteMessage method")
//			},
//			ExportGenesisFunc: func(ctx cosmossdktypes.Context) *nexustypes.GenesisState {
//				panic("mock out the ExportGenesis method")
//			},
//			GenerateMessageIDFunc: func(ctx cosmossdktypes.Context) (string, []byte, uint64) {
//				panic("mock out the GenerateMessageID method")
//			},
//			GetChainFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, bool) {
//				panic("mock out the GetChain method")
//			},
//			GetChainMaintainerStatesFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) []github_com_axelarnetwork_axelar_core_x_nexus_exported.MaintainerState {
//				panic("mock out the GetChainMaintainerStates method")
//			},
//			GetChainMaintainersFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) []cosmossdktypes.ValAddress {
//				panic("mock out the GetChainMaintainers method")
//			},
//			GetChainsFunc: func(ctx cosmossdktypes.Context) []github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain {
//				panic("mock out the GetChains method")
//			},
//			GetFeeInfoFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, asset string) github_com_axelarnetwork_axelar_core_x_nexus_exported.FeeInfo {
//				panic("mock out the GetFeeInfo method")
//			},
//			GetMessageFunc: func(ctx cosmossdktypes.Context, id string) (github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage, bool) {
//				panic("mock out the GetMessage method")
//			},
//			GetParamsFunc: func(ctx cosmossdktypes.Context) nexustypes.Params {
//				panic("mock out the GetParams method")
//			},
//			InitGenesisFunc: func(ctx cosmossdktypes.Context, genState *nexustypes.GenesisState)  {
//				panic("mock out the InitGenesis method")
//			},
//			IsChainActivatedFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) bool {
//				panic("mock out the IsChainActivated method")
//			},
//			IsChainMaintainerFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, maintainer cosmossdktypes.ValAddress) bool {
//				panic("mock out the IsChainMaintainer method")
//			},
//			LinkAddressesFunc: func(ctx cosmossdktypes.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress) error {
//				panic("mock out the LinkAddresses method")
//			},
//			LoggerFunc: func(ctx cosmossdktypes.Context) log.Logger {
//				panic("mock out the Logger method")
//			},
//			RateLimitTransferFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName, asset cosmossdktypes.Coin, direction github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferDirection) error {
//				panic("mock out the RateLimitTransfer method")
//			},
//			RegisterFeeFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, feeInfo github_com_axelarnetwork_axelar_core_x_nexus_exported.FeeInfo) error {
//				panic("mock out the RegisterFee method")
//			},
//			RemoveChainMaintainerFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, validator cosmossdktypes.ValAddress) error {
//				panic("mock out the RemoveChainMaintainer method")
//			},
//			RouteMessageFunc: func(ctx cosmossdktypes.Context, id string, routingCtx ...github_com_axelarnetwork_axelar_core_x_nexus_exported.RoutingContext) error {
//				panic("mock out the RouteMessage method")
//			},
//			SetMessageExecutedFunc: func(ctx cosmossdktypes.Context, id string) error {
//				panic("mock out the SetMessageExecuted method")
//			},
//			SetNewMessageFunc: func(ctx cosmossdktypes.Context, msg github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage) error {
//				panic("mock out the SetNewMessage method")
//			},
//			SetParamsFunc: func(ctx cosmossdktypes.Context, p nexustypes.Params)  {
//				panic("mock out the SetParams method")
//			},
//			SetRateLimitFunc: func(ctx cosmossdktypes.Context, chainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName, limit cosmossdktypes.Coin, window time.Duration) error {
//				panic("mock out the SetRateLimit method")
//			},
//		}
//
//		// use mockedNexus in code that requires nexustypes.Nexus
//		// and then make assertions.
//
//	}
type NexusMock struct {
	// ActivateChainFunc mocks the ActivateChain method.
	ActivateChainFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain)

	// AddChainMaintainerFunc mocks the AddChainMaintainer method.
	AddChainMaintainerFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, validator cosmossdktypes.ValAddress) error

	// DeactivateChainFunc mocks the DeactivateChain method.
	DeactivateChainFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain)

	// DequeueRouteMessageFunc mocks the DequeueRouteMessage method.
	DequeueRouteMessageFunc func(ctx cosmossdktypes.Context) (github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage, bool)

	// ExportGenesisFunc mocks the ExportGenesis method.
	ExportGenesisFunc func(ctx cosmossdktypes.Context) *nexustypes.GenesisState

	// GenerateMessageIDFunc mocks the GenerateMessageID method.
	GenerateMessageIDFunc func(ctx cosmossdktypes.Context) (string, []byte, uint64)

	// GetChainFunc mocks the GetChain method.
	GetChainFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, bool)

	// GetChainMaintainerStatesFunc mocks the GetChainMaintainerStates method.
	GetChainMaintainerStatesFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) []github_com_axelarnetwork_axelar_core_x_nexus_exported.MaintainerState

	// GetChainMaintainersFunc mocks the GetChainMaintainers method.
	GetChainMaintainersFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) []cosmossdktypes.ValAddress

	// GetChainsFunc mocks the GetChains method.
	GetChainsFunc func(ctx cosmossdktypes.Context) []github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain

	// GetFeeInfoFunc mocks the GetFeeInfo method.
	GetFeeInfoFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, asset string) github_com_axelarnetwork_axelar_core_x_nexus_exported.FeeInfo

	// GetMessageFunc mocks the GetMessage method.
	GetMessageFunc func(ctx cosmossdktypes.Context, id string) (github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage, bool)

	// GetParamsFunc mocks the GetParams method.
	GetParamsFunc func(ctx cosmossdktypes.Context) nexustypes.Params

	// InitGenesisFunc mocks the InitGenesis method.
	InitGenesisFunc func(ctx cosmossdktypes.Context, genState *nexustypes.GenesisState)

	// IsChainActivatedFunc mocks the IsChainActivated method.
	IsChainActivatedFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) bool

	// IsChainMaintainerFunc mocks the IsChainMaintainer method.
	IsChainMaintainerFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, maintainer cosmossdktypes.ValAddress) bool

	// LinkAddressesFunc mocks the LinkAddresses method.
	LinkAddressesFunc func(ctx cosmossdktypes.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress) error

	// LoggerFunc mocks the Logger method.
	LoggerFunc func(ctx cosmossdktypes.Context) log.Logger

	// RateLimitTransferFunc mocks the RateLimitTransfer method.
	RateLimitTransferFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName, asset cosmossdktypes.Coin, direction github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferDirection) error

	// RegisterFeeFunc mocks the RegisterFee method.
	RegisterFeeFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, feeInfo github_com_axelarnetwork_axelar_core_x_nexus_exported.FeeInfo) error

	// RemoveChainMaintainerFunc mocks the RemoveChainMaintainer method.
	RemoveChainMaintainerFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, validator cosmossdktypes.ValAddress) error

	// RouteMessageFunc mocks the RouteMessage method.
	RouteMessageFunc func(ctx cosmossdktypes.Context, id string, routingCtx ...github_com_axelarnetwork_axelar_core_x_nexus_exported.RoutingContext) error

	// SetMessageExecutedFunc mocks the SetMessageExecuted method.
	SetMessageExecutedFunc func(ctx cosmossdktypes.Context, id string) error

	// SetNewMessageFunc mocks the SetNewMessage method.
	SetNewMessageFunc func(ctx cosmossdktypes.Context, msg github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage) error

	// SetParamsFunc mocks the SetParams method.
	SetParamsFunc func(ctx cosmossdktypes.Context, p nexustypes.Params)

	// SetRateLimitFunc mocks the SetRateLimit method.
	SetRateLimitFunc func(ctx cosmossdktypes.Context, chainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName, limit cosmossdktypes.Coin, window time.Duration) error

	// calls tracks calls to the methods.
	calls struct {
		// ActivateChain holds details about calls to the ActivateChain method.
		ActivateChain []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		}
		// AddChainMaintainer holds details about calls to the AddChainMaintainer method.
		AddChainMaintainer []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
			// Validator is the validator argument value.
			Validator cosmossdktypes.ValAddress
		}
		// DeactivateChain holds details about calls to the DeactivateChain method.
		DeactivateChain []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		}
		// DequeueRouteMessage holds details about calls to the DequeueRouteMessage method.
		DequeueRouteMessage []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// ExportGenesis holds details about calls to the ExportGenesis method.
		ExportGenesis []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// GenerateMessageID holds details about calls to the GenerateMessageID method.
		GenerateMessageID []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// GetChain holds details about calls to the GetChain method.
		GetChain []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
		}
		// GetChainMaintainerStates holds details about calls to the GetChainMaintainerStates method.
		GetChainMaintainerStates []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		}
		// GetChainMaintainers holds details about calls to the GetChainMaintainers method.
		GetChainMaintainers []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		}
		// GetChains holds details about calls to the GetChains method.
		GetChains []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// GetFeeInfo holds details about calls to the GetFeeInfo method.
		GetFeeInfo []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
			// Asset is the asset argument value.
			Asset string
		}
		// GetMessage holds details about calls to the GetMessage method.
		GetMessage []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ID is the id argument value.
			ID string
		}
		// GetParams holds details about calls to the GetParams method.
		GetParams []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// InitGenesis holds details about calls to the InitGenesis method.
		InitGenesis []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// GenState is the genState argument value.
			GenState *nexustypes.GenesisState
		}
		// IsChainActivated holds details about calls to the IsChainActivated method.
		IsChainActivated []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		}
		// IsChainMaintainer holds details about calls to the IsChainMaintainer method.
		IsChainMaintainer []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
			// Maintainer is the maintainer argument value.
			Maintainer cosmossdktypes.ValAddress
		}
		// LinkAddresses holds details about calls to the LinkAddresses method.
		LinkAddresses []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Sender is the sender argument value.
			Sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
			// Recipient is the recipient argument value.
			Recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
		}
		// Logger holds details about calls to the Logger method.
		Logger []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// RateLimitTransfer holds details about calls to the RateLimitTransfer method.
		RateLimitTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
			// Asset is the asset argument value.
			Asset cosmossdktypes.Coin
			// Direction is the direction argument value.
			Direction github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferDirection
		}
		// RegisterFee holds details about calls to the RegisterFee method.
		RegisterFee []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
			// FeeInfo is the feeInfo argument value.
			FeeInfo github_com_axelarnetwork_axelar_core_x_nexus_exported.FeeInfo
		}
		// RemoveChainMaintainer holds details about calls to the RemoveChainMaintainer method.
		RemoveChainMaintainer []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
			// Validator is the validator argument value.
			Validator cosmossdktypes.ValAddress
		}
		// RouteMessage holds details about calls to the RouteMessage method.
		RouteMessage []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ID is the id argument value.
			ID string
			// RoutingCtx is the routingCtx argument value.
			RoutingCtx []github_com_axelarnetwork_axelar_core_x_nexus_exported.RoutingContext
		}
		// SetMessageExecuted holds details about calls to the SetMessageExecuted method.
		SetMessageExecuted []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ID is the id argument value.
			ID string
		}
		// SetNewMessage holds details about calls to the SetNewMessage method.
		SetNewMessage []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Msg is the msg argument value.
			Msg github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage
		}
		// SetParams holds details about calls to the SetParams method.
		SetParams []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// P is the p argument value.
			P nexustypes.Params
		}
		// SetRateLimit holds details about calls to the SetRateLimit method.
		SetRateLimit []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ChainName is the chainName argument value.
			ChainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
			// Limit is the limit argument value.
			Limit cosmossdktypes.Coin
			// Window is the window argument value.
			Window time.Duration
		}
	}
	lockActivateChain            sync.RWMutex
	lockAddChainMaintainer       sync.RWMutex
	lockDeactivateChain          sync.RWMutex
	lockDequeueRouteMessage      sync.RWMutex
	lockExportGenesis            sync.RWMutex
	lockGenerateMessageID        sync.RWMutex
	lockGetChain                 sync.RWMutex
	lockGetChainMaintainerStates sync.RWMutex
	lockGetChainMaintainers      sync.RWMutex
	lockGetChains                sync.RWMutex
	lockGetFeeInfo               sync.RWMutex
	lockGetMessage               sync.RWMutex
	lockGetParams                sync.RWMutex
	lockInitGenesis              sync.RWMutex
	lockIsChainActivated         sync.RWMutex
	lockIsChainMaintainer        sync.RWMutex
	lockLinkAddresses            sync.RWMutex
	lockLogger                   sync.RWMutex
	lockRateLimitTransfer        sync.RWMutex
	lockRegisterFee              sync.RWMutex
	lockRemoveChainMaintainer    sync.RWMutex
	lockRouteMessage             sync.RWMutex
	lockSetMessageExecuted       sync.RWMutex
	lockSetNewMessage            sync.RWMutex
	lockSetParams                sync.RWMutex
	lockSetRateLimit             sync.RWMutex
}

// ActivateChain calls ActivateChainFunc.
func (mock *NexusMock) ActivateChain(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) {
	if mock.ActivateChainFunc == nil {
		panic("NexusMock.ActivateChainFunc: method is nil but Nexus.ActivateChain was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockActivateChain.Lock()
	mock.calls.ActivateChain = append(mock.calls.ActivateChain, callInfo)
	mock.lockActivateChain.Unlock()
	mock.ActivateChainFunc(ctx, chain)
}

// ActivateChainCalls gets all the calls that were made to ActivateChain.
// Check the length with:
//
//	len(mockedNexus.ActivateChainCalls())
func (mock *NexusMock) ActivateChainCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}
	mock.lockActivateChain.RLock()
	calls = mock.calls.ActivateChain
	mock.lockActivateChain.RUnlock()
	return calls
}

// AddChainMaintainer calls AddChainMaintainerFunc.
func (mock *NexusMock) AddChainMaintainer(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, validator cosmossdktypes.ValAddress) error {
	if mock.AddChainMaintainerFunc == nil {
		panic("NexusMock.AddChainMaintainerFunc: method is nil but Nexus.AddChainMaintainer was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		Chain     github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Validator cosmossdktypes.ValAddress
	}{
		Ctx:       ctx,
		Chain:     chain,
		Validator: validator,
	}
	mock.lockAddChainMaintainer.Lock()
	mock.calls.AddChainMaintainer = append(mock.calls.AddChainMaintainer, callInfo)
	mock.lockAddChainMaintainer.Unlock()
	return mock.AddChainMaintainerFunc(ctx, chain, validator)
}

// AddChainMaintainerCalls gets all the calls that were made to AddChainMaintainer.
// Check the length with:
//
//	len(mockedNexus.AddChainMaintainerCalls())
func (mock *NexusMock) AddChainMaintainerCalls() []struct {
	Ctx       cosmossdktypes.Context
	Chain     github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	Validator cosmossdktypes.ValAddress
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		Chain     github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Validator cosmossdktypes.ValAddress
	}
	mock.lockAddChainMaintainer.RLock()
	calls = mock.calls.AddChainMaintainer
	mock.lockAddChainMaintainer.RUnlock()
	return calls
}

// DeactivateChain calls DeactivateChainFunc.
func (mock *NexusMock) DeactivateChain(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) {
	if mock.DeactivateChainFunc == nil {
		panic("NexusMock.DeactivateChainFunc: method is nil but Nexus.DeactivateChain was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockDeactivateChain.Lock()
	mock.calls.DeactivateChain = append(mock.calls.DeactivateChain, callInfo)
	mock.lockDeactivateChain.Unlock()
	mock.DeactivateChainFunc(ctx, chain)
}

// DeactivateChainCalls gets all the calls that were made to DeactivateChain.
// Check the length with:
//
//	len(mockedNexus.DeactivateChainCalls())
func (mock *NexusMock) DeactivateChainCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}
	mock.lockDeactivateChain.RLock()
	calls = mock.calls.DeactivateChain
	mock.lockDeactivateChain.RUnlock()
	return calls
}

// DequeueRouteMessage calls DequeueRouteMessageFunc.
func (mock *NexusMock) DequeueRouteMessage(ctx cosmossdktypes.Context) (github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage, bool) {
	if mock.DequeueRouteMessageFunc == nil {
		panic("NexusMock.DequeueRouteMessageFunc: method is nil but Nexus.DequeueRouteMessage was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockDequeueRouteMessage.Lock()
	mock.calls.DequeueRouteMessage = append(mock.calls.DequeueRouteMessage, callInfo)
	mock.lockDequeueRouteMessage.Unlock()
	return mock.DequeueRouteMessageFunc(ctx)
}

// DequeueRouteMessageCalls gets all the calls that were made to DequeueRouteMessage.
// Check the length with:
//
//	len(mockedNexus.DequeueRouteMessageCalls())
func (mock *NexusMock) DequeueRouteMessageCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockDequeueRouteMessage.RLock()
	calls = mock.calls.DequeueRouteMessage
	mock.lockDequeueRouteMessage.RUnlock()
	return calls
}

// ExportGenesis calls ExportGenesisFunc.
func (mock *NexusMock) ExportGenesis(ctx cosmossdktypes.Context) *nexustypes.GenesisState {
	if mock.ExportGenesisFunc == nil {
		panic("NexusMock.ExportGenesisFunc: method is nil but Nexus.ExportGenesis was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockExportGenesis.Lock()
	mock.calls.ExportGenesis = append(mock.calls.ExportGenesis, callInfo)
	mock.lockExportGenesis.Unlock()
	return mock.ExportGenesisFunc(ctx)
}

// ExportGenesisCalls gets all the calls that were made to ExportGenesis.
// Check the length with:
//
//	len(mockedNexus.ExportGenesisCalls())
func (mock *NexusMock) ExportGenesisCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockExportGenesis.RLock()
	calls = mock.calls.ExportGenesis
	mock.lockExportGenesis.RUnlock()
	return calls
}

// GenerateMessageID calls GenerateMessageIDFunc.
func (mock *NexusMock) GenerateMessageID(ctx cosmossdktypes.Context) (string, []byte, uint64) {
	if mock.GenerateMessageIDFunc == nil {
		panic("NexusMock.GenerateMessageIDFunc: method is nil but Nexus.GenerateMessageID was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockGenerateMessageID.Lock()
	mock.calls.GenerateMessageID = append(mock.calls.GenerateMessageID, callInfo)
	mock.lockGenerateMessageID.Unlock()
	return mock.GenerateMessageIDFunc(ctx)
}

// GenerateMessageIDCalls gets all the calls that were made to GenerateMessageID.
// Check the length with:
//
//	len(mockedNexus.GenerateMessageIDCalls())
func (mock *NexusMock) GenerateMessageIDCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockGenerateMessageID.RLock()
	calls = mock.calls.GenerateMessageID
	mock.lockGenerateMessageID.RUnlock()
	return calls
}

// GetChain calls GetChainFunc.
func (mock *NexusMock) GetChain(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, bool) {
	if mock.GetChainFunc == nil {
		panic("NexusMock.GetChainFunc: method is nil but Nexus.GetChain was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockGetChain.Lock()
	mock.calls.GetChain = append(mock.calls.GetChain, callInfo)
	mock.lockGetChain.Unlock()
	return mock.GetChainFunc(ctx, chain)
}

// GetChainCalls gets all the calls that were made to GetChain.
// Check the length with:
//
//	len(mockedNexus.GetChainCalls())
func (mock *NexusMock) GetChainCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}
	mock.lockGetChain.RLock()
	calls = mock.calls.GetChain
	mock.lockGetChain.RUnlock()
	return calls
}

// GetChainMaintainerStates calls GetChainMaintainerStatesFunc.
func (mock *NexusMock) GetChainMaintainerStates(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) []github_com_axelarnetwork_axelar_core_x_nexus_exported.MaintainerState {
	if mock.GetChainMaintainerStatesFunc == nil {
		panic("NexusMock.GetChainMaintainerStatesFunc: method is nil but Nexus.GetChainMaintainerStates was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockGetChainMaintainerStates.Lock()
	mock.calls.GetChainMaintainerStates = append(mock.calls.GetChainMaintainerStates, callInfo)
	mock.lockGetChainMaintainerStates.Unlock()
	return mock.GetChainMaintainerStatesFunc(ctx, chain)
}

// GetChainMaintainerStatesCalls gets all the calls that were made to GetChainMaintainerStates.
// Check the length with:
//
//	len(mockedNexus.GetChainMaintainerStatesCalls())
func (mock *NexusMock) GetChainMaintainerStatesCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}
	mock.lockGetChainMaintainerStates.RLock()
	calls = mock.calls.GetChainMaintainerStates
	mock.lockGetChainMaintainerStates.RUnlock()
	return calls
}

// GetChainMaintainers calls GetChainMaintainersFunc.
func (mock *NexusMock) GetChainMaintainers(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) []cosmossdktypes.ValAddress {
	if mock.GetChainMaintainersFunc == nil {
		panic("NexusMock.GetChainMaintainersFunc: method is nil but Nexus.GetChainMaintainers was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockGetChainMaintainers.Lock()
	mock.calls.GetChainMaintainers = append(mock.calls.GetChainMaintainers, callInfo)
	mock.lockGetChainMaintainers.Unlock()
	return mock.GetChainMaintainersFunc(ctx, chain)
}

// GetChainMaintainersCalls gets all the calls that were made to GetChainMaintainers.
// Check the length with:
//
//	len(mockedNexus.GetChainMaintainersCalls())
func (mock *NexusMock) GetChainMaintainersCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}
	mock.lockGetChainMaintainers.RLock()
	calls = mock.calls.GetChainMaintainers
	mock.lockGetChainMaintainers.RUnlock()
	return calls
}

// GetChains calls GetChainsFunc.
func (mock *NexusMock) GetChains(ctx cosmossdktypes.Context) []github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain {
	if mock.GetChainsFunc == nil {
		panic("NexusMock.GetChainsFunc: method is nil but Nexus.GetChains was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetChains.Lock()
	mock.calls.GetChains = append(mock.calls.GetChains, callInfo)
	mock.lockGetChains.Unlock()
	return mock.GetChainsFunc(ctx)
}

// GetChainsCalls gets all the calls that were made to GetChains.
// Check the length with:
//
//	len(mockedNexus.GetChainsCalls())
func (mock *NexusMock) GetChainsCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockGetChains.RLock()
	calls = mock.calls.GetChains
	mock.lockGetChains.RUnlock()
	return calls
}

// GetFeeInfo calls GetFeeInfoFunc.
func (mock *NexusMock) GetFeeInfo(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, asset string) github_com_axelarnetwork_axelar_core_x_nexus_exported.FeeInfo {
	if mock.GetFeeInfoFunc == nil {
		panic("NexusMock.GetFeeInfoFunc: method is nil but Nexus.GetFeeInfo was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Asset string
	}{
		Ctx:   ctx,
		Chain: chain,
		Asset: asset,
	}
	mock.lockGetFeeInfo.Lock()
	mock.calls.GetFeeInfo = append(mock.calls.GetFeeInfo, callInfo)
	mock.lockGetFeeInfo.Unlock()
	return mock.GetFeeInfoFunc(ctx, chain, asset)
}

// GetFeeInfoCalls gets all the calls that were made to GetFeeInfo.
// Check the length with:
//
//	len(mockedNexus.GetFeeInfoCalls())
func (mock *NexusMock) GetFeeInfoCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	Asset string
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Asset string
	}
	mock.lockGetFeeInfo.RLock()
	calls = mock.calls.GetFeeInfo
	mock.lockGetFeeInfo.RUnlock()
	return calls
}

// GetMessage calls GetMessageFunc.
func (mock *NexusMock) GetMessage(ctx cosmossdktypes.Context, id string) (github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage, bool) {
	if mock.GetMessageFunc == nil {
		panic("NexusMock.GetMessageFunc: method is nil but Nexus.GetMessage was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetMessage.Lock()
	mock.calls.GetMessage = append(mock.calls.GetMessage, callInfo)
	mock.lockGetMessage.Unlock()
	return mock.GetMessageFunc(ctx, id)
}

// GetMessageCalls gets all the calls that were made to GetMessage.
// Check the length with:
//
//	len(mockedNexus.GetMessageCalls())
func (mock *NexusMock) GetMessageCalls() []struct {
	Ctx cosmossdktypes.Context
	ID  string
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
		ID  string
	}
	mock.lockGetMessage.RLock()
	calls = mock.calls.GetMessage
	mock.lockGetMessage.RUnlock()
	return calls
}

// GetParams calls GetParamsFunc.
func (mock *NexusMock) GetParams(ctx cosmossdktypes.Context) nexustypes.Params {
	if mock.GetParamsFunc == nil {
		panic("NexusMock.GetParamsFunc: method is nil but Nexus.GetParams was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetParams.Lock()
	mock.calls.GetParams = append(mock.calls.GetParams, callInfo)
	mock.lockGetParams.Unlock()
	return mock.GetParamsFunc(ctx)
}

// GetParamsCalls gets all the calls that were made to GetParams.
// Check the length with:
//
//	len(mockedNexus.GetParamsCalls())
func (mock *NexusMock) GetParamsCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockGetParams.RLock()
	calls = mock.calls.GetParams
	mock.lockGetParams.RUnlock()
	return calls
}

// InitGenesis calls InitGenesisFunc.
func (mock *NexusMock) InitGenesis(ctx cosmossdktypes.Context, genState *nexustypes.GenesisState) {
	if mock.InitGenesisFunc == nil {
		panic("NexusMock.InitGenesisFunc: method is nil but Nexus.InitGenesis was just called")
	}
	callInfo := struct {
		Ctx      cosmossdktypes.Context
		GenState *nexustypes.GenesisState
	}{
		Ctx:      ctx,
		GenState: genState,
	}
	mock.lockInitGenesis.Lock()
	mock.calls.InitGenesis = append(mock.calls.InitGenesis, callInfo)
	mock.lockInitGenesis.Unlock()
	mock.InitGenesisFunc(ctx, genState)
}

// InitGenesisCalls gets all the calls that were made to InitGenesis.
// Check the length with:
//
//	len(mockedNexus.InitGenesisCalls())
func (mock *NexusMock) InitGenesisCalls() []struct {
	Ctx      cosmossdktypes.Context
	GenState *nexustypes.GenesisState
} {
	var calls []struct {
		Ctx      cosmossdktypes.Context
		GenState *nexustypes.GenesisState
	}
	mock.lockInitGenesis.RLock()
	calls = mock.calls.InitGenesis
	mock.lockInitGenesis.RUnlock()
	return calls
}

// IsChainActivated calls IsChainActivatedFunc.
func (mock *NexusMock) IsChainActivated(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) bool {
	if mock.IsChainActivatedFunc == nil {
		panic("NexusMock.IsChainActivatedFunc: method is nil but Nexus.IsChainActivated was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockIsChainActivated.Lock()
	mock.calls.IsChainActivated = append(mock.calls.IsChainActivated, callInfo)
	mock.lockIsChainActivated.Unlock()
	return mock.IsChainActivatedFunc(ctx, chain)
}

// IsChainActivatedCalls gets all the calls that were made to IsChainActivated.
// Check the length with:
//
//	len(mockedNexus.IsChainActivatedCalls())
func (mock *NexusMock) IsChainActivatedCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}
	mock.lockIsChainActivated.RLock()
	calls = mock.calls.IsChainActivated
	mock.lockIsChainActivated.RUnlock()
	return calls
}

// IsChainMaintainer calls IsChainMaintainerFunc.
func (mock *NexusMock) IsChainMaintainer(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, maintainer cosmossdktypes.ValAddress) bool {
	if mock.IsChainMaintainerFunc == nil {
		panic("NexusMock.IsChainMaintainerFunc: method is nil but Nexus.IsChainMaintainer was just called")
	}
	callInfo := struct {
		Ctx        cosmossdktypes.Context
		Chain      github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Maintainer cosmossdktypes.ValAddress
	}{
		Ctx:        ctx,
		Chain:      chain,
		Maintainer: maintainer,
	}
	mock.lockIsChainMaintainer.Lock()
	mock.calls.IsChainMaintainer = append(mock.calls.IsChainMaintainer, callInfo)
	mock.lockIsChainMaintainer.Unlock()
	return mock.IsChainMaintainerFunc(ctx, chain, maintainer)
}

// IsChainMaintainerCalls gets all the calls that were made to IsChainMaintainer.
// Check the length with:
//
//	len(mockedNexus.IsChainMaintainerCalls())
func (mock *NexusMock) IsChainMaintainerCalls() []struct {
	Ctx        cosmossdktypes.Context
	Chain      github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	Maintainer cosmossdktypes.ValAddress
} {
	var calls []struct {
		Ctx        cosmossdktypes.Context
		Chain      github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Maintainer cosmossdktypes.ValAddress
	}
	mock.lockIsChainMaintainer.RLock()
	calls = mock.calls.IsChainMaintainer
	mock.lockIsChainMaintainer.RUnlock()
	return calls
}

// LinkAddresses calls LinkAddressesFunc.
func (mock *NexusMock) LinkAddresses(ctx cosmossdktypes.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress) error {
	if mock.LinkAddressesFunc == nil {
		panic("NexusMock.LinkAddressesFunc: method is nil but Nexus.LinkAddresses was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		Sender    github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
		Recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
	}{
		Ctx:       ctx,
		Sender:    sender,
		Recipient: recipient,
	}
	mock.lockLinkAddresses.Lock()
	mock.calls.LinkAddresses = append(mock.calls.LinkAddresses, callInfo)
	mock.lockLinkAddresses.Unlock()
	return mock.LinkAddressesFunc(ctx, sender, recipient)
}

// LinkAddressesCalls gets all the calls that were made to LinkAddresses.
// Check the length with:
//
//	len(mockedNexus.LinkAddressesCalls())
func (mock *NexusMock) LinkAddressesCalls() []struct {
	Ctx       cosmossdktypes.Context
	Sender    github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
	Recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		Sender    github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
		Recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
	}
	mock.lockLinkAddresses.RLock()
	calls = mock.calls.LinkAddresses
	mock.lockLinkAddresses.RUnlock()
	return calls
}

// Logger calls LoggerFunc.
func (mock *NexusMock) Logger(ctx cosmossdktypes.Context) log.Logger {
	if mock.LoggerFunc == nil {
		panic("NexusMock.LoggerFunc: method is nil but Nexus.Logger was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockLogger.Lock()
	mock.calls.Logger = append(mock.calls.Logger, callInfo)
	mock.lockLogger.Unlock()
	return mock.LoggerFunc(ctx)
}

// LoggerCalls gets all the calls that were made to Logger.
// Check the length with:
//
//	len(mockedNexus.LoggerCalls())
func (mock *NexusMock) LoggerCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockLogger.RLock()
	calls = mock.calls.Logger
	mock.lockLogger.RUnlock()
	return calls
}

// RateLimitTransfer calls RateLimitTransferFunc.
func (mock *NexusMock) RateLimitTransfer(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName, asset cosmossdktypes.Coin, direction github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferDirection) error {
	if mock.RateLimitTransferFunc == nil {
		panic("NexusMock.RateLimitTransferFunc: method is nil but Nexus.RateLimitTransfer was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		Chain     github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
		Asset     cosmossdktypes.Coin
		Direction github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferDirection
	}{
		Ctx:       ctx,
		Chain:     chain,
		Asset:     asset,
		Direction: direction,
	}
	mock.lockRateLimitTransfer.Lock()
	mock.calls.RateLimitTransfer = append(mock.calls.RateLimitTransfer, callInfo)
	mock.lockRateLimitTransfer.Unlock()
	return mock.RateLimitTransferFunc(ctx, chain, asset, direction)
}

// RateLimitTransferCalls gets all the calls that were made to RateLimitTransfer.
// Check the length with:
//
//	len(mockedNexus.RateLimitTransferCalls())
func (mock *NexusMock) RateLimitTransferCalls() []struct {
	Ctx       cosmossdktypes.Context
	Chain     github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	Asset     cosmossdktypes.Coin
	Direction github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferDirection
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		Chain     github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
		Asset     cosmossdktypes.Coin
		Direction github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferDirection
	}
	mock.lockRateLimitTransfer.RLock()
	calls = mock.calls.RateLimitTransfer
	mock.lockRateLimitTransfer.RUnlock()
	return calls
}

// RegisterFee calls RegisterFeeFunc.
func (mock *NexusMock) RegisterFee(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, feeInfo github_com_axelarnetwork_axelar_core_x_nexus_exported.FeeInfo) error {
	if mock.RegisterFeeFunc == nil {
		panic("NexusMock.RegisterFeeFunc: method is nil but Nexus.RegisterFee was just called")
	}
	callInfo := struct {
		Ctx     cosmossdktypes.Context
		Chain   github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		FeeInfo github_com_axelarnetwork_axelar_core_x_nexus_exported.FeeInfo
	}{
		Ctx:     ctx,
		Chain:   chain,
		FeeInfo: feeInfo,
	}
	mock.lockRegisterFee.Lock()
	mock.calls.RegisterFee = append(mock.calls.RegisterFee, callInfo)
	mock.lockRegisterFee.Unlock()
	return mock.RegisterFeeFunc(ctx, chain, feeInfo)
}

// RegisterFeeCalls gets all the calls that were made to RegisterFee.
// Check the length with:
//
//	len(mockedNexus.RegisterFeeCalls())
func (mock *NexusMock) RegisterFeeCalls() []struct {
	Ctx     cosmossdktypes.Context
	Chain   github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	FeeInfo github_com_axelarnetwork_axelar_core_x_nexus_exported.FeeInfo
} {
	var calls []struct {
		Ctx     cosmossdktypes.Context
		Chain   github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		FeeInfo github_com_axelarnetwork_axelar_core_x_nexus_exported.FeeInfo
	}
	mock.lockRegisterFee.RLock()
	calls = mock.calls.RegisterFee
	mock.lockRegisterFee.RUnlock()
	return calls
}

// RemoveChainMaintainer calls RemoveChainMaintainerFunc.
func (mock *NexusMock) RemoveChainMaintainer(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, validator cosmossdktypes.ValAddress) error {
	if mock.RemoveChainMaintainerFunc == nil {
		panic("NexusMock.RemoveChainMaintainerFunc: method is nil but Nexus.RemoveChainMaintainer was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		Chain     github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Validator cosmossdktypes.ValAddress
	}{
		Ctx:       ctx,
		Chain:     chain,
		Validator: validator,
	}
	mock.lockRemoveChainMaintainer.Lock()
	mock.calls.RemoveChainMaintainer = append(mock.calls.RemoveChainMaintainer, callInfo)
	mock.lockRemoveChainMaintainer.Unlock()
	return mock.RemoveChainMaintainerFunc(ctx, chain, validator)
}

// RemoveChainMaintainerCalls gets all the calls that were made to RemoveChainMaintainer.
// Check the length with:
//
//	len(mockedNexus.RemoveChainMaintainerCalls())
func (mock *NexusMock) RemoveChainMaintainerCalls() []struct {
	Ctx       cosmossdktypes.Context
	Chain     github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	Validator cosmossdktypes.ValAddress
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		Chain     github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Validator cosmossdktypes.ValAddress
	}
	mock.lockRemoveChainMaintainer.RLock()
	calls = mock.calls.RemoveChainMaintainer
	mock.lockRemoveChainMaintainer.RUnlock()
	return calls
}

// RouteMessage calls RouteMessageFunc.
func (mock *NexusMock) RouteMessage(ctx cosmossdktypes.Context, id string, routingCtx ...github_com_axelarnetwork_axelar_core_x_nexus_exported.RoutingContext) error {
	if mock.RouteMessageFunc == nil {
		panic("NexusMock.RouteMessageFunc: method is nil but Nexus.RouteMessage was just called")
	}
	callInfo := struct {
		Ctx        cosmossdktypes.Context
		ID         string
		RoutingCtx []github_com_axelarnetwork_axelar_core_x_nexus_exported.RoutingContext
	}{
		Ctx:        ctx,
		ID:         id,
		RoutingCtx: routingCtx,
	}
	mock.lockRouteMessage.Lock()
	mock.calls.RouteMessage = append(mock.calls.RouteMessage, callInfo)
	mock.lockRouteMessage.Unlock()
	return mock.RouteMessageFunc(ctx, id, routingCtx...)
}

// RouteMessageCalls gets all the calls that were made to RouteMessage.
// Check the length with:
//
//	len(mockedNexus.RouteMessageCalls())
func (mock *NexusMock) RouteMessageCalls() []struct {
	Ctx        cosmossdktypes.Context
	ID         string
	RoutingCtx []github_com_axelarnetwork_axelar_core_x_nexus_exported.RoutingContext
} {
	var calls []struct {
		Ctx        cosmossdktypes.Context
		ID         string
		RoutingCtx []github_com_axelarnetwork_axelar_core_x_nexus_exported.RoutingContext
	}
	mock.lockRouteMessage.RLock()
	calls = mock.calls.RouteMessage
	mock.lockRouteMessage.RUnlock()
	return calls
}

// SetMessageExecuted calls SetMessageExecutedFunc.
func (mock *NexusMock) SetMessageExecuted(ctx cosmossdktypes.Context, id string) error {
	if mock.SetMessageExecutedFunc == nil {
		panic("NexusMock.SetMessageExecutedFunc: method is nil but Nexus.SetMessageExecuted was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockSetMessageExecuted.Lock()
	mock.calls.SetMessageExecuted = append(mock.calls.SetMessageExecuted, callInfo)
	mock.lockSetMessageExecuted.Unlock()
	return mock.SetMessageExecutedFunc(ctx, id)
}

// SetMessageExecutedCalls gets all the calls that were made to SetMessageExecuted.
// Check the length with:
//
//	len(mockedNexus.SetMessageExecutedCalls())
func (mock *NexusMock) SetMessageExecutedCalls() []struct {
	Ctx cosmossdktypes.Context
	ID  string
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
		ID  string
	}
	mock.lockSetMessageExecuted.RLock()
	calls = mock.calls.SetMessageExecuted
	mock.lockSetMessageExecuted.RUnlock()
	return calls
}

// SetNewMessage calls SetNewMessageFunc.
func (mock *NexusMock) SetNewMessage(ctx cosmossdktypes.Context, msg github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage) error {
	if mock.SetNewMessageFunc == nil {
		panic("NexusMock.SetNewMessageFunc: method is nil but Nexus.SetNewMessage was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
		Msg github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage
	}{
		Ctx: ctx,
		Msg: msg,
	}
	mock.lockSetNewMessage.Lock()
	mock.calls.SetNewMessage = append(mock.calls.SetNewMessage, callInfo)
	mock.lockSetNewMessage.Unlock()
	return mock.SetNewMessageFunc(ctx, msg)
}

// SetNewMessageCalls gets all the calls that were made to SetNewMessage.
// Check the length with:
//
//	len(mockedNexus.SetNewMessageCalls())
func (mock *NexusMock) SetNewMessageCalls() []struct {
	Ctx cosmossdktypes.Context
	Msg github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
		Msg github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage
	}
	mock.lockSetNewMessage.RLock()
	calls = mock.calls.SetNewMessage
	mock.lockSetNewMessage.RUnlock()
	return calls
}

// SetParams calls SetParamsFunc.
func (mock *NexusMock) SetParams(ctx cosmossdktypes.Context, p nexustypes.Params) {
	if mock.SetParamsFunc == nil {
		panic("NexusMock.SetParamsFunc: method is nil but Nexus.SetParams was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
		P   nexustypes.Params
	}{
		Ctx: ctx,
		P:   p,
	}
	mock.lockSetParams.Lock()
	mock.calls.SetParams = append(mock.calls.SetParams, callInfo)
	mock.lockSetParams.Unlock()
	mock.SetParamsFunc(ctx, p)
}

// SetParamsCalls gets all the calls that were made to SetParams.
// Check the length with:
//
//	len(mockedNexus.SetParamsCalls())
func (mock *NexusMock) SetParamsCalls() []struct {
	Ctx cosmossdktypes.Context
	P   nexustypes.Params
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
		P   nexustypes.Params
	}
	mock.lockSetParams.RLock()
	calls = mock.calls.SetParams
	mock.lockSetParams.RUnlock()
	return calls
}

// SetRateLimit calls SetRateLimitFunc.
func (mock *NexusMock) SetRateLimit(ctx cosmossdktypes.Context, chainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName, limit cosmossdktypes.Coin, window time.Duration) error {
	if mock.SetRateLimitFunc == nil {
		panic("NexusMock.SetRateLimitFunc: method is nil but Nexus.SetRateLimit was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		ChainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
		Limit     cosmossdktypes.Coin
		Window    time.Duration
	}{
		Ctx:       ctx,
		ChainName: chainName,
		Limit:     limit,
		Window:    window,
	}
	mock.lockSetRateLimit.Lock()
	mock.calls.SetRateLimit = append(mock.calls.SetRateLimit, callInfo)
	mock.lockSetRateLimit.Unlock()
	return mock.SetRateLimitFunc(ctx, chainName, limit, window)
}

// SetRateLimitCalls gets all the calls that were made to SetRateLimit.
// Check the length with:
//
//	len(mockedNexus.SetRateLimitCalls())
func (mock *NexusMock) SetRateLimitCalls() []struct {
	Ctx       cosmossdktypes.Context
	ChainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	Limit     cosmossdktypes.Coin
	Window    time.Duration
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		ChainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
		Limit     cosmossdktypes.Coin
		Window    time.Duration
	}
	mock.lockSetRateLimit.RLock()
	calls = mock.calls.SetRateLimit
	mock.lockSetRateLimit.RUnlock()
	return calls
}

// Ensure, that SnapshotterMock does implement nexustypes.Snapshotter.
// If this is not the case, regenerate this file with moq.
var _ nexustypes.Snapshotter = &SnapshotterMock{}

// SnapshotterMock is a mock implementation of nexustypes.Snapshotter.
//
//	func TestSomethingThatUsesSnapshotter(t *testing.T) {
//
//		// make and configure a mocked nexustypes.Snapshotter
//		mockedSnapshotter := &SnapshotterMock{
//			CreateSnapshotFunc: func(ctx cosmossdktypes.Context, candidates []cosmossdktypes.ValAddress, filterFunc func(snapshot.ValidatorI) bool, weightFunc func(consensusPower cosmossdktypes.Uint) cosmossdktypes.Uint, threshold utils.Threshold) (snapshot.Snapshot, error) {
//				panic("mock out the CreateSnapshot method")
//			},
//			GetOperatorFunc: func(ctx cosmossdktypes.Context, proxy cosmossdktypes.AccAddress) cosmossdktypes.ValAddress {
//				panic("mock out the GetOperator method")
//			},
//			GetProxyFunc: func(ctx cosmossdktypes.Context, operator cosmossdktypes.ValAddress) (cosmossdktypes.AccAddress, bool) {
//				panic("mock out the GetProxy method")
//			},
//		}
//
//		// use mockedSnapshotter in code that requires nexustypes.Snapshotter
//		// and then make assertions.
//
//	}
type SnapshotterMock struct {
	// CreateSnapshotFunc mocks the CreateSnapshot method.
	CreateSnapshotFunc func(ctx cosmossdktypes.Context, candidates []cosmossdktypes.ValAddress, filterFunc func(snapshot.ValidatorI) bool, weightFunc func(consensusPower cosmossdktypes.Uint) cosmossdktypes.Uint, threshold utils.Threshold) (snapshot.Snapshot, error)

	// GetOperatorFunc mocks the GetOperator method.
	GetOperatorFunc func(ctx cosmossdktypes.Context, proxy cosmossdktypes.AccAddress) cosmossdktypes.ValAddress

	// GetProxyFunc mocks the GetProxy method.
	GetProxyFunc func(ctx cosmossdktypes.Context, operator cosmossdktypes.ValAddress) (cosmossdktypes.AccAddress, bool)

	// calls tracks calls to the methods.
	calls struct {
		// CreateSnapshot holds details about calls to the CreateSnapshot method.
		CreateSnapshot []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Candidates is the candidates argument value.
			Candidates []cosmossdktypes.ValAddress
			// FilterFunc is the filterFunc argument value.
			FilterFunc func(snapshot.ValidatorI) bool
			// WeightFunc is the weightFunc argument value.
			WeightFunc func(consensusPower cosmossdktypes.Uint) cosmossdktypes.Uint
			// Threshold is the threshold argument value.
			Threshold utils.Threshold
		}
		// GetOperator holds details about calls to the GetOperator method.
		GetOperator []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Proxy is the proxy argument value.
			Proxy cosmossdktypes.AccAddress
		}
		// GetProxy holds details about calls to the GetProxy method.
		GetProxy []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Operator is the operator argument value.
			Operator cosmossdktypes.ValAddress
		}
	}
	lockCreateSnapshot sync.RWMutex
	lockGetOperator    sync.RWMutex
	lockGetProxy       sync.RWMutex
}

// CreateSnapshot calls CreateSnapshotFunc.
func (mock *SnapshotterMock) CreateSnapshot(ctx cosmossdktypes.Context, candidates []cosmossdktypes.ValAddress, filterFunc func(snapshot.ValidatorI) bool, weightFunc func(consensusPower cosmossdktypes.Uint) cosmossdktypes.Uint, threshold utils.Threshold) (snapshot.Snapshot, error) {
	if mock.CreateSnapshotFunc == nil {
		panic("SnapshotterMock.CreateSnapshotFunc: method is nil but Snapshotter.CreateSnapshot was just called")
	}
	callInfo := struct {
		Ctx        cosmossdktypes.Context
		Candidates []cosmossdktypes.ValAddress
		FilterFunc func(snapshot.ValidatorI) bool
		WeightFunc func(consensusPower cosmossdktypes.Uint) cosmossdktypes.Uint
		Threshold  utils.Threshold
	}{
		Ctx:        ctx,
		Candidates: candidates,
		FilterFunc: filterFunc,
		WeightFunc: weightFunc,
		Threshold:  threshold,
	}
	mock.lockCreateSnapshot.Lock()
	mock.calls.CreateSnapshot = append(mock.calls.CreateSnapshot, callInfo)
	mock.lockCreateSnapshot.Unlock()
	return mock.CreateSnapshotFunc(ctx, candidates, filterFunc, weightFunc, threshold)
}

// CreateSnapshotCalls gets all the calls that were made to CreateSnapshot.
// Check the length with:
//
//	len(mockedSnapshotter.CreateSnapshotCalls())
func (mock *SnapshotterMock) CreateSnapshotCalls() []struct {
	Ctx        cosmossdktypes.Context
	Candidates []cosmossdktypes.ValAddress
	FilterFunc func(snapshot.ValidatorI) bool
	WeightFunc func(consensusPower cosmossdktypes.Uint) cosmossdktypes.Uint
	Threshold  utils.Threshold
} {
	var calls []struct {
		Ctx        cosmossdktypes.Context
		Candidates []cosmossdktypes.ValAddress
		FilterFunc func(snapshot.ValidatorI) bool
		WeightFunc func(consensusPower cosmossdktypes.Uint) cosmossdktypes.Uint
		Threshold  utils.Threshold
	}
	mock.lockCreateSnapshot.RLock()
	calls = mock.calls.CreateSnapshot
	mock.lockCreateSnapshot.RUnlock()
	return calls
}

// GetOperator calls GetOperatorFunc.
func (mock *SnapshotterMock) GetOperator(ctx cosmossdktypes.Context, proxy cosmossdktypes.AccAddress) cosmossdktypes.ValAddress {
	if mock.GetOperatorFunc == nil {
		panic("SnapshotterMock.GetOperatorFunc: method is nil but Snapshotter.GetOperator was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Proxy cosmossdktypes.AccAddress
	}{
		Ctx:   ctx,
		Proxy: proxy,
	}
	mock.lockGetOperator.Lock()
	mock.calls.GetOperator = append(mock.calls.GetOperator, callInfo)
	mock.lockGetOperator.Unlock()
	return mock.GetOperatorFunc(ctx, proxy)
}

// GetOperatorCalls gets all the calls that were made to GetOperator.
// Check the length with:
//
//	len(mockedSnapshotter.GetOperatorCalls())
func (mock *SnapshotterMock) GetOperatorCalls() []struct {
	Ctx   cosmossdktypes.Context
	Proxy cosmossdktypes.AccAddress
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Proxy cosmossdktypes.AccAddress
	}
	mock.lockGetOperator.RLock()
	calls = mock.calls.GetOperator
	mock.lockGetOperator.RUnlock()
	return calls
}

// GetProxy calls GetProxyFunc.
func (mock *SnapshotterMock) GetProxy(ctx cosmossdktypes.Context, operator cosmossdktypes.ValAddress) (cosmossdktypes.AccAddress, bool) {
	if mock.GetProxyFunc == nil {
		panic("SnapshotterMock.GetProxyFunc: method is nil but Snapshotter.GetProxy was just called")
	}
	callInfo := struct {
		Ctx      cosmossdktypes.Context
		Operator cosmossdktypes.ValAddress
	}{
		Ctx:      ctx,
		Operator: operator,
	}
	mock.lockGetProxy.Lock()
	mock.calls.GetProxy = append(mock.calls.GetProxy, callInfo)
	mock.lockGetProxy.Unlock()
	return mock.GetProxyFunc(ctx, operator)
}

// GetProxyCalls gets all the calls that were made to GetProxy.
// Check the length with:
//
//	len(mockedSnapshotter.GetProxyCalls())
func (mock *SnapshotterMock) GetProxyCalls() []struct {
	Ctx      cosmossdktypes.Context
	Operator cosmossdktypes.ValAddress
} {
	var calls []struct {
		Ctx      cosmossdktypes.Context
		Operator cosmossdktypes.ValAddress
	}
	mock.lockGetProxy.RLock()
	calls = mock.calls.GetProxy
	mock.lockGetProxy.RUnlock()
	return calls
}

// Ensure, that AxelarnetKeeperMock does implement nexustypes.AxelarnetKeeper.
// If this is not the case, regenerate this file with moq.
var _ nexustypes.AxelarnetKeeper = &AxelarnetKeeperMock{}

// AxelarnetKeeperMock is a mock implementation of nexustypes.AxelarnetKeeper.
//
//	func TestSomethingThatUsesAxelarnetKeeper(t *testing.T) {
//
//		// make and configure a mocked nexustypes.AxelarnetKeeper
//		mockedAxelarnetKeeper := &AxelarnetKeeperMock{
//			IsCosmosChainFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) bool {
//				panic("mock out the IsCosmosChain method")
//			},
//		}
//
//		// use mockedAxelarnetKeeper in code that requires nexustypes.AxelarnetKeeper
//		// and then make assertions.
//
//	}
type AxelarnetKeeperMock struct {
	// IsCosmosChainFunc mocks the IsCosmosChain method.
	IsCosmosChainFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) bool

	// calls tracks calls to the methods.
	calls struct {
		// IsCosmosChain holds details about calls to the IsCosmosChain method.
		IsCosmosChain []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
		}
	}
	lockIsCosmosChain sync.RWMutex
}

// IsCosmosChain calls IsCosmosChainFunc.
func (mock *AxelarnetKeeperMock) IsCosmosChain(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) bool {
	if mock.IsCosmosChainFunc == nil {
		panic("AxelarnetKeeperMock.IsCosmosChainFunc: method is nil but AxelarnetKeeper.IsCosmosChain was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockIsCosmosChain.Lock()
	mock.calls.IsCosmosChain = append(mock.calls.IsCosmosChain, callInfo)
	mock.lockIsCosmosChain.Unlock()
	return mock.IsCosmosChainFunc(ctx, chain)
}

// IsCosmosChainCalls gets all the calls that were made to IsCosmosChain.
// Check the length with:
//
//	len(mockedAxelarnetKeeper.IsCosmosChainCalls())
func (mock *AxelarnetKeeperMock) IsCosmosChainCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}
	mock.lockIsCosmosChain.RLock()
	calls = mock.calls.IsCosmosChain
	mock.lockIsCosmosChain.RUnlock()
	return calls
}

// Ensure, that RewardKeeperMock does implement nexustypes.RewardKeeper.
// If this is not the case, regenerate this file with moq.
var _ nexustypes.RewardKeeper = &RewardKeeperMock{}

// RewardKeeperMock is a mock implementation of nexustypes.RewardKeeper.
//
//	func TestSomethingThatUsesRewardKeeper(t *testing.T) {
//
//		// make and configure a mocked nexustypes.RewardKeeper
//		mockedRewardKeeper := &RewardKeeperMock{
//			GetPoolFunc: func(ctx cosmossdktypes.Context, name string) reward.RewardPool {
//				panic("mock out the GetPool method")
//			},
//		}
//
//		// use mockedRewardKeeper in code that requires nexustypes.RewardKeeper
//		// and then make assertions.
//
//	}
type RewardKeeperMock struct {
	// GetPoolFunc mocks the GetPool method.
	GetPoolFunc func(ctx cosmossdktypes.Context, name string) reward.RewardPool

	// calls tracks calls to the methods.
	calls struct {
		// GetPool holds details about calls to the GetPool method.
		GetPool []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Name is the name argument value.
			Name string
		}
	}
	lockGetPool sync.RWMutex
}

// GetPool calls GetPoolFunc.
func (mock *RewardKeeperMock) GetPool(ctx cosmossdktypes.Context, name string) reward.RewardPool {
	if mock.GetPoolFunc == nil {
		panic("RewardKeeperMock.GetPoolFunc: method is nil but RewardKeeper.GetPool was just called")
	}
	callInfo := struct {
		Ctx  cosmossdktypes.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockGetPool.Lock()
	mock.calls.GetPool = append(mock.calls.GetPool, callInfo)
	mock.lockGetPool.Unlock()
	return mock.GetPoolFunc(ctx, name)
}

// GetPoolCalls gets all the calls that were made to GetPool.
// Check the length with:
//
//	len(mockedRewardKeeper.GetPoolCalls())
func (mock *RewardKeeperMock) GetPoolCalls() []struct {
	Ctx  cosmossdktypes.Context
	Name string
} {
	var calls []struct {
		Ctx  cosmossdktypes.Context
		Name string
	}
	mock.lockGetPool.RLock()
	calls = mock.calls.GetPool
	mock.lockGetPool.RUnlock()
	return calls
}

// Ensure, that SlashingKeeperMock does implement nexustypes.SlashingKeeper.
// If this is not the case, regenerate this file with moq.
var _ nexustypes.SlashingKeeper = &SlashingKeeperMock{}

// SlashingKeeperMock is a mock implementation of nexustypes.SlashingKeeper.
//
//	func TestSomethingThatUsesSlashingKeeper(t *testing.T) {
//
//		// make and configure a mocked nexustypes.SlashingKeeper
//		mockedSlashingKeeper := &SlashingKeeperMock{
//			IsTombstonedFunc: func(ctx cosmossdktypes.Context, consAddr cosmossdktypes.ConsAddress) bool {
//				panic("mock out the IsTombstoned method")
//			},
//		}
//
//		// use mockedSlashingKeeper in code that requires nexustypes.SlashingKeeper
//		// and then make assertions.
//
//	}
type SlashingKeeperMock struct {
	// IsTombstonedFunc mocks the IsTombstoned method.
	IsTombstonedFunc func(ctx cosmossdktypes.Context, consAddr cosmossdktypes.ConsAddress) bool

	// calls tracks calls to the methods.
	calls struct {
		// IsTombstoned holds details about calls to the IsTombstoned method.
		IsTombstoned []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ConsAddr is the consAddr argument value.
			ConsAddr cosmossdktypes.ConsAddress
		}
	}
	lockIsTombstoned sync.RWMutex
}

// IsTombstoned calls IsTombstonedFunc.
func (mock *SlashingKeeperMock) IsTombstoned(ctx cosmossdktypes.Context, consAddr cosmossdktypes.ConsAddress) bool {
	if mock.IsTombstonedFunc == nil {
		panic("SlashingKeeperMock.IsTombstonedFunc: method is nil but SlashingKeeper.IsTombstoned was just called")
	}
	callInfo := struct {
		Ctx      cosmossdktypes.Context
		ConsAddr cosmossdktypes.ConsAddress
	}{
		Ctx:      ctx,
		ConsAddr: consAddr,
	}
	mock.lockIsTombstoned.Lock()
	mock.calls.IsTombstoned = append(mock.calls.IsTombstoned, callInfo)
	mock.lockIsTombstoned.Unlock()
	return mock.IsTombstonedFunc(ctx, consAddr)
}

// IsTombstonedCalls gets all the calls that were made to IsTombstoned.
// Check the length with:
//
//	len(mockedSlashingKeeper.IsTombstonedCalls())
func (mock *SlashingKeeperMock) IsTombstonedCalls() []struct {
	Ctx      cosmossdktypes.Context
	ConsAddr cosmossdktypes.ConsAddress
} {
	var calls []struct {
		Ctx      cosmossdktypes.Context
		ConsAddr cosmossdktypes.ConsAddress
	}
	mock.lockIsTombstoned.RLock()
	calls = mock.calls.IsTombstoned
	mock.lockIsTombstoned.RUnlock()
	return calls
}

// Ensure, that WasmKeeperMock does implement nexustypes.WasmKeeper.
// If this is not the case, regenerate this file with moq.
var _ nexustypes.WasmKeeper = &WasmKeeperMock{}

// WasmKeeperMock is a mock implementation of nexustypes.WasmKeeper.
//
//	func TestSomethingThatUsesWasmKeeper(t *testing.T) {
//
//		// make and configure a mocked nexustypes.WasmKeeper
//		mockedWasmKeeper := &WasmKeeperMock{
//			ClearContractAdminFunc: func(ctx cosmossdktypes.Context, contractAddress cosmossdktypes.AccAddress, caller cosmossdktypes.AccAddress) error {
//				panic("mock out the ClearContractAdmin method")
//			},
//			CreateFunc: func(ctx cosmossdktypes.Context, creator cosmossdktypes.AccAddress, wasmCode []byte, instantiateAccess *wasmtypes.AccessConfig) (uint64, []byte, error) {
//				panic("mock out the Create method")
//			},
//			ExecuteFunc: func(ctx cosmossdktypes.Context, contractAddress cosmossdktypes.AccAddress, caller cosmossdktypes.AccAddress, msg []byte, coins cosmossdktypes.Coins) ([]byte, error) {
//				panic("mock out the Execute method")
//			},
//			InstantiateFunc: func(ctx cosmossdktypes.Context, codeID uint64, creator cosmossdktypes.AccAddress, admin cosmossdktypes.AccAddress, initMsg []byte, label string, deposit cosmossdktypes.Coins) (cosmossdktypes.AccAddress, []byte, error) {
//				panic("mock out the Instantiate method")
//			},
//			Instantiate2Func: func(ctx cosmossdktypes.Context, codeID uint64, creator cosmossdktypes.AccAddress, admin cosmossdktypes.AccAddress, initMsg []byte, label string, deposit cosmossdktypes.Coins, salt []byte, fixMsg bool) (cosmossdktypes.AccAddress, []byte, error) {
//				panic("mock out the Instantiate2 method")
//			},
//			MigrateFunc: func(ctx cosmossdktypes.Context, contractAddress cosmossdktypes.AccAddress, caller cosmossdktypes.AccAddress, newCodeID uint64, msg []byte) ([]byte, error) {
//				panic("mock out the Migrate method")
//			},
//			PinCodeFunc: func(ctx cosmossdktypes.Context, codeID uint64) error {
//				panic("mock out the PinCode method")
//			},
//			SetAccessConfigFunc: func(ctx cosmossdktypes.Context, codeID uint64, caller cosmossdktypes.AccAddress, newConfig wasmtypes.AccessConfig) error {
//				panic("mock out the SetAccessConfig method")
//			},
//			SetContractInfoExtensionFunc: func(ctx cosmossdktypes.Context, contract cosmossdktypes.AccAddress, extra wasmtypes.ContractInfoExtension) error {
//				panic("mock out the SetContractInfoExtension method")
//			},
//			SudoFunc: func(ctx cosmossdktypes.Context, contractAddress cosmossdktypes.AccAddress, msg []byte) ([]byte, error) {
//				panic("mock out the Sudo method")
//			},
//			UnpinCodeFunc: func(ctx cosmossdktypes.Context, codeID uint64) error {
//				panic("mock out the UnpinCode method")
//			},
//			UpdateContractAdminFunc: func(ctx cosmossdktypes.Context, contractAddress cosmossdktypes.AccAddress, caller cosmossdktypes.AccAddress, newAdmin cosmossdktypes.AccAddress) error {
//				panic("mock out the UpdateContractAdmin method")
//			},
//		}
//
//		// use mockedWasmKeeper in code that requires nexustypes.WasmKeeper
//		// and then make assertions.
//
//	}
type WasmKeeperMock struct {
	// ClearContractAdminFunc mocks the ClearContractAdmin method.
	ClearContractAdminFunc func(ctx cosmossdktypes.Context, contractAddress cosmossdktypes.AccAddress, caller cosmossdktypes.AccAddress) error

	// CreateFunc mocks the Create method.
	CreateFunc func(ctx cosmossdktypes.Context, creator cosmossdktypes.AccAddress, wasmCode []byte, instantiateAccess *wasmtypes.AccessConfig) (uint64, []byte, error)

	// ExecuteFunc mocks the Execute method.
	ExecuteFunc func(ctx cosmossdktypes.Context, contractAddress cosmossdktypes.AccAddress, caller cosmossdktypes.AccAddress, msg []byte, coins cosmossdktypes.Coins) ([]byte, error)

	// InstantiateFunc mocks the Instantiate method.
	InstantiateFunc func(ctx cosmossdktypes.Context, codeID uint64, creator cosmossdktypes.AccAddress, admin cosmossdktypes.AccAddress, initMsg []byte, label string, deposit cosmossdktypes.Coins) (cosmossdktypes.AccAddress, []byte, error)

	// Instantiate2Func mocks the Instantiate2 method.
	Instantiate2Func func(ctx cosmossdktypes.Context, codeID uint64, creator cosmossdktypes.AccAddress, admin cosmossdktypes.AccAddress, initMsg []byte, label string, deposit cosmossdktypes.Coins, salt []byte, fixMsg bool) (cosmossdktypes.AccAddress, []byte, error)

	// MigrateFunc mocks the Migrate method.
	MigrateFunc func(ctx cosmossdktypes.Context, contractAddress cosmossdktypes.AccAddress, caller cosmossdktypes.AccAddress, newCodeID uint64, msg []byte) ([]byte, error)

	// PinCodeFunc mocks the PinCode method.
	PinCodeFunc func(ctx cosmossdktypes.Context, codeID uint64) error

	// SetAccessConfigFunc mocks the SetAccessConfig method.
	SetAccessConfigFunc func(ctx cosmossdktypes.Context, codeID uint64, caller cosmossdktypes.AccAddress, newConfig wasmtypes.AccessConfig) error

	// SetContractInfoExtensionFunc mocks the SetContractInfoExtension method.
	SetContractInfoExtensionFunc func(ctx cosmossdktypes.Context, contract cosmossdktypes.AccAddress, extra wasmtypes.ContractInfoExtension) error

	// SudoFunc mocks the Sudo method.
	SudoFunc func(ctx cosmossdktypes.Context, contractAddress cosmossdktypes.AccAddress, msg []byte) ([]byte, error)

	// UnpinCodeFunc mocks the UnpinCode method.
	UnpinCodeFunc func(ctx cosmossdktypes.Context, codeID uint64) error

	// UpdateContractAdminFunc mocks the UpdateContractAdmin method.
	UpdateContractAdminFunc func(ctx cosmossdktypes.Context, contractAddress cosmossdktypes.AccAddress, caller cosmossdktypes.AccAddress, newAdmin cosmossdktypes.AccAddress) error

	// calls tracks calls to the methods.
	calls struct {
		// ClearContractAdmin holds details about calls to the ClearContractAdmin method.
		ClearContractAdmin []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ContractAddress is the contractAddress argument value.
			ContractAddress cosmossdktypes.AccAddress
			// Caller is the caller argument value.
			Caller cosmossdktypes.AccAddress
		}
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Creator is the creator argument value.
			Creator cosmossdktypes.AccAddress
			// WasmCode is the wasmCode argument value.
			WasmCode []byte
			// InstantiateAccess is the instantiateAccess argument value.
			InstantiateAccess *wasmtypes.AccessConfig
		}
		// Execute holds details about calls to the Execute method.
		Execute []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ContractAddress is the contractAddress argument value.
			ContractAddress cosmossdktypes.AccAddress
			// Caller is the caller argument value.
			Caller cosmossdktypes.AccAddress
			// Msg is the msg argument value.
			Msg []byte
			// Coins is the coins argument value.
			Coins cosmossdktypes.Coins
		}
		// Instantiate holds details about calls to the Instantiate method.
		Instantiate []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// CodeID is the codeID argument value.
			CodeID uint64
			// Creator is the creator argument value.
			Creator cosmossdktypes.AccAddress
			// Admin is the admin argument value.
			Admin cosmossdktypes.AccAddress
			// InitMsg is the initMsg argument value.
			InitMsg []byte
			// Label is the label argument value.
			Label string
			// Deposit is the deposit argument value.
			Deposit cosmossdktypes.Coins
		}
		// Instantiate2 holds details about calls to the Instantiate2 method.
		Instantiate2 []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// CodeID is the codeID argument value.
			CodeID uint64
			// Creator is the creator argument value.
			Creator cosmossdktypes.AccAddress
			// Admin is the admin argument value.
			Admin cosmossdktypes.AccAddress
			// InitMsg is the initMsg argument value.
			InitMsg []byte
			// Label is the label argument value.
			Label string
			// Deposit is the deposit argument value.
			Deposit cosmossdktypes.Coins
			// Salt is the salt argument value.
			Salt []byte
			// FixMsg is the fixMsg argument value.
			FixMsg bool
		}
		// Migrate holds details about calls to the Migrate method.
		Migrate []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ContractAddress is the contractAddress argument value.
			ContractAddress cosmossdktypes.AccAddress
			// Caller is the caller argument value.
			Caller cosmossdktypes.AccAddress
			// NewCodeID is the newCodeID argument value.
			NewCodeID uint64
			// Msg is the msg argument value.
			Msg []byte
		}
		// PinCode holds details about calls to the PinCode method.
		PinCode []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// CodeID is the codeID argument value.
			CodeID uint64
		}
		// SetAccessConfig holds details about calls to the SetAccessConfig method.
		SetAccessConfig []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// CodeID is the codeID argument value.
			CodeID uint64
			// Caller is the caller argument value.
			Caller cosmossdktypes.AccAddress
			// NewConfig is the newConfig argument value.
			NewConfig wasmtypes.AccessConfig
		}
		// SetContractInfoExtension holds details about calls to the SetContractInfoExtension method.
		SetContractInfoExtension []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Contract is the contract argument value.
			Contract cosmossdktypes.AccAddress
			// Extra is the extra argument value.
			Extra wasmtypes.ContractInfoExtension
		}
		// Sudo holds details about calls to the Sudo method.
		Sudo []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ContractAddress is the contractAddress argument value.
			ContractAddress cosmossdktypes.AccAddress
			// Msg is the msg argument value.
			Msg []byte
		}
		// UnpinCode holds details about calls to the UnpinCode method.
		UnpinCode []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// CodeID is the codeID argument value.
			CodeID uint64
		}
		// UpdateContractAdmin holds details about calls to the UpdateContractAdmin method.
		UpdateContractAdmin []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ContractAddress is the contractAddress argument value.
			ContractAddress cosmossdktypes.AccAddress
			// Caller is the caller argument value.
			Caller cosmossdktypes.AccAddress
			// NewAdmin is the newAdmin argument value.
			NewAdmin cosmossdktypes.AccAddress
		}
	}
	lockClearContractAdmin       sync.RWMutex
	lockCreate                   sync.RWMutex
	lockExecute                  sync.RWMutex
	lockInstantiate              sync.RWMutex
	lockInstantiate2             sync.RWMutex
	lockMigrate                  sync.RWMutex
	lockPinCode                  sync.RWMutex
	lockSetAccessConfig          sync.RWMutex
	lockSetContractInfoExtension sync.RWMutex
	lockSudo                     sync.RWMutex
	lockUnpinCode                sync.RWMutex
	lockUpdateContractAdmin      sync.RWMutex
}

// ClearContractAdmin calls ClearContractAdminFunc.
func (mock *WasmKeeperMock) ClearContractAdmin(ctx cosmossdktypes.Context, contractAddress cosmossdktypes.AccAddress, caller cosmossdktypes.AccAddress) error {
	if mock.ClearContractAdminFunc == nil {
		panic("WasmKeeperMock.ClearContractAdminFunc: method is nil but WasmKeeper.ClearContractAdmin was just called")
	}
	callInfo := struct {
		Ctx             cosmossdktypes.Context
		ContractAddress cosmossdktypes.AccAddress
		Caller          cosmossdktypes.AccAddress
	}{
		Ctx:             ctx,
		ContractAddress: contractAddress,
		Caller:          caller,
	}
	mock.lockClearContractAdmin.Lock()
	mock.calls.ClearContractAdmin = append(mock.calls.ClearContractAdmin, callInfo)
	mock.lockClearContractAdmin.Unlock()
	return mock.ClearContractAdminFunc(ctx, contractAddress, caller)
}

// ClearContractAdminCalls gets all the calls that were made to ClearContractAdmin.
// Check the length with:
//
//	len(mockedWasmKeeper.ClearContractAdminCalls())
func (mock *WasmKeeperMock) ClearContractAdminCalls() []struct {
	Ctx             cosmossdktypes.Context
	ContractAddress cosmossdktypes.AccAddress
	Caller          cosmossdktypes.AccAddress
} {
	var calls []struct {
		Ctx             cosmossdktypes.Context
		ContractAddress cosmossdktypes.AccAddress
		Caller          cosmossdktypes.AccAddress
	}
	mock.lockClearContractAdmin.RLock()
	calls = mock.calls.ClearContractAdmin
	mock.lockClearContractAdmin.RUnlock()
	return calls
}

// Create calls CreateFunc.
func (mock *WasmKeeperMock) Create(ctx cosmossdktypes.Context, creator cosmossdktypes.AccAddress, wasmCode []byte, instantiateAccess *wasmtypes.AccessConfig) (uint64, []byte, error) {
	if mock.CreateFunc == nil {
		panic("WasmKeeperMock.CreateFunc: method is nil but WasmKeeper.Create was just called")
	}
	callInfo := struct {
		Ctx               cosmossdktypes.Context
		Creator           cosmossdktypes.AccAddress
		WasmCode          []byte
		InstantiateAccess *wasmtypes.AccessConfig
	}{
		Ctx:               ctx,
		Creator:           creator,
		WasmCode:          wasmCode,
		InstantiateAccess: instantiateAccess,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, creator, wasmCode, instantiateAccess)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedWasmKeeper.CreateCalls())
func (mock *WasmKeeperMock) CreateCalls() []struct {
	Ctx               cosmossdktypes.Context
	Creator           cosmossdktypes.AccAddress
	WasmCode          []byte
	InstantiateAccess *wasmtypes.AccessConfig
} {
	var calls []struct {
		Ctx               cosmossdktypes.Context
		Creator           cosmossdktypes.AccAddress
		WasmCode          []byte
		InstantiateAccess *wasmtypes.AccessConfig
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Execute calls ExecuteFunc.
func (mock *WasmKeeperMock) Execute(ctx cosmossdktypes.Context, contractAddress cosmossdktypes.AccAddress, caller cosmossdktypes.AccAddress, msg []byte, coins cosmossdktypes.Coins) ([]byte, error) {
	if mock.ExecuteFunc == nil {
		panic("WasmKeeperMock.ExecuteFunc: method is nil but WasmKeeper.Execute was just called")
	}
	callInfo := struct {
		Ctx             cosmossdktypes.Context
		ContractAddress cosmossdktypes.AccAddress
		Caller          cosmossdktypes.AccAddress
		Msg             []byte
		Coins           cosmossdktypes.Coins
	}{
		Ctx:             ctx,
		ContractAddress: contractAddress,
		Caller:          caller,
		Msg:             msg,
		Coins:           coins,
	}
	mock.lockExecute.Lock()
	mock.calls.Execute = append(mock.calls.Execute, callInfo)
	mock.lockExecute.Unlock()
	return mock.ExecuteFunc(ctx, contractAddress, caller, msg, coins)
}

// ExecuteCalls gets all the calls that were made to Execute.
// Check the length with:
//
//	len(mockedWasmKeeper.ExecuteCalls())
func (mock *WasmKeeperMock) ExecuteCalls() []struct {
	Ctx             cosmossdktypes.Context
	ContractAddress cosmossdktypes.AccAddress
	Caller          cosmossdktypes.AccAddress
	Msg             []byte
	Coins           cosmossdktypes.Coins
} {
	var calls []struct {
		Ctx             cosmossdktypes.Context
		ContractAddress cosmossdktypes.AccAddress
		Caller          cosmossdktypes.AccAddress
		Msg             []byte
		Coins           cosmossdktypes.Coins
	}
	mock.lockExecute.RLock()
	calls = mock.calls.Execute
	mock.lockExecute.RUnlock()
	return calls
}

// Instantiate calls InstantiateFunc.
func (mock *WasmKeeperMock) Instantiate(ctx cosmossdktypes.Context, codeID uint64, creator cosmossdktypes.AccAddress, admin cosmossdktypes.AccAddress, initMsg []byte, label string, deposit cosmossdktypes.Coins) (cosmossdktypes.AccAddress, []byte, error) {
	if mock.InstantiateFunc == nil {
		panic("WasmKeeperMock.InstantiateFunc: method is nil but WasmKeeper.Instantiate was just called")
	}
	callInfo := struct {
		Ctx     cosmossdktypes.Context
		CodeID  uint64
		Creator cosmossdktypes.AccAddress
		Admin   cosmossdktypes.AccAddress
		InitMsg []byte
		Label   string
		Deposit cosmossdktypes.Coins
	}{
		Ctx:     ctx,
		CodeID:  codeID,
		Creator: creator,
		Admin:   admin,
		InitMsg: initMsg,
		Label:   label,
		Deposit: deposit,
	}
	mock.lockInstantiate.Lock()
	mock.calls.Instantiate = append(mock.calls.Instantiate, callInfo)
	mock.lockInstantiate.Unlock()
	return mock.InstantiateFunc(ctx, codeID, creator, admin, initMsg, label, deposit)
}

// InstantiateCalls gets all the calls that were made to Instantiate.
// Check the length with:
//
//	len(mockedWasmKeeper.InstantiateCalls())
func (mock *WasmKeeperMock) InstantiateCalls() []struct {
	Ctx     cosmossdktypes.Context
	CodeID  uint64
	Creator cosmossdktypes.AccAddress
	Admin   cosmossdktypes.AccAddress
	InitMsg []byte
	Label   string
	Deposit cosmossdktypes.Coins
} {
	var calls []struct {
		Ctx     cosmossdktypes.Context
		CodeID  uint64
		Creator cosmossdktypes.AccAddress
		Admin   cosmossdktypes.AccAddress
		InitMsg []byte
		Label   string
		Deposit cosmossdktypes.Coins
	}
	mock.lockInstantiate.RLock()
	calls = mock.calls.Instantiate
	mock.lockInstantiate.RUnlock()
	return calls
}

// Instantiate2 calls Instantiate2Func.
func (mock *WasmKeeperMock) Instantiate2(ctx cosmossdktypes.Context, codeID uint64, creator cosmossdktypes.AccAddress, admin cosmossdktypes.AccAddress, initMsg []byte, label string, deposit cosmossdktypes.Coins, salt []byte, fixMsg bool) (cosmossdktypes.AccAddress, []byte, error) {
	if mock.Instantiate2Func == nil {
		panic("WasmKeeperMock.Instantiate2Func: method is nil but WasmKeeper.Instantiate2 was just called")
	}
	callInfo := struct {
		Ctx     cosmossdktypes.Context
		CodeID  uint64
		Creator cosmossdktypes.AccAddress
		Admin   cosmossdktypes.AccAddress
		InitMsg []byte
		Label   string
		Deposit cosmossdktypes.Coins
		Salt    []byte
		FixMsg  bool
	}{
		Ctx:     ctx,
		CodeID:  codeID,
		Creator: creator,
		Admin:   admin,
		InitMsg: initMsg,
		Label:   label,
		Deposit: deposit,
		Salt:    salt,
		FixMsg:  fixMsg,
	}
	mock.lockInstantiate2.Lock()
	mock.calls.Instantiate2 = append(mock.calls.Instantiate2, callInfo)
	mock.lockInstantiate2.Unlock()
	return mock.Instantiate2Func(ctx, codeID, creator, admin, initMsg, label, deposit, salt, fixMsg)
}

// Instantiate2Calls gets all the calls that were made to Instantiate2.
// Check the length with:
//
//	len(mockedWasmKeeper.Instantiate2Calls())
func (mock *WasmKeeperMock) Instantiate2Calls() []struct {
	Ctx     cosmossdktypes.Context
	CodeID  uint64
	Creator cosmossdktypes.AccAddress
	Admin   cosmossdktypes.AccAddress
	InitMsg []byte
	Label   string
	Deposit cosmossdktypes.Coins
	Salt    []byte
	FixMsg  bool
} {
	var calls []struct {
		Ctx     cosmossdktypes.Context
		CodeID  uint64
		Creator cosmossdktypes.AccAddress
		Admin   cosmossdktypes.AccAddress
		InitMsg []byte
		Label   string
		Deposit cosmossdktypes.Coins
		Salt    []byte
		FixMsg  bool
	}
	mock.lockInstantiate2.RLock()
	calls = mock.calls.Instantiate2
	mock.lockInstantiate2.RUnlock()
	return calls
}

// Migrate calls MigrateFunc.
func (mock *WasmKeeperMock) Migrate(ctx cosmossdktypes.Context, contractAddress cosmossdktypes.AccAddress, caller cosmossdktypes.AccAddress, newCodeID uint64, msg []byte) ([]byte, error) {
	if mock.MigrateFunc == nil {
		panic("WasmKeeperMock.MigrateFunc: method is nil but WasmKeeper.Migrate was just called")
	}
	callInfo := struct {
		Ctx             cosmossdktypes.Context
		ContractAddress cosmossdktypes.AccAddress
		Caller          cosmossdktypes.AccAddress
		NewCodeID       uint64
		Msg             []byte
	}{
		Ctx:             ctx,
		ContractAddress: contractAddress,
		Caller:          caller,
		NewCodeID:       newCodeID,
		Msg:             msg,
	}
	mock.lockMigrate.Lock()
	mock.calls.Migrate = append(mock.calls.Migrate, callInfo)
	mock.lockMigrate.Unlock()
	return mock.MigrateFunc(ctx, contractAddress, caller, newCodeID, msg)
}

// MigrateCalls gets all the calls that were made to Migrate.
// Check the length with:
//
//	len(mockedWasmKeeper.MigrateCalls())
func (mock *WasmKeeperMock) MigrateCalls() []struct {
	Ctx             cosmossdktypes.Context
	ContractAddress cosmossdktypes.AccAddress
	Caller          cosmossdktypes.AccAddress
	NewCodeID       uint64
	Msg             []byte
} {
	var calls []struct {
		Ctx             cosmossdktypes.Context
		ContractAddress cosmossdktypes.AccAddress
		Caller          cosmossdktypes.AccAddress
		NewCodeID       uint64
		Msg             []byte
	}
	mock.lockMigrate.RLock()
	calls = mock.calls.Migrate
	mock.lockMigrate.RUnlock()
	return calls
}

// PinCode calls PinCodeFunc.
func (mock *WasmKeeperMock) PinCode(ctx cosmossdktypes.Context, codeID uint64) error {
	if mock.PinCodeFunc == nil {
		panic("WasmKeeperMock.PinCodeFunc: method is nil but WasmKeeper.PinCode was just called")
	}
	callInfo := struct {
		Ctx    cosmossdktypes.Context
		CodeID uint64
	}{
		Ctx:    ctx,
		CodeID: codeID,
	}
	mock.lockPinCode.Lock()
	mock.calls.PinCode = append(mock.calls.PinCode, callInfo)
	mock.lockPinCode.Unlock()
	return mock.PinCodeFunc(ctx, codeID)
}

// PinCodeCalls gets all the calls that were made to PinCode.
// Check the length with:
//
//	len(mockedWasmKeeper.PinCodeCalls())
func (mock *WasmKeeperMock) PinCodeCalls() []struct {
	Ctx    cosmossdktypes.Context
	CodeID uint64
} {
	var calls []struct {
		Ctx    cosmossdktypes.Context
		CodeID uint64
	}
	mock.lockPinCode.RLock()
	calls = mock.calls.PinCode
	mock.lockPinCode.RUnlock()
	return calls
}

// SetAccessConfig calls SetAccessConfigFunc.
func (mock *WasmKeeperMock) SetAccessConfig(ctx cosmossdktypes.Context, codeID uint64, caller cosmossdktypes.AccAddress, newConfig wasmtypes.AccessConfig) error {
	if mock.SetAccessConfigFunc == nil {
		panic("WasmKeeperMock.SetAccessConfigFunc: method is nil but WasmKeeper.SetAccessConfig was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		CodeID    uint64
		Caller    cosmossdktypes.AccAddress
		NewConfig wasmtypes.AccessConfig
	}{
		Ctx:       ctx,
		CodeID:    codeID,
		Caller:    caller,
		NewConfig: newConfig,
	}
	mock.lockSetAccessConfig.Lock()
	mock.calls.SetAccessConfig = append(mock.calls.SetAccessConfig, callInfo)
	mock.lockSetAccessConfig.Unlock()
	return mock.SetAccessConfigFunc(ctx, codeID, caller, newConfig)
}

// SetAccessConfigCalls gets all the calls that were made to SetAccessConfig.
// Check the length with:
//
//	len(mockedWasmKeeper.SetAccessConfigCalls())
func (mock *WasmKeeperMock) SetAccessConfigCalls() []struct {
	Ctx       cosmossdktypes.Context
	CodeID    uint64
	Caller    cosmossdktypes.AccAddress
	NewConfig wasmtypes.AccessConfig
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		CodeID    uint64
		Caller    cosmossdktypes.AccAddress
		NewConfig wasmtypes.AccessConfig
	}
	mock.lockSetAccessConfig.RLock()
	calls = mock.calls.SetAccessConfig
	mock.lockSetAccessConfig.RUnlock()
	return calls
}

// SetContractInfoExtension calls SetContractInfoExtensionFunc.
func (mock *WasmKeeperMock) SetContractInfoExtension(ctx cosmossdktypes.Context, contract cosmossdktypes.AccAddress, extra wasmtypes.ContractInfoExtension) error {
	if mock.SetContractInfoExtensionFunc == nil {
		panic("WasmKeeperMock.SetContractInfoExtensionFunc: method is nil but WasmKeeper.SetContractInfoExtension was just called")
	}
	callInfo := struct {
		Ctx      cosmossdktypes.Context
		Contract cosmossdktypes.AccAddress
		Extra    wasmtypes.ContractInfoExtension
	}{
		Ctx:      ctx,
		Contract: contract,
		Extra:    extra,
	}
	mock.lockSetContractInfoExtension.Lock()
	mock.calls.SetContractInfoExtension = append(mock.calls.SetContractInfoExtension, callInfo)
	mock.lockSetContractInfoExtension.Unlock()
	return mock.SetContractInfoExtensionFunc(ctx, contract, extra)
}

// SetContractInfoExtensionCalls gets all the calls that were made to SetContractInfoExtension.
// Check the length with:
//
//	len(mockedWasmKeeper.SetContractInfoExtensionCalls())
func (mock *WasmKeeperMock) SetContractInfoExtensionCalls() []struct {
	Ctx      cosmossdktypes.Context
	Contract cosmossdktypes.AccAddress
	Extra    wasmtypes.ContractInfoExtension
} {
	var calls []struct {
		Ctx      cosmossdktypes.Context
		Contract cosmossdktypes.AccAddress
		Extra    wasmtypes.ContractInfoExtension
	}
	mock.lockSetContractInfoExtension.RLock()
	calls = mock.calls.SetContractInfoExtension
	mock.lockSetContractInfoExtension.RUnlock()
	return calls
}

// Sudo calls SudoFunc.
func (mock *WasmKeeperMock) Sudo(ctx cosmossdktypes.Context, contractAddress cosmossdktypes.AccAddress, msg []byte) ([]byte, error) {
	if mock.SudoFunc == nil {
		panic("WasmKeeperMock.SudoFunc: method is nil but WasmKeeper.Sudo was just called")
	}
	callInfo := struct {
		Ctx             cosmossdktypes.Context
		ContractAddress cosmossdktypes.AccAddress
		Msg             []byte
	}{
		Ctx:             ctx,
		ContractAddress: contractAddress,
		Msg:             msg,
	}
	mock.lockSudo.Lock()
	mock.calls.Sudo = append(mock.calls.Sudo, callInfo)
	mock.lockSudo.Unlock()
	return mock.SudoFunc(ctx, contractAddress, msg)
}

// SudoCalls gets all the calls that were made to Sudo.
// Check the length with:
//
//	len(mockedWasmKeeper.SudoCalls())
func (mock *WasmKeeperMock) SudoCalls() []struct {
	Ctx             cosmossdktypes.Context
	ContractAddress cosmossdktypes.AccAddress
	Msg             []byte
} {
	var calls []struct {
		Ctx             cosmossdktypes.Context
		ContractAddress cosmossdktypes.AccAddress
		Msg             []byte
	}
	mock.lockSudo.RLock()
	calls = mock.calls.Sudo
	mock.lockSudo.RUnlock()
	return calls
}

// UnpinCode calls UnpinCodeFunc.
func (mock *WasmKeeperMock) UnpinCode(ctx cosmossdktypes.Context, codeID uint64) error {
	if mock.UnpinCodeFunc == nil {
		panic("WasmKeeperMock.UnpinCodeFunc: method is nil but WasmKeeper.UnpinCode was just called")
	}
	callInfo := struct {
		Ctx    cosmossdktypes.Context
		CodeID uint64
	}{
		Ctx:    ctx,
		CodeID: codeID,
	}
	mock.lockUnpinCode.Lock()
	mock.calls.UnpinCode = append(mock.calls.UnpinCode, callInfo)
	mock.lockUnpinCode.Unlock()
	return mock.UnpinCodeFunc(ctx, codeID)
}

// UnpinCodeCalls gets all the calls that were made to UnpinCode.
// Check the length with:
//
//	len(mockedWasmKeeper.UnpinCodeCalls())
func (mock *WasmKeeperMock) UnpinCodeCalls() []struct {
	Ctx    cosmossdktypes.Context
	CodeID uint64
} {
	var calls []struct {
		Ctx    cosmossdktypes.Context
		CodeID uint64
	}
	mock.lockUnpinCode.RLock()
	calls = mock.calls.UnpinCode
	mock.lockUnpinCode.RUnlock()
	return calls
}

// UpdateContractAdmin calls UpdateContractAdminFunc.
func (mock *WasmKeeperMock) UpdateContractAdmin(ctx cosmossdktypes.Context, contractAddress cosmossdktypes.AccAddress, caller cosmossdktypes.AccAddress, newAdmin cosmossdktypes.AccAddress) error {
	if mock.UpdateContractAdminFunc == nil {
		panic("WasmKeeperMock.UpdateContractAdminFunc: method is nil but WasmKeeper.UpdateContractAdmin was just called")
	}
	callInfo := struct {
		Ctx             cosmossdktypes.Context
		ContractAddress cosmossdktypes.AccAddress
		Caller          cosmossdktypes.AccAddress
		NewAdmin        cosmossdktypes.AccAddress
	}{
		Ctx:             ctx,
		ContractAddress: contractAddress,
		Caller:          caller,
		NewAdmin:        newAdmin,
	}
	mock.lockUpdateContractAdmin.Lock()
	mock.calls.UpdateContractAdmin = append(mock.calls.UpdateContractAdmin, callInfo)
	mock.lockUpdateContractAdmin.Unlock()
	return mock.UpdateContractAdminFunc(ctx, contractAddress, caller, newAdmin)
}

// UpdateContractAdminCalls gets all the calls that were made to UpdateContractAdmin.
// Check the length with:
//
//	len(mockedWasmKeeper.UpdateContractAdminCalls())
func (mock *WasmKeeperMock) UpdateContractAdminCalls() []struct {
	Ctx             cosmossdktypes.Context
	ContractAddress cosmossdktypes.AccAddress
	Caller          cosmossdktypes.AccAddress
	NewAdmin        cosmossdktypes.AccAddress
} {
	var calls []struct {
		Ctx             cosmossdktypes.Context
		ContractAddress cosmossdktypes.AccAddress
		Caller          cosmossdktypes.AccAddress
		NewAdmin        cosmossdktypes.AccAddress
	}
	mock.lockUpdateContractAdmin.RLock()
	calls = mock.calls.UpdateContractAdmin
	mock.lockUpdateContractAdmin.RUnlock()
	return calls
}

// Ensure, that AccountKeeperMock does implement nexustypes.AccountKeeper.
// If this is not the case, regenerate this file with moq.
var _ nexustypes.AccountKeeper = &AccountKeeperMock{}

// AccountKeeperMock is a mock implementation of nexustypes.AccountKeeper.
//
//	func TestSomethingThatUsesAccountKeeper(t *testing.T) {
//
//		// make and configure a mocked nexustypes.AccountKeeper
//		mockedAccountKeeper := &AccountKeeperMock{
//			GetModuleAddressFunc: func(moduleName string) cosmossdktypes.AccAddress {
//				panic("mock out the GetModuleAddress method")
//			},
//		}
//
//		// use mockedAccountKeeper in code that requires nexustypes.AccountKeeper
//		// and then make assertions.
//
//	}
type AccountKeeperMock struct {
	// GetModuleAddressFunc mocks the GetModuleAddress method.
	GetModuleAddressFunc func(moduleName string) cosmossdktypes.AccAddress

	// calls tracks calls to the methods.
	calls struct {
		// GetModuleAddress holds details about calls to the GetModuleAddress method.
		GetModuleAddress []struct {
			// ModuleName is the moduleName argument value.
			ModuleName string
		}
	}
	lockGetModuleAddress sync.RWMutex
}

// GetModuleAddress calls GetModuleAddressFunc.
func (mock *AccountKeeperMock) GetModuleAddress(moduleName string) cosmossdktypes.AccAddress {
	if mock.GetModuleAddressFunc == nil {
		panic("AccountKeeperMock.GetModuleAddressFunc: method is nil but AccountKeeper.GetModuleAddress was just called")
	}
	callInfo := struct {
		ModuleName string
	}{
		ModuleName: moduleName,
	}
	mock.lockGetModuleAddress.Lock()
	mock.calls.GetModuleAddress = append(mock.calls.GetModuleAddress, callInfo)
	mock.lockGetModuleAddress.Unlock()
	return mock.GetModuleAddressFunc(moduleName)
}

// GetModuleAddressCalls gets all the calls that were made to GetModuleAddress.
// Check the length with:
//
//	len(mockedAccountKeeper.GetModuleAddressCalls())
func (mock *AccountKeeperMock) GetModuleAddressCalls() []struct {
	ModuleName string
} {
	var calls []struct {
		ModuleName string
	}
	mock.lockGetModuleAddress.RLock()
	calls = mock.calls.GetModuleAddress
	mock.lockGetModuleAddress.RUnlock()
	return calls
}
