// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	wasmtypes "github.com/CosmWasm/wasmd/x/wasm/types"
	utils "github.com/axelarnetwork/axelar-core/utils"
	github_com_axelarnetwork_axelar_core_x_nexus_exported "github.com/axelarnetwork/axelar-core/x/nexus/exported"
	nexustypes "github.com/axelarnetwork/axelar-core/x/nexus/types"
	reward "github.com/axelarnetwork/axelar-core/x/reward/exported"
	snapshot "github.com/axelarnetwork/axelar-core/x/snapshot/exported"
	cosmossdktypes "github.com/cosmos/cosmos-sdk/types"
	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
	ibctypes "github.com/cosmos/ibc-go/v4/modules/apps/transfer/types"
	"github.com/tendermint/tendermint/libs/log"
	"sync"
	time "time"
)

// Ensure, that NexusMock does implement nexustypes.Nexus.
// If this is not the case, regenerate this file with moq.
var _ nexustypes.Nexus = &NexusMock{}

// NexusMock is a mock implementation of nexustypes.Nexus.
//
//	func TestSomethingThatUsesNexus(t *testing.T) {
//
//		// make and configure a mocked nexustypes.Nexus
//		mockedNexus := &NexusMock{
//			ActivateChainFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain)  {
//				panic("mock out the ActivateChain method")
//			},
//			ActivateWasmConnectionFunc: func(ctx cosmossdktypes.Context)  {
//				panic("mock out the ActivateWasmConnection method")
//			},
//			AddChainMaintainerFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, validator cosmossdktypes.ValAddress) error {
//				panic("mock out the AddChainMaintainer method")
//			},
//			CurrIDFunc: func(ctx cosmossdktypes.Context) ([32]byte, uint64) {
//				panic("mock out the CurrID method")
//			},
//			DeactivateChainFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain)  {
//				panic("mock out the DeactivateChain method")
//			},
//			DeactivateWasmConnectionFunc: func(ctx cosmossdktypes.Context)  {
//				panic("mock out the DeactivateWasmConnection method")
//			},
//			DequeueRouteMessageFunc: func(ctx cosmossdktypes.Context) (github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage, bool) {
//				panic("mock out the DequeueRouteMessage method")
//			},
//			ExportGenesisFunc: func(ctx cosmossdktypes.Context) *nexustypes.GenesisState {
//				panic("mock out the ExportGenesis method")
//			},
//			GenerateMessageIDFunc: func(ctx cosmossdktypes.Context) (string, []byte, uint64) {
//				panic("mock out the GenerateMessageID method")
//			},
//			GetChainFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, bool) {
//				panic("mock out the GetChain method")
//			},
//			GetChainByNativeAssetFunc: func(ctx cosmossdktypes.Context, asset string) (github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, bool) {
//				panic("mock out the GetChainByNativeAsset method")
//			},
//			GetChainMaintainerStatesFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) []github_com_axelarnetwork_axelar_core_x_nexus_exported.MaintainerState {
//				panic("mock out the GetChainMaintainerStates method")
//			},
//			GetChainMaintainersFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) []cosmossdktypes.ValAddress {
//				panic("mock out the GetChainMaintainers method")
//			},
//			GetChainsFunc: func(ctx cosmossdktypes.Context) []github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain {
//				panic("mock out the GetChains method")
//			},
//			GetFeeInfoFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, asset string) github_com_axelarnetwork_axelar_core_x_nexus_exported.FeeInfo {
//				panic("mock out the GetFeeInfo method")
//			},
//			GetMessageFunc: func(ctx cosmossdktypes.Context, id string) (github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage, bool) {
//				panic("mock out the GetMessage method")
//			},
//			GetParamsFunc: func(ctx cosmossdktypes.Context) nexustypes.Params {
//				panic("mock out the GetParams method")
//			},
//			InitGenesisFunc: func(ctx cosmossdktypes.Context, genState *nexustypes.GenesisState)  {
//				panic("mock out the InitGenesis method")
//			},
//			IsAssetRegisteredFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, denom string) bool {
//				panic("mock out the IsAssetRegistered method")
//			},
//			IsChainActivatedFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) bool {
//				panic("mock out the IsChainActivated method")
//			},
//			IsChainMaintainerFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, maintainer cosmossdktypes.ValAddress) bool {
//				panic("mock out the IsChainMaintainer method")
//			},
//			IsWasmConnectionActivatedFunc: func(ctx cosmossdktypes.Context) bool {
//				panic("mock out the IsWasmConnectionActivated method")
//			},
//			LinkAddressesFunc: func(ctx cosmossdktypes.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress) error {
//				panic("mock out the LinkAddresses method")
//			},
//			LoggerFunc: func(ctx cosmossdktypes.Context) log.Logger {
//				panic("mock out the Logger method")
//			},
//			RateLimitTransferFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName, asset cosmossdktypes.Coin, direction github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferDirection) error {
//				panic("mock out the RateLimitTransfer method")
//			},
//			RegisterFeeFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, feeInfo github_com_axelarnetwork_axelar_core_x_nexus_exported.FeeInfo) error {
//				panic("mock out the RegisterFee method")
//			},
//			RemoveChainMaintainerFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, validator cosmossdktypes.ValAddress) error {
//				panic("mock out the RemoveChainMaintainer method")
//			},
//			RouteMessageFunc: func(ctx cosmossdktypes.Context, id string, routingCtx ...github_com_axelarnetwork_axelar_core_x_nexus_exported.RoutingContext) error {
//				panic("mock out the RouteMessage method")
//			},
//			SetMessageExecutedFunc: func(ctx cosmossdktypes.Context, id string) error {
//				panic("mock out the SetMessageExecuted method")
//			},
//			SetNewMessageFunc: func(ctx cosmossdktypes.Context, msg github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage) error {
//				panic("mock out the SetNewMessage method")
//			},
//			SetParamsFunc: func(ctx cosmossdktypes.Context, p nexustypes.Params)  {
//				panic("mock out the SetParams method")
//			},
//			SetRateLimitFunc: func(ctx cosmossdktypes.Context, chainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName, limit cosmossdktypes.Coin, window time.Duration) error {
//				panic("mock out the SetRateLimit method")
//			},
//		}
//
//		// use mockedNexus in code that requires nexustypes.Nexus
//		// and then make assertions.
//
//	}
type NexusMock struct {
	// ActivateChainFunc mocks the ActivateChain method.
	ActivateChainFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain)

	// ActivateWasmConnectionFunc mocks the ActivateWasmConnection method.
	ActivateWasmConnectionFunc func(ctx cosmossdktypes.Context)

	// AddChainMaintainerFunc mocks the AddChainMaintainer method.
	AddChainMaintainerFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, validator cosmossdktypes.ValAddress) error

	// CurrIDFunc mocks the CurrID method.
	CurrIDFunc func(ctx cosmossdktypes.Context) ([32]byte, uint64)

	// DeactivateChainFunc mocks the DeactivateChain method.
	DeactivateChainFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain)

	// DeactivateWasmConnectionFunc mocks the DeactivateWasmConnection method.
	DeactivateWasmConnectionFunc func(ctx cosmossdktypes.Context)

	// DequeueRouteMessageFunc mocks the DequeueRouteMessage method.
	DequeueRouteMessageFunc func(ctx cosmossdktypes.Context) (github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage, bool)

	// ExportGenesisFunc mocks the ExportGenesis method.
	ExportGenesisFunc func(ctx cosmossdktypes.Context) *nexustypes.GenesisState

	// GenerateMessageIDFunc mocks the GenerateMessageID method.
	GenerateMessageIDFunc func(ctx cosmossdktypes.Context) (string, []byte, uint64)

	// GetChainFunc mocks the GetChain method.
	GetChainFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, bool)

	// GetChainByNativeAssetFunc mocks the GetChainByNativeAsset method.
	GetChainByNativeAssetFunc func(ctx cosmossdktypes.Context, asset string) (github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, bool)

	// GetChainMaintainerStatesFunc mocks the GetChainMaintainerStates method.
	GetChainMaintainerStatesFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) []github_com_axelarnetwork_axelar_core_x_nexus_exported.MaintainerState

	// GetChainMaintainersFunc mocks the GetChainMaintainers method.
	GetChainMaintainersFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) []cosmossdktypes.ValAddress

	// GetChainsFunc mocks the GetChains method.
	GetChainsFunc func(ctx cosmossdktypes.Context) []github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain

	// GetFeeInfoFunc mocks the GetFeeInfo method.
	GetFeeInfoFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, asset string) github_com_axelarnetwork_axelar_core_x_nexus_exported.FeeInfo

	// GetMessageFunc mocks the GetMessage method.
	GetMessageFunc func(ctx cosmossdktypes.Context, id string) (github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage, bool)

	// GetParamsFunc mocks the GetParams method.
	GetParamsFunc func(ctx cosmossdktypes.Context) nexustypes.Params

	// InitGenesisFunc mocks the InitGenesis method.
	InitGenesisFunc func(ctx cosmossdktypes.Context, genState *nexustypes.GenesisState)

	// IsAssetRegisteredFunc mocks the IsAssetRegistered method.
	IsAssetRegisteredFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, denom string) bool

	// IsChainActivatedFunc mocks the IsChainActivated method.
	IsChainActivatedFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) bool

	// IsChainMaintainerFunc mocks the IsChainMaintainer method.
	IsChainMaintainerFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, maintainer cosmossdktypes.ValAddress) bool

	// IsWasmConnectionActivatedFunc mocks the IsWasmConnectionActivated method.
	IsWasmConnectionActivatedFunc func(ctx cosmossdktypes.Context) bool

	// LinkAddressesFunc mocks the LinkAddresses method.
	LinkAddressesFunc func(ctx cosmossdktypes.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress) error

	// LoggerFunc mocks the Logger method.
	LoggerFunc func(ctx cosmossdktypes.Context) log.Logger

	// RateLimitTransferFunc mocks the RateLimitTransfer method.
	RateLimitTransferFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName, asset cosmossdktypes.Coin, direction github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferDirection) error

	// RegisterFeeFunc mocks the RegisterFee method.
	RegisterFeeFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, feeInfo github_com_axelarnetwork_axelar_core_x_nexus_exported.FeeInfo) error

	// RemoveChainMaintainerFunc mocks the RemoveChainMaintainer method.
	RemoveChainMaintainerFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, validator cosmossdktypes.ValAddress) error

	// RouteMessageFunc mocks the RouteMessage method.
	RouteMessageFunc func(ctx cosmossdktypes.Context, id string, routingCtx ...github_com_axelarnetwork_axelar_core_x_nexus_exported.RoutingContext) error

	// SetMessageExecutedFunc mocks the SetMessageExecuted method.
	SetMessageExecutedFunc func(ctx cosmossdktypes.Context, id string) error

	// SetNewMessageFunc mocks the SetNewMessage method.
	SetNewMessageFunc func(ctx cosmossdktypes.Context, msg github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage) error

	// SetParamsFunc mocks the SetParams method.
	SetParamsFunc func(ctx cosmossdktypes.Context, p nexustypes.Params)

	// SetRateLimitFunc mocks the SetRateLimit method.
	SetRateLimitFunc func(ctx cosmossdktypes.Context, chainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName, limit cosmossdktypes.Coin, window time.Duration) error

	// calls tracks calls to the methods.
	calls struct {
		// ActivateChain holds details about calls to the ActivateChain method.
		ActivateChain []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		}
		// ActivateWasmConnection holds details about calls to the ActivateWasmConnection method.
		ActivateWasmConnection []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// AddChainMaintainer holds details about calls to the AddChainMaintainer method.
		AddChainMaintainer []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
			// Validator is the validator argument value.
			Validator cosmossdktypes.ValAddress
		}
		// CurrID holds details about calls to the CurrID method.
		CurrID []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// DeactivateChain holds details about calls to the DeactivateChain method.
		DeactivateChain []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		}
		// DeactivateWasmConnection holds details about calls to the DeactivateWasmConnection method.
		DeactivateWasmConnection []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// DequeueRouteMessage holds details about calls to the DequeueRouteMessage method.
		DequeueRouteMessage []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// ExportGenesis holds details about calls to the ExportGenesis method.
		ExportGenesis []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// GenerateMessageID holds details about calls to the GenerateMessageID method.
		GenerateMessageID []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// GetChain holds details about calls to the GetChain method.
		GetChain []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
		}
		// GetChainByNativeAsset holds details about calls to the GetChainByNativeAsset method.
		GetChainByNativeAsset []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Asset is the asset argument value.
			Asset string
		}
		// GetChainMaintainerStates holds details about calls to the GetChainMaintainerStates method.
		GetChainMaintainerStates []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		}
		// GetChainMaintainers holds details about calls to the GetChainMaintainers method.
		GetChainMaintainers []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		}
		// GetChains holds details about calls to the GetChains method.
		GetChains []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// GetFeeInfo holds details about calls to the GetFeeInfo method.
		GetFeeInfo []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
			// Asset is the asset argument value.
			Asset string
		}
		// GetMessage holds details about calls to the GetMessage method.
		GetMessage []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ID is the id argument value.
			ID string
		}
		// GetParams holds details about calls to the GetParams method.
		GetParams []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// InitGenesis holds details about calls to the InitGenesis method.
		InitGenesis []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// GenState is the genState argument value.
			GenState *nexustypes.GenesisState
		}
		// IsAssetRegistered holds details about calls to the IsAssetRegistered method.
		IsAssetRegistered []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
			// Denom is the denom argument value.
			Denom string
		}
		// IsChainActivated holds details about calls to the IsChainActivated method.
		IsChainActivated []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		}
		// IsChainMaintainer holds details about calls to the IsChainMaintainer method.
		IsChainMaintainer []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
			// Maintainer is the maintainer argument value.
			Maintainer cosmossdktypes.ValAddress
		}
		// IsWasmConnectionActivated holds details about calls to the IsWasmConnectionActivated method.
		IsWasmConnectionActivated []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// LinkAddresses holds details about calls to the LinkAddresses method.
		LinkAddresses []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Sender is the sender argument value.
			Sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
			// Recipient is the recipient argument value.
			Recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
		}
		// Logger holds details about calls to the Logger method.
		Logger []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// RateLimitTransfer holds details about calls to the RateLimitTransfer method.
		RateLimitTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
			// Asset is the asset argument value.
			Asset cosmossdktypes.Coin
			// Direction is the direction argument value.
			Direction github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferDirection
		}
		// RegisterFee holds details about calls to the RegisterFee method.
		RegisterFee []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
			// FeeInfo is the feeInfo argument value.
			FeeInfo github_com_axelarnetwork_axelar_core_x_nexus_exported.FeeInfo
		}
		// RemoveChainMaintainer holds details about calls to the RemoveChainMaintainer method.
		RemoveChainMaintainer []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
			// Validator is the validator argument value.
			Validator cosmossdktypes.ValAddress
		}
		// RouteMessage holds details about calls to the RouteMessage method.
		RouteMessage []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ID is the id argument value.
			ID string
			// RoutingCtx is the routingCtx argument value.
			RoutingCtx []github_com_axelarnetwork_axelar_core_x_nexus_exported.RoutingContext
		}
		// SetMessageExecuted holds details about calls to the SetMessageExecuted method.
		SetMessageExecuted []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ID is the id argument value.
			ID string
		}
		// SetNewMessage holds details about calls to the SetNewMessage method.
		SetNewMessage []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Msg is the msg argument value.
			Msg github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage
		}
		// SetParams holds details about calls to the SetParams method.
		SetParams []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// P is the p argument value.
			P nexustypes.Params
		}
		// SetRateLimit holds details about calls to the SetRateLimit method.
		SetRateLimit []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ChainName is the chainName argument value.
			ChainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
			// Limit is the limit argument value.
			Limit cosmossdktypes.Coin
			// Window is the window argument value.
			Window time.Duration
		}
	}
	lockActivateChain             sync.RWMutex
	lockActivateWasmConnection    sync.RWMutex
	lockAddChainMaintainer        sync.RWMutex
	lockCurrID                    sync.RWMutex
	lockDeactivateChain           sync.RWMutex
	lockDeactivateWasmConnection  sync.RWMutex
	lockDequeueRouteMessage       sync.RWMutex
	lockExportGenesis             sync.RWMutex
	lockGenerateMessageID         sync.RWMutex
	lockGetChain                  sync.RWMutex
	lockGetChainByNativeAsset     sync.RWMutex
	lockGetChainMaintainerStates  sync.RWMutex
	lockGetChainMaintainers       sync.RWMutex
	lockGetChains                 sync.RWMutex
	lockGetFeeInfo                sync.RWMutex
	lockGetMessage                sync.RWMutex
	lockGetParams                 sync.RWMutex
	lockInitGenesis               sync.RWMutex
	lockIsAssetRegistered         sync.RWMutex
	lockIsChainActivated          sync.RWMutex
	lockIsChainMaintainer         sync.RWMutex
	lockIsWasmConnectionActivated sync.RWMutex
	lockLinkAddresses             sync.RWMutex
	lockLogger                    sync.RWMutex
	lockRateLimitTransfer         sync.RWMutex
	lockRegisterFee               sync.RWMutex
	lockRemoveChainMaintainer     sync.RWMutex
	lockRouteMessage              sync.RWMutex
	lockSetMessageExecuted        sync.RWMutex
	lockSetNewMessage             sync.RWMutex
	lockSetParams                 sync.RWMutex
	lockSetRateLimit              sync.RWMutex
}

// ActivateChain calls ActivateChainFunc.
func (mock *NexusMock) ActivateChain(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) {
	if mock.ActivateChainFunc == nil {
		panic("NexusMock.ActivateChainFunc: method is nil but Nexus.ActivateChain was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockActivateChain.Lock()
	mock.calls.ActivateChain = append(mock.calls.ActivateChain, callInfo)
	mock.lockActivateChain.Unlock()
	mock.ActivateChainFunc(ctx, chain)
}

// ActivateChainCalls gets all the calls that were made to ActivateChain.
// Check the length with:
//
//	len(mockedNexus.ActivateChainCalls())
func (mock *NexusMock) ActivateChainCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}
	mock.lockActivateChain.RLock()
	calls = mock.calls.ActivateChain
	mock.lockActivateChain.RUnlock()
	return calls
}

// ActivateWasmConnection calls ActivateWasmConnectionFunc.
func (mock *NexusMock) ActivateWasmConnection(ctx cosmossdktypes.Context) {
	if mock.ActivateWasmConnectionFunc == nil {
		panic("NexusMock.ActivateWasmConnectionFunc: method is nil but Nexus.ActivateWasmConnection was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockActivateWasmConnection.Lock()
	mock.calls.ActivateWasmConnection = append(mock.calls.ActivateWasmConnection, callInfo)
	mock.lockActivateWasmConnection.Unlock()
	mock.ActivateWasmConnectionFunc(ctx)
}

// ActivateWasmConnectionCalls gets all the calls that were made to ActivateWasmConnection.
// Check the length with:
//
//	len(mockedNexus.ActivateWasmConnectionCalls())
func (mock *NexusMock) ActivateWasmConnectionCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockActivateWasmConnection.RLock()
	calls = mock.calls.ActivateWasmConnection
	mock.lockActivateWasmConnection.RUnlock()
	return calls
}

// AddChainMaintainer calls AddChainMaintainerFunc.
func (mock *NexusMock) AddChainMaintainer(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, validator cosmossdktypes.ValAddress) error {
	if mock.AddChainMaintainerFunc == nil {
		panic("NexusMock.AddChainMaintainerFunc: method is nil but Nexus.AddChainMaintainer was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		Chain     github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Validator cosmossdktypes.ValAddress
	}{
		Ctx:       ctx,
		Chain:     chain,
		Validator: validator,
	}
	mock.lockAddChainMaintainer.Lock()
	mock.calls.AddChainMaintainer = append(mock.calls.AddChainMaintainer, callInfo)
	mock.lockAddChainMaintainer.Unlock()
	return mock.AddChainMaintainerFunc(ctx, chain, validator)
}

// AddChainMaintainerCalls gets all the calls that were made to AddChainMaintainer.
// Check the length with:
//
//	len(mockedNexus.AddChainMaintainerCalls())
func (mock *NexusMock) AddChainMaintainerCalls() []struct {
	Ctx       cosmossdktypes.Context
	Chain     github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	Validator cosmossdktypes.ValAddress
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		Chain     github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Validator cosmossdktypes.ValAddress
	}
	mock.lockAddChainMaintainer.RLock()
	calls = mock.calls.AddChainMaintainer
	mock.lockAddChainMaintainer.RUnlock()
	return calls
}

// CurrID calls CurrIDFunc.
func (mock *NexusMock) CurrID(ctx cosmossdktypes.Context) ([32]byte, uint64) {
	if mock.CurrIDFunc == nil {
		panic("NexusMock.CurrIDFunc: method is nil but Nexus.CurrID was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockCurrID.Lock()
	mock.calls.CurrID = append(mock.calls.CurrID, callInfo)
	mock.lockCurrID.Unlock()
	return mock.CurrIDFunc(ctx)
}

// CurrIDCalls gets all the calls that were made to CurrID.
// Check the length with:
//
//	len(mockedNexus.CurrIDCalls())
func (mock *NexusMock) CurrIDCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockCurrID.RLock()
	calls = mock.calls.CurrID
	mock.lockCurrID.RUnlock()
	return calls
}

// DeactivateChain calls DeactivateChainFunc.
func (mock *NexusMock) DeactivateChain(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) {
	if mock.DeactivateChainFunc == nil {
		panic("NexusMock.DeactivateChainFunc: method is nil but Nexus.DeactivateChain was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockDeactivateChain.Lock()
	mock.calls.DeactivateChain = append(mock.calls.DeactivateChain, callInfo)
	mock.lockDeactivateChain.Unlock()
	mock.DeactivateChainFunc(ctx, chain)
}

// DeactivateChainCalls gets all the calls that were made to DeactivateChain.
// Check the length with:
//
//	len(mockedNexus.DeactivateChainCalls())
func (mock *NexusMock) DeactivateChainCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}
	mock.lockDeactivateChain.RLock()
	calls = mock.calls.DeactivateChain
	mock.lockDeactivateChain.RUnlock()
	return calls
}

// DeactivateWasmConnection calls DeactivateWasmConnectionFunc.
func (mock *NexusMock) DeactivateWasmConnection(ctx cosmossdktypes.Context) {
	if mock.DeactivateWasmConnectionFunc == nil {
		panic("NexusMock.DeactivateWasmConnectionFunc: method is nil but Nexus.DeactivateWasmConnection was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockDeactivateWasmConnection.Lock()
	mock.calls.DeactivateWasmConnection = append(mock.calls.DeactivateWasmConnection, callInfo)
	mock.lockDeactivateWasmConnection.Unlock()
	mock.DeactivateWasmConnectionFunc(ctx)
}

// DeactivateWasmConnectionCalls gets all the calls that were made to DeactivateWasmConnection.
// Check the length with:
//
//	len(mockedNexus.DeactivateWasmConnectionCalls())
func (mock *NexusMock) DeactivateWasmConnectionCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockDeactivateWasmConnection.RLock()
	calls = mock.calls.DeactivateWasmConnection
	mock.lockDeactivateWasmConnection.RUnlock()
	return calls
}

// DequeueRouteMessage calls DequeueRouteMessageFunc.
func (mock *NexusMock) DequeueRouteMessage(ctx cosmossdktypes.Context) (github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage, bool) {
	if mock.DequeueRouteMessageFunc == nil {
		panic("NexusMock.DequeueRouteMessageFunc: method is nil but Nexus.DequeueRouteMessage was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockDequeueRouteMessage.Lock()
	mock.calls.DequeueRouteMessage = append(mock.calls.DequeueRouteMessage, callInfo)
	mock.lockDequeueRouteMessage.Unlock()
	return mock.DequeueRouteMessageFunc(ctx)
}

// DequeueRouteMessageCalls gets all the calls that were made to DequeueRouteMessage.
// Check the length with:
//
//	len(mockedNexus.DequeueRouteMessageCalls())
func (mock *NexusMock) DequeueRouteMessageCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockDequeueRouteMessage.RLock()
	calls = mock.calls.DequeueRouteMessage
	mock.lockDequeueRouteMessage.RUnlock()
	return calls
}

// ExportGenesis calls ExportGenesisFunc.
func (mock *NexusMock) ExportGenesis(ctx cosmossdktypes.Context) *nexustypes.GenesisState {
	if mock.ExportGenesisFunc == nil {
		panic("NexusMock.ExportGenesisFunc: method is nil but Nexus.ExportGenesis was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockExportGenesis.Lock()
	mock.calls.ExportGenesis = append(mock.calls.ExportGenesis, callInfo)
	mock.lockExportGenesis.Unlock()
	return mock.ExportGenesisFunc(ctx)
}

// ExportGenesisCalls gets all the calls that were made to ExportGenesis.
// Check the length with:
//
//	len(mockedNexus.ExportGenesisCalls())
func (mock *NexusMock) ExportGenesisCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockExportGenesis.RLock()
	calls = mock.calls.ExportGenesis
	mock.lockExportGenesis.RUnlock()
	return calls
}

// GenerateMessageID calls GenerateMessageIDFunc.
func (mock *NexusMock) GenerateMessageID(ctx cosmossdktypes.Context) (string, []byte, uint64) {
	if mock.GenerateMessageIDFunc == nil {
		panic("NexusMock.GenerateMessageIDFunc: method is nil but Nexus.GenerateMessageID was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockGenerateMessageID.Lock()
	mock.calls.GenerateMessageID = append(mock.calls.GenerateMessageID, callInfo)
	mock.lockGenerateMessageID.Unlock()
	return mock.GenerateMessageIDFunc(ctx)
}

// GenerateMessageIDCalls gets all the calls that were made to GenerateMessageID.
// Check the length with:
//
//	len(mockedNexus.GenerateMessageIDCalls())
func (mock *NexusMock) GenerateMessageIDCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockGenerateMessageID.RLock()
	calls = mock.calls.GenerateMessageID
	mock.lockGenerateMessageID.RUnlock()
	return calls
}

// GetChain calls GetChainFunc.
func (mock *NexusMock) GetChain(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, bool) {
	if mock.GetChainFunc == nil {
		panic("NexusMock.GetChainFunc: method is nil but Nexus.GetChain was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockGetChain.Lock()
	mock.calls.GetChain = append(mock.calls.GetChain, callInfo)
	mock.lockGetChain.Unlock()
	return mock.GetChainFunc(ctx, chain)
}

// GetChainCalls gets all the calls that were made to GetChain.
// Check the length with:
//
//	len(mockedNexus.GetChainCalls())
func (mock *NexusMock) GetChainCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}
	mock.lockGetChain.RLock()
	calls = mock.calls.GetChain
	mock.lockGetChain.RUnlock()
	return calls
}

// GetChainByNativeAsset calls GetChainByNativeAssetFunc.
func (mock *NexusMock) GetChainByNativeAsset(ctx cosmossdktypes.Context, asset string) (github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, bool) {
	if mock.GetChainByNativeAssetFunc == nil {
		panic("NexusMock.GetChainByNativeAssetFunc: method is nil but Nexus.GetChainByNativeAsset was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Asset string
	}{
		Ctx:   ctx,
		Asset: asset,
	}
	mock.lockGetChainByNativeAsset.Lock()
	mock.calls.GetChainByNativeAsset = append(mock.calls.GetChainByNativeAsset, callInfo)
	mock.lockGetChainByNativeAsset.Unlock()
	return mock.GetChainByNativeAssetFunc(ctx, asset)
}

// GetChainByNativeAssetCalls gets all the calls that were made to GetChainByNativeAsset.
// Check the length with:
//
//	len(mockedNexus.GetChainByNativeAssetCalls())
func (mock *NexusMock) GetChainByNativeAssetCalls() []struct {
	Ctx   cosmossdktypes.Context
	Asset string
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Asset string
	}
	mock.lockGetChainByNativeAsset.RLock()
	calls = mock.calls.GetChainByNativeAsset
	mock.lockGetChainByNativeAsset.RUnlock()
	return calls
}

// GetChainMaintainerStates calls GetChainMaintainerStatesFunc.
func (mock *NexusMock) GetChainMaintainerStates(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) []github_com_axelarnetwork_axelar_core_x_nexus_exported.MaintainerState {
	if mock.GetChainMaintainerStatesFunc == nil {
		panic("NexusMock.GetChainMaintainerStatesFunc: method is nil but Nexus.GetChainMaintainerStates was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockGetChainMaintainerStates.Lock()
	mock.calls.GetChainMaintainerStates = append(mock.calls.GetChainMaintainerStates, callInfo)
	mock.lockGetChainMaintainerStates.Unlock()
	return mock.GetChainMaintainerStatesFunc(ctx, chain)
}

// GetChainMaintainerStatesCalls gets all the calls that were made to GetChainMaintainerStates.
// Check the length with:
//
//	len(mockedNexus.GetChainMaintainerStatesCalls())
func (mock *NexusMock) GetChainMaintainerStatesCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}
	mock.lockGetChainMaintainerStates.RLock()
	calls = mock.calls.GetChainMaintainerStates
	mock.lockGetChainMaintainerStates.RUnlock()
	return calls
}

// GetChainMaintainers calls GetChainMaintainersFunc.
func (mock *NexusMock) GetChainMaintainers(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) []cosmossdktypes.ValAddress {
	if mock.GetChainMaintainersFunc == nil {
		panic("NexusMock.GetChainMaintainersFunc: method is nil but Nexus.GetChainMaintainers was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockGetChainMaintainers.Lock()
	mock.calls.GetChainMaintainers = append(mock.calls.GetChainMaintainers, callInfo)
	mock.lockGetChainMaintainers.Unlock()
	return mock.GetChainMaintainersFunc(ctx, chain)
}

// GetChainMaintainersCalls gets all the calls that were made to GetChainMaintainers.
// Check the length with:
//
//	len(mockedNexus.GetChainMaintainersCalls())
func (mock *NexusMock) GetChainMaintainersCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}
	mock.lockGetChainMaintainers.RLock()
	calls = mock.calls.GetChainMaintainers
	mock.lockGetChainMaintainers.RUnlock()
	return calls
}

// GetChains calls GetChainsFunc.
func (mock *NexusMock) GetChains(ctx cosmossdktypes.Context) []github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain {
	if mock.GetChainsFunc == nil {
		panic("NexusMock.GetChainsFunc: method is nil but Nexus.GetChains was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetChains.Lock()
	mock.calls.GetChains = append(mock.calls.GetChains, callInfo)
	mock.lockGetChains.Unlock()
	return mock.GetChainsFunc(ctx)
}

// GetChainsCalls gets all the calls that were made to GetChains.
// Check the length with:
//
//	len(mockedNexus.GetChainsCalls())
func (mock *NexusMock) GetChainsCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockGetChains.RLock()
	calls = mock.calls.GetChains
	mock.lockGetChains.RUnlock()
	return calls
}

// GetFeeInfo calls GetFeeInfoFunc.
func (mock *NexusMock) GetFeeInfo(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, asset string) github_com_axelarnetwork_axelar_core_x_nexus_exported.FeeInfo {
	if mock.GetFeeInfoFunc == nil {
		panic("NexusMock.GetFeeInfoFunc: method is nil but Nexus.GetFeeInfo was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Asset string
	}{
		Ctx:   ctx,
		Chain: chain,
		Asset: asset,
	}
	mock.lockGetFeeInfo.Lock()
	mock.calls.GetFeeInfo = append(mock.calls.GetFeeInfo, callInfo)
	mock.lockGetFeeInfo.Unlock()
	return mock.GetFeeInfoFunc(ctx, chain, asset)
}

// GetFeeInfoCalls gets all the calls that were made to GetFeeInfo.
// Check the length with:
//
//	len(mockedNexus.GetFeeInfoCalls())
func (mock *NexusMock) GetFeeInfoCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	Asset string
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Asset string
	}
	mock.lockGetFeeInfo.RLock()
	calls = mock.calls.GetFeeInfo
	mock.lockGetFeeInfo.RUnlock()
	return calls
}

// GetMessage calls GetMessageFunc.
func (mock *NexusMock) GetMessage(ctx cosmossdktypes.Context, id string) (github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage, bool) {
	if mock.GetMessageFunc == nil {
		panic("NexusMock.GetMessageFunc: method is nil but Nexus.GetMessage was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetMessage.Lock()
	mock.calls.GetMessage = append(mock.calls.GetMessage, callInfo)
	mock.lockGetMessage.Unlock()
	return mock.GetMessageFunc(ctx, id)
}

// GetMessageCalls gets all the calls that were made to GetMessage.
// Check the length with:
//
//	len(mockedNexus.GetMessageCalls())
func (mock *NexusMock) GetMessageCalls() []struct {
	Ctx cosmossdktypes.Context
	ID  string
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
		ID  string
	}
	mock.lockGetMessage.RLock()
	calls = mock.calls.GetMessage
	mock.lockGetMessage.RUnlock()
	return calls
}

// GetParams calls GetParamsFunc.
func (mock *NexusMock) GetParams(ctx cosmossdktypes.Context) nexustypes.Params {
	if mock.GetParamsFunc == nil {
		panic("NexusMock.GetParamsFunc: method is nil but Nexus.GetParams was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetParams.Lock()
	mock.calls.GetParams = append(mock.calls.GetParams, callInfo)
	mock.lockGetParams.Unlock()
	return mock.GetParamsFunc(ctx)
}

// GetParamsCalls gets all the calls that were made to GetParams.
// Check the length with:
//
//	len(mockedNexus.GetParamsCalls())
func (mock *NexusMock) GetParamsCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockGetParams.RLock()
	calls = mock.calls.GetParams
	mock.lockGetParams.RUnlock()
	return calls
}

// InitGenesis calls InitGenesisFunc.
func (mock *NexusMock) InitGenesis(ctx cosmossdktypes.Context, genState *nexustypes.GenesisState) {
	if mock.InitGenesisFunc == nil {
		panic("NexusMock.InitGenesisFunc: method is nil but Nexus.InitGenesis was just called")
	}
	callInfo := struct {
		Ctx      cosmossdktypes.Context
		GenState *nexustypes.GenesisState
	}{
		Ctx:      ctx,
		GenState: genState,
	}
	mock.lockInitGenesis.Lock()
	mock.calls.InitGenesis = append(mock.calls.InitGenesis, callInfo)
	mock.lockInitGenesis.Unlock()
	mock.InitGenesisFunc(ctx, genState)
}

// InitGenesisCalls gets all the calls that were made to InitGenesis.
// Check the length with:
//
//	len(mockedNexus.InitGenesisCalls())
func (mock *NexusMock) InitGenesisCalls() []struct {
	Ctx      cosmossdktypes.Context
	GenState *nexustypes.GenesisState
} {
	var calls []struct {
		Ctx      cosmossdktypes.Context
		GenState *nexustypes.GenesisState
	}
	mock.lockInitGenesis.RLock()
	calls = mock.calls.InitGenesis
	mock.lockInitGenesis.RUnlock()
	return calls
}

// IsAssetRegistered calls IsAssetRegisteredFunc.
func (mock *NexusMock) IsAssetRegistered(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, denom string) bool {
	if mock.IsAssetRegisteredFunc == nil {
		panic("NexusMock.IsAssetRegisteredFunc: method is nil but Nexus.IsAssetRegistered was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Denom string
	}{
		Ctx:   ctx,
		Chain: chain,
		Denom: denom,
	}
	mock.lockIsAssetRegistered.Lock()
	mock.calls.IsAssetRegistered = append(mock.calls.IsAssetRegistered, callInfo)
	mock.lockIsAssetRegistered.Unlock()
	return mock.IsAssetRegisteredFunc(ctx, chain, denom)
}

// IsAssetRegisteredCalls gets all the calls that were made to IsAssetRegistered.
// Check the length with:
//
//	len(mockedNexus.IsAssetRegisteredCalls())
func (mock *NexusMock) IsAssetRegisteredCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	Denom string
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Denom string
	}
	mock.lockIsAssetRegistered.RLock()
	calls = mock.calls.IsAssetRegistered
	mock.lockIsAssetRegistered.RUnlock()
	return calls
}

// IsChainActivated calls IsChainActivatedFunc.
func (mock *NexusMock) IsChainActivated(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) bool {
	if mock.IsChainActivatedFunc == nil {
		panic("NexusMock.IsChainActivatedFunc: method is nil but Nexus.IsChainActivated was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockIsChainActivated.Lock()
	mock.calls.IsChainActivated = append(mock.calls.IsChainActivated, callInfo)
	mock.lockIsChainActivated.Unlock()
	return mock.IsChainActivatedFunc(ctx, chain)
}

// IsChainActivatedCalls gets all the calls that were made to IsChainActivated.
// Check the length with:
//
//	len(mockedNexus.IsChainActivatedCalls())
func (mock *NexusMock) IsChainActivatedCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}
	mock.lockIsChainActivated.RLock()
	calls = mock.calls.IsChainActivated
	mock.lockIsChainActivated.RUnlock()
	return calls
}

// IsChainMaintainer calls IsChainMaintainerFunc.
func (mock *NexusMock) IsChainMaintainer(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, maintainer cosmossdktypes.ValAddress) bool {
	if mock.IsChainMaintainerFunc == nil {
		panic("NexusMock.IsChainMaintainerFunc: method is nil but Nexus.IsChainMaintainer was just called")
	}
	callInfo := struct {
		Ctx        cosmossdktypes.Context
		Chain      github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Maintainer cosmossdktypes.ValAddress
	}{
		Ctx:        ctx,
		Chain:      chain,
		Maintainer: maintainer,
	}
	mock.lockIsChainMaintainer.Lock()
	mock.calls.IsChainMaintainer = append(mock.calls.IsChainMaintainer, callInfo)
	mock.lockIsChainMaintainer.Unlock()
	return mock.IsChainMaintainerFunc(ctx, chain, maintainer)
}

// IsChainMaintainerCalls gets all the calls that were made to IsChainMaintainer.
// Check the length with:
//
//	len(mockedNexus.IsChainMaintainerCalls())
func (mock *NexusMock) IsChainMaintainerCalls() []struct {
	Ctx        cosmossdktypes.Context
	Chain      github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	Maintainer cosmossdktypes.ValAddress
} {
	var calls []struct {
		Ctx        cosmossdktypes.Context
		Chain      github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Maintainer cosmossdktypes.ValAddress
	}
	mock.lockIsChainMaintainer.RLock()
	calls = mock.calls.IsChainMaintainer
	mock.lockIsChainMaintainer.RUnlock()
	return calls
}

// IsWasmConnectionActivated calls IsWasmConnectionActivatedFunc.
func (mock *NexusMock) IsWasmConnectionActivated(ctx cosmossdktypes.Context) bool {
	if mock.IsWasmConnectionActivatedFunc == nil {
		panic("NexusMock.IsWasmConnectionActivatedFunc: method is nil but Nexus.IsWasmConnectionActivated was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockIsWasmConnectionActivated.Lock()
	mock.calls.IsWasmConnectionActivated = append(mock.calls.IsWasmConnectionActivated, callInfo)
	mock.lockIsWasmConnectionActivated.Unlock()
	return mock.IsWasmConnectionActivatedFunc(ctx)
}

// IsWasmConnectionActivatedCalls gets all the calls that were made to IsWasmConnectionActivated.
// Check the length with:
//
//	len(mockedNexus.IsWasmConnectionActivatedCalls())
func (mock *NexusMock) IsWasmConnectionActivatedCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockIsWasmConnectionActivated.RLock()
	calls = mock.calls.IsWasmConnectionActivated
	mock.lockIsWasmConnectionActivated.RUnlock()
	return calls
}

// LinkAddresses calls LinkAddressesFunc.
func (mock *NexusMock) LinkAddresses(ctx cosmossdktypes.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress) error {
	if mock.LinkAddressesFunc == nil {
		panic("NexusMock.LinkAddressesFunc: method is nil but Nexus.LinkAddresses was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		Sender    github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
		Recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
	}{
		Ctx:       ctx,
		Sender:    sender,
		Recipient: recipient,
	}
	mock.lockLinkAddresses.Lock()
	mock.calls.LinkAddresses = append(mock.calls.LinkAddresses, callInfo)
	mock.lockLinkAddresses.Unlock()
	return mock.LinkAddressesFunc(ctx, sender, recipient)
}

// LinkAddressesCalls gets all the calls that were made to LinkAddresses.
// Check the length with:
//
//	len(mockedNexus.LinkAddressesCalls())
func (mock *NexusMock) LinkAddressesCalls() []struct {
	Ctx       cosmossdktypes.Context
	Sender    github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
	Recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		Sender    github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
		Recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
	}
	mock.lockLinkAddresses.RLock()
	calls = mock.calls.LinkAddresses
	mock.lockLinkAddresses.RUnlock()
	return calls
}

// Logger calls LoggerFunc.
func (mock *NexusMock) Logger(ctx cosmossdktypes.Context) log.Logger {
	if mock.LoggerFunc == nil {
		panic("NexusMock.LoggerFunc: method is nil but Nexus.Logger was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockLogger.Lock()
	mock.calls.Logger = append(mock.calls.Logger, callInfo)
	mock.lockLogger.Unlock()
	return mock.LoggerFunc(ctx)
}

// LoggerCalls gets all the calls that were made to Logger.
// Check the length with:
//
//	len(mockedNexus.LoggerCalls())
func (mock *NexusMock) LoggerCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockLogger.RLock()
	calls = mock.calls.Logger
	mock.lockLogger.RUnlock()
	return calls
}

// RateLimitTransfer calls RateLimitTransferFunc.
func (mock *NexusMock) RateLimitTransfer(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName, asset cosmossdktypes.Coin, direction github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferDirection) error {
	if mock.RateLimitTransferFunc == nil {
		panic("NexusMock.RateLimitTransferFunc: method is nil but Nexus.RateLimitTransfer was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		Chain     github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
		Asset     cosmossdktypes.Coin
		Direction github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferDirection
	}{
		Ctx:       ctx,
		Chain:     chain,
		Asset:     asset,
		Direction: direction,
	}
	mock.lockRateLimitTransfer.Lock()
	mock.calls.RateLimitTransfer = append(mock.calls.RateLimitTransfer, callInfo)
	mock.lockRateLimitTransfer.Unlock()
	return mock.RateLimitTransferFunc(ctx, chain, asset, direction)
}

// RateLimitTransferCalls gets all the calls that were made to RateLimitTransfer.
// Check the length with:
//
//	len(mockedNexus.RateLimitTransferCalls())
func (mock *NexusMock) RateLimitTransferCalls() []struct {
	Ctx       cosmossdktypes.Context
	Chain     github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	Asset     cosmossdktypes.Coin
	Direction github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferDirection
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		Chain     github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
		Asset     cosmossdktypes.Coin
		Direction github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferDirection
	}
	mock.lockRateLimitTransfer.RLock()
	calls = mock.calls.RateLimitTransfer
	mock.lockRateLimitTransfer.RUnlock()
	return calls
}

// RegisterFee calls RegisterFeeFunc.
func (mock *NexusMock) RegisterFee(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, feeInfo github_com_axelarnetwork_axelar_core_x_nexus_exported.FeeInfo) error {
	if mock.RegisterFeeFunc == nil {
		panic("NexusMock.RegisterFeeFunc: method is nil but Nexus.RegisterFee was just called")
	}
	callInfo := struct {
		Ctx     cosmossdktypes.Context
		Chain   github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		FeeInfo github_com_axelarnetwork_axelar_core_x_nexus_exported.FeeInfo
	}{
		Ctx:     ctx,
		Chain:   chain,
		FeeInfo: feeInfo,
	}
	mock.lockRegisterFee.Lock()
	mock.calls.RegisterFee = append(mock.calls.RegisterFee, callInfo)
	mock.lockRegisterFee.Unlock()
	return mock.RegisterFeeFunc(ctx, chain, feeInfo)
}

// RegisterFeeCalls gets all the calls that were made to RegisterFee.
// Check the length with:
//
//	len(mockedNexus.RegisterFeeCalls())
func (mock *NexusMock) RegisterFeeCalls() []struct {
	Ctx     cosmossdktypes.Context
	Chain   github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	FeeInfo github_com_axelarnetwork_axelar_core_x_nexus_exported.FeeInfo
} {
	var calls []struct {
		Ctx     cosmossdktypes.Context
		Chain   github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		FeeInfo github_com_axelarnetwork_axelar_core_x_nexus_exported.FeeInfo
	}
	mock.lockRegisterFee.RLock()
	calls = mock.calls.RegisterFee
	mock.lockRegisterFee.RUnlock()
	return calls
}

// RemoveChainMaintainer calls RemoveChainMaintainerFunc.
func (mock *NexusMock) RemoveChainMaintainer(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, validator cosmossdktypes.ValAddress) error {
	if mock.RemoveChainMaintainerFunc == nil {
		panic("NexusMock.RemoveChainMaintainerFunc: method is nil but Nexus.RemoveChainMaintainer was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		Chain     github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Validator cosmossdktypes.ValAddress
	}{
		Ctx:       ctx,
		Chain:     chain,
		Validator: validator,
	}
	mock.lockRemoveChainMaintainer.Lock()
	mock.calls.RemoveChainMaintainer = append(mock.calls.RemoveChainMaintainer, callInfo)
	mock.lockRemoveChainMaintainer.Unlock()
	return mock.RemoveChainMaintainerFunc(ctx, chain, validator)
}

// RemoveChainMaintainerCalls gets all the calls that were made to RemoveChainMaintainer.
// Check the length with:
//
//	len(mockedNexus.RemoveChainMaintainerCalls())
func (mock *NexusMock) RemoveChainMaintainerCalls() []struct {
	Ctx       cosmossdktypes.Context
	Chain     github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	Validator cosmossdktypes.ValAddress
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		Chain     github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Validator cosmossdktypes.ValAddress
	}
	mock.lockRemoveChainMaintainer.RLock()
	calls = mock.calls.RemoveChainMaintainer
	mock.lockRemoveChainMaintainer.RUnlock()
	return calls
}

// RouteMessage calls RouteMessageFunc.
func (mock *NexusMock) RouteMessage(ctx cosmossdktypes.Context, id string, routingCtx ...github_com_axelarnetwork_axelar_core_x_nexus_exported.RoutingContext) error {
	if mock.RouteMessageFunc == nil {
		panic("NexusMock.RouteMessageFunc: method is nil but Nexus.RouteMessage was just called")
	}
	callInfo := struct {
		Ctx        cosmossdktypes.Context
		ID         string
		RoutingCtx []github_com_axelarnetwork_axelar_core_x_nexus_exported.RoutingContext
	}{
		Ctx:        ctx,
		ID:         id,
		RoutingCtx: routingCtx,
	}
	mock.lockRouteMessage.Lock()
	mock.calls.RouteMessage = append(mock.calls.RouteMessage, callInfo)
	mock.lockRouteMessage.Unlock()
	return mock.RouteMessageFunc(ctx, id, routingCtx...)
}

// RouteMessageCalls gets all the calls that were made to RouteMessage.
// Check the length with:
//
//	len(mockedNexus.RouteMessageCalls())
func (mock *NexusMock) RouteMessageCalls() []struct {
	Ctx        cosmossdktypes.Context
	ID         string
	RoutingCtx []github_com_axelarnetwork_axelar_core_x_nexus_exported.RoutingContext
} {
	var calls []struct {
		Ctx        cosmossdktypes.Context
		ID         string
		RoutingCtx []github_com_axelarnetwork_axelar_core_x_nexus_exported.RoutingContext
	}
	mock.lockRouteMessage.RLock()
	calls = mock.calls.RouteMessage
	mock.lockRouteMessage.RUnlock()
	return calls
}

// SetMessageExecuted calls SetMessageExecutedFunc.
func (mock *NexusMock) SetMessageExecuted(ctx cosmossdktypes.Context, id string) error {
	if mock.SetMessageExecutedFunc == nil {
		panic("NexusMock.SetMessageExecutedFunc: method is nil but Nexus.SetMessageExecuted was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockSetMessageExecuted.Lock()
	mock.calls.SetMessageExecuted = append(mock.calls.SetMessageExecuted, callInfo)
	mock.lockSetMessageExecuted.Unlock()
	return mock.SetMessageExecutedFunc(ctx, id)
}

// SetMessageExecutedCalls gets all the calls that were made to SetMessageExecuted.
// Check the length with:
//
//	len(mockedNexus.SetMessageExecutedCalls())
func (mock *NexusMock) SetMessageExecutedCalls() []struct {
	Ctx cosmossdktypes.Context
	ID  string
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
		ID  string
	}
	mock.lockSetMessageExecuted.RLock()
	calls = mock.calls.SetMessageExecuted
	mock.lockSetMessageExecuted.RUnlock()
	return calls
}

// SetNewMessage calls SetNewMessageFunc.
func (mock *NexusMock) SetNewMessage(ctx cosmossdktypes.Context, msg github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage) error {
	if mock.SetNewMessageFunc == nil {
		panic("NexusMock.SetNewMessageFunc: method is nil but Nexus.SetNewMessage was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
		Msg github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage
	}{
		Ctx: ctx,
		Msg: msg,
	}
	mock.lockSetNewMessage.Lock()
	mock.calls.SetNewMessage = append(mock.calls.SetNewMessage, callInfo)
	mock.lockSetNewMessage.Unlock()
	return mock.SetNewMessageFunc(ctx, msg)
}

// SetNewMessageCalls gets all the calls that were made to SetNewMessage.
// Check the length with:
//
//	len(mockedNexus.SetNewMessageCalls())
func (mock *NexusMock) SetNewMessageCalls() []struct {
	Ctx cosmossdktypes.Context
	Msg github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
		Msg github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage
	}
	mock.lockSetNewMessage.RLock()
	calls = mock.calls.SetNewMessage
	mock.lockSetNewMessage.RUnlock()
	return calls
}

// SetParams calls SetParamsFunc.
func (mock *NexusMock) SetParams(ctx cosmossdktypes.Context, p nexustypes.Params) {
	if mock.SetParamsFunc == nil {
		panic("NexusMock.SetParamsFunc: method is nil but Nexus.SetParams was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
		P   nexustypes.Params
	}{
		Ctx: ctx,
		P:   p,
	}
	mock.lockSetParams.Lock()
	mock.calls.SetParams = append(mock.calls.SetParams, callInfo)
	mock.lockSetParams.Unlock()
	mock.SetParamsFunc(ctx, p)
}

// SetParamsCalls gets all the calls that were made to SetParams.
// Check the length with:
//
//	len(mockedNexus.SetParamsCalls())
func (mock *NexusMock) SetParamsCalls() []struct {
	Ctx cosmossdktypes.Context
	P   nexustypes.Params
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
		P   nexustypes.Params
	}
	mock.lockSetParams.RLock()
	calls = mock.calls.SetParams
	mock.lockSetParams.RUnlock()
	return calls
}

// SetRateLimit calls SetRateLimitFunc.
func (mock *NexusMock) SetRateLimit(ctx cosmossdktypes.Context, chainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName, limit cosmossdktypes.Coin, window time.Duration) error {
	if mock.SetRateLimitFunc == nil {
		panic("NexusMock.SetRateLimitFunc: method is nil but Nexus.SetRateLimit was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		ChainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
		Limit     cosmossdktypes.Coin
		Window    time.Duration
	}{
		Ctx:       ctx,
		ChainName: chainName,
		Limit:     limit,
		Window:    window,
	}
	mock.lockSetRateLimit.Lock()
	mock.calls.SetRateLimit = append(mock.calls.SetRateLimit, callInfo)
	mock.lockSetRateLimit.Unlock()
	return mock.SetRateLimitFunc(ctx, chainName, limit, window)
}

// SetRateLimitCalls gets all the calls that were made to SetRateLimit.
// Check the length with:
//
//	len(mockedNexus.SetRateLimitCalls())
func (mock *NexusMock) SetRateLimitCalls() []struct {
	Ctx       cosmossdktypes.Context
	ChainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	Limit     cosmossdktypes.Coin
	Window    time.Duration
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		ChainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
		Limit     cosmossdktypes.Coin
		Window    time.Duration
	}
	mock.lockSetRateLimit.RLock()
	calls = mock.calls.SetRateLimit
	mock.lockSetRateLimit.RUnlock()
	return calls
}

// Ensure, that SnapshotterMock does implement nexustypes.Snapshotter.
// If this is not the case, regenerate this file with moq.
var _ nexustypes.Snapshotter = &SnapshotterMock{}

// SnapshotterMock is a mock implementation of nexustypes.Snapshotter.
//
//	func TestSomethingThatUsesSnapshotter(t *testing.T) {
//
//		// make and configure a mocked nexustypes.Snapshotter
//		mockedSnapshotter := &SnapshotterMock{
//			CreateSnapshotFunc: func(ctx cosmossdktypes.Context, candidates []cosmossdktypes.ValAddress, filterFunc func(snapshot.ValidatorI) bool, weightFunc func(consensusPower cosmossdktypes.Uint) cosmossdktypes.Uint, threshold utils.Threshold) (snapshot.Snapshot, error) {
//				panic("mock out the CreateSnapshot method")
//			},
//			GetOperatorFunc: func(ctx cosmossdktypes.Context, proxy cosmossdktypes.AccAddress) cosmossdktypes.ValAddress {
//				panic("mock out the GetOperator method")
//			},
//			GetProxyFunc: func(ctx cosmossdktypes.Context, operator cosmossdktypes.ValAddress) (cosmossdktypes.AccAddress, bool) {
//				panic("mock out the GetProxy method")
//			},
//		}
//
//		// use mockedSnapshotter in code that requires nexustypes.Snapshotter
//		// and then make assertions.
//
//	}
type SnapshotterMock struct {
	// CreateSnapshotFunc mocks the CreateSnapshot method.
	CreateSnapshotFunc func(ctx cosmossdktypes.Context, candidates []cosmossdktypes.ValAddress, filterFunc func(snapshot.ValidatorI) bool, weightFunc func(consensusPower cosmossdktypes.Uint) cosmossdktypes.Uint, threshold utils.Threshold) (snapshot.Snapshot, error)

	// GetOperatorFunc mocks the GetOperator method.
	GetOperatorFunc func(ctx cosmossdktypes.Context, proxy cosmossdktypes.AccAddress) cosmossdktypes.ValAddress

	// GetProxyFunc mocks the GetProxy method.
	GetProxyFunc func(ctx cosmossdktypes.Context, operator cosmossdktypes.ValAddress) (cosmossdktypes.AccAddress, bool)

	// calls tracks calls to the methods.
	calls struct {
		// CreateSnapshot holds details about calls to the CreateSnapshot method.
		CreateSnapshot []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Candidates is the candidates argument value.
			Candidates []cosmossdktypes.ValAddress
			// FilterFunc is the filterFunc argument value.
			FilterFunc func(snapshot.ValidatorI) bool
			// WeightFunc is the weightFunc argument value.
			WeightFunc func(consensusPower cosmossdktypes.Uint) cosmossdktypes.Uint
			// Threshold is the threshold argument value.
			Threshold utils.Threshold
		}
		// GetOperator holds details about calls to the GetOperator method.
		GetOperator []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Proxy is the proxy argument value.
			Proxy cosmossdktypes.AccAddress
		}
		// GetProxy holds details about calls to the GetProxy method.
		GetProxy []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Operator is the operator argument value.
			Operator cosmossdktypes.ValAddress
		}
	}
	lockCreateSnapshot sync.RWMutex
	lockGetOperator    sync.RWMutex
	lockGetProxy       sync.RWMutex
}

// CreateSnapshot calls CreateSnapshotFunc.
func (mock *SnapshotterMock) CreateSnapshot(ctx cosmossdktypes.Context, candidates []cosmossdktypes.ValAddress, filterFunc func(snapshot.ValidatorI) bool, weightFunc func(consensusPower cosmossdktypes.Uint) cosmossdktypes.Uint, threshold utils.Threshold) (snapshot.Snapshot, error) {
	if mock.CreateSnapshotFunc == nil {
		panic("SnapshotterMock.CreateSnapshotFunc: method is nil but Snapshotter.CreateSnapshot was just called")
	}
	callInfo := struct {
		Ctx        cosmossdktypes.Context
		Candidates []cosmossdktypes.ValAddress
		FilterFunc func(snapshot.ValidatorI) bool
		WeightFunc func(consensusPower cosmossdktypes.Uint) cosmossdktypes.Uint
		Threshold  utils.Threshold
	}{
		Ctx:        ctx,
		Candidates: candidates,
		FilterFunc: filterFunc,
		WeightFunc: weightFunc,
		Threshold:  threshold,
	}
	mock.lockCreateSnapshot.Lock()
	mock.calls.CreateSnapshot = append(mock.calls.CreateSnapshot, callInfo)
	mock.lockCreateSnapshot.Unlock()
	return mock.CreateSnapshotFunc(ctx, candidates, filterFunc, weightFunc, threshold)
}

// CreateSnapshotCalls gets all the calls that were made to CreateSnapshot.
// Check the length with:
//
//	len(mockedSnapshotter.CreateSnapshotCalls())
func (mock *SnapshotterMock) CreateSnapshotCalls() []struct {
	Ctx        cosmossdktypes.Context
	Candidates []cosmossdktypes.ValAddress
	FilterFunc func(snapshot.ValidatorI) bool
	WeightFunc func(consensusPower cosmossdktypes.Uint) cosmossdktypes.Uint
	Threshold  utils.Threshold
} {
	var calls []struct {
		Ctx        cosmossdktypes.Context
		Candidates []cosmossdktypes.ValAddress
		FilterFunc func(snapshot.ValidatorI) bool
		WeightFunc func(consensusPower cosmossdktypes.Uint) cosmossdktypes.Uint
		Threshold  utils.Threshold
	}
	mock.lockCreateSnapshot.RLock()
	calls = mock.calls.CreateSnapshot
	mock.lockCreateSnapshot.RUnlock()
	return calls
}

// GetOperator calls GetOperatorFunc.
func (mock *SnapshotterMock) GetOperator(ctx cosmossdktypes.Context, proxy cosmossdktypes.AccAddress) cosmossdktypes.ValAddress {
	if mock.GetOperatorFunc == nil {
		panic("SnapshotterMock.GetOperatorFunc: method is nil but Snapshotter.GetOperator was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Proxy cosmossdktypes.AccAddress
	}{
		Ctx:   ctx,
		Proxy: proxy,
	}
	mock.lockGetOperator.Lock()
	mock.calls.GetOperator = append(mock.calls.GetOperator, callInfo)
	mock.lockGetOperator.Unlock()
	return mock.GetOperatorFunc(ctx, proxy)
}

// GetOperatorCalls gets all the calls that were made to GetOperator.
// Check the length with:
//
//	len(mockedSnapshotter.GetOperatorCalls())
func (mock *SnapshotterMock) GetOperatorCalls() []struct {
	Ctx   cosmossdktypes.Context
	Proxy cosmossdktypes.AccAddress
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Proxy cosmossdktypes.AccAddress
	}
	mock.lockGetOperator.RLock()
	calls = mock.calls.GetOperator
	mock.lockGetOperator.RUnlock()
	return calls
}

// GetProxy calls GetProxyFunc.
func (mock *SnapshotterMock) GetProxy(ctx cosmossdktypes.Context, operator cosmossdktypes.ValAddress) (cosmossdktypes.AccAddress, bool) {
	if mock.GetProxyFunc == nil {
		panic("SnapshotterMock.GetProxyFunc: method is nil but Snapshotter.GetProxy was just called")
	}
	callInfo := struct {
		Ctx      cosmossdktypes.Context
		Operator cosmossdktypes.ValAddress
	}{
		Ctx:      ctx,
		Operator: operator,
	}
	mock.lockGetProxy.Lock()
	mock.calls.GetProxy = append(mock.calls.GetProxy, callInfo)
	mock.lockGetProxy.Unlock()
	return mock.GetProxyFunc(ctx, operator)
}

// GetProxyCalls gets all the calls that were made to GetProxy.
// Check the length with:
//
//	len(mockedSnapshotter.GetProxyCalls())
func (mock *SnapshotterMock) GetProxyCalls() []struct {
	Ctx      cosmossdktypes.Context
	Operator cosmossdktypes.ValAddress
} {
	var calls []struct {
		Ctx      cosmossdktypes.Context
		Operator cosmossdktypes.ValAddress
	}
	mock.lockGetProxy.RLock()
	calls = mock.calls.GetProxy
	mock.lockGetProxy.RUnlock()
	return calls
}

// Ensure, that AxelarnetKeeperMock does implement nexustypes.AxelarnetKeeper.
// If this is not the case, regenerate this file with moq.
var _ nexustypes.AxelarnetKeeper = &AxelarnetKeeperMock{}

// AxelarnetKeeperMock is a mock implementation of nexustypes.AxelarnetKeeper.
//
//	func TestSomethingThatUsesAxelarnetKeeper(t *testing.T) {
//
//		// make and configure a mocked nexustypes.AxelarnetKeeper
//		mockedAxelarnetKeeper := &AxelarnetKeeperMock{
//			IsCosmosChainFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) bool {
//				panic("mock out the IsCosmosChain method")
//			},
//		}
//
//		// use mockedAxelarnetKeeper in code that requires nexustypes.AxelarnetKeeper
//		// and then make assertions.
//
//	}
type AxelarnetKeeperMock struct {
	// IsCosmosChainFunc mocks the IsCosmosChain method.
	IsCosmosChainFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) bool

	// calls tracks calls to the methods.
	calls struct {
		// IsCosmosChain holds details about calls to the IsCosmosChain method.
		IsCosmosChain []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
		}
	}
	lockIsCosmosChain sync.RWMutex
}

// IsCosmosChain calls IsCosmosChainFunc.
func (mock *AxelarnetKeeperMock) IsCosmosChain(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) bool {
	if mock.IsCosmosChainFunc == nil {
		panic("AxelarnetKeeperMock.IsCosmosChainFunc: method is nil but AxelarnetKeeper.IsCosmosChain was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockIsCosmosChain.Lock()
	mock.calls.IsCosmosChain = append(mock.calls.IsCosmosChain, callInfo)
	mock.lockIsCosmosChain.Unlock()
	return mock.IsCosmosChainFunc(ctx, chain)
}

// IsCosmosChainCalls gets all the calls that were made to IsCosmosChain.
// Check the length with:
//
//	len(mockedAxelarnetKeeper.IsCosmosChainCalls())
func (mock *AxelarnetKeeperMock) IsCosmosChainCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}
	mock.lockIsCosmosChain.RLock()
	calls = mock.calls.IsCosmosChain
	mock.lockIsCosmosChain.RUnlock()
	return calls
}

// Ensure, that RewardKeeperMock does implement nexustypes.RewardKeeper.
// If this is not the case, regenerate this file with moq.
var _ nexustypes.RewardKeeper = &RewardKeeperMock{}

// RewardKeeperMock is a mock implementation of nexustypes.RewardKeeper.
//
//	func TestSomethingThatUsesRewardKeeper(t *testing.T) {
//
//		// make and configure a mocked nexustypes.RewardKeeper
//		mockedRewardKeeper := &RewardKeeperMock{
//			GetPoolFunc: func(ctx cosmossdktypes.Context, name string) reward.RewardPool {
//				panic("mock out the GetPool method")
//			},
//		}
//
//		// use mockedRewardKeeper in code that requires nexustypes.RewardKeeper
//		// and then make assertions.
//
//	}
type RewardKeeperMock struct {
	// GetPoolFunc mocks the GetPool method.
	GetPoolFunc func(ctx cosmossdktypes.Context, name string) reward.RewardPool

	// calls tracks calls to the methods.
	calls struct {
		// GetPool holds details about calls to the GetPool method.
		GetPool []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Name is the name argument value.
			Name string
		}
	}
	lockGetPool sync.RWMutex
}

// GetPool calls GetPoolFunc.
func (mock *RewardKeeperMock) GetPool(ctx cosmossdktypes.Context, name string) reward.RewardPool {
	if mock.GetPoolFunc == nil {
		panic("RewardKeeperMock.GetPoolFunc: method is nil but RewardKeeper.GetPool was just called")
	}
	callInfo := struct {
		Ctx  cosmossdktypes.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockGetPool.Lock()
	mock.calls.GetPool = append(mock.calls.GetPool, callInfo)
	mock.lockGetPool.Unlock()
	return mock.GetPoolFunc(ctx, name)
}

// GetPoolCalls gets all the calls that were made to GetPool.
// Check the length with:
//
//	len(mockedRewardKeeper.GetPoolCalls())
func (mock *RewardKeeperMock) GetPoolCalls() []struct {
	Ctx  cosmossdktypes.Context
	Name string
} {
	var calls []struct {
		Ctx  cosmossdktypes.Context
		Name string
	}
	mock.lockGetPool.RLock()
	calls = mock.calls.GetPool
	mock.lockGetPool.RUnlock()
	return calls
}

// Ensure, that SlashingKeeperMock does implement nexustypes.SlashingKeeper.
// If this is not the case, regenerate this file with moq.
var _ nexustypes.SlashingKeeper = &SlashingKeeperMock{}

// SlashingKeeperMock is a mock implementation of nexustypes.SlashingKeeper.
//
//	func TestSomethingThatUsesSlashingKeeper(t *testing.T) {
//
//		// make and configure a mocked nexustypes.SlashingKeeper
//		mockedSlashingKeeper := &SlashingKeeperMock{
//			IsTombstonedFunc: func(ctx cosmossdktypes.Context, consAddr cosmossdktypes.ConsAddress) bool {
//				panic("mock out the IsTombstoned method")
//			},
//		}
//
//		// use mockedSlashingKeeper in code that requires nexustypes.SlashingKeeper
//		// and then make assertions.
//
//	}
type SlashingKeeperMock struct {
	// IsTombstonedFunc mocks the IsTombstoned method.
	IsTombstonedFunc func(ctx cosmossdktypes.Context, consAddr cosmossdktypes.ConsAddress) bool

	// calls tracks calls to the methods.
	calls struct {
		// IsTombstoned holds details about calls to the IsTombstoned method.
		IsTombstoned []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ConsAddr is the consAddr argument value.
			ConsAddr cosmossdktypes.ConsAddress
		}
	}
	lockIsTombstoned sync.RWMutex
}

// IsTombstoned calls IsTombstonedFunc.
func (mock *SlashingKeeperMock) IsTombstoned(ctx cosmossdktypes.Context, consAddr cosmossdktypes.ConsAddress) bool {
	if mock.IsTombstonedFunc == nil {
		panic("SlashingKeeperMock.IsTombstonedFunc: method is nil but SlashingKeeper.IsTombstoned was just called")
	}
	callInfo := struct {
		Ctx      cosmossdktypes.Context
		ConsAddr cosmossdktypes.ConsAddress
	}{
		Ctx:      ctx,
		ConsAddr: consAddr,
	}
	mock.lockIsTombstoned.Lock()
	mock.calls.IsTombstoned = append(mock.calls.IsTombstoned, callInfo)
	mock.lockIsTombstoned.Unlock()
	return mock.IsTombstonedFunc(ctx, consAddr)
}

// IsTombstonedCalls gets all the calls that were made to IsTombstoned.
// Check the length with:
//
//	len(mockedSlashingKeeper.IsTombstonedCalls())
func (mock *SlashingKeeperMock) IsTombstonedCalls() []struct {
	Ctx      cosmossdktypes.Context
	ConsAddr cosmossdktypes.ConsAddress
} {
	var calls []struct {
		Ctx      cosmossdktypes.Context
		ConsAddr cosmossdktypes.ConsAddress
	}
	mock.lockIsTombstoned.RLock()
	calls = mock.calls.IsTombstoned
	mock.lockIsTombstoned.RUnlock()
	return calls
}

// Ensure, that WasmKeeperMock does implement nexustypes.WasmKeeper.
// If this is not the case, regenerate this file with moq.
var _ nexustypes.WasmKeeper = &WasmKeeperMock{}

// WasmKeeperMock is a mock implementation of nexustypes.WasmKeeper.
//
//	func TestSomethingThatUsesWasmKeeper(t *testing.T) {
//
//		// make and configure a mocked nexustypes.WasmKeeper
//		mockedWasmKeeper := &WasmKeeperMock{
//			ClearContractAdminFunc: func(ctx cosmossdktypes.Context, contractAddress cosmossdktypes.AccAddress, caller cosmossdktypes.AccAddress) error {
//				panic("mock out the ClearContractAdmin method")
//			},
//			CreateFunc: func(ctx cosmossdktypes.Context, creator cosmossdktypes.AccAddress, wasmCode []byte, instantiateAccess *wasmtypes.AccessConfig) (uint64, []byte, error) {
//				panic("mock out the Create method")
//			},
//			ExecuteFunc: func(ctx cosmossdktypes.Context, contractAddress cosmossdktypes.AccAddress, caller cosmossdktypes.AccAddress, msg []byte, coins cosmossdktypes.Coins) ([]byte, error) {
//				panic("mock out the Execute method")
//			},
//			InstantiateFunc: func(ctx cosmossdktypes.Context, codeID uint64, creator cosmossdktypes.AccAddress, admin cosmossdktypes.AccAddress, initMsg []byte, label string, deposit cosmossdktypes.Coins) (cosmossdktypes.AccAddress, []byte, error) {
//				panic("mock out the Instantiate method")
//			},
//			Instantiate2Func: func(ctx cosmossdktypes.Context, codeID uint64, creator cosmossdktypes.AccAddress, admin cosmossdktypes.AccAddress, initMsg []byte, label string, deposit cosmossdktypes.Coins, salt []byte, fixMsg bool) (cosmossdktypes.AccAddress, []byte, error) {
//				panic("mock out the Instantiate2 method")
//			},
//			MigrateFunc: func(ctx cosmossdktypes.Context, contractAddress cosmossdktypes.AccAddress, caller cosmossdktypes.AccAddress, newCodeID uint64, msg []byte) ([]byte, error) {
//				panic("mock out the Migrate method")
//			},
//			PinCodeFunc: func(ctx cosmossdktypes.Context, codeID uint64) error {
//				panic("mock out the PinCode method")
//			},
//			SetAccessConfigFunc: func(ctx cosmossdktypes.Context, codeID uint64, caller cosmossdktypes.AccAddress, newConfig wasmtypes.AccessConfig) error {
//				panic("mock out the SetAccessConfig method")
//			},
//			SetContractInfoExtensionFunc: func(ctx cosmossdktypes.Context, contract cosmossdktypes.AccAddress, extra wasmtypes.ContractInfoExtension) error {
//				panic("mock out the SetContractInfoExtension method")
//			},
//			SudoFunc: func(ctx cosmossdktypes.Context, contractAddress cosmossdktypes.AccAddress, msg []byte) ([]byte, error) {
//				panic("mock out the Sudo method")
//			},
//			UnpinCodeFunc: func(ctx cosmossdktypes.Context, codeID uint64) error {
//				panic("mock out the UnpinCode method")
//			},
//			UpdateContractAdminFunc: func(ctx cosmossdktypes.Context, contractAddress cosmossdktypes.AccAddress, caller cosmossdktypes.AccAddress, newAdmin cosmossdktypes.AccAddress) error {
//				panic("mock out the UpdateContractAdmin method")
//			},
//		}
//
//		// use mockedWasmKeeper in code that requires nexustypes.WasmKeeper
//		// and then make assertions.
//
//	}
type WasmKeeperMock struct {
	// ClearContractAdminFunc mocks the ClearContractAdmin method.
	ClearContractAdminFunc func(ctx cosmossdktypes.Context, contractAddress cosmossdktypes.AccAddress, caller cosmossdktypes.AccAddress) error

	// CreateFunc mocks the Create method.
	CreateFunc func(ctx cosmossdktypes.Context, creator cosmossdktypes.AccAddress, wasmCode []byte, instantiateAccess *wasmtypes.AccessConfig) (uint64, []byte, error)

	// ExecuteFunc mocks the Execute method.
	ExecuteFunc func(ctx cosmossdktypes.Context, contractAddress cosmossdktypes.AccAddress, caller cosmossdktypes.AccAddress, msg []byte, coins cosmossdktypes.Coins) ([]byte, error)

	// InstantiateFunc mocks the Instantiate method.
	InstantiateFunc func(ctx cosmossdktypes.Context, codeID uint64, creator cosmossdktypes.AccAddress, admin cosmossdktypes.AccAddress, initMsg []byte, label string, deposit cosmossdktypes.Coins) (cosmossdktypes.AccAddress, []byte, error)

	// Instantiate2Func mocks the Instantiate2 method.
	Instantiate2Func func(ctx cosmossdktypes.Context, codeID uint64, creator cosmossdktypes.AccAddress, admin cosmossdktypes.AccAddress, initMsg []byte, label string, deposit cosmossdktypes.Coins, salt []byte, fixMsg bool) (cosmossdktypes.AccAddress, []byte, error)

	// MigrateFunc mocks the Migrate method.
	MigrateFunc func(ctx cosmossdktypes.Context, contractAddress cosmossdktypes.AccAddress, caller cosmossdktypes.AccAddress, newCodeID uint64, msg []byte) ([]byte, error)

	// PinCodeFunc mocks the PinCode method.
	PinCodeFunc func(ctx cosmossdktypes.Context, codeID uint64) error

	// SetAccessConfigFunc mocks the SetAccessConfig method.
	SetAccessConfigFunc func(ctx cosmossdktypes.Context, codeID uint64, caller cosmossdktypes.AccAddress, newConfig wasmtypes.AccessConfig) error

	// SetContractInfoExtensionFunc mocks the SetContractInfoExtension method.
	SetContractInfoExtensionFunc func(ctx cosmossdktypes.Context, contract cosmossdktypes.AccAddress, extra wasmtypes.ContractInfoExtension) error

	// SudoFunc mocks the Sudo method.
	SudoFunc func(ctx cosmossdktypes.Context, contractAddress cosmossdktypes.AccAddress, msg []byte) ([]byte, error)

	// UnpinCodeFunc mocks the UnpinCode method.
	UnpinCodeFunc func(ctx cosmossdktypes.Context, codeID uint64) error

	// UpdateContractAdminFunc mocks the UpdateContractAdmin method.
	UpdateContractAdminFunc func(ctx cosmossdktypes.Context, contractAddress cosmossdktypes.AccAddress, caller cosmossdktypes.AccAddress, newAdmin cosmossdktypes.AccAddress) error

	// calls tracks calls to the methods.
	calls struct {
		// ClearContractAdmin holds details about calls to the ClearContractAdmin method.
		ClearContractAdmin []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ContractAddress is the contractAddress argument value.
			ContractAddress cosmossdktypes.AccAddress
			// Caller is the caller argument value.
			Caller cosmossdktypes.AccAddress
		}
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Creator is the creator argument value.
			Creator cosmossdktypes.AccAddress
			// WasmCode is the wasmCode argument value.
			WasmCode []byte
			// InstantiateAccess is the instantiateAccess argument value.
			InstantiateAccess *wasmtypes.AccessConfig
		}
		// Execute holds details about calls to the Execute method.
		Execute []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ContractAddress is the contractAddress argument value.
			ContractAddress cosmossdktypes.AccAddress
			// Caller is the caller argument value.
			Caller cosmossdktypes.AccAddress
			// Msg is the msg argument value.
			Msg []byte
			// Coins is the coins argument value.
			Coins cosmossdktypes.Coins
		}
		// Instantiate holds details about calls to the Instantiate method.
		Instantiate []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// CodeID is the codeID argument value.
			CodeID uint64
			// Creator is the creator argument value.
			Creator cosmossdktypes.AccAddress
			// Admin is the admin argument value.
			Admin cosmossdktypes.AccAddress
			// InitMsg is the initMsg argument value.
			InitMsg []byte
			// Label is the label argument value.
			Label string
			// Deposit is the deposit argument value.
			Deposit cosmossdktypes.Coins
		}
		// Instantiate2 holds details about calls to the Instantiate2 method.
		Instantiate2 []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// CodeID is the codeID argument value.
			CodeID uint64
			// Creator is the creator argument value.
			Creator cosmossdktypes.AccAddress
			// Admin is the admin argument value.
			Admin cosmossdktypes.AccAddress
			// InitMsg is the initMsg argument value.
			InitMsg []byte
			// Label is the label argument value.
			Label string
			// Deposit is the deposit argument value.
			Deposit cosmossdktypes.Coins
			// Salt is the salt argument value.
			Salt []byte
			// FixMsg is the fixMsg argument value.
			FixMsg bool
		}
		// Migrate holds details about calls to the Migrate method.
		Migrate []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ContractAddress is the contractAddress argument value.
			ContractAddress cosmossdktypes.AccAddress
			// Caller is the caller argument value.
			Caller cosmossdktypes.AccAddress
			// NewCodeID is the newCodeID argument value.
			NewCodeID uint64
			// Msg is the msg argument value.
			Msg []byte
		}
		// PinCode holds details about calls to the PinCode method.
		PinCode []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// CodeID is the codeID argument value.
			CodeID uint64
		}
		// SetAccessConfig holds details about calls to the SetAccessConfig method.
		SetAccessConfig []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// CodeID is the codeID argument value.
			CodeID uint64
			// Caller is the caller argument value.
			Caller cosmossdktypes.AccAddress
			// NewConfig is the newConfig argument value.
			NewConfig wasmtypes.AccessConfig
		}
		// SetContractInfoExtension holds details about calls to the SetContractInfoExtension method.
		SetContractInfoExtension []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Contract is the contract argument value.
			Contract cosmossdktypes.AccAddress
			// Extra is the extra argument value.
			Extra wasmtypes.ContractInfoExtension
		}
		// Sudo holds details about calls to the Sudo method.
		Sudo []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ContractAddress is the contractAddress argument value.
			ContractAddress cosmossdktypes.AccAddress
			// Msg is the msg argument value.
			Msg []byte
		}
		// UnpinCode holds details about calls to the UnpinCode method.
		UnpinCode []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// CodeID is the codeID argument value.
			CodeID uint64
		}
		// UpdateContractAdmin holds details about calls to the UpdateContractAdmin method.
		UpdateContractAdmin []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ContractAddress is the contractAddress argument value.
			ContractAddress cosmossdktypes.AccAddress
			// Caller is the caller argument value.
			Caller cosmossdktypes.AccAddress
			// NewAdmin is the newAdmin argument value.
			NewAdmin cosmossdktypes.AccAddress
		}
	}
	lockClearContractAdmin       sync.RWMutex
	lockCreate                   sync.RWMutex
	lockExecute                  sync.RWMutex
	lockInstantiate              sync.RWMutex
	lockInstantiate2             sync.RWMutex
	lockMigrate                  sync.RWMutex
	lockPinCode                  sync.RWMutex
	lockSetAccessConfig          sync.RWMutex
	lockSetContractInfoExtension sync.RWMutex
	lockSudo                     sync.RWMutex
	lockUnpinCode                sync.RWMutex
	lockUpdateContractAdmin      sync.RWMutex
}

// ClearContractAdmin calls ClearContractAdminFunc.
func (mock *WasmKeeperMock) ClearContractAdmin(ctx cosmossdktypes.Context, contractAddress cosmossdktypes.AccAddress, caller cosmossdktypes.AccAddress) error {
	if mock.ClearContractAdminFunc == nil {
		panic("WasmKeeperMock.ClearContractAdminFunc: method is nil but WasmKeeper.ClearContractAdmin was just called")
	}
	callInfo := struct {
		Ctx             cosmossdktypes.Context
		ContractAddress cosmossdktypes.AccAddress
		Caller          cosmossdktypes.AccAddress
	}{
		Ctx:             ctx,
		ContractAddress: contractAddress,
		Caller:          caller,
	}
	mock.lockClearContractAdmin.Lock()
	mock.calls.ClearContractAdmin = append(mock.calls.ClearContractAdmin, callInfo)
	mock.lockClearContractAdmin.Unlock()
	return mock.ClearContractAdminFunc(ctx, contractAddress, caller)
}

// ClearContractAdminCalls gets all the calls that were made to ClearContractAdmin.
// Check the length with:
//
//	len(mockedWasmKeeper.ClearContractAdminCalls())
func (mock *WasmKeeperMock) ClearContractAdminCalls() []struct {
	Ctx             cosmossdktypes.Context
	ContractAddress cosmossdktypes.AccAddress
	Caller          cosmossdktypes.AccAddress
} {
	var calls []struct {
		Ctx             cosmossdktypes.Context
		ContractAddress cosmossdktypes.AccAddress
		Caller          cosmossdktypes.AccAddress
	}
	mock.lockClearContractAdmin.RLock()
	calls = mock.calls.ClearContractAdmin
	mock.lockClearContractAdmin.RUnlock()
	return calls
}

// Create calls CreateFunc.
func (mock *WasmKeeperMock) Create(ctx cosmossdktypes.Context, creator cosmossdktypes.AccAddress, wasmCode []byte, instantiateAccess *wasmtypes.AccessConfig) (uint64, []byte, error) {
	if mock.CreateFunc == nil {
		panic("WasmKeeperMock.CreateFunc: method is nil but WasmKeeper.Create was just called")
	}
	callInfo := struct {
		Ctx               cosmossdktypes.Context
		Creator           cosmossdktypes.AccAddress
		WasmCode          []byte
		InstantiateAccess *wasmtypes.AccessConfig
	}{
		Ctx:               ctx,
		Creator:           creator,
		WasmCode:          wasmCode,
		InstantiateAccess: instantiateAccess,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, creator, wasmCode, instantiateAccess)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedWasmKeeper.CreateCalls())
func (mock *WasmKeeperMock) CreateCalls() []struct {
	Ctx               cosmossdktypes.Context
	Creator           cosmossdktypes.AccAddress
	WasmCode          []byte
	InstantiateAccess *wasmtypes.AccessConfig
} {
	var calls []struct {
		Ctx               cosmossdktypes.Context
		Creator           cosmossdktypes.AccAddress
		WasmCode          []byte
		InstantiateAccess *wasmtypes.AccessConfig
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Execute calls ExecuteFunc.
func (mock *WasmKeeperMock) Execute(ctx cosmossdktypes.Context, contractAddress cosmossdktypes.AccAddress, caller cosmossdktypes.AccAddress, msg []byte, coins cosmossdktypes.Coins) ([]byte, error) {
	if mock.ExecuteFunc == nil {
		panic("WasmKeeperMock.ExecuteFunc: method is nil but WasmKeeper.Execute was just called")
	}
	callInfo := struct {
		Ctx             cosmossdktypes.Context
		ContractAddress cosmossdktypes.AccAddress
		Caller          cosmossdktypes.AccAddress
		Msg             []byte
		Coins           cosmossdktypes.Coins
	}{
		Ctx:             ctx,
		ContractAddress: contractAddress,
		Caller:          caller,
		Msg:             msg,
		Coins:           coins,
	}
	mock.lockExecute.Lock()
	mock.calls.Execute = append(mock.calls.Execute, callInfo)
	mock.lockExecute.Unlock()
	return mock.ExecuteFunc(ctx, contractAddress, caller, msg, coins)
}

// ExecuteCalls gets all the calls that were made to Execute.
// Check the length with:
//
//	len(mockedWasmKeeper.ExecuteCalls())
func (mock *WasmKeeperMock) ExecuteCalls() []struct {
	Ctx             cosmossdktypes.Context
	ContractAddress cosmossdktypes.AccAddress
	Caller          cosmossdktypes.AccAddress
	Msg             []byte
	Coins           cosmossdktypes.Coins
} {
	var calls []struct {
		Ctx             cosmossdktypes.Context
		ContractAddress cosmossdktypes.AccAddress
		Caller          cosmossdktypes.AccAddress
		Msg             []byte
		Coins           cosmossdktypes.Coins
	}
	mock.lockExecute.RLock()
	calls = mock.calls.Execute
	mock.lockExecute.RUnlock()
	return calls
}

// Instantiate calls InstantiateFunc.
func (mock *WasmKeeperMock) Instantiate(ctx cosmossdktypes.Context, codeID uint64, creator cosmossdktypes.AccAddress, admin cosmossdktypes.AccAddress, initMsg []byte, label string, deposit cosmossdktypes.Coins) (cosmossdktypes.AccAddress, []byte, error) {
	if mock.InstantiateFunc == nil {
		panic("WasmKeeperMock.InstantiateFunc: method is nil but WasmKeeper.Instantiate was just called")
	}
	callInfo := struct {
		Ctx     cosmossdktypes.Context
		CodeID  uint64
		Creator cosmossdktypes.AccAddress
		Admin   cosmossdktypes.AccAddress
		InitMsg []byte
		Label   string
		Deposit cosmossdktypes.Coins
	}{
		Ctx:     ctx,
		CodeID:  codeID,
		Creator: creator,
		Admin:   admin,
		InitMsg: initMsg,
		Label:   label,
		Deposit: deposit,
	}
	mock.lockInstantiate.Lock()
	mock.calls.Instantiate = append(mock.calls.Instantiate, callInfo)
	mock.lockInstantiate.Unlock()
	return mock.InstantiateFunc(ctx, codeID, creator, admin, initMsg, label, deposit)
}

// InstantiateCalls gets all the calls that were made to Instantiate.
// Check the length with:
//
//	len(mockedWasmKeeper.InstantiateCalls())
func (mock *WasmKeeperMock) InstantiateCalls() []struct {
	Ctx     cosmossdktypes.Context
	CodeID  uint64
	Creator cosmossdktypes.AccAddress
	Admin   cosmossdktypes.AccAddress
	InitMsg []byte
	Label   string
	Deposit cosmossdktypes.Coins
} {
	var calls []struct {
		Ctx     cosmossdktypes.Context
		CodeID  uint64
		Creator cosmossdktypes.AccAddress
		Admin   cosmossdktypes.AccAddress
		InitMsg []byte
		Label   string
		Deposit cosmossdktypes.Coins
	}
	mock.lockInstantiate.RLock()
	calls = mock.calls.Instantiate
	mock.lockInstantiate.RUnlock()
	return calls
}

// Instantiate2 calls Instantiate2Func.
func (mock *WasmKeeperMock) Instantiate2(ctx cosmossdktypes.Context, codeID uint64, creator cosmossdktypes.AccAddress, admin cosmossdktypes.AccAddress, initMsg []byte, label string, deposit cosmossdktypes.Coins, salt []byte, fixMsg bool) (cosmossdktypes.AccAddress, []byte, error) {
	if mock.Instantiate2Func == nil {
		panic("WasmKeeperMock.Instantiate2Func: method is nil but WasmKeeper.Instantiate2 was just called")
	}
	callInfo := struct {
		Ctx     cosmossdktypes.Context
		CodeID  uint64
		Creator cosmossdktypes.AccAddress
		Admin   cosmossdktypes.AccAddress
		InitMsg []byte
		Label   string
		Deposit cosmossdktypes.Coins
		Salt    []byte
		FixMsg  bool
	}{
		Ctx:     ctx,
		CodeID:  codeID,
		Creator: creator,
		Admin:   admin,
		InitMsg: initMsg,
		Label:   label,
		Deposit: deposit,
		Salt:    salt,
		FixMsg:  fixMsg,
	}
	mock.lockInstantiate2.Lock()
	mock.calls.Instantiate2 = append(mock.calls.Instantiate2, callInfo)
	mock.lockInstantiate2.Unlock()
	return mock.Instantiate2Func(ctx, codeID, creator, admin, initMsg, label, deposit, salt, fixMsg)
}

// Instantiate2Calls gets all the calls that were made to Instantiate2.
// Check the length with:
//
//	len(mockedWasmKeeper.Instantiate2Calls())
func (mock *WasmKeeperMock) Instantiate2Calls() []struct {
	Ctx     cosmossdktypes.Context
	CodeID  uint64
	Creator cosmossdktypes.AccAddress
	Admin   cosmossdktypes.AccAddress
	InitMsg []byte
	Label   string
	Deposit cosmossdktypes.Coins
	Salt    []byte
	FixMsg  bool
} {
	var calls []struct {
		Ctx     cosmossdktypes.Context
		CodeID  uint64
		Creator cosmossdktypes.AccAddress
		Admin   cosmossdktypes.AccAddress
		InitMsg []byte
		Label   string
		Deposit cosmossdktypes.Coins
		Salt    []byte
		FixMsg  bool
	}
	mock.lockInstantiate2.RLock()
	calls = mock.calls.Instantiate2
	mock.lockInstantiate2.RUnlock()
	return calls
}

// Migrate calls MigrateFunc.
func (mock *WasmKeeperMock) Migrate(ctx cosmossdktypes.Context, contractAddress cosmossdktypes.AccAddress, caller cosmossdktypes.AccAddress, newCodeID uint64, msg []byte) ([]byte, error) {
	if mock.MigrateFunc == nil {
		panic("WasmKeeperMock.MigrateFunc: method is nil but WasmKeeper.Migrate was just called")
	}
	callInfo := struct {
		Ctx             cosmossdktypes.Context
		ContractAddress cosmossdktypes.AccAddress
		Caller          cosmossdktypes.AccAddress
		NewCodeID       uint64
		Msg             []byte
	}{
		Ctx:             ctx,
		ContractAddress: contractAddress,
		Caller:          caller,
		NewCodeID:       newCodeID,
		Msg:             msg,
	}
	mock.lockMigrate.Lock()
	mock.calls.Migrate = append(mock.calls.Migrate, callInfo)
	mock.lockMigrate.Unlock()
	return mock.MigrateFunc(ctx, contractAddress, caller, newCodeID, msg)
}

// MigrateCalls gets all the calls that were made to Migrate.
// Check the length with:
//
//	len(mockedWasmKeeper.MigrateCalls())
func (mock *WasmKeeperMock) MigrateCalls() []struct {
	Ctx             cosmossdktypes.Context
	ContractAddress cosmossdktypes.AccAddress
	Caller          cosmossdktypes.AccAddress
	NewCodeID       uint64
	Msg             []byte
} {
	var calls []struct {
		Ctx             cosmossdktypes.Context
		ContractAddress cosmossdktypes.AccAddress
		Caller          cosmossdktypes.AccAddress
		NewCodeID       uint64
		Msg             []byte
	}
	mock.lockMigrate.RLock()
	calls = mock.calls.Migrate
	mock.lockMigrate.RUnlock()
	return calls
}

// PinCode calls PinCodeFunc.
func (mock *WasmKeeperMock) PinCode(ctx cosmossdktypes.Context, codeID uint64) error {
	if mock.PinCodeFunc == nil {
		panic("WasmKeeperMock.PinCodeFunc: method is nil but WasmKeeper.PinCode was just called")
	}
	callInfo := struct {
		Ctx    cosmossdktypes.Context
		CodeID uint64
	}{
		Ctx:    ctx,
		CodeID: codeID,
	}
	mock.lockPinCode.Lock()
	mock.calls.PinCode = append(mock.calls.PinCode, callInfo)
	mock.lockPinCode.Unlock()
	return mock.PinCodeFunc(ctx, codeID)
}

// PinCodeCalls gets all the calls that were made to PinCode.
// Check the length with:
//
//	len(mockedWasmKeeper.PinCodeCalls())
func (mock *WasmKeeperMock) PinCodeCalls() []struct {
	Ctx    cosmossdktypes.Context
	CodeID uint64
} {
	var calls []struct {
		Ctx    cosmossdktypes.Context
		CodeID uint64
	}
	mock.lockPinCode.RLock()
	calls = mock.calls.PinCode
	mock.lockPinCode.RUnlock()
	return calls
}

// SetAccessConfig calls SetAccessConfigFunc.
func (mock *WasmKeeperMock) SetAccessConfig(ctx cosmossdktypes.Context, codeID uint64, caller cosmossdktypes.AccAddress, newConfig wasmtypes.AccessConfig) error {
	if mock.SetAccessConfigFunc == nil {
		panic("WasmKeeperMock.SetAccessConfigFunc: method is nil but WasmKeeper.SetAccessConfig was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		CodeID    uint64
		Caller    cosmossdktypes.AccAddress
		NewConfig wasmtypes.AccessConfig
	}{
		Ctx:       ctx,
		CodeID:    codeID,
		Caller:    caller,
		NewConfig: newConfig,
	}
	mock.lockSetAccessConfig.Lock()
	mock.calls.SetAccessConfig = append(mock.calls.SetAccessConfig, callInfo)
	mock.lockSetAccessConfig.Unlock()
	return mock.SetAccessConfigFunc(ctx, codeID, caller, newConfig)
}

// SetAccessConfigCalls gets all the calls that were made to SetAccessConfig.
// Check the length with:
//
//	len(mockedWasmKeeper.SetAccessConfigCalls())
func (mock *WasmKeeperMock) SetAccessConfigCalls() []struct {
	Ctx       cosmossdktypes.Context
	CodeID    uint64
	Caller    cosmossdktypes.AccAddress
	NewConfig wasmtypes.AccessConfig
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		CodeID    uint64
		Caller    cosmossdktypes.AccAddress
		NewConfig wasmtypes.AccessConfig
	}
	mock.lockSetAccessConfig.RLock()
	calls = mock.calls.SetAccessConfig
	mock.lockSetAccessConfig.RUnlock()
	return calls
}

// SetContractInfoExtension calls SetContractInfoExtensionFunc.
func (mock *WasmKeeperMock) SetContractInfoExtension(ctx cosmossdktypes.Context, contract cosmossdktypes.AccAddress, extra wasmtypes.ContractInfoExtension) error {
	if mock.SetContractInfoExtensionFunc == nil {
		panic("WasmKeeperMock.SetContractInfoExtensionFunc: method is nil but WasmKeeper.SetContractInfoExtension was just called")
	}
	callInfo := struct {
		Ctx      cosmossdktypes.Context
		Contract cosmossdktypes.AccAddress
		Extra    wasmtypes.ContractInfoExtension
	}{
		Ctx:      ctx,
		Contract: contract,
		Extra:    extra,
	}
	mock.lockSetContractInfoExtension.Lock()
	mock.calls.SetContractInfoExtension = append(mock.calls.SetContractInfoExtension, callInfo)
	mock.lockSetContractInfoExtension.Unlock()
	return mock.SetContractInfoExtensionFunc(ctx, contract, extra)
}

// SetContractInfoExtensionCalls gets all the calls that were made to SetContractInfoExtension.
// Check the length with:
//
//	len(mockedWasmKeeper.SetContractInfoExtensionCalls())
func (mock *WasmKeeperMock) SetContractInfoExtensionCalls() []struct {
	Ctx      cosmossdktypes.Context
	Contract cosmossdktypes.AccAddress
	Extra    wasmtypes.ContractInfoExtension
} {
	var calls []struct {
		Ctx      cosmossdktypes.Context
		Contract cosmossdktypes.AccAddress
		Extra    wasmtypes.ContractInfoExtension
	}
	mock.lockSetContractInfoExtension.RLock()
	calls = mock.calls.SetContractInfoExtension
	mock.lockSetContractInfoExtension.RUnlock()
	return calls
}

// Sudo calls SudoFunc.
func (mock *WasmKeeperMock) Sudo(ctx cosmossdktypes.Context, contractAddress cosmossdktypes.AccAddress, msg []byte) ([]byte, error) {
	if mock.SudoFunc == nil {
		panic("WasmKeeperMock.SudoFunc: method is nil but WasmKeeper.Sudo was just called")
	}
	callInfo := struct {
		Ctx             cosmossdktypes.Context
		ContractAddress cosmossdktypes.AccAddress
		Msg             []byte
	}{
		Ctx:             ctx,
		ContractAddress: contractAddress,
		Msg:             msg,
	}
	mock.lockSudo.Lock()
	mock.calls.Sudo = append(mock.calls.Sudo, callInfo)
	mock.lockSudo.Unlock()
	return mock.SudoFunc(ctx, contractAddress, msg)
}

// SudoCalls gets all the calls that were made to Sudo.
// Check the length with:
//
//	len(mockedWasmKeeper.SudoCalls())
func (mock *WasmKeeperMock) SudoCalls() []struct {
	Ctx             cosmossdktypes.Context
	ContractAddress cosmossdktypes.AccAddress
	Msg             []byte
} {
	var calls []struct {
		Ctx             cosmossdktypes.Context
		ContractAddress cosmossdktypes.AccAddress
		Msg             []byte
	}
	mock.lockSudo.RLock()
	calls = mock.calls.Sudo
	mock.lockSudo.RUnlock()
	return calls
}

// UnpinCode calls UnpinCodeFunc.
func (mock *WasmKeeperMock) UnpinCode(ctx cosmossdktypes.Context, codeID uint64) error {
	if mock.UnpinCodeFunc == nil {
		panic("WasmKeeperMock.UnpinCodeFunc: method is nil but WasmKeeper.UnpinCode was just called")
	}
	callInfo := struct {
		Ctx    cosmossdktypes.Context
		CodeID uint64
	}{
		Ctx:    ctx,
		CodeID: codeID,
	}
	mock.lockUnpinCode.Lock()
	mock.calls.UnpinCode = append(mock.calls.UnpinCode, callInfo)
	mock.lockUnpinCode.Unlock()
	return mock.UnpinCodeFunc(ctx, codeID)
}

// UnpinCodeCalls gets all the calls that were made to UnpinCode.
// Check the length with:
//
//	len(mockedWasmKeeper.UnpinCodeCalls())
func (mock *WasmKeeperMock) UnpinCodeCalls() []struct {
	Ctx    cosmossdktypes.Context
	CodeID uint64
} {
	var calls []struct {
		Ctx    cosmossdktypes.Context
		CodeID uint64
	}
	mock.lockUnpinCode.RLock()
	calls = mock.calls.UnpinCode
	mock.lockUnpinCode.RUnlock()
	return calls
}

// UpdateContractAdmin calls UpdateContractAdminFunc.
func (mock *WasmKeeperMock) UpdateContractAdmin(ctx cosmossdktypes.Context, contractAddress cosmossdktypes.AccAddress, caller cosmossdktypes.AccAddress, newAdmin cosmossdktypes.AccAddress) error {
	if mock.UpdateContractAdminFunc == nil {
		panic("WasmKeeperMock.UpdateContractAdminFunc: method is nil but WasmKeeper.UpdateContractAdmin was just called")
	}
	callInfo := struct {
		Ctx             cosmossdktypes.Context
		ContractAddress cosmossdktypes.AccAddress
		Caller          cosmossdktypes.AccAddress
		NewAdmin        cosmossdktypes.AccAddress
	}{
		Ctx:             ctx,
		ContractAddress: contractAddress,
		Caller:          caller,
		NewAdmin:        newAdmin,
	}
	mock.lockUpdateContractAdmin.Lock()
	mock.calls.UpdateContractAdmin = append(mock.calls.UpdateContractAdmin, callInfo)
	mock.lockUpdateContractAdmin.Unlock()
	return mock.UpdateContractAdminFunc(ctx, contractAddress, caller, newAdmin)
}

// UpdateContractAdminCalls gets all the calls that were made to UpdateContractAdmin.
// Check the length with:
//
//	len(mockedWasmKeeper.UpdateContractAdminCalls())
func (mock *WasmKeeperMock) UpdateContractAdminCalls() []struct {
	Ctx             cosmossdktypes.Context
	ContractAddress cosmossdktypes.AccAddress
	Caller          cosmossdktypes.AccAddress
	NewAdmin        cosmossdktypes.AccAddress
} {
	var calls []struct {
		Ctx             cosmossdktypes.Context
		ContractAddress cosmossdktypes.AccAddress
		Caller          cosmossdktypes.AccAddress
		NewAdmin        cosmossdktypes.AccAddress
	}
	mock.lockUpdateContractAdmin.RLock()
	calls = mock.calls.UpdateContractAdmin
	mock.lockUpdateContractAdmin.RUnlock()
	return calls
}

// Ensure, that AccountKeeperMock does implement nexustypes.AccountKeeper.
// If this is not the case, regenerate this file with moq.
var _ nexustypes.AccountKeeper = &AccountKeeperMock{}

// AccountKeeperMock is a mock implementation of nexustypes.AccountKeeper.
//
//	func TestSomethingThatUsesAccountKeeper(t *testing.T) {
//
//		// make and configure a mocked nexustypes.AccountKeeper
//		mockedAccountKeeper := &AccountKeeperMock{
//			GetModuleAddressFunc: func(moduleName string) cosmossdktypes.AccAddress {
//				panic("mock out the GetModuleAddress method")
//			},
//		}
//
//		// use mockedAccountKeeper in code that requires nexustypes.AccountKeeper
//		// and then make assertions.
//
//	}
type AccountKeeperMock struct {
	// GetModuleAddressFunc mocks the GetModuleAddress method.
	GetModuleAddressFunc func(moduleName string) cosmossdktypes.AccAddress

	// calls tracks calls to the methods.
	calls struct {
		// GetModuleAddress holds details about calls to the GetModuleAddress method.
		GetModuleAddress []struct {
			// ModuleName is the moduleName argument value.
			ModuleName string
		}
	}
	lockGetModuleAddress sync.RWMutex
}

// GetModuleAddress calls GetModuleAddressFunc.
func (mock *AccountKeeperMock) GetModuleAddress(moduleName string) cosmossdktypes.AccAddress {
	if mock.GetModuleAddressFunc == nil {
		panic("AccountKeeperMock.GetModuleAddressFunc: method is nil but AccountKeeper.GetModuleAddress was just called")
	}
	callInfo := struct {
		ModuleName string
	}{
		ModuleName: moduleName,
	}
	mock.lockGetModuleAddress.Lock()
	mock.calls.GetModuleAddress = append(mock.calls.GetModuleAddress, callInfo)
	mock.lockGetModuleAddress.Unlock()
	return mock.GetModuleAddressFunc(moduleName)
}

// GetModuleAddressCalls gets all the calls that were made to GetModuleAddress.
// Check the length with:
//
//	len(mockedAccountKeeper.GetModuleAddressCalls())
func (mock *AccountKeeperMock) GetModuleAddressCalls() []struct {
	ModuleName string
} {
	var calls []struct {
		ModuleName string
	}
	mock.lockGetModuleAddress.RLock()
	calls = mock.calls.GetModuleAddress
	mock.lockGetModuleAddress.RUnlock()
	return calls
}

// Ensure, that StakingKeeperMock does implement nexustypes.StakingKeeper.
// If this is not the case, regenerate this file with moq.
var _ nexustypes.StakingKeeper = &StakingKeeperMock{}

// StakingKeeperMock is a mock implementation of nexustypes.StakingKeeper.
//
//	func TestSomethingThatUsesStakingKeeper(t *testing.T) {
//
//		// make and configure a mocked nexustypes.StakingKeeper
//		mockedStakingKeeper := &StakingKeeperMock{
//			GetLastTotalPowerFunc: func(context cosmossdktypes.Context) cosmossdktypes.Int {
//				panic("mock out the GetLastTotalPower method")
//			},
//			PowerReductionFunc: func(context cosmossdktypes.Context) cosmossdktypes.Int {
//				panic("mock out the PowerReduction method")
//			},
//			ValidatorFunc: func(ctx cosmossdktypes.Context, addr cosmossdktypes.ValAddress) stakingtypes.ValidatorI {
//				panic("mock out the Validator method")
//			},
//		}
//
//		// use mockedStakingKeeper in code that requires nexustypes.StakingKeeper
//		// and then make assertions.
//
//	}
type StakingKeeperMock struct {
	// GetLastTotalPowerFunc mocks the GetLastTotalPower method.
	GetLastTotalPowerFunc func(context cosmossdktypes.Context) cosmossdktypes.Int

	// PowerReductionFunc mocks the PowerReduction method.
	PowerReductionFunc func(context cosmossdktypes.Context) cosmossdktypes.Int

	// ValidatorFunc mocks the Validator method.
	ValidatorFunc func(ctx cosmossdktypes.Context, addr cosmossdktypes.ValAddress) stakingtypes.ValidatorI

	// calls tracks calls to the methods.
	calls struct {
		// GetLastTotalPower holds details about calls to the GetLastTotalPower method.
		GetLastTotalPower []struct {
			// Context is the context argument value.
			Context cosmossdktypes.Context
		}
		// PowerReduction holds details about calls to the PowerReduction method.
		PowerReduction []struct {
			// Context is the context argument value.
			Context cosmossdktypes.Context
		}
		// Validator holds details about calls to the Validator method.
		Validator []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Addr is the addr argument value.
			Addr cosmossdktypes.ValAddress
		}
	}
	lockGetLastTotalPower sync.RWMutex
	lockPowerReduction    sync.RWMutex
	lockValidator         sync.RWMutex
}

// GetLastTotalPower calls GetLastTotalPowerFunc.
func (mock *StakingKeeperMock) GetLastTotalPower(context cosmossdktypes.Context) cosmossdktypes.Int {
	if mock.GetLastTotalPowerFunc == nil {
		panic("StakingKeeperMock.GetLastTotalPowerFunc: method is nil but StakingKeeper.GetLastTotalPower was just called")
	}
	callInfo := struct {
		Context cosmossdktypes.Context
	}{
		Context: context,
	}
	mock.lockGetLastTotalPower.Lock()
	mock.calls.GetLastTotalPower = append(mock.calls.GetLastTotalPower, callInfo)
	mock.lockGetLastTotalPower.Unlock()
	return mock.GetLastTotalPowerFunc(context)
}

// GetLastTotalPowerCalls gets all the calls that were made to GetLastTotalPower.
// Check the length with:
//
//	len(mockedStakingKeeper.GetLastTotalPowerCalls())
func (mock *StakingKeeperMock) GetLastTotalPowerCalls() []struct {
	Context cosmossdktypes.Context
} {
	var calls []struct {
		Context cosmossdktypes.Context
	}
	mock.lockGetLastTotalPower.RLock()
	calls = mock.calls.GetLastTotalPower
	mock.lockGetLastTotalPower.RUnlock()
	return calls
}

// PowerReduction calls PowerReductionFunc.
func (mock *StakingKeeperMock) PowerReduction(context cosmossdktypes.Context) cosmossdktypes.Int {
	if mock.PowerReductionFunc == nil {
		panic("StakingKeeperMock.PowerReductionFunc: method is nil but StakingKeeper.PowerReduction was just called")
	}
	callInfo := struct {
		Context cosmossdktypes.Context
	}{
		Context: context,
	}
	mock.lockPowerReduction.Lock()
	mock.calls.PowerReduction = append(mock.calls.PowerReduction, callInfo)
	mock.lockPowerReduction.Unlock()
	return mock.PowerReductionFunc(context)
}

// PowerReductionCalls gets all the calls that were made to PowerReduction.
// Check the length with:
//
//	len(mockedStakingKeeper.PowerReductionCalls())
func (mock *StakingKeeperMock) PowerReductionCalls() []struct {
	Context cosmossdktypes.Context
} {
	var calls []struct {
		Context cosmossdktypes.Context
	}
	mock.lockPowerReduction.RLock()
	calls = mock.calls.PowerReduction
	mock.lockPowerReduction.RUnlock()
	return calls
}

// Validator calls ValidatorFunc.
func (mock *StakingKeeperMock) Validator(ctx cosmossdktypes.Context, addr cosmossdktypes.ValAddress) stakingtypes.ValidatorI {
	if mock.ValidatorFunc == nil {
		panic("StakingKeeperMock.ValidatorFunc: method is nil but StakingKeeper.Validator was just called")
	}
	callInfo := struct {
		Ctx  cosmossdktypes.Context
		Addr cosmossdktypes.ValAddress
	}{
		Ctx:  ctx,
		Addr: addr,
	}
	mock.lockValidator.Lock()
	mock.calls.Validator = append(mock.calls.Validator, callInfo)
	mock.lockValidator.Unlock()
	return mock.ValidatorFunc(ctx, addr)
}

// ValidatorCalls gets all the calls that were made to Validator.
// Check the length with:
//
//	len(mockedStakingKeeper.ValidatorCalls())
func (mock *StakingKeeperMock) ValidatorCalls() []struct {
	Ctx  cosmossdktypes.Context
	Addr cosmossdktypes.ValAddress
} {
	var calls []struct {
		Ctx  cosmossdktypes.Context
		Addr cosmossdktypes.ValAddress
	}
	mock.lockValidator.RLock()
	calls = mock.calls.Validator
	mock.lockValidator.RUnlock()
	return calls
}

// Ensure, that MsgIDGeneratorMock does implement nexustypes.MsgIDGenerator.
// If this is not the case, regenerate this file with moq.
var _ nexustypes.MsgIDGenerator = &MsgIDGeneratorMock{}

// MsgIDGeneratorMock is a mock implementation of nexustypes.MsgIDGenerator.
//
//	func TestSomethingThatUsesMsgIDGenerator(t *testing.T) {
//
//		// make and configure a mocked nexustypes.MsgIDGenerator
//		mockedMsgIDGenerator := &MsgIDGeneratorMock{
//			CurrIDFunc: func(ctx cosmossdktypes.Context) ([32]byte, uint64) {
//				panic("mock out the CurrID method")
//			},
//			IncrIDFunc: func(ctx cosmossdktypes.Context)  {
//				panic("mock out the IncrID method")
//			},
//		}
//
//		// use mockedMsgIDGenerator in code that requires nexustypes.MsgIDGenerator
//		// and then make assertions.
//
//	}
type MsgIDGeneratorMock struct {
	// CurrIDFunc mocks the CurrID method.
	CurrIDFunc func(ctx cosmossdktypes.Context) ([32]byte, uint64)

	// IncrIDFunc mocks the IncrID method.
	IncrIDFunc func(ctx cosmossdktypes.Context)

	// calls tracks calls to the methods.
	calls struct {
		// CurrID holds details about calls to the CurrID method.
		CurrID []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// IncrID holds details about calls to the IncrID method.
		IncrID []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
	}
	lockCurrID sync.RWMutex
	lockIncrID sync.RWMutex
}

// CurrID calls CurrIDFunc.
func (mock *MsgIDGeneratorMock) CurrID(ctx cosmossdktypes.Context) ([32]byte, uint64) {
	if mock.CurrIDFunc == nil {
		panic("MsgIDGeneratorMock.CurrIDFunc: method is nil but MsgIDGenerator.CurrID was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockCurrID.Lock()
	mock.calls.CurrID = append(mock.calls.CurrID, callInfo)
	mock.lockCurrID.Unlock()
	return mock.CurrIDFunc(ctx)
}

// CurrIDCalls gets all the calls that were made to CurrID.
// Check the length with:
//
//	len(mockedMsgIDGenerator.CurrIDCalls())
func (mock *MsgIDGeneratorMock) CurrIDCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockCurrID.RLock()
	calls = mock.calls.CurrID
	mock.lockCurrID.RUnlock()
	return calls
}

// IncrID calls IncrIDFunc.
func (mock *MsgIDGeneratorMock) IncrID(ctx cosmossdktypes.Context) {
	if mock.IncrIDFunc == nil {
		panic("MsgIDGeneratorMock.IncrIDFunc: method is nil but MsgIDGenerator.IncrID was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockIncrID.Lock()
	mock.calls.IncrID = append(mock.calls.IncrID, callInfo)
	mock.lockIncrID.Unlock()
	mock.IncrIDFunc(ctx)
}

// IncrIDCalls gets all the calls that were made to IncrID.
// Check the length with:
//
//	len(mockedMsgIDGenerator.IncrIDCalls())
func (mock *MsgIDGeneratorMock) IncrIDCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockIncrID.RLock()
	calls = mock.calls.IncrID
	mock.lockIncrID.RUnlock()
	return calls
}

// Ensure, that IBCKeeperMock does implement nexustypes.IBCKeeper.
// If this is not the case, regenerate this file with moq.
var _ nexustypes.IBCKeeper = &IBCKeeperMock{}

// IBCKeeperMock is a mock implementation of nexustypes.IBCKeeper.
//
//	func TestSomethingThatUsesIBCKeeper(t *testing.T) {
//
//		// make and configure a mocked nexustypes.IBCKeeper
//		mockedIBCKeeper := &IBCKeeperMock{
//			GetIBCPathFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (string, bool) {
//				panic("mock out the GetIBCPath method")
//			},
//			ParseIBCDenomFunc: func(ctx cosmossdktypes.Context, ibcDenom string) (ibctypes.DenomTrace, error) {
//				panic("mock out the ParseIBCDenom method")
//			},
//		}
//
//		// use mockedIBCKeeper in code that requires nexustypes.IBCKeeper
//		// and then make assertions.
//
//	}
type IBCKeeperMock struct {
	// GetIBCPathFunc mocks the GetIBCPath method.
	GetIBCPathFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (string, bool)

	// ParseIBCDenomFunc mocks the ParseIBCDenom method.
	ParseIBCDenomFunc func(ctx cosmossdktypes.Context, ibcDenom string) (ibctypes.DenomTrace, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetIBCPath holds details about calls to the GetIBCPath method.
		GetIBCPath []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
		}
		// ParseIBCDenom holds details about calls to the ParseIBCDenom method.
		ParseIBCDenom []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// IbcDenom is the ibcDenom argument value.
			IbcDenom string
		}
	}
	lockGetIBCPath    sync.RWMutex
	lockParseIBCDenom sync.RWMutex
}

// GetIBCPath calls GetIBCPathFunc.
func (mock *IBCKeeperMock) GetIBCPath(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (string, bool) {
	if mock.GetIBCPathFunc == nil {
		panic("IBCKeeperMock.GetIBCPathFunc: method is nil but IBCKeeper.GetIBCPath was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockGetIBCPath.Lock()
	mock.calls.GetIBCPath = append(mock.calls.GetIBCPath, callInfo)
	mock.lockGetIBCPath.Unlock()
	return mock.GetIBCPathFunc(ctx, chain)
}

// GetIBCPathCalls gets all the calls that were made to GetIBCPath.
// Check the length with:
//
//	len(mockedIBCKeeper.GetIBCPathCalls())
func (mock *IBCKeeperMock) GetIBCPathCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}
	mock.lockGetIBCPath.RLock()
	calls = mock.calls.GetIBCPath
	mock.lockGetIBCPath.RUnlock()
	return calls
}

// ParseIBCDenom calls ParseIBCDenomFunc.
func (mock *IBCKeeperMock) ParseIBCDenom(ctx cosmossdktypes.Context, ibcDenom string) (ibctypes.DenomTrace, error) {
	if mock.ParseIBCDenomFunc == nil {
		panic("IBCKeeperMock.ParseIBCDenomFunc: method is nil but IBCKeeper.ParseIBCDenom was just called")
	}
	callInfo := struct {
		Ctx      cosmossdktypes.Context
		IbcDenom string
	}{
		Ctx:      ctx,
		IbcDenom: ibcDenom,
	}
	mock.lockParseIBCDenom.Lock()
	mock.calls.ParseIBCDenom = append(mock.calls.ParseIBCDenom, callInfo)
	mock.lockParseIBCDenom.Unlock()
	return mock.ParseIBCDenomFunc(ctx, ibcDenom)
}

// ParseIBCDenomCalls gets all the calls that were made to ParseIBCDenom.
// Check the length with:
//
//	len(mockedIBCKeeper.ParseIBCDenomCalls())
func (mock *IBCKeeperMock) ParseIBCDenomCalls() []struct {
	Ctx      cosmossdktypes.Context
	IbcDenom string
} {
	var calls []struct {
		Ctx      cosmossdktypes.Context
		IbcDenom string
	}
	mock.lockParseIBCDenom.RLock()
	calls = mock.calls.ParseIBCDenom
	mock.lockParseIBCDenom.RUnlock()
	return calls
}

// Ensure, that BankKeeperMock does implement nexustypes.BankKeeper.
// If this is not the case, regenerate this file with moq.
var _ nexustypes.BankKeeper = &BankKeeperMock{}

// BankKeeperMock is a mock implementation of nexustypes.BankKeeper.
//
//	func TestSomethingThatUsesBankKeeper(t *testing.T) {
//
//		// make and configure a mocked nexustypes.BankKeeper
//		mockedBankKeeper := &BankKeeperMock{
//			BurnCoinsFunc: func(ctx cosmossdktypes.Context, moduleName string, amt cosmossdktypes.Coins) error {
//				panic("mock out the BurnCoins method")
//			},
//			GetAllBalancesFunc: func(ctx cosmossdktypes.Context, addr cosmossdktypes.AccAddress) cosmossdktypes.Coins {
//				panic("mock out the GetAllBalances method")
//			},
//			MintCoinsFunc: func(ctx cosmossdktypes.Context, moduleName string, amt cosmossdktypes.Coins) error {
//				panic("mock out the MintCoins method")
//			},
//			SendCoinsFunc: func(ctx cosmossdktypes.Context, fromAddr cosmossdktypes.AccAddress, toAddr cosmossdktypes.AccAddress, amt cosmossdktypes.Coins) error {
//				panic("mock out the SendCoins method")
//			},
//			SendCoinsFromAccountToModuleFunc: func(ctx cosmossdktypes.Context, senderAddr cosmossdktypes.AccAddress, recipientModule string, amt cosmossdktypes.Coins) error {
//				panic("mock out the SendCoinsFromAccountToModule method")
//			},
//			SendCoinsFromModuleToAccountFunc: func(ctx cosmossdktypes.Context, senderModule string, recipientAddr cosmossdktypes.AccAddress, amt cosmossdktypes.Coins) error {
//				panic("mock out the SendCoinsFromModuleToAccount method")
//			},
//			SendCoinsFromModuleToModuleFunc: func(ctx cosmossdktypes.Context, senderModule string, recipientModule string, amt cosmossdktypes.Coins) error {
//				panic("mock out the SendCoinsFromModuleToModule method")
//			},
//		}
//
//		// use mockedBankKeeper in code that requires nexustypes.BankKeeper
//		// and then make assertions.
//
//	}
type BankKeeperMock struct {
	// BurnCoinsFunc mocks the BurnCoins method.
	BurnCoinsFunc func(ctx cosmossdktypes.Context, moduleName string, amt cosmossdktypes.Coins) error

	// GetAllBalancesFunc mocks the GetAllBalances method.
	GetAllBalancesFunc func(ctx cosmossdktypes.Context, addr cosmossdktypes.AccAddress) cosmossdktypes.Coins

	// MintCoinsFunc mocks the MintCoins method.
	MintCoinsFunc func(ctx cosmossdktypes.Context, moduleName string, amt cosmossdktypes.Coins) error

	// SendCoinsFunc mocks the SendCoins method.
	SendCoinsFunc func(ctx cosmossdktypes.Context, fromAddr cosmossdktypes.AccAddress, toAddr cosmossdktypes.AccAddress, amt cosmossdktypes.Coins) error

	// SendCoinsFromAccountToModuleFunc mocks the SendCoinsFromAccountToModule method.
	SendCoinsFromAccountToModuleFunc func(ctx cosmossdktypes.Context, senderAddr cosmossdktypes.AccAddress, recipientModule string, amt cosmossdktypes.Coins) error

	// SendCoinsFromModuleToAccountFunc mocks the SendCoinsFromModuleToAccount method.
	SendCoinsFromModuleToAccountFunc func(ctx cosmossdktypes.Context, senderModule string, recipientAddr cosmossdktypes.AccAddress, amt cosmossdktypes.Coins) error

	// SendCoinsFromModuleToModuleFunc mocks the SendCoinsFromModuleToModule method.
	SendCoinsFromModuleToModuleFunc func(ctx cosmossdktypes.Context, senderModule string, recipientModule string, amt cosmossdktypes.Coins) error

	// calls tracks calls to the methods.
	calls struct {
		// BurnCoins holds details about calls to the BurnCoins method.
		BurnCoins []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ModuleName is the moduleName argument value.
			ModuleName string
			// Amt is the amt argument value.
			Amt cosmossdktypes.Coins
		}
		// GetAllBalances holds details about calls to the GetAllBalances method.
		GetAllBalances []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Addr is the addr argument value.
			Addr cosmossdktypes.AccAddress
		}
		// MintCoins holds details about calls to the MintCoins method.
		MintCoins []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ModuleName is the moduleName argument value.
			ModuleName string
			// Amt is the amt argument value.
			Amt cosmossdktypes.Coins
		}
		// SendCoins holds details about calls to the SendCoins method.
		SendCoins []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// FromAddr is the fromAddr argument value.
			FromAddr cosmossdktypes.AccAddress
			// ToAddr is the toAddr argument value.
			ToAddr cosmossdktypes.AccAddress
			// Amt is the amt argument value.
			Amt cosmossdktypes.Coins
		}
		// SendCoinsFromAccountToModule holds details about calls to the SendCoinsFromAccountToModule method.
		SendCoinsFromAccountToModule []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// SenderAddr is the senderAddr argument value.
			SenderAddr cosmossdktypes.AccAddress
			// RecipientModule is the recipientModule argument value.
			RecipientModule string
			// Amt is the amt argument value.
			Amt cosmossdktypes.Coins
		}
		// SendCoinsFromModuleToAccount holds details about calls to the SendCoinsFromModuleToAccount method.
		SendCoinsFromModuleToAccount []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// SenderModule is the senderModule argument value.
			SenderModule string
			// RecipientAddr is the recipientAddr argument value.
			RecipientAddr cosmossdktypes.AccAddress
			// Amt is the amt argument value.
			Amt cosmossdktypes.Coins
		}
		// SendCoinsFromModuleToModule holds details about calls to the SendCoinsFromModuleToModule method.
		SendCoinsFromModuleToModule []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// SenderModule is the senderModule argument value.
			SenderModule string
			// RecipientModule is the recipientModule argument value.
			RecipientModule string
			// Amt is the amt argument value.
			Amt cosmossdktypes.Coins
		}
	}
	lockBurnCoins                    sync.RWMutex
	lockGetAllBalances               sync.RWMutex
	lockMintCoins                    sync.RWMutex
	lockSendCoins                    sync.RWMutex
	lockSendCoinsFromAccountToModule sync.RWMutex
	lockSendCoinsFromModuleToAccount sync.RWMutex
	lockSendCoinsFromModuleToModule  sync.RWMutex
}

// BurnCoins calls BurnCoinsFunc.
func (mock *BankKeeperMock) BurnCoins(ctx cosmossdktypes.Context, moduleName string, amt cosmossdktypes.Coins) error {
	if mock.BurnCoinsFunc == nil {
		panic("BankKeeperMock.BurnCoinsFunc: method is nil but BankKeeper.BurnCoins was just called")
	}
	callInfo := struct {
		Ctx        cosmossdktypes.Context
		ModuleName string
		Amt        cosmossdktypes.Coins
	}{
		Ctx:        ctx,
		ModuleName: moduleName,
		Amt:        amt,
	}
	mock.lockBurnCoins.Lock()
	mock.calls.BurnCoins = append(mock.calls.BurnCoins, callInfo)
	mock.lockBurnCoins.Unlock()
	return mock.BurnCoinsFunc(ctx, moduleName, amt)
}

// BurnCoinsCalls gets all the calls that were made to BurnCoins.
// Check the length with:
//
//	len(mockedBankKeeper.BurnCoinsCalls())
func (mock *BankKeeperMock) BurnCoinsCalls() []struct {
	Ctx        cosmossdktypes.Context
	ModuleName string
	Amt        cosmossdktypes.Coins
} {
	var calls []struct {
		Ctx        cosmossdktypes.Context
		ModuleName string
		Amt        cosmossdktypes.Coins
	}
	mock.lockBurnCoins.RLock()
	calls = mock.calls.BurnCoins
	mock.lockBurnCoins.RUnlock()
	return calls
}

// GetAllBalances calls GetAllBalancesFunc.
func (mock *BankKeeperMock) GetAllBalances(ctx cosmossdktypes.Context, addr cosmossdktypes.AccAddress) cosmossdktypes.Coins {
	if mock.GetAllBalancesFunc == nil {
		panic("BankKeeperMock.GetAllBalancesFunc: method is nil but BankKeeper.GetAllBalances was just called")
	}
	callInfo := struct {
		Ctx  cosmossdktypes.Context
		Addr cosmossdktypes.AccAddress
	}{
		Ctx:  ctx,
		Addr: addr,
	}
	mock.lockGetAllBalances.Lock()
	mock.calls.GetAllBalances = append(mock.calls.GetAllBalances, callInfo)
	mock.lockGetAllBalances.Unlock()
	return mock.GetAllBalancesFunc(ctx, addr)
}

// GetAllBalancesCalls gets all the calls that were made to GetAllBalances.
// Check the length with:
//
//	len(mockedBankKeeper.GetAllBalancesCalls())
func (mock *BankKeeperMock) GetAllBalancesCalls() []struct {
	Ctx  cosmossdktypes.Context
	Addr cosmossdktypes.AccAddress
} {
	var calls []struct {
		Ctx  cosmossdktypes.Context
		Addr cosmossdktypes.AccAddress
	}
	mock.lockGetAllBalances.RLock()
	calls = mock.calls.GetAllBalances
	mock.lockGetAllBalances.RUnlock()
	return calls
}

// MintCoins calls MintCoinsFunc.
func (mock *BankKeeperMock) MintCoins(ctx cosmossdktypes.Context, moduleName string, amt cosmossdktypes.Coins) error {
	if mock.MintCoinsFunc == nil {
		panic("BankKeeperMock.MintCoinsFunc: method is nil but BankKeeper.MintCoins was just called")
	}
	callInfo := struct {
		Ctx        cosmossdktypes.Context
		ModuleName string
		Amt        cosmossdktypes.Coins
	}{
		Ctx:        ctx,
		ModuleName: moduleName,
		Amt:        amt,
	}
	mock.lockMintCoins.Lock()
	mock.calls.MintCoins = append(mock.calls.MintCoins, callInfo)
	mock.lockMintCoins.Unlock()
	return mock.MintCoinsFunc(ctx, moduleName, amt)
}

// MintCoinsCalls gets all the calls that were made to MintCoins.
// Check the length with:
//
//	len(mockedBankKeeper.MintCoinsCalls())
func (mock *BankKeeperMock) MintCoinsCalls() []struct {
	Ctx        cosmossdktypes.Context
	ModuleName string
	Amt        cosmossdktypes.Coins
} {
	var calls []struct {
		Ctx        cosmossdktypes.Context
		ModuleName string
		Amt        cosmossdktypes.Coins
	}
	mock.lockMintCoins.RLock()
	calls = mock.calls.MintCoins
	mock.lockMintCoins.RUnlock()
	return calls
}

// SendCoins calls SendCoinsFunc.
func (mock *BankKeeperMock) SendCoins(ctx cosmossdktypes.Context, fromAddr cosmossdktypes.AccAddress, toAddr cosmossdktypes.AccAddress, amt cosmossdktypes.Coins) error {
	if mock.SendCoinsFunc == nil {
		panic("BankKeeperMock.SendCoinsFunc: method is nil but BankKeeper.SendCoins was just called")
	}
	callInfo := struct {
		Ctx      cosmossdktypes.Context
		FromAddr cosmossdktypes.AccAddress
		ToAddr   cosmossdktypes.AccAddress
		Amt      cosmossdktypes.Coins
	}{
		Ctx:      ctx,
		FromAddr: fromAddr,
		ToAddr:   toAddr,
		Amt:      amt,
	}
	mock.lockSendCoins.Lock()
	mock.calls.SendCoins = append(mock.calls.SendCoins, callInfo)
	mock.lockSendCoins.Unlock()
	return mock.SendCoinsFunc(ctx, fromAddr, toAddr, amt)
}

// SendCoinsCalls gets all the calls that were made to SendCoins.
// Check the length with:
//
//	len(mockedBankKeeper.SendCoinsCalls())
func (mock *BankKeeperMock) SendCoinsCalls() []struct {
	Ctx      cosmossdktypes.Context
	FromAddr cosmossdktypes.AccAddress
	ToAddr   cosmossdktypes.AccAddress
	Amt      cosmossdktypes.Coins
} {
	var calls []struct {
		Ctx      cosmossdktypes.Context
		FromAddr cosmossdktypes.AccAddress
		ToAddr   cosmossdktypes.AccAddress
		Amt      cosmossdktypes.Coins
	}
	mock.lockSendCoins.RLock()
	calls = mock.calls.SendCoins
	mock.lockSendCoins.RUnlock()
	return calls
}

// SendCoinsFromAccountToModule calls SendCoinsFromAccountToModuleFunc.
func (mock *BankKeeperMock) SendCoinsFromAccountToModule(ctx cosmossdktypes.Context, senderAddr cosmossdktypes.AccAddress, recipientModule string, amt cosmossdktypes.Coins) error {
	if mock.SendCoinsFromAccountToModuleFunc == nil {
		panic("BankKeeperMock.SendCoinsFromAccountToModuleFunc: method is nil but BankKeeper.SendCoinsFromAccountToModule was just called")
	}
	callInfo := struct {
		Ctx             cosmossdktypes.Context
		SenderAddr      cosmossdktypes.AccAddress
		RecipientModule string
		Amt             cosmossdktypes.Coins
	}{
		Ctx:             ctx,
		SenderAddr:      senderAddr,
		RecipientModule: recipientModule,
		Amt:             amt,
	}
	mock.lockSendCoinsFromAccountToModule.Lock()
	mock.calls.SendCoinsFromAccountToModule = append(mock.calls.SendCoinsFromAccountToModule, callInfo)
	mock.lockSendCoinsFromAccountToModule.Unlock()
	return mock.SendCoinsFromAccountToModuleFunc(ctx, senderAddr, recipientModule, amt)
}

// SendCoinsFromAccountToModuleCalls gets all the calls that were made to SendCoinsFromAccountToModule.
// Check the length with:
//
//	len(mockedBankKeeper.SendCoinsFromAccountToModuleCalls())
func (mock *BankKeeperMock) SendCoinsFromAccountToModuleCalls() []struct {
	Ctx             cosmossdktypes.Context
	SenderAddr      cosmossdktypes.AccAddress
	RecipientModule string
	Amt             cosmossdktypes.Coins
} {
	var calls []struct {
		Ctx             cosmossdktypes.Context
		SenderAddr      cosmossdktypes.AccAddress
		RecipientModule string
		Amt             cosmossdktypes.Coins
	}
	mock.lockSendCoinsFromAccountToModule.RLock()
	calls = mock.calls.SendCoinsFromAccountToModule
	mock.lockSendCoinsFromAccountToModule.RUnlock()
	return calls
}

// SendCoinsFromModuleToAccount calls SendCoinsFromModuleToAccountFunc.
func (mock *BankKeeperMock) SendCoinsFromModuleToAccount(ctx cosmossdktypes.Context, senderModule string, recipientAddr cosmossdktypes.AccAddress, amt cosmossdktypes.Coins) error {
	if mock.SendCoinsFromModuleToAccountFunc == nil {
		panic("BankKeeperMock.SendCoinsFromModuleToAccountFunc: method is nil but BankKeeper.SendCoinsFromModuleToAccount was just called")
	}
	callInfo := struct {
		Ctx           cosmossdktypes.Context
		SenderModule  string
		RecipientAddr cosmossdktypes.AccAddress
		Amt           cosmossdktypes.Coins
	}{
		Ctx:           ctx,
		SenderModule:  senderModule,
		RecipientAddr: recipientAddr,
		Amt:           amt,
	}
	mock.lockSendCoinsFromModuleToAccount.Lock()
	mock.calls.SendCoinsFromModuleToAccount = append(mock.calls.SendCoinsFromModuleToAccount, callInfo)
	mock.lockSendCoinsFromModuleToAccount.Unlock()
	return mock.SendCoinsFromModuleToAccountFunc(ctx, senderModule, recipientAddr, amt)
}

// SendCoinsFromModuleToAccountCalls gets all the calls that were made to SendCoinsFromModuleToAccount.
// Check the length with:
//
//	len(mockedBankKeeper.SendCoinsFromModuleToAccountCalls())
func (mock *BankKeeperMock) SendCoinsFromModuleToAccountCalls() []struct {
	Ctx           cosmossdktypes.Context
	SenderModule  string
	RecipientAddr cosmossdktypes.AccAddress
	Amt           cosmossdktypes.Coins
} {
	var calls []struct {
		Ctx           cosmossdktypes.Context
		SenderModule  string
		RecipientAddr cosmossdktypes.AccAddress
		Amt           cosmossdktypes.Coins
	}
	mock.lockSendCoinsFromModuleToAccount.RLock()
	calls = mock.calls.SendCoinsFromModuleToAccount
	mock.lockSendCoinsFromModuleToAccount.RUnlock()
	return calls
}

// SendCoinsFromModuleToModule calls SendCoinsFromModuleToModuleFunc.
func (mock *BankKeeperMock) SendCoinsFromModuleToModule(ctx cosmossdktypes.Context, senderModule string, recipientModule string, amt cosmossdktypes.Coins) error {
	if mock.SendCoinsFromModuleToModuleFunc == nil {
		panic("BankKeeperMock.SendCoinsFromModuleToModuleFunc: method is nil but BankKeeper.SendCoinsFromModuleToModule was just called")
	}
	callInfo := struct {
		Ctx             cosmossdktypes.Context
		SenderModule    string
		RecipientModule string
		Amt             cosmossdktypes.Coins
	}{
		Ctx:             ctx,
		SenderModule:    senderModule,
		RecipientModule: recipientModule,
		Amt:             amt,
	}
	mock.lockSendCoinsFromModuleToModule.Lock()
	mock.calls.SendCoinsFromModuleToModule = append(mock.calls.SendCoinsFromModuleToModule, callInfo)
	mock.lockSendCoinsFromModuleToModule.Unlock()
	return mock.SendCoinsFromModuleToModuleFunc(ctx, senderModule, recipientModule, amt)
}

// SendCoinsFromModuleToModuleCalls gets all the calls that were made to SendCoinsFromModuleToModule.
// Check the length with:
//
//	len(mockedBankKeeper.SendCoinsFromModuleToModuleCalls())
func (mock *BankKeeperMock) SendCoinsFromModuleToModuleCalls() []struct {
	Ctx             cosmossdktypes.Context
	SenderModule    string
	RecipientModule string
	Amt             cosmossdktypes.Coins
} {
	var calls []struct {
		Ctx             cosmossdktypes.Context
		SenderModule    string
		RecipientModule string
		Amt             cosmossdktypes.Coins
	}
	mock.lockSendCoinsFromModuleToModule.RLock()
	calls = mock.calls.SendCoinsFromModuleToModule
	mock.lockSendCoinsFromModuleToModule.RUnlock()
	return calls
}
