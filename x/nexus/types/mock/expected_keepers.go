// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	utils "github.com/axelarnetwork/axelar-core/utils"
	evm "github.com/axelarnetwork/axelar-core/x/evm/types"
	exported "github.com/axelarnetwork/axelar-core/x/nexus/exported"
	"github.com/axelarnetwork/axelar-core/x/nexus/types"
	reward "github.com/axelarnetwork/axelar-core/x/reward/exported"
	snapshot "github.com/axelarnetwork/axelar-core/x/snapshot/exported"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	"github.com/tendermint/tendermint/libs/log"
	"sync"
)

// Ensure, that NexusMock does implement types.Nexus.
// If this is not the case, regenerate this file with moq.
var _ types.Nexus = &NexusMock{}

// NexusMock is a mock implementation of types.Nexus.
//
// 	func TestSomethingThatUsesNexus(t *testing.T) {
//
// 		// make and configure a mocked types.Nexus
// 		mockedNexus := &NexusMock{
// 			ActivateChainFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.Chain)  {
// 				panic("mock out the ActivateChain method")
// 			},
// 			AddChainMaintainerFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.Chain, validator github_com_cosmos_cosmos_sdk_types.ValAddress) error {
// 				panic("mock out the AddChainMaintainer method")
// 			},
// 			DeactivateChainFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.Chain)  {
// 				panic("mock out the DeactivateChain method")
// 			},
// 			ExportGenesisFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context) *types.GenesisState {
// 				panic("mock out the ExportGenesis method")
// 			},
// 			GetChainFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.ChainName) (exported.Chain, bool) {
// 				panic("mock out the GetChain method")
// 			},
// 			GetChainMaintainerStatesFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.Chain) []types.MaintainerState {
// 				panic("mock out the GetChainMaintainerStates method")
// 			},
// 			GetChainMaintainersFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.Chain) []github_com_cosmos_cosmos_sdk_types.ValAddress {
// 				panic("mock out the GetChainMaintainers method")
// 			},
// 			GetChainsFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context) []exported.Chain {
// 				panic("mock out the GetChains method")
// 			},
// 			GetFeeInfoFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.Chain, asset string) (exported.FeeInfo, bool) {
// 				panic("mock out the GetFeeInfo method")
// 			},
// 			GetParamsFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context) types.Params {
// 				panic("mock out the GetParams method")
// 			},
// 			InitGenesisFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, genState *types.GenesisState)  {
// 				panic("mock out the InitGenesis method")
// 			},
// 			IsChainActivatedFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.Chain) bool {
// 				panic("mock out the IsChainActivated method")
// 			},
// 			IsChainMaintainerFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.Chain, maintainer github_com_cosmos_cosmos_sdk_types.ValAddress) bool {
// 				panic("mock out the IsChainMaintainer method")
// 			},
// 			LinkAddressesFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, sender exported.CrossChainAddress, recipient exported.CrossChainAddress) error {
// 				panic("mock out the LinkAddresses method")
// 			},
// 			LoggerFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context) log.Logger {
// 				panic("mock out the Logger method")
// 			},
// 			RegisterFeeFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.Chain, feeInfo exported.FeeInfo) error {
// 				panic("mock out the RegisterFee method")
// 			},
// 			RemoveChainMaintainerFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.Chain, validator github_com_cosmos_cosmos_sdk_types.ValAddress) error {
// 				panic("mock out the RemoveChainMaintainer method")
// 			},
// 			SetParamsFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, p types.Params)  {
// 				panic("mock out the SetParams method")
// 			},
// 		}
//
// 		// use mockedNexus in code that requires types.Nexus
// 		// and then make assertions.
//
// 	}
type NexusMock struct {
	// ActivateChainFunc mocks the ActivateChain method.
	ActivateChainFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.Chain)

	// AddChainMaintainerFunc mocks the AddChainMaintainer method.
	AddChainMaintainerFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.Chain, validator github_com_cosmos_cosmos_sdk_types.ValAddress) error

	// DeactivateChainFunc mocks the DeactivateChain method.
	DeactivateChainFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.Chain)

	// ExportGenesisFunc mocks the ExportGenesis method.
	ExportGenesisFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context) *types.GenesisState

	// GetChainFunc mocks the GetChain method.
	GetChainFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.ChainName) (exported.Chain, bool)

	// GetChainMaintainerStatesFunc mocks the GetChainMaintainerStates method.
	GetChainMaintainerStatesFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.Chain) []types.MaintainerState

	// GetChainMaintainersFunc mocks the GetChainMaintainers method.
	GetChainMaintainersFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.Chain) []github_com_cosmos_cosmos_sdk_types.ValAddress

	// GetChainsFunc mocks the GetChains method.
	GetChainsFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context) []exported.Chain

	// GetFeeInfoFunc mocks the GetFeeInfo method.
	GetFeeInfoFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.Chain, asset string) (exported.FeeInfo, bool)

	// GetParamsFunc mocks the GetParams method.
	GetParamsFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context) types.Params

	// InitGenesisFunc mocks the InitGenesis method.
	InitGenesisFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, genState *types.GenesisState)

	// IsChainActivatedFunc mocks the IsChainActivated method.
	IsChainActivatedFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.Chain) bool

	// IsChainMaintainerFunc mocks the IsChainMaintainer method.
	IsChainMaintainerFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.Chain, maintainer github_com_cosmos_cosmos_sdk_types.ValAddress) bool

	// LinkAddressesFunc mocks the LinkAddresses method.
	LinkAddressesFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, sender exported.CrossChainAddress, recipient exported.CrossChainAddress) error

	// LoggerFunc mocks the Logger method.
	LoggerFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context) log.Logger

	// RegisterFeeFunc mocks the RegisterFee method.
	RegisterFeeFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.Chain, feeInfo exported.FeeInfo) error

	// RemoveChainMaintainerFunc mocks the RemoveChainMaintainer method.
	RemoveChainMaintainerFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.Chain, validator github_com_cosmos_cosmos_sdk_types.ValAddress) error

	// SetParamsFunc mocks the SetParams method.
	SetParamsFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, p types.Params)

	// calls tracks calls to the methods.
	calls struct {
		// ActivateChain holds details about calls to the ActivateChain method.
		ActivateChain []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Chain is the chain argument value.
			Chain exported.Chain
		}
		// AddChainMaintainer holds details about calls to the AddChainMaintainer method.
		AddChainMaintainer []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Chain is the chain argument value.
			Chain exported.Chain
			// Validator is the validator argument value.
			Validator github_com_cosmos_cosmos_sdk_types.ValAddress
		}
		// DeactivateChain holds details about calls to the DeactivateChain method.
		DeactivateChain []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Chain is the chain argument value.
			Chain exported.Chain
		}
		// ExportGenesis holds details about calls to the ExportGenesis method.
		ExportGenesis []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
		}
		// GetChain holds details about calls to the GetChain method.
		GetChain []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Chain is the chain argument value.
			Chain exported.ChainName
		}
		// GetChainMaintainerStates holds details about calls to the GetChainMaintainerStates method.
		GetChainMaintainerStates []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Chain is the chain argument value.
			Chain exported.Chain
		}
		// GetChainMaintainers holds details about calls to the GetChainMaintainers method.
		GetChainMaintainers []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Chain is the chain argument value.
			Chain exported.Chain
		}
		// GetChains holds details about calls to the GetChains method.
		GetChains []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
		}
		// GetFeeInfo holds details about calls to the GetFeeInfo method.
		GetFeeInfo []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Chain is the chain argument value.
			Chain exported.Chain
			// Asset is the asset argument value.
			Asset string
		}
		// GetParams holds details about calls to the GetParams method.
		GetParams []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
		}
		// InitGenesis holds details about calls to the InitGenesis method.
		InitGenesis []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// GenState is the genState argument value.
			GenState *types.GenesisState
		}
		// IsChainActivated holds details about calls to the IsChainActivated method.
		IsChainActivated []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Chain is the chain argument value.
			Chain exported.Chain
		}
		// IsChainMaintainer holds details about calls to the IsChainMaintainer method.
		IsChainMaintainer []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Chain is the chain argument value.
			Chain exported.Chain
			// Maintainer is the maintainer argument value.
			Maintainer github_com_cosmos_cosmos_sdk_types.ValAddress
		}
		// LinkAddresses holds details about calls to the LinkAddresses method.
		LinkAddresses []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Sender is the sender argument value.
			Sender exported.CrossChainAddress
			// Recipient is the recipient argument value.
			Recipient exported.CrossChainAddress
		}
		// Logger holds details about calls to the Logger method.
		Logger []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
		}
		// RegisterFee holds details about calls to the RegisterFee method.
		RegisterFee []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Chain is the chain argument value.
			Chain exported.Chain
			// FeeInfo is the feeInfo argument value.
			FeeInfo exported.FeeInfo
		}
		// RemoveChainMaintainer holds details about calls to the RemoveChainMaintainer method.
		RemoveChainMaintainer []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Chain is the chain argument value.
			Chain exported.Chain
			// Validator is the validator argument value.
			Validator github_com_cosmos_cosmos_sdk_types.ValAddress
		}
		// SetParams holds details about calls to the SetParams method.
		SetParams []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// P is the p argument value.
			P types.Params
		}
	}
	lockActivateChain            sync.RWMutex
	lockAddChainMaintainer       sync.RWMutex
	lockDeactivateChain          sync.RWMutex
	lockExportGenesis            sync.RWMutex
	lockGetChain                 sync.RWMutex
	lockGetChainMaintainerStates sync.RWMutex
	lockGetChainMaintainers      sync.RWMutex
	lockGetChains                sync.RWMutex
	lockGetFeeInfo               sync.RWMutex
	lockGetParams                sync.RWMutex
	lockInitGenesis              sync.RWMutex
	lockIsChainActivated         sync.RWMutex
	lockIsChainMaintainer        sync.RWMutex
	lockLinkAddresses            sync.RWMutex
	lockLogger                   sync.RWMutex
	lockRegisterFee              sync.RWMutex
	lockRemoveChainMaintainer    sync.RWMutex
	lockSetParams                sync.RWMutex
}

// ActivateChain calls ActivateChainFunc.
func (mock *NexusMock) ActivateChain(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.Chain) {
	if mock.ActivateChainFunc == nil {
		panic("NexusMock.ActivateChainFunc: method is nil but Nexus.ActivateChain was just called")
	}
	callInfo := struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain exported.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockActivateChain.Lock()
	mock.calls.ActivateChain = append(mock.calls.ActivateChain, callInfo)
	mock.lockActivateChain.Unlock()
	mock.ActivateChainFunc(ctx, chain)
}

// ActivateChainCalls gets all the calls that were made to ActivateChain.
// Check the length with:
//     len(mockedNexus.ActivateChainCalls())
func (mock *NexusMock) ActivateChainCalls() []struct {
	Ctx   github_com_cosmos_cosmos_sdk_types.Context
	Chain exported.Chain
} {
	var calls []struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain exported.Chain
	}
	mock.lockActivateChain.RLock()
	calls = mock.calls.ActivateChain
	mock.lockActivateChain.RUnlock()
	return calls
}

// AddChainMaintainer calls AddChainMaintainerFunc.
func (mock *NexusMock) AddChainMaintainer(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.Chain, validator github_com_cosmos_cosmos_sdk_types.ValAddress) error {
	if mock.AddChainMaintainerFunc == nil {
		panic("NexusMock.AddChainMaintainerFunc: method is nil but Nexus.AddChainMaintainer was just called")
	}
	callInfo := struct {
		Ctx       github_com_cosmos_cosmos_sdk_types.Context
		Chain     exported.Chain
		Validator github_com_cosmos_cosmos_sdk_types.ValAddress
	}{
		Ctx:       ctx,
		Chain:     chain,
		Validator: validator,
	}
	mock.lockAddChainMaintainer.Lock()
	mock.calls.AddChainMaintainer = append(mock.calls.AddChainMaintainer, callInfo)
	mock.lockAddChainMaintainer.Unlock()
	return mock.AddChainMaintainerFunc(ctx, chain, validator)
}

// AddChainMaintainerCalls gets all the calls that were made to AddChainMaintainer.
// Check the length with:
//     len(mockedNexus.AddChainMaintainerCalls())
func (mock *NexusMock) AddChainMaintainerCalls() []struct {
	Ctx       github_com_cosmos_cosmos_sdk_types.Context
	Chain     exported.Chain
	Validator github_com_cosmos_cosmos_sdk_types.ValAddress
} {
	var calls []struct {
		Ctx       github_com_cosmos_cosmos_sdk_types.Context
		Chain     exported.Chain
		Validator github_com_cosmos_cosmos_sdk_types.ValAddress
	}
	mock.lockAddChainMaintainer.RLock()
	calls = mock.calls.AddChainMaintainer
	mock.lockAddChainMaintainer.RUnlock()
	return calls
}

// DeactivateChain calls DeactivateChainFunc.
func (mock *NexusMock) DeactivateChain(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.Chain) {
	if mock.DeactivateChainFunc == nil {
		panic("NexusMock.DeactivateChainFunc: method is nil but Nexus.DeactivateChain was just called")
	}
	callInfo := struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain exported.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockDeactivateChain.Lock()
	mock.calls.DeactivateChain = append(mock.calls.DeactivateChain, callInfo)
	mock.lockDeactivateChain.Unlock()
	mock.DeactivateChainFunc(ctx, chain)
}

// DeactivateChainCalls gets all the calls that were made to DeactivateChain.
// Check the length with:
//     len(mockedNexus.DeactivateChainCalls())
func (mock *NexusMock) DeactivateChainCalls() []struct {
	Ctx   github_com_cosmos_cosmos_sdk_types.Context
	Chain exported.Chain
} {
	var calls []struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain exported.Chain
	}
	mock.lockDeactivateChain.RLock()
	calls = mock.calls.DeactivateChain
	mock.lockDeactivateChain.RUnlock()
	return calls
}

// ExportGenesis calls ExportGenesisFunc.
func (mock *NexusMock) ExportGenesis(ctx github_com_cosmos_cosmos_sdk_types.Context) *types.GenesisState {
	if mock.ExportGenesisFunc == nil {
		panic("NexusMock.ExportGenesisFunc: method is nil but Nexus.ExportGenesis was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}{
		Ctx: ctx,
	}
	mock.lockExportGenesis.Lock()
	mock.calls.ExportGenesis = append(mock.calls.ExportGenesis, callInfo)
	mock.lockExportGenesis.Unlock()
	return mock.ExportGenesisFunc(ctx)
}

// ExportGenesisCalls gets all the calls that were made to ExportGenesis.
// Check the length with:
//     len(mockedNexus.ExportGenesisCalls())
func (mock *NexusMock) ExportGenesisCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}
	mock.lockExportGenesis.RLock()
	calls = mock.calls.ExportGenesis
	mock.lockExportGenesis.RUnlock()
	return calls
}

// GetChain calls GetChainFunc.
func (mock *NexusMock) GetChain(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.ChainName) (exported.Chain, bool) {
	if mock.GetChainFunc == nil {
		panic("NexusMock.GetChainFunc: method is nil but Nexus.GetChain was just called")
	}
	callInfo := struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain exported.ChainName
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockGetChain.Lock()
	mock.calls.GetChain = append(mock.calls.GetChain, callInfo)
	mock.lockGetChain.Unlock()
	return mock.GetChainFunc(ctx, chain)
}

// GetChainCalls gets all the calls that were made to GetChain.
// Check the length with:
//     len(mockedNexus.GetChainCalls())
func (mock *NexusMock) GetChainCalls() []struct {
	Ctx   github_com_cosmos_cosmos_sdk_types.Context
	Chain exported.ChainName
} {
	var calls []struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain exported.ChainName
	}
	mock.lockGetChain.RLock()
	calls = mock.calls.GetChain
	mock.lockGetChain.RUnlock()
	return calls
}

// GetChainMaintainerStates calls GetChainMaintainerStatesFunc.
func (mock *NexusMock) GetChainMaintainerStates(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.Chain) []types.MaintainerState {
	if mock.GetChainMaintainerStatesFunc == nil {
		panic("NexusMock.GetChainMaintainerStatesFunc: method is nil but Nexus.GetChainMaintainerStates was just called")
	}
	callInfo := struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain exported.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockGetChainMaintainerStates.Lock()
	mock.calls.GetChainMaintainerStates = append(mock.calls.GetChainMaintainerStates, callInfo)
	mock.lockGetChainMaintainerStates.Unlock()
	return mock.GetChainMaintainerStatesFunc(ctx, chain)
}

// GetChainMaintainerStatesCalls gets all the calls that were made to GetChainMaintainerStates.
// Check the length with:
//     len(mockedNexus.GetChainMaintainerStatesCalls())
func (mock *NexusMock) GetChainMaintainerStatesCalls() []struct {
	Ctx   github_com_cosmos_cosmos_sdk_types.Context
	Chain exported.Chain
} {
	var calls []struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain exported.Chain
	}
	mock.lockGetChainMaintainerStates.RLock()
	calls = mock.calls.GetChainMaintainerStates
	mock.lockGetChainMaintainerStates.RUnlock()
	return calls
}

// GetChainMaintainers calls GetChainMaintainersFunc.
func (mock *NexusMock) GetChainMaintainers(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.Chain) []github_com_cosmos_cosmos_sdk_types.ValAddress {
	if mock.GetChainMaintainersFunc == nil {
		panic("NexusMock.GetChainMaintainersFunc: method is nil but Nexus.GetChainMaintainers was just called")
	}
	callInfo := struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain exported.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockGetChainMaintainers.Lock()
	mock.calls.GetChainMaintainers = append(mock.calls.GetChainMaintainers, callInfo)
	mock.lockGetChainMaintainers.Unlock()
	return mock.GetChainMaintainersFunc(ctx, chain)
}

// GetChainMaintainersCalls gets all the calls that were made to GetChainMaintainers.
// Check the length with:
//     len(mockedNexus.GetChainMaintainersCalls())
func (mock *NexusMock) GetChainMaintainersCalls() []struct {
	Ctx   github_com_cosmos_cosmos_sdk_types.Context
	Chain exported.Chain
} {
	var calls []struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain exported.Chain
	}
	mock.lockGetChainMaintainers.RLock()
	calls = mock.calls.GetChainMaintainers
	mock.lockGetChainMaintainers.RUnlock()
	return calls
}

// GetChains calls GetChainsFunc.
func (mock *NexusMock) GetChains(ctx github_com_cosmos_cosmos_sdk_types.Context) []exported.Chain {
	if mock.GetChainsFunc == nil {
		panic("NexusMock.GetChainsFunc: method is nil but Nexus.GetChains was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetChains.Lock()
	mock.calls.GetChains = append(mock.calls.GetChains, callInfo)
	mock.lockGetChains.Unlock()
	return mock.GetChainsFunc(ctx)
}

// GetChainsCalls gets all the calls that were made to GetChains.
// Check the length with:
//     len(mockedNexus.GetChainsCalls())
func (mock *NexusMock) GetChainsCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}
	mock.lockGetChains.RLock()
	calls = mock.calls.GetChains
	mock.lockGetChains.RUnlock()
	return calls
}

// GetFeeInfo calls GetFeeInfoFunc.
func (mock *NexusMock) GetFeeInfo(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.Chain, asset string) (exported.FeeInfo, bool) {
	if mock.GetFeeInfoFunc == nil {
		panic("NexusMock.GetFeeInfoFunc: method is nil but Nexus.GetFeeInfo was just called")
	}
	callInfo := struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain exported.Chain
		Asset string
	}{
		Ctx:   ctx,
		Chain: chain,
		Asset: asset,
	}
	mock.lockGetFeeInfo.Lock()
	mock.calls.GetFeeInfo = append(mock.calls.GetFeeInfo, callInfo)
	mock.lockGetFeeInfo.Unlock()
	return mock.GetFeeInfoFunc(ctx, chain, asset)
}

// GetFeeInfoCalls gets all the calls that were made to GetFeeInfo.
// Check the length with:
//     len(mockedNexus.GetFeeInfoCalls())
func (mock *NexusMock) GetFeeInfoCalls() []struct {
	Ctx   github_com_cosmos_cosmos_sdk_types.Context
	Chain exported.Chain
	Asset string
} {
	var calls []struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain exported.Chain
		Asset string
	}
	mock.lockGetFeeInfo.RLock()
	calls = mock.calls.GetFeeInfo
	mock.lockGetFeeInfo.RUnlock()
	return calls
}

// GetParams calls GetParamsFunc.
func (mock *NexusMock) GetParams(ctx github_com_cosmos_cosmos_sdk_types.Context) types.Params {
	if mock.GetParamsFunc == nil {
		panic("NexusMock.GetParamsFunc: method is nil but Nexus.GetParams was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetParams.Lock()
	mock.calls.GetParams = append(mock.calls.GetParams, callInfo)
	mock.lockGetParams.Unlock()
	return mock.GetParamsFunc(ctx)
}

// GetParamsCalls gets all the calls that were made to GetParams.
// Check the length with:
//     len(mockedNexus.GetParamsCalls())
func (mock *NexusMock) GetParamsCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}
	mock.lockGetParams.RLock()
	calls = mock.calls.GetParams
	mock.lockGetParams.RUnlock()
	return calls
}

// InitGenesis calls InitGenesisFunc.
func (mock *NexusMock) InitGenesis(ctx github_com_cosmos_cosmos_sdk_types.Context, genState *types.GenesisState) {
	if mock.InitGenesisFunc == nil {
		panic("NexusMock.InitGenesisFunc: method is nil but Nexus.InitGenesis was just called")
	}
	callInfo := struct {
		Ctx      github_com_cosmos_cosmos_sdk_types.Context
		GenState *types.GenesisState
	}{
		Ctx:      ctx,
		GenState: genState,
	}
	mock.lockInitGenesis.Lock()
	mock.calls.InitGenesis = append(mock.calls.InitGenesis, callInfo)
	mock.lockInitGenesis.Unlock()
	mock.InitGenesisFunc(ctx, genState)
}

// InitGenesisCalls gets all the calls that were made to InitGenesis.
// Check the length with:
//     len(mockedNexus.InitGenesisCalls())
func (mock *NexusMock) InitGenesisCalls() []struct {
	Ctx      github_com_cosmos_cosmos_sdk_types.Context
	GenState *types.GenesisState
} {
	var calls []struct {
		Ctx      github_com_cosmos_cosmos_sdk_types.Context
		GenState *types.GenesisState
	}
	mock.lockInitGenesis.RLock()
	calls = mock.calls.InitGenesis
	mock.lockInitGenesis.RUnlock()
	return calls
}

// IsChainActivated calls IsChainActivatedFunc.
func (mock *NexusMock) IsChainActivated(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.Chain) bool {
	if mock.IsChainActivatedFunc == nil {
		panic("NexusMock.IsChainActivatedFunc: method is nil but Nexus.IsChainActivated was just called")
	}
	callInfo := struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain exported.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockIsChainActivated.Lock()
	mock.calls.IsChainActivated = append(mock.calls.IsChainActivated, callInfo)
	mock.lockIsChainActivated.Unlock()
	return mock.IsChainActivatedFunc(ctx, chain)
}

// IsChainActivatedCalls gets all the calls that were made to IsChainActivated.
// Check the length with:
//     len(mockedNexus.IsChainActivatedCalls())
func (mock *NexusMock) IsChainActivatedCalls() []struct {
	Ctx   github_com_cosmos_cosmos_sdk_types.Context
	Chain exported.Chain
} {
	var calls []struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain exported.Chain
	}
	mock.lockIsChainActivated.RLock()
	calls = mock.calls.IsChainActivated
	mock.lockIsChainActivated.RUnlock()
	return calls
}

// IsChainMaintainer calls IsChainMaintainerFunc.
func (mock *NexusMock) IsChainMaintainer(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.Chain, maintainer github_com_cosmos_cosmos_sdk_types.ValAddress) bool {
	if mock.IsChainMaintainerFunc == nil {
		panic("NexusMock.IsChainMaintainerFunc: method is nil but Nexus.IsChainMaintainer was just called")
	}
	callInfo := struct {
		Ctx        github_com_cosmos_cosmos_sdk_types.Context
		Chain      exported.Chain
		Maintainer github_com_cosmos_cosmos_sdk_types.ValAddress
	}{
		Ctx:        ctx,
		Chain:      chain,
		Maintainer: maintainer,
	}
	mock.lockIsChainMaintainer.Lock()
	mock.calls.IsChainMaintainer = append(mock.calls.IsChainMaintainer, callInfo)
	mock.lockIsChainMaintainer.Unlock()
	return mock.IsChainMaintainerFunc(ctx, chain, maintainer)
}

// IsChainMaintainerCalls gets all the calls that were made to IsChainMaintainer.
// Check the length with:
//     len(mockedNexus.IsChainMaintainerCalls())
func (mock *NexusMock) IsChainMaintainerCalls() []struct {
	Ctx        github_com_cosmos_cosmos_sdk_types.Context
	Chain      exported.Chain
	Maintainer github_com_cosmos_cosmos_sdk_types.ValAddress
} {
	var calls []struct {
		Ctx        github_com_cosmos_cosmos_sdk_types.Context
		Chain      exported.Chain
		Maintainer github_com_cosmos_cosmos_sdk_types.ValAddress
	}
	mock.lockIsChainMaintainer.RLock()
	calls = mock.calls.IsChainMaintainer
	mock.lockIsChainMaintainer.RUnlock()
	return calls
}

// LinkAddresses calls LinkAddressesFunc.
func (mock *NexusMock) LinkAddresses(ctx github_com_cosmos_cosmos_sdk_types.Context, sender exported.CrossChainAddress, recipient exported.CrossChainAddress) error {
	if mock.LinkAddressesFunc == nil {
		panic("NexusMock.LinkAddressesFunc: method is nil but Nexus.LinkAddresses was just called")
	}
	callInfo := struct {
		Ctx       github_com_cosmos_cosmos_sdk_types.Context
		Sender    exported.CrossChainAddress
		Recipient exported.CrossChainAddress
	}{
		Ctx:       ctx,
		Sender:    sender,
		Recipient: recipient,
	}
	mock.lockLinkAddresses.Lock()
	mock.calls.LinkAddresses = append(mock.calls.LinkAddresses, callInfo)
	mock.lockLinkAddresses.Unlock()
	return mock.LinkAddressesFunc(ctx, sender, recipient)
}

// LinkAddressesCalls gets all the calls that were made to LinkAddresses.
// Check the length with:
//     len(mockedNexus.LinkAddressesCalls())
func (mock *NexusMock) LinkAddressesCalls() []struct {
	Ctx       github_com_cosmos_cosmos_sdk_types.Context
	Sender    exported.CrossChainAddress
	Recipient exported.CrossChainAddress
} {
	var calls []struct {
		Ctx       github_com_cosmos_cosmos_sdk_types.Context
		Sender    exported.CrossChainAddress
		Recipient exported.CrossChainAddress
	}
	mock.lockLinkAddresses.RLock()
	calls = mock.calls.LinkAddresses
	mock.lockLinkAddresses.RUnlock()
	return calls
}

// Logger calls LoggerFunc.
func (mock *NexusMock) Logger(ctx github_com_cosmos_cosmos_sdk_types.Context) log.Logger {
	if mock.LoggerFunc == nil {
		panic("NexusMock.LoggerFunc: method is nil but Nexus.Logger was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}{
		Ctx: ctx,
	}
	mock.lockLogger.Lock()
	mock.calls.Logger = append(mock.calls.Logger, callInfo)
	mock.lockLogger.Unlock()
	return mock.LoggerFunc(ctx)
}

// LoggerCalls gets all the calls that were made to Logger.
// Check the length with:
//     len(mockedNexus.LoggerCalls())
func (mock *NexusMock) LoggerCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}
	mock.lockLogger.RLock()
	calls = mock.calls.Logger
	mock.lockLogger.RUnlock()
	return calls
}

// RegisterFee calls RegisterFeeFunc.
func (mock *NexusMock) RegisterFee(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.Chain, feeInfo exported.FeeInfo) error {
	if mock.RegisterFeeFunc == nil {
		panic("NexusMock.RegisterFeeFunc: method is nil but Nexus.RegisterFee was just called")
	}
	callInfo := struct {
		Ctx     github_com_cosmos_cosmos_sdk_types.Context
		Chain   exported.Chain
		FeeInfo exported.FeeInfo
	}{
		Ctx:     ctx,
		Chain:   chain,
		FeeInfo: feeInfo,
	}
	mock.lockRegisterFee.Lock()
	mock.calls.RegisterFee = append(mock.calls.RegisterFee, callInfo)
	mock.lockRegisterFee.Unlock()
	return mock.RegisterFeeFunc(ctx, chain, feeInfo)
}

// RegisterFeeCalls gets all the calls that were made to RegisterFee.
// Check the length with:
//     len(mockedNexus.RegisterFeeCalls())
func (mock *NexusMock) RegisterFeeCalls() []struct {
	Ctx     github_com_cosmos_cosmos_sdk_types.Context
	Chain   exported.Chain
	FeeInfo exported.FeeInfo
} {
	var calls []struct {
		Ctx     github_com_cosmos_cosmos_sdk_types.Context
		Chain   exported.Chain
		FeeInfo exported.FeeInfo
	}
	mock.lockRegisterFee.RLock()
	calls = mock.calls.RegisterFee
	mock.lockRegisterFee.RUnlock()
	return calls
}

// RemoveChainMaintainer calls RemoveChainMaintainerFunc.
func (mock *NexusMock) RemoveChainMaintainer(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.Chain, validator github_com_cosmos_cosmos_sdk_types.ValAddress) error {
	if mock.RemoveChainMaintainerFunc == nil {
		panic("NexusMock.RemoveChainMaintainerFunc: method is nil but Nexus.RemoveChainMaintainer was just called")
	}
	callInfo := struct {
		Ctx       github_com_cosmos_cosmos_sdk_types.Context
		Chain     exported.Chain
		Validator github_com_cosmos_cosmos_sdk_types.ValAddress
	}{
		Ctx:       ctx,
		Chain:     chain,
		Validator: validator,
	}
	mock.lockRemoveChainMaintainer.Lock()
	mock.calls.RemoveChainMaintainer = append(mock.calls.RemoveChainMaintainer, callInfo)
	mock.lockRemoveChainMaintainer.Unlock()
	return mock.RemoveChainMaintainerFunc(ctx, chain, validator)
}

// RemoveChainMaintainerCalls gets all the calls that were made to RemoveChainMaintainer.
// Check the length with:
//     len(mockedNexus.RemoveChainMaintainerCalls())
func (mock *NexusMock) RemoveChainMaintainerCalls() []struct {
	Ctx       github_com_cosmos_cosmos_sdk_types.Context
	Chain     exported.Chain
	Validator github_com_cosmos_cosmos_sdk_types.ValAddress
} {
	var calls []struct {
		Ctx       github_com_cosmos_cosmos_sdk_types.Context
		Chain     exported.Chain
		Validator github_com_cosmos_cosmos_sdk_types.ValAddress
	}
	mock.lockRemoveChainMaintainer.RLock()
	calls = mock.calls.RemoveChainMaintainer
	mock.lockRemoveChainMaintainer.RUnlock()
	return calls
}

// SetParams calls SetParamsFunc.
func (mock *NexusMock) SetParams(ctx github_com_cosmos_cosmos_sdk_types.Context, p types.Params) {
	if mock.SetParamsFunc == nil {
		panic("NexusMock.SetParamsFunc: method is nil but Nexus.SetParams was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
		P   types.Params
	}{
		Ctx: ctx,
		P:   p,
	}
	mock.lockSetParams.Lock()
	mock.calls.SetParams = append(mock.calls.SetParams, callInfo)
	mock.lockSetParams.Unlock()
	mock.SetParamsFunc(ctx, p)
}

// SetParamsCalls gets all the calls that were made to SetParams.
// Check the length with:
//     len(mockedNexus.SetParamsCalls())
func (mock *NexusMock) SetParamsCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
	P   types.Params
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
		P   types.Params
	}
	mock.lockSetParams.RLock()
	calls = mock.calls.SetParams
	mock.lockSetParams.RUnlock()
	return calls
}

// Ensure, that SnapshotterMock does implement types.Snapshotter.
// If this is not the case, regenerate this file with moq.
var _ types.Snapshotter = &SnapshotterMock{}

// SnapshotterMock is a mock implementation of types.Snapshotter.
//
// 	func TestSomethingThatUsesSnapshotter(t *testing.T) {
//
// 		// make and configure a mocked types.Snapshotter
// 		mockedSnapshotter := &SnapshotterMock{
// 			CreateSnapshotFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, candidates []github_com_cosmos_cosmos_sdk_types.ValAddress, filterFunc func(snapshot.ValidatorI) bool, weightFunc func(consensusPower github_com_cosmos_cosmos_sdk_types.Uint) github_com_cosmos_cosmos_sdk_types.Uint, threshold utils.Threshold) (snapshot.Snapshot, error) {
// 				panic("mock out the CreateSnapshot method")
// 			},
// 			GetOperatorFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, proxy github_com_cosmos_cosmos_sdk_types.AccAddress) github_com_cosmos_cosmos_sdk_types.ValAddress {
// 				panic("mock out the GetOperator method")
// 			},
// 			GetProxyFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, operator github_com_cosmos_cosmos_sdk_types.ValAddress) (github_com_cosmos_cosmos_sdk_types.AccAddress, bool) {
// 				panic("mock out the GetProxy method")
// 			},
// 		}
//
// 		// use mockedSnapshotter in code that requires types.Snapshotter
// 		// and then make assertions.
//
// 	}
type SnapshotterMock struct {
	// CreateSnapshotFunc mocks the CreateSnapshot method.
	CreateSnapshotFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, candidates []github_com_cosmos_cosmos_sdk_types.ValAddress, filterFunc func(snapshot.ValidatorI) bool, weightFunc func(consensusPower github_com_cosmos_cosmos_sdk_types.Uint) github_com_cosmos_cosmos_sdk_types.Uint, threshold utils.Threshold) (snapshot.Snapshot, error)

	// GetOperatorFunc mocks the GetOperator method.
	GetOperatorFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, proxy github_com_cosmos_cosmos_sdk_types.AccAddress) github_com_cosmos_cosmos_sdk_types.ValAddress

	// GetProxyFunc mocks the GetProxy method.
	GetProxyFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, operator github_com_cosmos_cosmos_sdk_types.ValAddress) (github_com_cosmos_cosmos_sdk_types.AccAddress, bool)

	// calls tracks calls to the methods.
	calls struct {
		// CreateSnapshot holds details about calls to the CreateSnapshot method.
		CreateSnapshot []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Candidates is the candidates argument value.
			Candidates []github_com_cosmos_cosmos_sdk_types.ValAddress
			// FilterFunc is the filterFunc argument value.
			FilterFunc func(snapshot.ValidatorI) bool
			// WeightFunc is the weightFunc argument value.
			WeightFunc func(consensusPower github_com_cosmos_cosmos_sdk_types.Uint) github_com_cosmos_cosmos_sdk_types.Uint
			// Threshold is the threshold argument value.
			Threshold utils.Threshold
		}
		// GetOperator holds details about calls to the GetOperator method.
		GetOperator []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Proxy is the proxy argument value.
			Proxy github_com_cosmos_cosmos_sdk_types.AccAddress
		}
		// GetProxy holds details about calls to the GetProxy method.
		GetProxy []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Operator is the operator argument value.
			Operator github_com_cosmos_cosmos_sdk_types.ValAddress
		}
	}
	lockCreateSnapshot sync.RWMutex
	lockGetOperator    sync.RWMutex
	lockGetProxy       sync.RWMutex
}

// CreateSnapshot calls CreateSnapshotFunc.
func (mock *SnapshotterMock) CreateSnapshot(ctx github_com_cosmos_cosmos_sdk_types.Context, candidates []github_com_cosmos_cosmos_sdk_types.ValAddress, filterFunc func(snapshot.ValidatorI) bool, weightFunc func(consensusPower github_com_cosmos_cosmos_sdk_types.Uint) github_com_cosmos_cosmos_sdk_types.Uint, threshold utils.Threshold) (snapshot.Snapshot, error) {
	if mock.CreateSnapshotFunc == nil {
		panic("SnapshotterMock.CreateSnapshotFunc: method is nil but Snapshotter.CreateSnapshot was just called")
	}
	callInfo := struct {
		Ctx        github_com_cosmos_cosmos_sdk_types.Context
		Candidates []github_com_cosmos_cosmos_sdk_types.ValAddress
		FilterFunc func(snapshot.ValidatorI) bool
		WeightFunc func(consensusPower github_com_cosmos_cosmos_sdk_types.Uint) github_com_cosmos_cosmos_sdk_types.Uint
		Threshold  utils.Threshold
	}{
		Ctx:        ctx,
		Candidates: candidates,
		FilterFunc: filterFunc,
		WeightFunc: weightFunc,
		Threshold:  threshold,
	}
	mock.lockCreateSnapshot.Lock()
	mock.calls.CreateSnapshot = append(mock.calls.CreateSnapshot, callInfo)
	mock.lockCreateSnapshot.Unlock()
	return mock.CreateSnapshotFunc(ctx, candidates, filterFunc, weightFunc, threshold)
}

// CreateSnapshotCalls gets all the calls that were made to CreateSnapshot.
// Check the length with:
//     len(mockedSnapshotter.CreateSnapshotCalls())
func (mock *SnapshotterMock) CreateSnapshotCalls() []struct {
	Ctx        github_com_cosmos_cosmos_sdk_types.Context
	Candidates []github_com_cosmos_cosmos_sdk_types.ValAddress
	FilterFunc func(snapshot.ValidatorI) bool
	WeightFunc func(consensusPower github_com_cosmos_cosmos_sdk_types.Uint) github_com_cosmos_cosmos_sdk_types.Uint
	Threshold  utils.Threshold
} {
	var calls []struct {
		Ctx        github_com_cosmos_cosmos_sdk_types.Context
		Candidates []github_com_cosmos_cosmos_sdk_types.ValAddress
		FilterFunc func(snapshot.ValidatorI) bool
		WeightFunc func(consensusPower github_com_cosmos_cosmos_sdk_types.Uint) github_com_cosmos_cosmos_sdk_types.Uint
		Threshold  utils.Threshold
	}
	mock.lockCreateSnapshot.RLock()
	calls = mock.calls.CreateSnapshot
	mock.lockCreateSnapshot.RUnlock()
	return calls
}

// GetOperator calls GetOperatorFunc.
func (mock *SnapshotterMock) GetOperator(ctx github_com_cosmos_cosmos_sdk_types.Context, proxy github_com_cosmos_cosmos_sdk_types.AccAddress) github_com_cosmos_cosmos_sdk_types.ValAddress {
	if mock.GetOperatorFunc == nil {
		panic("SnapshotterMock.GetOperatorFunc: method is nil but Snapshotter.GetOperator was just called")
	}
	callInfo := struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Proxy github_com_cosmos_cosmos_sdk_types.AccAddress
	}{
		Ctx:   ctx,
		Proxy: proxy,
	}
	mock.lockGetOperator.Lock()
	mock.calls.GetOperator = append(mock.calls.GetOperator, callInfo)
	mock.lockGetOperator.Unlock()
	return mock.GetOperatorFunc(ctx, proxy)
}

// GetOperatorCalls gets all the calls that were made to GetOperator.
// Check the length with:
//     len(mockedSnapshotter.GetOperatorCalls())
func (mock *SnapshotterMock) GetOperatorCalls() []struct {
	Ctx   github_com_cosmos_cosmos_sdk_types.Context
	Proxy github_com_cosmos_cosmos_sdk_types.AccAddress
} {
	var calls []struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Proxy github_com_cosmos_cosmos_sdk_types.AccAddress
	}
	mock.lockGetOperator.RLock()
	calls = mock.calls.GetOperator
	mock.lockGetOperator.RUnlock()
	return calls
}

// GetProxy calls GetProxyFunc.
func (mock *SnapshotterMock) GetProxy(ctx github_com_cosmos_cosmos_sdk_types.Context, operator github_com_cosmos_cosmos_sdk_types.ValAddress) (github_com_cosmos_cosmos_sdk_types.AccAddress, bool) {
	if mock.GetProxyFunc == nil {
		panic("SnapshotterMock.GetProxyFunc: method is nil but Snapshotter.GetProxy was just called")
	}
	callInfo := struct {
		Ctx      github_com_cosmos_cosmos_sdk_types.Context
		Operator github_com_cosmos_cosmos_sdk_types.ValAddress
	}{
		Ctx:      ctx,
		Operator: operator,
	}
	mock.lockGetProxy.Lock()
	mock.calls.GetProxy = append(mock.calls.GetProxy, callInfo)
	mock.lockGetProxy.Unlock()
	return mock.GetProxyFunc(ctx, operator)
}

// GetProxyCalls gets all the calls that were made to GetProxy.
// Check the length with:
//     len(mockedSnapshotter.GetProxyCalls())
func (mock *SnapshotterMock) GetProxyCalls() []struct {
	Ctx      github_com_cosmos_cosmos_sdk_types.Context
	Operator github_com_cosmos_cosmos_sdk_types.ValAddress
} {
	var calls []struct {
		Ctx      github_com_cosmos_cosmos_sdk_types.Context
		Operator github_com_cosmos_cosmos_sdk_types.ValAddress
	}
	mock.lockGetProxy.RLock()
	calls = mock.calls.GetProxy
	mock.lockGetProxy.RUnlock()
	return calls
}

// Ensure, that AxelarnetKeeperMock does implement types.AxelarnetKeeper.
// If this is not the case, regenerate this file with moq.
var _ types.AxelarnetKeeper = &AxelarnetKeeperMock{}

// AxelarnetKeeperMock is a mock implementation of types.AxelarnetKeeper.
//
// 	func TestSomethingThatUsesAxelarnetKeeper(t *testing.T) {
//
// 		// make and configure a mocked types.AxelarnetKeeper
// 		mockedAxelarnetKeeper := &AxelarnetKeeperMock{
// 			IsCosmosChainFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.ChainName) bool {
// 				panic("mock out the IsCosmosChain method")
// 			},
// 		}
//
// 		// use mockedAxelarnetKeeper in code that requires types.AxelarnetKeeper
// 		// and then make assertions.
//
// 	}
type AxelarnetKeeperMock struct {
	// IsCosmosChainFunc mocks the IsCosmosChain method.
	IsCosmosChainFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.ChainName) bool

	// calls tracks calls to the methods.
	calls struct {
		// IsCosmosChain holds details about calls to the IsCosmosChain method.
		IsCosmosChain []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Chain is the chain argument value.
			Chain exported.ChainName
		}
	}
	lockIsCosmosChain sync.RWMutex
}

// IsCosmosChain calls IsCosmosChainFunc.
func (mock *AxelarnetKeeperMock) IsCosmosChain(ctx github_com_cosmos_cosmos_sdk_types.Context, chain exported.ChainName) bool {
	if mock.IsCosmosChainFunc == nil {
		panic("AxelarnetKeeperMock.IsCosmosChainFunc: method is nil but AxelarnetKeeper.IsCosmosChain was just called")
	}
	callInfo := struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain exported.ChainName
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockIsCosmosChain.Lock()
	mock.calls.IsCosmosChain = append(mock.calls.IsCosmosChain, callInfo)
	mock.lockIsCosmosChain.Unlock()
	return mock.IsCosmosChainFunc(ctx, chain)
}

// IsCosmosChainCalls gets all the calls that were made to IsCosmosChain.
// Check the length with:
//     len(mockedAxelarnetKeeper.IsCosmosChainCalls())
func (mock *AxelarnetKeeperMock) IsCosmosChainCalls() []struct {
	Ctx   github_com_cosmos_cosmos_sdk_types.Context
	Chain exported.ChainName
} {
	var calls []struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain exported.ChainName
	}
	mock.lockIsCosmosChain.RLock()
	calls = mock.calls.IsCosmosChain
	mock.lockIsCosmosChain.RUnlock()
	return calls
}

// Ensure, that EVMBaseKeeperMock does implement types.EVMBaseKeeper.
// If this is not the case, regenerate this file with moq.
var _ types.EVMBaseKeeper = &EVMBaseKeeperMock{}

// EVMBaseKeeperMock is a mock implementation of types.EVMBaseKeeper.
//
// 	func TestSomethingThatUsesEVMBaseKeeper(t *testing.T) {
//
// 		// make and configure a mocked types.EVMBaseKeeper
// 		mockedEVMBaseKeeper := &EVMBaseKeeperMock{
// 			ForChainFunc: func(chain exported.ChainName) evm.ChainKeeper {
// 				panic("mock out the ForChain method")
// 			},
// 		}
//
// 		// use mockedEVMBaseKeeper in code that requires types.EVMBaseKeeper
// 		// and then make assertions.
//
// 	}
type EVMBaseKeeperMock struct {
	// ForChainFunc mocks the ForChain method.
	ForChainFunc func(chain exported.ChainName) evm.ChainKeeper

	// calls tracks calls to the methods.
	calls struct {
		// ForChain holds details about calls to the ForChain method.
		ForChain []struct {
			// Chain is the chain argument value.
			Chain exported.ChainName
		}
	}
	lockForChain sync.RWMutex
}

// ForChain calls ForChainFunc.
func (mock *EVMBaseKeeperMock) ForChain(chain exported.ChainName) evm.ChainKeeper {
	if mock.ForChainFunc == nil {
		panic("EVMBaseKeeperMock.ForChainFunc: method is nil but EVMBaseKeeper.ForChain was just called")
	}
	callInfo := struct {
		Chain exported.ChainName
	}{
		Chain: chain,
	}
	mock.lockForChain.Lock()
	mock.calls.ForChain = append(mock.calls.ForChain, callInfo)
	mock.lockForChain.Unlock()
	return mock.ForChainFunc(chain)
}

// ForChainCalls gets all the calls that were made to ForChain.
// Check the length with:
//     len(mockedEVMBaseKeeper.ForChainCalls())
func (mock *EVMBaseKeeperMock) ForChainCalls() []struct {
	Chain exported.ChainName
} {
	var calls []struct {
		Chain exported.ChainName
	}
	mock.lockForChain.RLock()
	calls = mock.calls.ForChain
	mock.lockForChain.RUnlock()
	return calls
}

// Ensure, that RewardKeeperMock does implement types.RewardKeeper.
// If this is not the case, regenerate this file with moq.
var _ types.RewardKeeper = &RewardKeeperMock{}

// RewardKeeperMock is a mock implementation of types.RewardKeeper.
//
// 	func TestSomethingThatUsesRewardKeeper(t *testing.T) {
//
// 		// make and configure a mocked types.RewardKeeper
// 		mockedRewardKeeper := &RewardKeeperMock{
// 			GetPoolFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, name string) reward.RewardPool {
// 				panic("mock out the GetPool method")
// 			},
// 		}
//
// 		// use mockedRewardKeeper in code that requires types.RewardKeeper
// 		// and then make assertions.
//
// 	}
type RewardKeeperMock struct {
	// GetPoolFunc mocks the GetPool method.
	GetPoolFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, name string) reward.RewardPool

	// calls tracks calls to the methods.
	calls struct {
		// GetPool holds details about calls to the GetPool method.
		GetPool []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Name is the name argument value.
			Name string
		}
	}
	lockGetPool sync.RWMutex
}

// GetPool calls GetPoolFunc.
func (mock *RewardKeeperMock) GetPool(ctx github_com_cosmos_cosmos_sdk_types.Context, name string) reward.RewardPool {
	if mock.GetPoolFunc == nil {
		panic("RewardKeeperMock.GetPoolFunc: method is nil but RewardKeeper.GetPool was just called")
	}
	callInfo := struct {
		Ctx  github_com_cosmos_cosmos_sdk_types.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockGetPool.Lock()
	mock.calls.GetPool = append(mock.calls.GetPool, callInfo)
	mock.lockGetPool.Unlock()
	return mock.GetPoolFunc(ctx, name)
}

// GetPoolCalls gets all the calls that were made to GetPool.
// Check the length with:
//     len(mockedRewardKeeper.GetPoolCalls())
func (mock *RewardKeeperMock) GetPoolCalls() []struct {
	Ctx  github_com_cosmos_cosmos_sdk_types.Context
	Name string
} {
	var calls []struct {
		Ctx  github_com_cosmos_cosmos_sdk_types.Context
		Name string
	}
	mock.lockGetPool.RLock()
	calls = mock.calls.GetPool
	mock.lockGetPool.RUnlock()
	return calls
}

// Ensure, that SlashingKeeperMock does implement types.SlashingKeeper.
// If this is not the case, regenerate this file with moq.
var _ types.SlashingKeeper = &SlashingKeeperMock{}

// SlashingKeeperMock is a mock implementation of types.SlashingKeeper.
//
// 	func TestSomethingThatUsesSlashingKeeper(t *testing.T) {
//
// 		// make and configure a mocked types.SlashingKeeper
// 		mockedSlashingKeeper := &SlashingKeeperMock{
// 			IsTombstonedFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, consAddr github_com_cosmos_cosmos_sdk_types.ConsAddress) bool {
// 				panic("mock out the IsTombstoned method")
// 			},
// 		}
//
// 		// use mockedSlashingKeeper in code that requires types.SlashingKeeper
// 		// and then make assertions.
//
// 	}
type SlashingKeeperMock struct {
	// IsTombstonedFunc mocks the IsTombstoned method.
	IsTombstonedFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, consAddr github_com_cosmos_cosmos_sdk_types.ConsAddress) bool

	// calls tracks calls to the methods.
	calls struct {
		// IsTombstoned holds details about calls to the IsTombstoned method.
		IsTombstoned []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// ConsAddr is the consAddr argument value.
			ConsAddr github_com_cosmos_cosmos_sdk_types.ConsAddress
		}
	}
	lockIsTombstoned sync.RWMutex
}

// IsTombstoned calls IsTombstonedFunc.
func (mock *SlashingKeeperMock) IsTombstoned(ctx github_com_cosmos_cosmos_sdk_types.Context, consAddr github_com_cosmos_cosmos_sdk_types.ConsAddress) bool {
	if mock.IsTombstonedFunc == nil {
		panic("SlashingKeeperMock.IsTombstonedFunc: method is nil but SlashingKeeper.IsTombstoned was just called")
	}
	callInfo := struct {
		Ctx      github_com_cosmos_cosmos_sdk_types.Context
		ConsAddr github_com_cosmos_cosmos_sdk_types.ConsAddress
	}{
		Ctx:      ctx,
		ConsAddr: consAddr,
	}
	mock.lockIsTombstoned.Lock()
	mock.calls.IsTombstoned = append(mock.calls.IsTombstoned, callInfo)
	mock.lockIsTombstoned.Unlock()
	return mock.IsTombstonedFunc(ctx, consAddr)
}

// IsTombstonedCalls gets all the calls that were made to IsTombstoned.
// Check the length with:
//     len(mockedSlashingKeeper.IsTombstonedCalls())
func (mock *SlashingKeeperMock) IsTombstonedCalls() []struct {
	Ctx      github_com_cosmos_cosmos_sdk_types.Context
	ConsAddr github_com_cosmos_cosmos_sdk_types.ConsAddress
} {
	var calls []struct {
		Ctx      github_com_cosmos_cosmos_sdk_types.Context
		ConsAddr github_com_cosmos_cosmos_sdk_types.ConsAddress
	}
	mock.lockIsTombstoned.RLock()
	calls = mock.calls.IsTombstoned
	mock.lockIsTombstoned.RUnlock()
	return calls
}
