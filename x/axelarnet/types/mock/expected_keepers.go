// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	axelarnettypes "github.com/axelarnetwork/axelar-core/x/axelarnet/types"
	exported "github.com/axelarnetwork/axelar-core/x/nexus/exported"
	cosmossdktypes "github.com/cosmos/cosmos-sdk/types"
	ibctypes "github.com/cosmos/ibc-go/modules/apps/transfer/types"
	clienttypes "github.com/cosmos/ibc-go/modules/core/02-client/types"
	ibcclient "github.com/cosmos/ibc-go/modules/core/exported"
	tmbytes "github.com/tendermint/tendermint/libs/bytes"
	"github.com/tendermint/tendermint/libs/log"
	"sync"
)

// Ensure, that BaseKeeperMock does implement axelarnettypes.BaseKeeper.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.BaseKeeper = &BaseKeeperMock{}

// BaseKeeperMock is a mock implementation of axelarnettypes.BaseKeeper.
//
// 	func TestSomethingThatUsesBaseKeeper(t *testing.T) {
//
// 		// make and configure a mocked axelarnettypes.BaseKeeper
// 		mockedBaseKeeper := &BaseKeeperMock{
// 			DeletePendingIBCTransferFunc: func(ctx cosmossdktypes.Context, portID string, channelID string, sequence uint64)  {
// 				panic("mock out the DeletePendingIBCTransfer method")
// 			},
// 			DeletePendingRefundFunc: func(ctx cosmossdktypes.Context, req axelarnettypes.RefundMsgRequest)  {
// 				panic("mock out the DeletePendingRefund method")
// 			},
// 			GetCosmosChainFunc: func(ctx cosmossdktypes.Context, asset string) (string, bool) {
// 				panic("mock out the GetCosmosChain method")
// 			},
// 			GetCosmosChainsFunc: func(ctx cosmossdktypes.Context) []string {
// 				panic("mock out the GetCosmosChains method")
// 			},
// 			GetFeeCollectorFunc: func(ctx cosmossdktypes.Context) (cosmossdktypes.AccAddress, bool) {
// 				panic("mock out the GetFeeCollector method")
// 			},
// 			GetIBCPathFunc: func(ctx cosmossdktypes.Context, chain string) (string, bool) {
// 				panic("mock out the GetIBCPath method")
// 			},
// 			GetPendingIBCTransferFunc: func(ctx cosmossdktypes.Context, portID string, channelID string, sequence uint64) (axelarnettypes.IBCTransfer, bool) {
// 				panic("mock out the GetPendingIBCTransfer method")
// 			},
// 			GetPendingRefundFunc: func(ctx cosmossdktypes.Context, req axelarnettypes.RefundMsgRequest) (cosmossdktypes.Coin, bool) {
// 				panic("mock out the GetPendingRefund method")
// 			},
// 			GetRouteTimeoutWindowFunc: func(ctx cosmossdktypes.Context) uint64 {
// 				panic("mock out the GetRouteTimeoutWindow method")
// 			},
// 			LoggerFunc: func(ctx cosmossdktypes.Context) log.Logger {
// 				panic("mock out the Logger method")
// 			},
// 			RegisterAssetToCosmosChainFunc: func(ctx cosmossdktypes.Context, asset string, chain string)  {
// 				panic("mock out the RegisterAssetToCosmosChain method")
// 			},
// 			RegisterIBCPathFunc: func(ctx cosmossdktypes.Context, asset string, path string) error {
// 				panic("mock out the RegisterIBCPath method")
// 			},
// 			SetFeeCollectorFunc: func(ctx cosmossdktypes.Context, address cosmossdktypes.AccAddress)  {
// 				panic("mock out the SetFeeCollector method")
// 			},
// 			SetParamsFunc: func(ctx cosmossdktypes.Context, n axelarnettypes.Nexus, p axelarnettypes.Params)  {
// 				panic("mock out the SetParams method")
// 			},
// 			SetPendingIBCTransferFunc: func(ctx cosmossdktypes.Context, portID string, channelID string, sequence uint64, value axelarnettypes.IBCTransfer)  {
// 				panic("mock out the SetPendingIBCTransfer method")
// 			},
// 		}
//
// 		// use mockedBaseKeeper in code that requires axelarnettypes.BaseKeeper
// 		// and then make assertions.
//
// 	}
type BaseKeeperMock struct {
	// DeletePendingIBCTransferFunc mocks the DeletePendingIBCTransfer method.
	DeletePendingIBCTransferFunc func(ctx cosmossdktypes.Context, portID string, channelID string, sequence uint64)

	// DeletePendingRefundFunc mocks the DeletePendingRefund method.
	DeletePendingRefundFunc func(ctx cosmossdktypes.Context, req axelarnettypes.RefundMsgRequest)

	// GetCosmosChainFunc mocks the GetCosmosChain method.
	GetCosmosChainFunc func(ctx cosmossdktypes.Context, asset string) (string, bool)

	// GetCosmosChainsFunc mocks the GetCosmosChains method.
	GetCosmosChainsFunc func(ctx cosmossdktypes.Context) []string

	// GetFeeCollectorFunc mocks the GetFeeCollector method.
	GetFeeCollectorFunc func(ctx cosmossdktypes.Context) (cosmossdktypes.AccAddress, bool)

	// GetIBCPathFunc mocks the GetIBCPath method.
	GetIBCPathFunc func(ctx cosmossdktypes.Context, chain string) (string, bool)

	// GetPendingIBCTransferFunc mocks the GetPendingIBCTransfer method.
	GetPendingIBCTransferFunc func(ctx cosmossdktypes.Context, portID string, channelID string, sequence uint64) (axelarnettypes.IBCTransfer, bool)

	// GetPendingRefundFunc mocks the GetPendingRefund method.
	GetPendingRefundFunc func(ctx cosmossdktypes.Context, req axelarnettypes.RefundMsgRequest) (cosmossdktypes.Coin, bool)

	// GetRouteTimeoutWindowFunc mocks the GetRouteTimeoutWindow method.
	GetRouteTimeoutWindowFunc func(ctx cosmossdktypes.Context) uint64

	// LoggerFunc mocks the Logger method.
	LoggerFunc func(ctx cosmossdktypes.Context) log.Logger

	// RegisterAssetToCosmosChainFunc mocks the RegisterAssetToCosmosChain method.
	RegisterAssetToCosmosChainFunc func(ctx cosmossdktypes.Context, asset string, chain string)

	// RegisterIBCPathFunc mocks the RegisterIBCPath method.
	RegisterIBCPathFunc func(ctx cosmossdktypes.Context, asset string, path string) error

	// SetFeeCollectorFunc mocks the SetFeeCollector method.
	SetFeeCollectorFunc func(ctx cosmossdktypes.Context, address cosmossdktypes.AccAddress)

	// SetParamsFunc mocks the SetParams method.
	SetParamsFunc func(ctx cosmossdktypes.Context, n axelarnettypes.Nexus, p axelarnettypes.Params)

	// SetPendingIBCTransferFunc mocks the SetPendingIBCTransfer method.
	SetPendingIBCTransferFunc func(ctx cosmossdktypes.Context, portID string, channelID string, sequence uint64, value axelarnettypes.IBCTransfer)

	// calls tracks calls to the methods.
	calls struct {
		// DeletePendingIBCTransfer holds details about calls to the DeletePendingIBCTransfer method.
		DeletePendingIBCTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// PortID is the portID argument value.
			PortID string
			// ChannelID is the channelID argument value.
			ChannelID string
			// Sequence is the sequence argument value.
			Sequence uint64
		}
		// DeletePendingRefund holds details about calls to the DeletePendingRefund method.
		DeletePendingRefund []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Req is the req argument value.
			Req axelarnettypes.RefundMsgRequest
		}
		// GetCosmosChain holds details about calls to the GetCosmosChain method.
		GetCosmosChain []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Asset is the asset argument value.
			Asset string
		}
		// GetCosmosChains holds details about calls to the GetCosmosChains method.
		GetCosmosChains []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// GetFeeCollector holds details about calls to the GetFeeCollector method.
		GetFeeCollector []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// GetIBCPath holds details about calls to the GetIBCPath method.
		GetIBCPath []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain string
		}
		// GetPendingIBCTransfer holds details about calls to the GetPendingIBCTransfer method.
		GetPendingIBCTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// PortID is the portID argument value.
			PortID string
			// ChannelID is the channelID argument value.
			ChannelID string
			// Sequence is the sequence argument value.
			Sequence uint64
		}
		// GetPendingRefund holds details about calls to the GetPendingRefund method.
		GetPendingRefund []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Req is the req argument value.
			Req axelarnettypes.RefundMsgRequest
		}
		// GetRouteTimeoutWindow holds details about calls to the GetRouteTimeoutWindow method.
		GetRouteTimeoutWindow []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// Logger holds details about calls to the Logger method.
		Logger []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// RegisterAssetToCosmosChain holds details about calls to the RegisterAssetToCosmosChain method.
		RegisterAssetToCosmosChain []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Asset is the asset argument value.
			Asset string
			// Chain is the chain argument value.
			Chain string
		}
		// RegisterIBCPath holds details about calls to the RegisterIBCPath method.
		RegisterIBCPath []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Asset is the asset argument value.
			Asset string
			// Path is the path argument value.
			Path string
		}
		// SetFeeCollector holds details about calls to the SetFeeCollector method.
		SetFeeCollector []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Address is the address argument value.
			Address cosmossdktypes.AccAddress
		}
		// SetParams holds details about calls to the SetParams method.
		SetParams []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// N is the n argument value.
			N axelarnettypes.Nexus
			// P is the p argument value.
			P axelarnettypes.Params
		}
		// SetPendingIBCTransfer holds details about calls to the SetPendingIBCTransfer method.
		SetPendingIBCTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// PortID is the portID argument value.
			PortID string
			// ChannelID is the channelID argument value.
			ChannelID string
			// Sequence is the sequence argument value.
			Sequence uint64
			// Value is the value argument value.
			Value axelarnettypes.IBCTransfer
		}
	}
	lockDeletePendingIBCTransfer   sync.RWMutex
	lockDeletePendingRefund        sync.RWMutex
	lockGetCosmosChain             sync.RWMutex
	lockGetCosmosChains            sync.RWMutex
	lockGetFeeCollector            sync.RWMutex
	lockGetIBCPath                 sync.RWMutex
	lockGetPendingIBCTransfer      sync.RWMutex
	lockGetPendingRefund           sync.RWMutex
	lockGetRouteTimeoutWindow      sync.RWMutex
	lockLogger                     sync.RWMutex
	lockRegisterAssetToCosmosChain sync.RWMutex
	lockRegisterIBCPath            sync.RWMutex
	lockSetFeeCollector            sync.RWMutex
	lockSetParams                  sync.RWMutex
	lockSetPendingIBCTransfer      sync.RWMutex
}

// DeletePendingIBCTransfer calls DeletePendingIBCTransferFunc.
func (mock *BaseKeeperMock) DeletePendingIBCTransfer(ctx cosmossdktypes.Context, portID string, channelID string, sequence uint64) {
	if mock.DeletePendingIBCTransferFunc == nil {
		panic("BaseKeeperMock.DeletePendingIBCTransferFunc: method is nil but BaseKeeper.DeletePendingIBCTransfer was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		PortID    string
		ChannelID string
		Sequence  uint64
	}{
		Ctx:       ctx,
		PortID:    portID,
		ChannelID: channelID,
		Sequence:  sequence,
	}
	mock.lockDeletePendingIBCTransfer.Lock()
	mock.calls.DeletePendingIBCTransfer = append(mock.calls.DeletePendingIBCTransfer, callInfo)
	mock.lockDeletePendingIBCTransfer.Unlock()
	mock.DeletePendingIBCTransferFunc(ctx, portID, channelID, sequence)
}

// DeletePendingIBCTransferCalls gets all the calls that were made to DeletePendingIBCTransfer.
// Check the length with:
//     len(mockedBaseKeeper.DeletePendingIBCTransferCalls())
func (mock *BaseKeeperMock) DeletePendingIBCTransferCalls() []struct {
	Ctx       cosmossdktypes.Context
	PortID    string
	ChannelID string
	Sequence  uint64
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		PortID    string
		ChannelID string
		Sequence  uint64
	}
	mock.lockDeletePendingIBCTransfer.RLock()
	calls = mock.calls.DeletePendingIBCTransfer
	mock.lockDeletePendingIBCTransfer.RUnlock()
	return calls
}

// DeletePendingRefund calls DeletePendingRefundFunc.
func (mock *BaseKeeperMock) DeletePendingRefund(ctx cosmossdktypes.Context, req axelarnettypes.RefundMsgRequest) {
	if mock.DeletePendingRefundFunc == nil {
		panic("BaseKeeperMock.DeletePendingRefundFunc: method is nil but BaseKeeper.DeletePendingRefund was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
		Req axelarnettypes.RefundMsgRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockDeletePendingRefund.Lock()
	mock.calls.DeletePendingRefund = append(mock.calls.DeletePendingRefund, callInfo)
	mock.lockDeletePendingRefund.Unlock()
	mock.DeletePendingRefundFunc(ctx, req)
}

// DeletePendingRefundCalls gets all the calls that were made to DeletePendingRefund.
// Check the length with:
//     len(mockedBaseKeeper.DeletePendingRefundCalls())
func (mock *BaseKeeperMock) DeletePendingRefundCalls() []struct {
	Ctx cosmossdktypes.Context
	Req axelarnettypes.RefundMsgRequest
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
		Req axelarnettypes.RefundMsgRequest
	}
	mock.lockDeletePendingRefund.RLock()
	calls = mock.calls.DeletePendingRefund
	mock.lockDeletePendingRefund.RUnlock()
	return calls
}

// GetCosmosChain calls GetCosmosChainFunc.
func (mock *BaseKeeperMock) GetCosmosChain(ctx cosmossdktypes.Context, asset string) (string, bool) {
	if mock.GetCosmosChainFunc == nil {
		panic("BaseKeeperMock.GetCosmosChainFunc: method is nil but BaseKeeper.GetCosmosChain was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Asset string
	}{
		Ctx:   ctx,
		Asset: asset,
	}
	mock.lockGetCosmosChain.Lock()
	mock.calls.GetCosmosChain = append(mock.calls.GetCosmosChain, callInfo)
	mock.lockGetCosmosChain.Unlock()
	return mock.GetCosmosChainFunc(ctx, asset)
}

// GetCosmosChainCalls gets all the calls that were made to GetCosmosChain.
// Check the length with:
//     len(mockedBaseKeeper.GetCosmosChainCalls())
func (mock *BaseKeeperMock) GetCosmosChainCalls() []struct {
	Ctx   cosmossdktypes.Context
	Asset string
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Asset string
	}
	mock.lockGetCosmosChain.RLock()
	calls = mock.calls.GetCosmosChain
	mock.lockGetCosmosChain.RUnlock()
	return calls
}

// GetCosmosChains calls GetCosmosChainsFunc.
func (mock *BaseKeeperMock) GetCosmosChains(ctx cosmossdktypes.Context) []string {
	if mock.GetCosmosChainsFunc == nil {
		panic("BaseKeeperMock.GetCosmosChainsFunc: method is nil but BaseKeeper.GetCosmosChains was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetCosmosChains.Lock()
	mock.calls.GetCosmosChains = append(mock.calls.GetCosmosChains, callInfo)
	mock.lockGetCosmosChains.Unlock()
	return mock.GetCosmosChainsFunc(ctx)
}

// GetCosmosChainsCalls gets all the calls that were made to GetCosmosChains.
// Check the length with:
//     len(mockedBaseKeeper.GetCosmosChainsCalls())
func (mock *BaseKeeperMock) GetCosmosChainsCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockGetCosmosChains.RLock()
	calls = mock.calls.GetCosmosChains
	mock.lockGetCosmosChains.RUnlock()
	return calls
}

// GetFeeCollector calls GetFeeCollectorFunc.
func (mock *BaseKeeperMock) GetFeeCollector(ctx cosmossdktypes.Context) (cosmossdktypes.AccAddress, bool) {
	if mock.GetFeeCollectorFunc == nil {
		panic("BaseKeeperMock.GetFeeCollectorFunc: method is nil but BaseKeeper.GetFeeCollector was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetFeeCollector.Lock()
	mock.calls.GetFeeCollector = append(mock.calls.GetFeeCollector, callInfo)
	mock.lockGetFeeCollector.Unlock()
	return mock.GetFeeCollectorFunc(ctx)
}

// GetFeeCollectorCalls gets all the calls that were made to GetFeeCollector.
// Check the length with:
//     len(mockedBaseKeeper.GetFeeCollectorCalls())
func (mock *BaseKeeperMock) GetFeeCollectorCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockGetFeeCollector.RLock()
	calls = mock.calls.GetFeeCollector
	mock.lockGetFeeCollector.RUnlock()
	return calls
}

// GetIBCPath calls GetIBCPathFunc.
func (mock *BaseKeeperMock) GetIBCPath(ctx cosmossdktypes.Context, chain string) (string, bool) {
	if mock.GetIBCPathFunc == nil {
		panic("BaseKeeperMock.GetIBCPathFunc: method is nil but BaseKeeper.GetIBCPath was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain string
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockGetIBCPath.Lock()
	mock.calls.GetIBCPath = append(mock.calls.GetIBCPath, callInfo)
	mock.lockGetIBCPath.Unlock()
	return mock.GetIBCPathFunc(ctx, chain)
}

// GetIBCPathCalls gets all the calls that were made to GetIBCPath.
// Check the length with:
//     len(mockedBaseKeeper.GetIBCPathCalls())
func (mock *BaseKeeperMock) GetIBCPathCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain string
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain string
	}
	mock.lockGetIBCPath.RLock()
	calls = mock.calls.GetIBCPath
	mock.lockGetIBCPath.RUnlock()
	return calls
}

// GetPendingIBCTransfer calls GetPendingIBCTransferFunc.
func (mock *BaseKeeperMock) GetPendingIBCTransfer(ctx cosmossdktypes.Context, portID string, channelID string, sequence uint64) (axelarnettypes.IBCTransfer, bool) {
	if mock.GetPendingIBCTransferFunc == nil {
		panic("BaseKeeperMock.GetPendingIBCTransferFunc: method is nil but BaseKeeper.GetPendingIBCTransfer was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		PortID    string
		ChannelID string
		Sequence  uint64
	}{
		Ctx:       ctx,
		PortID:    portID,
		ChannelID: channelID,
		Sequence:  sequence,
	}
	mock.lockGetPendingIBCTransfer.Lock()
	mock.calls.GetPendingIBCTransfer = append(mock.calls.GetPendingIBCTransfer, callInfo)
	mock.lockGetPendingIBCTransfer.Unlock()
	return mock.GetPendingIBCTransferFunc(ctx, portID, channelID, sequence)
}

// GetPendingIBCTransferCalls gets all the calls that were made to GetPendingIBCTransfer.
// Check the length with:
//     len(mockedBaseKeeper.GetPendingIBCTransferCalls())
func (mock *BaseKeeperMock) GetPendingIBCTransferCalls() []struct {
	Ctx       cosmossdktypes.Context
	PortID    string
	ChannelID string
	Sequence  uint64
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		PortID    string
		ChannelID string
		Sequence  uint64
	}
	mock.lockGetPendingIBCTransfer.RLock()
	calls = mock.calls.GetPendingIBCTransfer
	mock.lockGetPendingIBCTransfer.RUnlock()
	return calls
}

// GetPendingRefund calls GetPendingRefundFunc.
func (mock *BaseKeeperMock) GetPendingRefund(ctx cosmossdktypes.Context, req axelarnettypes.RefundMsgRequest) (cosmossdktypes.Coin, bool) {
	if mock.GetPendingRefundFunc == nil {
		panic("BaseKeeperMock.GetPendingRefundFunc: method is nil but BaseKeeper.GetPendingRefund was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
		Req axelarnettypes.RefundMsgRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockGetPendingRefund.Lock()
	mock.calls.GetPendingRefund = append(mock.calls.GetPendingRefund, callInfo)
	mock.lockGetPendingRefund.Unlock()
	return mock.GetPendingRefundFunc(ctx, req)
}

// GetPendingRefundCalls gets all the calls that were made to GetPendingRefund.
// Check the length with:
//     len(mockedBaseKeeper.GetPendingRefundCalls())
func (mock *BaseKeeperMock) GetPendingRefundCalls() []struct {
	Ctx cosmossdktypes.Context
	Req axelarnettypes.RefundMsgRequest
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
		Req axelarnettypes.RefundMsgRequest
	}
	mock.lockGetPendingRefund.RLock()
	calls = mock.calls.GetPendingRefund
	mock.lockGetPendingRefund.RUnlock()
	return calls
}

// GetRouteTimeoutWindow calls GetRouteTimeoutWindowFunc.
func (mock *BaseKeeperMock) GetRouteTimeoutWindow(ctx cosmossdktypes.Context) uint64 {
	if mock.GetRouteTimeoutWindowFunc == nil {
		panic("BaseKeeperMock.GetRouteTimeoutWindowFunc: method is nil but BaseKeeper.GetRouteTimeoutWindow was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetRouteTimeoutWindow.Lock()
	mock.calls.GetRouteTimeoutWindow = append(mock.calls.GetRouteTimeoutWindow, callInfo)
	mock.lockGetRouteTimeoutWindow.Unlock()
	return mock.GetRouteTimeoutWindowFunc(ctx)
}

// GetRouteTimeoutWindowCalls gets all the calls that were made to GetRouteTimeoutWindow.
// Check the length with:
//     len(mockedBaseKeeper.GetRouteTimeoutWindowCalls())
func (mock *BaseKeeperMock) GetRouteTimeoutWindowCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockGetRouteTimeoutWindow.RLock()
	calls = mock.calls.GetRouteTimeoutWindow
	mock.lockGetRouteTimeoutWindow.RUnlock()
	return calls
}

// Logger calls LoggerFunc.
func (mock *BaseKeeperMock) Logger(ctx cosmossdktypes.Context) log.Logger {
	if mock.LoggerFunc == nil {
		panic("BaseKeeperMock.LoggerFunc: method is nil but BaseKeeper.Logger was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockLogger.Lock()
	mock.calls.Logger = append(mock.calls.Logger, callInfo)
	mock.lockLogger.Unlock()
	return mock.LoggerFunc(ctx)
}

// LoggerCalls gets all the calls that were made to Logger.
// Check the length with:
//     len(mockedBaseKeeper.LoggerCalls())
func (mock *BaseKeeperMock) LoggerCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockLogger.RLock()
	calls = mock.calls.Logger
	mock.lockLogger.RUnlock()
	return calls
}

// RegisterAssetToCosmosChain calls RegisterAssetToCosmosChainFunc.
func (mock *BaseKeeperMock) RegisterAssetToCosmosChain(ctx cosmossdktypes.Context, asset string, chain string) {
	if mock.RegisterAssetToCosmosChainFunc == nil {
		panic("BaseKeeperMock.RegisterAssetToCosmosChainFunc: method is nil but BaseKeeper.RegisterAssetToCosmosChain was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Asset string
		Chain string
	}{
		Ctx:   ctx,
		Asset: asset,
		Chain: chain,
	}
	mock.lockRegisterAssetToCosmosChain.Lock()
	mock.calls.RegisterAssetToCosmosChain = append(mock.calls.RegisterAssetToCosmosChain, callInfo)
	mock.lockRegisterAssetToCosmosChain.Unlock()
	mock.RegisterAssetToCosmosChainFunc(ctx, asset, chain)
}

// RegisterAssetToCosmosChainCalls gets all the calls that were made to RegisterAssetToCosmosChain.
// Check the length with:
//     len(mockedBaseKeeper.RegisterAssetToCosmosChainCalls())
func (mock *BaseKeeperMock) RegisterAssetToCosmosChainCalls() []struct {
	Ctx   cosmossdktypes.Context
	Asset string
	Chain string
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Asset string
		Chain string
	}
	mock.lockRegisterAssetToCosmosChain.RLock()
	calls = mock.calls.RegisterAssetToCosmosChain
	mock.lockRegisterAssetToCosmosChain.RUnlock()
	return calls
}

// RegisterIBCPath calls RegisterIBCPathFunc.
func (mock *BaseKeeperMock) RegisterIBCPath(ctx cosmossdktypes.Context, asset string, path string) error {
	if mock.RegisterIBCPathFunc == nil {
		panic("BaseKeeperMock.RegisterIBCPathFunc: method is nil but BaseKeeper.RegisterIBCPath was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Asset string
		Path  string
	}{
		Ctx:   ctx,
		Asset: asset,
		Path:  path,
	}
	mock.lockRegisterIBCPath.Lock()
	mock.calls.RegisterIBCPath = append(mock.calls.RegisterIBCPath, callInfo)
	mock.lockRegisterIBCPath.Unlock()
	return mock.RegisterIBCPathFunc(ctx, asset, path)
}

// RegisterIBCPathCalls gets all the calls that were made to RegisterIBCPath.
// Check the length with:
//     len(mockedBaseKeeper.RegisterIBCPathCalls())
func (mock *BaseKeeperMock) RegisterIBCPathCalls() []struct {
	Ctx   cosmossdktypes.Context
	Asset string
	Path  string
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Asset string
		Path  string
	}
	mock.lockRegisterIBCPath.RLock()
	calls = mock.calls.RegisterIBCPath
	mock.lockRegisterIBCPath.RUnlock()
	return calls
}

// SetFeeCollector calls SetFeeCollectorFunc.
func (mock *BaseKeeperMock) SetFeeCollector(ctx cosmossdktypes.Context, address cosmossdktypes.AccAddress) {
	if mock.SetFeeCollectorFunc == nil {
		panic("BaseKeeperMock.SetFeeCollectorFunc: method is nil but BaseKeeper.SetFeeCollector was just called")
	}
	callInfo := struct {
		Ctx     cosmossdktypes.Context
		Address cosmossdktypes.AccAddress
	}{
		Ctx:     ctx,
		Address: address,
	}
	mock.lockSetFeeCollector.Lock()
	mock.calls.SetFeeCollector = append(mock.calls.SetFeeCollector, callInfo)
	mock.lockSetFeeCollector.Unlock()
	mock.SetFeeCollectorFunc(ctx, address)
}

// SetFeeCollectorCalls gets all the calls that were made to SetFeeCollector.
// Check the length with:
//     len(mockedBaseKeeper.SetFeeCollectorCalls())
func (mock *BaseKeeperMock) SetFeeCollectorCalls() []struct {
	Ctx     cosmossdktypes.Context
	Address cosmossdktypes.AccAddress
} {
	var calls []struct {
		Ctx     cosmossdktypes.Context
		Address cosmossdktypes.AccAddress
	}
	mock.lockSetFeeCollector.RLock()
	calls = mock.calls.SetFeeCollector
	mock.lockSetFeeCollector.RUnlock()
	return calls
}

// SetParams calls SetParamsFunc.
func (mock *BaseKeeperMock) SetParams(ctx cosmossdktypes.Context, n axelarnettypes.Nexus, p axelarnettypes.Params) {
	if mock.SetParamsFunc == nil {
		panic("BaseKeeperMock.SetParamsFunc: method is nil but BaseKeeper.SetParams was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
		N   axelarnettypes.Nexus
		P   axelarnettypes.Params
	}{
		Ctx: ctx,
		N:   n,
		P:   p,
	}
	mock.lockSetParams.Lock()
	mock.calls.SetParams = append(mock.calls.SetParams, callInfo)
	mock.lockSetParams.Unlock()
	mock.SetParamsFunc(ctx, n, p)
}

// SetParamsCalls gets all the calls that were made to SetParams.
// Check the length with:
//     len(mockedBaseKeeper.SetParamsCalls())
func (mock *BaseKeeperMock) SetParamsCalls() []struct {
	Ctx cosmossdktypes.Context
	N   axelarnettypes.Nexus
	P   axelarnettypes.Params
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
		N   axelarnettypes.Nexus
		P   axelarnettypes.Params
	}
	mock.lockSetParams.RLock()
	calls = mock.calls.SetParams
	mock.lockSetParams.RUnlock()
	return calls
}

// SetPendingIBCTransfer calls SetPendingIBCTransferFunc.
func (mock *BaseKeeperMock) SetPendingIBCTransfer(ctx cosmossdktypes.Context, portID string, channelID string, sequence uint64, value axelarnettypes.IBCTransfer) {
	if mock.SetPendingIBCTransferFunc == nil {
		panic("BaseKeeperMock.SetPendingIBCTransferFunc: method is nil but BaseKeeper.SetPendingIBCTransfer was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		PortID    string
		ChannelID string
		Sequence  uint64
		Value     axelarnettypes.IBCTransfer
	}{
		Ctx:       ctx,
		PortID:    portID,
		ChannelID: channelID,
		Sequence:  sequence,
		Value:     value,
	}
	mock.lockSetPendingIBCTransfer.Lock()
	mock.calls.SetPendingIBCTransfer = append(mock.calls.SetPendingIBCTransfer, callInfo)
	mock.lockSetPendingIBCTransfer.Unlock()
	mock.SetPendingIBCTransferFunc(ctx, portID, channelID, sequence, value)
}

// SetPendingIBCTransferCalls gets all the calls that were made to SetPendingIBCTransfer.
// Check the length with:
//     len(mockedBaseKeeper.SetPendingIBCTransferCalls())
func (mock *BaseKeeperMock) SetPendingIBCTransferCalls() []struct {
	Ctx       cosmossdktypes.Context
	PortID    string
	ChannelID string
	Sequence  uint64
	Value     axelarnettypes.IBCTransfer
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		PortID    string
		ChannelID string
		Sequence  uint64
		Value     axelarnettypes.IBCTransfer
	}
	mock.lockSetPendingIBCTransfer.RLock()
	calls = mock.calls.SetPendingIBCTransfer
	mock.lockSetPendingIBCTransfer.RUnlock()
	return calls
}

// Ensure, that NexusMock does implement axelarnettypes.Nexus.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.Nexus = &NexusMock{}

// NexusMock is a mock implementation of axelarnettypes.Nexus.
//
// 	func TestSomethingThatUsesNexus(t *testing.T) {
//
// 		// make and configure a mocked axelarnettypes.Nexus
// 		mockedNexus := &NexusMock{
// 			AddToChainTotalFunc: func(ctx cosmossdktypes.Context, chain exported.Chain, amount cosmossdktypes.Coin)  {
// 				panic("mock out the AddToChainTotal method")
// 			},
// 			ArchivePendingTransferFunc: func(ctx cosmossdktypes.Context, transfer exported.CrossChainTransfer)  {
// 				panic("mock out the ArchivePendingTransfer method")
// 			},
// 			EnqueueForTransferFunc: func(ctx cosmossdktypes.Context, sender exported.CrossChainAddress, amount cosmossdktypes.Coin) error {
// 				panic("mock out the EnqueueForTransfer method")
// 			},
// 			GetChainFunc: func(ctx cosmossdktypes.Context, chain string) (exported.Chain, bool) {
// 				panic("mock out the GetChain method")
// 			},
// 			GetRecipientFunc: func(ctx cosmossdktypes.Context, sender exported.CrossChainAddress) (exported.CrossChainAddress, bool) {
// 				panic("mock out the GetRecipient method")
// 			},
// 			GetTransfersForChainFunc: func(ctx cosmossdktypes.Context, chain exported.Chain, state exported.TransferState) []exported.CrossChainTransfer {
// 				panic("mock out the GetTransfersForChain method")
// 			},
// 			IsAssetRegisteredFunc: func(ctx cosmossdktypes.Context, chainName string, denom string) bool {
// 				panic("mock out the IsAssetRegistered method")
// 			},
// 			LinkAddressesFunc: func(ctx cosmossdktypes.Context, sender exported.CrossChainAddress, recipient exported.CrossChainAddress)  {
// 				panic("mock out the LinkAddresses method")
// 			},
// 			RegisterAssetFunc: func(ctx cosmossdktypes.Context, chainName string, denom string)  {
// 				panic("mock out the RegisterAsset method")
// 			},
// 			SetChainFunc: func(ctx cosmossdktypes.Context, chain exported.Chain)  {
// 				panic("mock out the SetChain method")
// 			},
// 		}
//
// 		// use mockedNexus in code that requires axelarnettypes.Nexus
// 		// and then make assertions.
//
// 	}
type NexusMock struct {
	// AddToChainTotalFunc mocks the AddToChainTotal method.
	AddToChainTotalFunc func(ctx cosmossdktypes.Context, chain exported.Chain, amount cosmossdktypes.Coin)

	// ArchivePendingTransferFunc mocks the ArchivePendingTransfer method.
	ArchivePendingTransferFunc func(ctx cosmossdktypes.Context, transfer exported.CrossChainTransfer)

	// EnqueueForTransferFunc mocks the EnqueueForTransfer method.
	EnqueueForTransferFunc func(ctx cosmossdktypes.Context, sender exported.CrossChainAddress, amount cosmossdktypes.Coin) error

	// GetChainFunc mocks the GetChain method.
	GetChainFunc func(ctx cosmossdktypes.Context, chain string) (exported.Chain, bool)

	// GetRecipientFunc mocks the GetRecipient method.
	GetRecipientFunc func(ctx cosmossdktypes.Context, sender exported.CrossChainAddress) (exported.CrossChainAddress, bool)

	// GetTransfersForChainFunc mocks the GetTransfersForChain method.
	GetTransfersForChainFunc func(ctx cosmossdktypes.Context, chain exported.Chain, state exported.TransferState) []exported.CrossChainTransfer

	// IsAssetRegisteredFunc mocks the IsAssetRegistered method.
	IsAssetRegisteredFunc func(ctx cosmossdktypes.Context, chainName string, denom string) bool

	// LinkAddressesFunc mocks the LinkAddresses method.
	LinkAddressesFunc func(ctx cosmossdktypes.Context, sender exported.CrossChainAddress, recipient exported.CrossChainAddress)

	// RegisterAssetFunc mocks the RegisterAsset method.
	RegisterAssetFunc func(ctx cosmossdktypes.Context, chainName string, denom string)

	// SetChainFunc mocks the SetChain method.
	SetChainFunc func(ctx cosmossdktypes.Context, chain exported.Chain)

	// calls tracks calls to the methods.
	calls struct {
		// AddToChainTotal holds details about calls to the AddToChainTotal method.
		AddToChainTotal []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain exported.Chain
			// Amount is the amount argument value.
			Amount cosmossdktypes.Coin
		}
		// ArchivePendingTransfer holds details about calls to the ArchivePendingTransfer method.
		ArchivePendingTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Transfer is the transfer argument value.
			Transfer exported.CrossChainTransfer
		}
		// EnqueueForTransfer holds details about calls to the EnqueueForTransfer method.
		EnqueueForTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Sender is the sender argument value.
			Sender exported.CrossChainAddress
			// Amount is the amount argument value.
			Amount cosmossdktypes.Coin
		}
		// GetChain holds details about calls to the GetChain method.
		GetChain []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain string
		}
		// GetRecipient holds details about calls to the GetRecipient method.
		GetRecipient []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Sender is the sender argument value.
			Sender exported.CrossChainAddress
		}
		// GetTransfersForChain holds details about calls to the GetTransfersForChain method.
		GetTransfersForChain []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain exported.Chain
			// State is the state argument value.
			State exported.TransferState
		}
		// IsAssetRegistered holds details about calls to the IsAssetRegistered method.
		IsAssetRegistered []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ChainName is the chainName argument value.
			ChainName string
			// Denom is the denom argument value.
			Denom string
		}
		// LinkAddresses holds details about calls to the LinkAddresses method.
		LinkAddresses []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Sender is the sender argument value.
			Sender exported.CrossChainAddress
			// Recipient is the recipient argument value.
			Recipient exported.CrossChainAddress
		}
		// RegisterAsset holds details about calls to the RegisterAsset method.
		RegisterAsset []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ChainName is the chainName argument value.
			ChainName string
			// Denom is the denom argument value.
			Denom string
		}
		// SetChain holds details about calls to the SetChain method.
		SetChain []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain exported.Chain
		}
	}
	lockAddToChainTotal        sync.RWMutex
	lockArchivePendingTransfer sync.RWMutex
	lockEnqueueForTransfer     sync.RWMutex
	lockGetChain               sync.RWMutex
	lockGetRecipient           sync.RWMutex
	lockGetTransfersForChain   sync.RWMutex
	lockIsAssetRegistered      sync.RWMutex
	lockLinkAddresses          sync.RWMutex
	lockRegisterAsset          sync.RWMutex
	lockSetChain               sync.RWMutex
}

// AddToChainTotal calls AddToChainTotalFunc.
func (mock *NexusMock) AddToChainTotal(ctx cosmossdktypes.Context, chain exported.Chain, amount cosmossdktypes.Coin) {
	if mock.AddToChainTotalFunc == nil {
		panic("NexusMock.AddToChainTotalFunc: method is nil but Nexus.AddToChainTotal was just called")
	}
	callInfo := struct {
		Ctx    cosmossdktypes.Context
		Chain  exported.Chain
		Amount cosmossdktypes.Coin
	}{
		Ctx:    ctx,
		Chain:  chain,
		Amount: amount,
	}
	mock.lockAddToChainTotal.Lock()
	mock.calls.AddToChainTotal = append(mock.calls.AddToChainTotal, callInfo)
	mock.lockAddToChainTotal.Unlock()
	mock.AddToChainTotalFunc(ctx, chain, amount)
}

// AddToChainTotalCalls gets all the calls that were made to AddToChainTotal.
// Check the length with:
//     len(mockedNexus.AddToChainTotalCalls())
func (mock *NexusMock) AddToChainTotalCalls() []struct {
	Ctx    cosmossdktypes.Context
	Chain  exported.Chain
	Amount cosmossdktypes.Coin
} {
	var calls []struct {
		Ctx    cosmossdktypes.Context
		Chain  exported.Chain
		Amount cosmossdktypes.Coin
	}
	mock.lockAddToChainTotal.RLock()
	calls = mock.calls.AddToChainTotal
	mock.lockAddToChainTotal.RUnlock()
	return calls
}

// ArchivePendingTransfer calls ArchivePendingTransferFunc.
func (mock *NexusMock) ArchivePendingTransfer(ctx cosmossdktypes.Context, transfer exported.CrossChainTransfer) {
	if mock.ArchivePendingTransferFunc == nil {
		panic("NexusMock.ArchivePendingTransferFunc: method is nil but Nexus.ArchivePendingTransfer was just called")
	}
	callInfo := struct {
		Ctx      cosmossdktypes.Context
		Transfer exported.CrossChainTransfer
	}{
		Ctx:      ctx,
		Transfer: transfer,
	}
	mock.lockArchivePendingTransfer.Lock()
	mock.calls.ArchivePendingTransfer = append(mock.calls.ArchivePendingTransfer, callInfo)
	mock.lockArchivePendingTransfer.Unlock()
	mock.ArchivePendingTransferFunc(ctx, transfer)
}

// ArchivePendingTransferCalls gets all the calls that were made to ArchivePendingTransfer.
// Check the length with:
//     len(mockedNexus.ArchivePendingTransferCalls())
func (mock *NexusMock) ArchivePendingTransferCalls() []struct {
	Ctx      cosmossdktypes.Context
	Transfer exported.CrossChainTransfer
} {
	var calls []struct {
		Ctx      cosmossdktypes.Context
		Transfer exported.CrossChainTransfer
	}
	mock.lockArchivePendingTransfer.RLock()
	calls = mock.calls.ArchivePendingTransfer
	mock.lockArchivePendingTransfer.RUnlock()
	return calls
}

// EnqueueForTransfer calls EnqueueForTransferFunc.
func (mock *NexusMock) EnqueueForTransfer(ctx cosmossdktypes.Context, sender exported.CrossChainAddress, amount cosmossdktypes.Coin) error {
	if mock.EnqueueForTransferFunc == nil {
		panic("NexusMock.EnqueueForTransferFunc: method is nil but Nexus.EnqueueForTransfer was just called")
	}
	callInfo := struct {
		Ctx    cosmossdktypes.Context
		Sender exported.CrossChainAddress
		Amount cosmossdktypes.Coin
	}{
		Ctx:    ctx,
		Sender: sender,
		Amount: amount,
	}
	mock.lockEnqueueForTransfer.Lock()
	mock.calls.EnqueueForTransfer = append(mock.calls.EnqueueForTransfer, callInfo)
	mock.lockEnqueueForTransfer.Unlock()
	return mock.EnqueueForTransferFunc(ctx, sender, amount)
}

// EnqueueForTransferCalls gets all the calls that were made to EnqueueForTransfer.
// Check the length with:
//     len(mockedNexus.EnqueueForTransferCalls())
func (mock *NexusMock) EnqueueForTransferCalls() []struct {
	Ctx    cosmossdktypes.Context
	Sender exported.CrossChainAddress
	Amount cosmossdktypes.Coin
} {
	var calls []struct {
		Ctx    cosmossdktypes.Context
		Sender exported.CrossChainAddress
		Amount cosmossdktypes.Coin
	}
	mock.lockEnqueueForTransfer.RLock()
	calls = mock.calls.EnqueueForTransfer
	mock.lockEnqueueForTransfer.RUnlock()
	return calls
}

// GetChain calls GetChainFunc.
func (mock *NexusMock) GetChain(ctx cosmossdktypes.Context, chain string) (exported.Chain, bool) {
	if mock.GetChainFunc == nil {
		panic("NexusMock.GetChainFunc: method is nil but Nexus.GetChain was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain string
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockGetChain.Lock()
	mock.calls.GetChain = append(mock.calls.GetChain, callInfo)
	mock.lockGetChain.Unlock()
	return mock.GetChainFunc(ctx, chain)
}

// GetChainCalls gets all the calls that were made to GetChain.
// Check the length with:
//     len(mockedNexus.GetChainCalls())
func (mock *NexusMock) GetChainCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain string
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain string
	}
	mock.lockGetChain.RLock()
	calls = mock.calls.GetChain
	mock.lockGetChain.RUnlock()
	return calls
}

// GetRecipient calls GetRecipientFunc.
func (mock *NexusMock) GetRecipient(ctx cosmossdktypes.Context, sender exported.CrossChainAddress) (exported.CrossChainAddress, bool) {
	if mock.GetRecipientFunc == nil {
		panic("NexusMock.GetRecipientFunc: method is nil but Nexus.GetRecipient was just called")
	}
	callInfo := struct {
		Ctx    cosmossdktypes.Context
		Sender exported.CrossChainAddress
	}{
		Ctx:    ctx,
		Sender: sender,
	}
	mock.lockGetRecipient.Lock()
	mock.calls.GetRecipient = append(mock.calls.GetRecipient, callInfo)
	mock.lockGetRecipient.Unlock()
	return mock.GetRecipientFunc(ctx, sender)
}

// GetRecipientCalls gets all the calls that were made to GetRecipient.
// Check the length with:
//     len(mockedNexus.GetRecipientCalls())
func (mock *NexusMock) GetRecipientCalls() []struct {
	Ctx    cosmossdktypes.Context
	Sender exported.CrossChainAddress
} {
	var calls []struct {
		Ctx    cosmossdktypes.Context
		Sender exported.CrossChainAddress
	}
	mock.lockGetRecipient.RLock()
	calls = mock.calls.GetRecipient
	mock.lockGetRecipient.RUnlock()
	return calls
}

// GetTransfersForChain calls GetTransfersForChainFunc.
func (mock *NexusMock) GetTransfersForChain(ctx cosmossdktypes.Context, chain exported.Chain, state exported.TransferState) []exported.CrossChainTransfer {
	if mock.GetTransfersForChainFunc == nil {
		panic("NexusMock.GetTransfersForChainFunc: method is nil but Nexus.GetTransfersForChain was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain exported.Chain
		State exported.TransferState
	}{
		Ctx:   ctx,
		Chain: chain,
		State: state,
	}
	mock.lockGetTransfersForChain.Lock()
	mock.calls.GetTransfersForChain = append(mock.calls.GetTransfersForChain, callInfo)
	mock.lockGetTransfersForChain.Unlock()
	return mock.GetTransfersForChainFunc(ctx, chain, state)
}

// GetTransfersForChainCalls gets all the calls that were made to GetTransfersForChain.
// Check the length with:
//     len(mockedNexus.GetTransfersForChainCalls())
func (mock *NexusMock) GetTransfersForChainCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain exported.Chain
	State exported.TransferState
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain exported.Chain
		State exported.TransferState
	}
	mock.lockGetTransfersForChain.RLock()
	calls = mock.calls.GetTransfersForChain
	mock.lockGetTransfersForChain.RUnlock()
	return calls
}

// IsAssetRegistered calls IsAssetRegisteredFunc.
func (mock *NexusMock) IsAssetRegistered(ctx cosmossdktypes.Context, chainName string, denom string) bool {
	if mock.IsAssetRegisteredFunc == nil {
		panic("NexusMock.IsAssetRegisteredFunc: method is nil but Nexus.IsAssetRegistered was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		ChainName string
		Denom     string
	}{
		Ctx:       ctx,
		ChainName: chainName,
		Denom:     denom,
	}
	mock.lockIsAssetRegistered.Lock()
	mock.calls.IsAssetRegistered = append(mock.calls.IsAssetRegistered, callInfo)
	mock.lockIsAssetRegistered.Unlock()
	return mock.IsAssetRegisteredFunc(ctx, chainName, denom)
}

// IsAssetRegisteredCalls gets all the calls that were made to IsAssetRegistered.
// Check the length with:
//     len(mockedNexus.IsAssetRegisteredCalls())
func (mock *NexusMock) IsAssetRegisteredCalls() []struct {
	Ctx       cosmossdktypes.Context
	ChainName string
	Denom     string
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		ChainName string
		Denom     string
	}
	mock.lockIsAssetRegistered.RLock()
	calls = mock.calls.IsAssetRegistered
	mock.lockIsAssetRegistered.RUnlock()
	return calls
}

// LinkAddresses calls LinkAddressesFunc.
func (mock *NexusMock) LinkAddresses(ctx cosmossdktypes.Context, sender exported.CrossChainAddress, recipient exported.CrossChainAddress) {
	if mock.LinkAddressesFunc == nil {
		panic("NexusMock.LinkAddressesFunc: method is nil but Nexus.LinkAddresses was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		Sender    exported.CrossChainAddress
		Recipient exported.CrossChainAddress
	}{
		Ctx:       ctx,
		Sender:    sender,
		Recipient: recipient,
	}
	mock.lockLinkAddresses.Lock()
	mock.calls.LinkAddresses = append(mock.calls.LinkAddresses, callInfo)
	mock.lockLinkAddresses.Unlock()
	mock.LinkAddressesFunc(ctx, sender, recipient)
}

// LinkAddressesCalls gets all the calls that were made to LinkAddresses.
// Check the length with:
//     len(mockedNexus.LinkAddressesCalls())
func (mock *NexusMock) LinkAddressesCalls() []struct {
	Ctx       cosmossdktypes.Context
	Sender    exported.CrossChainAddress
	Recipient exported.CrossChainAddress
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		Sender    exported.CrossChainAddress
		Recipient exported.CrossChainAddress
	}
	mock.lockLinkAddresses.RLock()
	calls = mock.calls.LinkAddresses
	mock.lockLinkAddresses.RUnlock()
	return calls
}

// RegisterAsset calls RegisterAssetFunc.
func (mock *NexusMock) RegisterAsset(ctx cosmossdktypes.Context, chainName string, denom string) {
	if mock.RegisterAssetFunc == nil {
		panic("NexusMock.RegisterAssetFunc: method is nil but Nexus.RegisterAsset was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		ChainName string
		Denom     string
	}{
		Ctx:       ctx,
		ChainName: chainName,
		Denom:     denom,
	}
	mock.lockRegisterAsset.Lock()
	mock.calls.RegisterAsset = append(mock.calls.RegisterAsset, callInfo)
	mock.lockRegisterAsset.Unlock()
	mock.RegisterAssetFunc(ctx, chainName, denom)
}

// RegisterAssetCalls gets all the calls that were made to RegisterAsset.
// Check the length with:
//     len(mockedNexus.RegisterAssetCalls())
func (mock *NexusMock) RegisterAssetCalls() []struct {
	Ctx       cosmossdktypes.Context
	ChainName string
	Denom     string
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		ChainName string
		Denom     string
	}
	mock.lockRegisterAsset.RLock()
	calls = mock.calls.RegisterAsset
	mock.lockRegisterAsset.RUnlock()
	return calls
}

// SetChain calls SetChainFunc.
func (mock *NexusMock) SetChain(ctx cosmossdktypes.Context, chain exported.Chain) {
	if mock.SetChainFunc == nil {
		panic("NexusMock.SetChainFunc: method is nil but Nexus.SetChain was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain exported.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockSetChain.Lock()
	mock.calls.SetChain = append(mock.calls.SetChain, callInfo)
	mock.lockSetChain.Unlock()
	mock.SetChainFunc(ctx, chain)
}

// SetChainCalls gets all the calls that were made to SetChain.
// Check the length with:
//     len(mockedNexus.SetChainCalls())
func (mock *NexusMock) SetChainCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain exported.Chain
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain exported.Chain
	}
	mock.lockSetChain.RLock()
	calls = mock.calls.SetChain
	mock.lockSetChain.RUnlock()
	return calls
}

// Ensure, that BankKeeperMock does implement axelarnettypes.BankKeeper.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.BankKeeper = &BankKeeperMock{}

// BankKeeperMock is a mock implementation of axelarnettypes.BankKeeper.
//
// 	func TestSomethingThatUsesBankKeeper(t *testing.T) {
//
// 		// make and configure a mocked axelarnettypes.BankKeeper
// 		mockedBankKeeper := &BankKeeperMock{
// 			BurnCoinsFunc: func(ctx cosmossdktypes.Context, moduleName string, amt cosmossdktypes.Coins) error {
// 				panic("mock out the BurnCoins method")
// 			},
// 			MintCoinsFunc: func(ctx cosmossdktypes.Context, moduleName string, amt cosmossdktypes.Coins) error {
// 				panic("mock out the MintCoins method")
// 			},
// 			SendCoinsFunc: func(ctx cosmossdktypes.Context, fromAddr cosmossdktypes.AccAddress, toAddr cosmossdktypes.AccAddress, amt cosmossdktypes.Coins) error {
// 				panic("mock out the SendCoins method")
// 			},
// 			SendCoinsFromAccountToModuleFunc: func(ctx cosmossdktypes.Context, senderAddr cosmossdktypes.AccAddress, recipientModule string, amt cosmossdktypes.Coins) error {
// 				panic("mock out the SendCoinsFromAccountToModule method")
// 			},
// 			SendCoinsFromModuleToAccountFunc: func(ctx cosmossdktypes.Context, senderModule string, recipientAddr cosmossdktypes.AccAddress, amt cosmossdktypes.Coins) error {
// 				panic("mock out the SendCoinsFromModuleToAccount method")
// 			},
// 		}
//
// 		// use mockedBankKeeper in code that requires axelarnettypes.BankKeeper
// 		// and then make assertions.
//
// 	}
type BankKeeperMock struct {
	// BurnCoinsFunc mocks the BurnCoins method.
	BurnCoinsFunc func(ctx cosmossdktypes.Context, moduleName string, amt cosmossdktypes.Coins) error

	// MintCoinsFunc mocks the MintCoins method.
	MintCoinsFunc func(ctx cosmossdktypes.Context, moduleName string, amt cosmossdktypes.Coins) error

	// SendCoinsFunc mocks the SendCoins method.
	SendCoinsFunc func(ctx cosmossdktypes.Context, fromAddr cosmossdktypes.AccAddress, toAddr cosmossdktypes.AccAddress, amt cosmossdktypes.Coins) error

	// SendCoinsFromAccountToModuleFunc mocks the SendCoinsFromAccountToModule method.
	SendCoinsFromAccountToModuleFunc func(ctx cosmossdktypes.Context, senderAddr cosmossdktypes.AccAddress, recipientModule string, amt cosmossdktypes.Coins) error

	// SendCoinsFromModuleToAccountFunc mocks the SendCoinsFromModuleToAccount method.
	SendCoinsFromModuleToAccountFunc func(ctx cosmossdktypes.Context, senderModule string, recipientAddr cosmossdktypes.AccAddress, amt cosmossdktypes.Coins) error

	// calls tracks calls to the methods.
	calls struct {
		// BurnCoins holds details about calls to the BurnCoins method.
		BurnCoins []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ModuleName is the moduleName argument value.
			ModuleName string
			// Amt is the amt argument value.
			Amt cosmossdktypes.Coins
		}
		// MintCoins holds details about calls to the MintCoins method.
		MintCoins []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ModuleName is the moduleName argument value.
			ModuleName string
			// Amt is the amt argument value.
			Amt cosmossdktypes.Coins
		}
		// SendCoins holds details about calls to the SendCoins method.
		SendCoins []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// FromAddr is the fromAddr argument value.
			FromAddr cosmossdktypes.AccAddress
			// ToAddr is the toAddr argument value.
			ToAddr cosmossdktypes.AccAddress
			// Amt is the amt argument value.
			Amt cosmossdktypes.Coins
		}
		// SendCoinsFromAccountToModule holds details about calls to the SendCoinsFromAccountToModule method.
		SendCoinsFromAccountToModule []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// SenderAddr is the senderAddr argument value.
			SenderAddr cosmossdktypes.AccAddress
			// RecipientModule is the recipientModule argument value.
			RecipientModule string
			// Amt is the amt argument value.
			Amt cosmossdktypes.Coins
		}
		// SendCoinsFromModuleToAccount holds details about calls to the SendCoinsFromModuleToAccount method.
		SendCoinsFromModuleToAccount []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// SenderModule is the senderModule argument value.
			SenderModule string
			// RecipientAddr is the recipientAddr argument value.
			RecipientAddr cosmossdktypes.AccAddress
			// Amt is the amt argument value.
			Amt cosmossdktypes.Coins
		}
	}
	lockBurnCoins                    sync.RWMutex
	lockMintCoins                    sync.RWMutex
	lockSendCoins                    sync.RWMutex
	lockSendCoinsFromAccountToModule sync.RWMutex
	lockSendCoinsFromModuleToAccount sync.RWMutex
}

// BurnCoins calls BurnCoinsFunc.
func (mock *BankKeeperMock) BurnCoins(ctx cosmossdktypes.Context, moduleName string, amt cosmossdktypes.Coins) error {
	if mock.BurnCoinsFunc == nil {
		panic("BankKeeperMock.BurnCoinsFunc: method is nil but BankKeeper.BurnCoins was just called")
	}
	callInfo := struct {
		Ctx        cosmossdktypes.Context
		ModuleName string
		Amt        cosmossdktypes.Coins
	}{
		Ctx:        ctx,
		ModuleName: moduleName,
		Amt:        amt,
	}
	mock.lockBurnCoins.Lock()
	mock.calls.BurnCoins = append(mock.calls.BurnCoins, callInfo)
	mock.lockBurnCoins.Unlock()
	return mock.BurnCoinsFunc(ctx, moduleName, amt)
}

// BurnCoinsCalls gets all the calls that were made to BurnCoins.
// Check the length with:
//     len(mockedBankKeeper.BurnCoinsCalls())
func (mock *BankKeeperMock) BurnCoinsCalls() []struct {
	Ctx        cosmossdktypes.Context
	ModuleName string
	Amt        cosmossdktypes.Coins
} {
	var calls []struct {
		Ctx        cosmossdktypes.Context
		ModuleName string
		Amt        cosmossdktypes.Coins
	}
	mock.lockBurnCoins.RLock()
	calls = mock.calls.BurnCoins
	mock.lockBurnCoins.RUnlock()
	return calls
}

// MintCoins calls MintCoinsFunc.
func (mock *BankKeeperMock) MintCoins(ctx cosmossdktypes.Context, moduleName string, amt cosmossdktypes.Coins) error {
	if mock.MintCoinsFunc == nil {
		panic("BankKeeperMock.MintCoinsFunc: method is nil but BankKeeper.MintCoins was just called")
	}
	callInfo := struct {
		Ctx        cosmossdktypes.Context
		ModuleName string
		Amt        cosmossdktypes.Coins
	}{
		Ctx:        ctx,
		ModuleName: moduleName,
		Amt:        amt,
	}
	mock.lockMintCoins.Lock()
	mock.calls.MintCoins = append(mock.calls.MintCoins, callInfo)
	mock.lockMintCoins.Unlock()
	return mock.MintCoinsFunc(ctx, moduleName, amt)
}

// MintCoinsCalls gets all the calls that were made to MintCoins.
// Check the length with:
//     len(mockedBankKeeper.MintCoinsCalls())
func (mock *BankKeeperMock) MintCoinsCalls() []struct {
	Ctx        cosmossdktypes.Context
	ModuleName string
	Amt        cosmossdktypes.Coins
} {
	var calls []struct {
		Ctx        cosmossdktypes.Context
		ModuleName string
		Amt        cosmossdktypes.Coins
	}
	mock.lockMintCoins.RLock()
	calls = mock.calls.MintCoins
	mock.lockMintCoins.RUnlock()
	return calls
}

// SendCoins calls SendCoinsFunc.
func (mock *BankKeeperMock) SendCoins(ctx cosmossdktypes.Context, fromAddr cosmossdktypes.AccAddress, toAddr cosmossdktypes.AccAddress, amt cosmossdktypes.Coins) error {
	if mock.SendCoinsFunc == nil {
		panic("BankKeeperMock.SendCoinsFunc: method is nil but BankKeeper.SendCoins was just called")
	}
	callInfo := struct {
		Ctx      cosmossdktypes.Context
		FromAddr cosmossdktypes.AccAddress
		ToAddr   cosmossdktypes.AccAddress
		Amt      cosmossdktypes.Coins
	}{
		Ctx:      ctx,
		FromAddr: fromAddr,
		ToAddr:   toAddr,
		Amt:      amt,
	}
	mock.lockSendCoins.Lock()
	mock.calls.SendCoins = append(mock.calls.SendCoins, callInfo)
	mock.lockSendCoins.Unlock()
	return mock.SendCoinsFunc(ctx, fromAddr, toAddr, amt)
}

// SendCoinsCalls gets all the calls that were made to SendCoins.
// Check the length with:
//     len(mockedBankKeeper.SendCoinsCalls())
func (mock *BankKeeperMock) SendCoinsCalls() []struct {
	Ctx      cosmossdktypes.Context
	FromAddr cosmossdktypes.AccAddress
	ToAddr   cosmossdktypes.AccAddress
	Amt      cosmossdktypes.Coins
} {
	var calls []struct {
		Ctx      cosmossdktypes.Context
		FromAddr cosmossdktypes.AccAddress
		ToAddr   cosmossdktypes.AccAddress
		Amt      cosmossdktypes.Coins
	}
	mock.lockSendCoins.RLock()
	calls = mock.calls.SendCoins
	mock.lockSendCoins.RUnlock()
	return calls
}

// SendCoinsFromAccountToModule calls SendCoinsFromAccountToModuleFunc.
func (mock *BankKeeperMock) SendCoinsFromAccountToModule(ctx cosmossdktypes.Context, senderAddr cosmossdktypes.AccAddress, recipientModule string, amt cosmossdktypes.Coins) error {
	if mock.SendCoinsFromAccountToModuleFunc == nil {
		panic("BankKeeperMock.SendCoinsFromAccountToModuleFunc: method is nil but BankKeeper.SendCoinsFromAccountToModule was just called")
	}
	callInfo := struct {
		Ctx             cosmossdktypes.Context
		SenderAddr      cosmossdktypes.AccAddress
		RecipientModule string
		Amt             cosmossdktypes.Coins
	}{
		Ctx:             ctx,
		SenderAddr:      senderAddr,
		RecipientModule: recipientModule,
		Amt:             amt,
	}
	mock.lockSendCoinsFromAccountToModule.Lock()
	mock.calls.SendCoinsFromAccountToModule = append(mock.calls.SendCoinsFromAccountToModule, callInfo)
	mock.lockSendCoinsFromAccountToModule.Unlock()
	return mock.SendCoinsFromAccountToModuleFunc(ctx, senderAddr, recipientModule, amt)
}

// SendCoinsFromAccountToModuleCalls gets all the calls that were made to SendCoinsFromAccountToModule.
// Check the length with:
//     len(mockedBankKeeper.SendCoinsFromAccountToModuleCalls())
func (mock *BankKeeperMock) SendCoinsFromAccountToModuleCalls() []struct {
	Ctx             cosmossdktypes.Context
	SenderAddr      cosmossdktypes.AccAddress
	RecipientModule string
	Amt             cosmossdktypes.Coins
} {
	var calls []struct {
		Ctx             cosmossdktypes.Context
		SenderAddr      cosmossdktypes.AccAddress
		RecipientModule string
		Amt             cosmossdktypes.Coins
	}
	mock.lockSendCoinsFromAccountToModule.RLock()
	calls = mock.calls.SendCoinsFromAccountToModule
	mock.lockSendCoinsFromAccountToModule.RUnlock()
	return calls
}

// SendCoinsFromModuleToAccount calls SendCoinsFromModuleToAccountFunc.
func (mock *BankKeeperMock) SendCoinsFromModuleToAccount(ctx cosmossdktypes.Context, senderModule string, recipientAddr cosmossdktypes.AccAddress, amt cosmossdktypes.Coins) error {
	if mock.SendCoinsFromModuleToAccountFunc == nil {
		panic("BankKeeperMock.SendCoinsFromModuleToAccountFunc: method is nil but BankKeeper.SendCoinsFromModuleToAccount was just called")
	}
	callInfo := struct {
		Ctx           cosmossdktypes.Context
		SenderModule  string
		RecipientAddr cosmossdktypes.AccAddress
		Amt           cosmossdktypes.Coins
	}{
		Ctx:           ctx,
		SenderModule:  senderModule,
		RecipientAddr: recipientAddr,
		Amt:           amt,
	}
	mock.lockSendCoinsFromModuleToAccount.Lock()
	mock.calls.SendCoinsFromModuleToAccount = append(mock.calls.SendCoinsFromModuleToAccount, callInfo)
	mock.lockSendCoinsFromModuleToAccount.Unlock()
	return mock.SendCoinsFromModuleToAccountFunc(ctx, senderModule, recipientAddr, amt)
}

// SendCoinsFromModuleToAccountCalls gets all the calls that were made to SendCoinsFromModuleToAccount.
// Check the length with:
//     len(mockedBankKeeper.SendCoinsFromModuleToAccountCalls())
func (mock *BankKeeperMock) SendCoinsFromModuleToAccountCalls() []struct {
	Ctx           cosmossdktypes.Context
	SenderModule  string
	RecipientAddr cosmossdktypes.AccAddress
	Amt           cosmossdktypes.Coins
} {
	var calls []struct {
		Ctx           cosmossdktypes.Context
		SenderModule  string
		RecipientAddr cosmossdktypes.AccAddress
		Amt           cosmossdktypes.Coins
	}
	mock.lockSendCoinsFromModuleToAccount.RLock()
	calls = mock.calls.SendCoinsFromModuleToAccount
	mock.lockSendCoinsFromModuleToAccount.RUnlock()
	return calls
}

// Ensure, that IBCTransferKeeperMock does implement axelarnettypes.IBCTransferKeeper.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.IBCTransferKeeper = &IBCTransferKeeperMock{}

// IBCTransferKeeperMock is a mock implementation of axelarnettypes.IBCTransferKeeper.
//
// 	func TestSomethingThatUsesIBCTransferKeeper(t *testing.T) {
//
// 		// make and configure a mocked axelarnettypes.IBCTransferKeeper
// 		mockedIBCTransferKeeper := &IBCTransferKeeperMock{
// 			GetDenomTraceFunc: func(ctx cosmossdktypes.Context, denomTraceHash tmbytes.HexBytes) (ibctypes.DenomTrace, bool) {
// 				panic("mock out the GetDenomTrace method")
// 			},
// 			SendTransferFunc: func(ctx cosmossdktypes.Context, sourcePort string, sourceChannel string, token cosmossdktypes.Coin, sender cosmossdktypes.AccAddress, receiver string, timeoutHeight clienttypes.Height, timeoutTimestamp uint64) error {
// 				panic("mock out the SendTransfer method")
// 			},
// 		}
//
// 		// use mockedIBCTransferKeeper in code that requires axelarnettypes.IBCTransferKeeper
// 		// and then make assertions.
//
// 	}
type IBCTransferKeeperMock struct {
	// GetDenomTraceFunc mocks the GetDenomTrace method.
	GetDenomTraceFunc func(ctx cosmossdktypes.Context, denomTraceHash tmbytes.HexBytes) (ibctypes.DenomTrace, bool)

	// SendTransferFunc mocks the SendTransfer method.
	SendTransferFunc func(ctx cosmossdktypes.Context, sourcePort string, sourceChannel string, token cosmossdktypes.Coin, sender cosmossdktypes.AccAddress, receiver string, timeoutHeight clienttypes.Height, timeoutTimestamp uint64) error

	// calls tracks calls to the methods.
	calls struct {
		// GetDenomTrace holds details about calls to the GetDenomTrace method.
		GetDenomTrace []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// DenomTraceHash is the denomTraceHash argument value.
			DenomTraceHash tmbytes.HexBytes
		}
		// SendTransfer holds details about calls to the SendTransfer method.
		SendTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// SourcePort is the sourcePort argument value.
			SourcePort string
			// SourceChannel is the sourceChannel argument value.
			SourceChannel string
			// Token is the token argument value.
			Token cosmossdktypes.Coin
			// Sender is the sender argument value.
			Sender cosmossdktypes.AccAddress
			// Receiver is the receiver argument value.
			Receiver string
			// TimeoutHeight is the timeoutHeight argument value.
			TimeoutHeight clienttypes.Height
			// TimeoutTimestamp is the timeoutTimestamp argument value.
			TimeoutTimestamp uint64
		}
	}
	lockGetDenomTrace sync.RWMutex
	lockSendTransfer  sync.RWMutex
}

// GetDenomTrace calls GetDenomTraceFunc.
func (mock *IBCTransferKeeperMock) GetDenomTrace(ctx cosmossdktypes.Context, denomTraceHash tmbytes.HexBytes) (ibctypes.DenomTrace, bool) {
	if mock.GetDenomTraceFunc == nil {
		panic("IBCTransferKeeperMock.GetDenomTraceFunc: method is nil but IBCTransferKeeper.GetDenomTrace was just called")
	}
	callInfo := struct {
		Ctx            cosmossdktypes.Context
		DenomTraceHash tmbytes.HexBytes
	}{
		Ctx:            ctx,
		DenomTraceHash: denomTraceHash,
	}
	mock.lockGetDenomTrace.Lock()
	mock.calls.GetDenomTrace = append(mock.calls.GetDenomTrace, callInfo)
	mock.lockGetDenomTrace.Unlock()
	return mock.GetDenomTraceFunc(ctx, denomTraceHash)
}

// GetDenomTraceCalls gets all the calls that were made to GetDenomTrace.
// Check the length with:
//     len(mockedIBCTransferKeeper.GetDenomTraceCalls())
func (mock *IBCTransferKeeperMock) GetDenomTraceCalls() []struct {
	Ctx            cosmossdktypes.Context
	DenomTraceHash tmbytes.HexBytes
} {
	var calls []struct {
		Ctx            cosmossdktypes.Context
		DenomTraceHash tmbytes.HexBytes
	}
	mock.lockGetDenomTrace.RLock()
	calls = mock.calls.GetDenomTrace
	mock.lockGetDenomTrace.RUnlock()
	return calls
}

// SendTransfer calls SendTransferFunc.
func (mock *IBCTransferKeeperMock) SendTransfer(ctx cosmossdktypes.Context, sourcePort string, sourceChannel string, token cosmossdktypes.Coin, sender cosmossdktypes.AccAddress, receiver string, timeoutHeight clienttypes.Height, timeoutTimestamp uint64) error {
	if mock.SendTransferFunc == nil {
		panic("IBCTransferKeeperMock.SendTransferFunc: method is nil but IBCTransferKeeper.SendTransfer was just called")
	}
	callInfo := struct {
		Ctx              cosmossdktypes.Context
		SourcePort       string
		SourceChannel    string
		Token            cosmossdktypes.Coin
		Sender           cosmossdktypes.AccAddress
		Receiver         string
		TimeoutHeight    clienttypes.Height
		TimeoutTimestamp uint64
	}{
		Ctx:              ctx,
		SourcePort:       sourcePort,
		SourceChannel:    sourceChannel,
		Token:            token,
		Sender:           sender,
		Receiver:         receiver,
		TimeoutHeight:    timeoutHeight,
		TimeoutTimestamp: timeoutTimestamp,
	}
	mock.lockSendTransfer.Lock()
	mock.calls.SendTransfer = append(mock.calls.SendTransfer, callInfo)
	mock.lockSendTransfer.Unlock()
	return mock.SendTransferFunc(ctx, sourcePort, sourceChannel, token, sender, receiver, timeoutHeight, timeoutTimestamp)
}

// SendTransferCalls gets all the calls that were made to SendTransfer.
// Check the length with:
//     len(mockedIBCTransferKeeper.SendTransferCalls())
func (mock *IBCTransferKeeperMock) SendTransferCalls() []struct {
	Ctx              cosmossdktypes.Context
	SourcePort       string
	SourceChannel    string
	Token            cosmossdktypes.Coin
	Sender           cosmossdktypes.AccAddress
	Receiver         string
	TimeoutHeight    clienttypes.Height
	TimeoutTimestamp uint64
} {
	var calls []struct {
		Ctx              cosmossdktypes.Context
		SourcePort       string
		SourceChannel    string
		Token            cosmossdktypes.Coin
		Sender           cosmossdktypes.AccAddress
		Receiver         string
		TimeoutHeight    clienttypes.Height
		TimeoutTimestamp uint64
	}
	mock.lockSendTransfer.RLock()
	calls = mock.calls.SendTransfer
	mock.lockSendTransfer.RUnlock()
	return calls
}

// Ensure, that ChannelKeeperMock does implement axelarnettypes.ChannelKeeper.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.ChannelKeeper = &ChannelKeeperMock{}

// ChannelKeeperMock is a mock implementation of axelarnettypes.ChannelKeeper.
//
// 	func TestSomethingThatUsesChannelKeeper(t *testing.T) {
//
// 		// make and configure a mocked axelarnettypes.ChannelKeeper
// 		mockedChannelKeeper := &ChannelKeeperMock{
// 			GetChannelClientStateFunc: func(ctx cosmossdktypes.Context, portID string, channelID string) (string, ibcclient.ClientState, error) {
// 				panic("mock out the GetChannelClientState method")
// 			},
// 			GetNextSequenceSendFunc: func(ctx cosmossdktypes.Context, portID string, channelID string) (uint64, bool) {
// 				panic("mock out the GetNextSequenceSend method")
// 			},
// 		}
//
// 		// use mockedChannelKeeper in code that requires axelarnettypes.ChannelKeeper
// 		// and then make assertions.
//
// 	}
type ChannelKeeperMock struct {
	// GetChannelClientStateFunc mocks the GetChannelClientState method.
	GetChannelClientStateFunc func(ctx cosmossdktypes.Context, portID string, channelID string) (string, ibcclient.ClientState, error)

	// GetNextSequenceSendFunc mocks the GetNextSequenceSend method.
	GetNextSequenceSendFunc func(ctx cosmossdktypes.Context, portID string, channelID string) (uint64, bool)

	// calls tracks calls to the methods.
	calls struct {
		// GetChannelClientState holds details about calls to the GetChannelClientState method.
		GetChannelClientState []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// PortID is the portID argument value.
			PortID string
			// ChannelID is the channelID argument value.
			ChannelID string
		}
		// GetNextSequenceSend holds details about calls to the GetNextSequenceSend method.
		GetNextSequenceSend []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// PortID is the portID argument value.
			PortID string
			// ChannelID is the channelID argument value.
			ChannelID string
		}
	}
	lockGetChannelClientState sync.RWMutex
	lockGetNextSequenceSend   sync.RWMutex
}

// GetChannelClientState calls GetChannelClientStateFunc.
func (mock *ChannelKeeperMock) GetChannelClientState(ctx cosmossdktypes.Context, portID string, channelID string) (string, ibcclient.ClientState, error) {
	if mock.GetChannelClientStateFunc == nil {
		panic("ChannelKeeperMock.GetChannelClientStateFunc: method is nil but ChannelKeeper.GetChannelClientState was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		PortID    string
		ChannelID string
	}{
		Ctx:       ctx,
		PortID:    portID,
		ChannelID: channelID,
	}
	mock.lockGetChannelClientState.Lock()
	mock.calls.GetChannelClientState = append(mock.calls.GetChannelClientState, callInfo)
	mock.lockGetChannelClientState.Unlock()
	return mock.GetChannelClientStateFunc(ctx, portID, channelID)
}

// GetChannelClientStateCalls gets all the calls that were made to GetChannelClientState.
// Check the length with:
//     len(mockedChannelKeeper.GetChannelClientStateCalls())
func (mock *ChannelKeeperMock) GetChannelClientStateCalls() []struct {
	Ctx       cosmossdktypes.Context
	PortID    string
	ChannelID string
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		PortID    string
		ChannelID string
	}
	mock.lockGetChannelClientState.RLock()
	calls = mock.calls.GetChannelClientState
	mock.lockGetChannelClientState.RUnlock()
	return calls
}

// GetNextSequenceSend calls GetNextSequenceSendFunc.
func (mock *ChannelKeeperMock) GetNextSequenceSend(ctx cosmossdktypes.Context, portID string, channelID string) (uint64, bool) {
	if mock.GetNextSequenceSendFunc == nil {
		panic("ChannelKeeperMock.GetNextSequenceSendFunc: method is nil but ChannelKeeper.GetNextSequenceSend was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		PortID    string
		ChannelID string
	}{
		Ctx:       ctx,
		PortID:    portID,
		ChannelID: channelID,
	}
	mock.lockGetNextSequenceSend.Lock()
	mock.calls.GetNextSequenceSend = append(mock.calls.GetNextSequenceSend, callInfo)
	mock.lockGetNextSequenceSend.Unlock()
	return mock.GetNextSequenceSendFunc(ctx, portID, channelID)
}

// GetNextSequenceSendCalls gets all the calls that were made to GetNextSequenceSend.
// Check the length with:
//     len(mockedChannelKeeper.GetNextSequenceSendCalls())
func (mock *ChannelKeeperMock) GetNextSequenceSendCalls() []struct {
	Ctx       cosmossdktypes.Context
	PortID    string
	ChannelID string
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		PortID    string
		ChannelID string
	}
	mock.lockGetNextSequenceSend.RLock()
	calls = mock.calls.GetNextSequenceSend
	mock.lockGetNextSequenceSend.RUnlock()
	return calls
}

// Ensure, that AccountKeeperMock does implement axelarnettypes.AccountKeeper.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.AccountKeeper = &AccountKeeperMock{}

// AccountKeeperMock is a mock implementation of axelarnettypes.AccountKeeper.
//
// 	func TestSomethingThatUsesAccountKeeper(t *testing.T) {
//
// 		// make and configure a mocked axelarnettypes.AccountKeeper
// 		mockedAccountKeeper := &AccountKeeperMock{
// 			GetModuleAddressFunc: func(moduleName string) cosmossdktypes.AccAddress {
// 				panic("mock out the GetModuleAddress method")
// 			},
// 		}
//
// 		// use mockedAccountKeeper in code that requires axelarnettypes.AccountKeeper
// 		// and then make assertions.
//
// 	}
type AccountKeeperMock struct {
	// GetModuleAddressFunc mocks the GetModuleAddress method.
	GetModuleAddressFunc func(moduleName string) cosmossdktypes.AccAddress

	// calls tracks calls to the methods.
	calls struct {
		// GetModuleAddress holds details about calls to the GetModuleAddress method.
		GetModuleAddress []struct {
			// ModuleName is the moduleName argument value.
			ModuleName string
		}
	}
	lockGetModuleAddress sync.RWMutex
}

// GetModuleAddress calls GetModuleAddressFunc.
func (mock *AccountKeeperMock) GetModuleAddress(moduleName string) cosmossdktypes.AccAddress {
	if mock.GetModuleAddressFunc == nil {
		panic("AccountKeeperMock.GetModuleAddressFunc: method is nil but AccountKeeper.GetModuleAddress was just called")
	}
	callInfo := struct {
		ModuleName string
	}{
		ModuleName: moduleName,
	}
	mock.lockGetModuleAddress.Lock()
	mock.calls.GetModuleAddress = append(mock.calls.GetModuleAddress, callInfo)
	mock.lockGetModuleAddress.Unlock()
	return mock.GetModuleAddressFunc(moduleName)
}

// GetModuleAddressCalls gets all the calls that were made to GetModuleAddress.
// Check the length with:
//     len(mockedAccountKeeper.GetModuleAddressCalls())
func (mock *AccountKeeperMock) GetModuleAddressCalls() []struct {
	ModuleName string
} {
	var calls []struct {
		ModuleName string
	}
	mock.lockGetModuleAddress.RLock()
	calls = mock.calls.GetModuleAddress
	mock.lockGetModuleAddress.RUnlock()
	return calls
}
