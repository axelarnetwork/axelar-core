// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	axelarnettypes "github.com/axelarnetwork/axelar-core/x/axelarnet/types"
	nexus "github.com/axelarnetwork/axelar-core/x/nexus/exported"
	sdk "github.com/cosmos/cosmos-sdk/types"
	transfertypes "github.com/cosmos/cosmos-sdk/x/ibc/applications/transfer/types"
	tmbytes "github.com/tendermint/tendermint/libs/bytes"
	"github.com/tendermint/tendermint/libs/log"
	"sync"
)

// Ensure, that BaseKeeperMock does implement axelarnettypes.BaseKeeper.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.BaseKeeper = &BaseKeeperMock{}

// BaseKeeperMock is a mock implementation of axelarnettypes.BaseKeeper.
//
// 	func TestSomethingThatUsesBaseKeeper(t *testing.T) {
//
// 		// make and configure a mocked axelarnettypes.BaseKeeper
// 		mockedBaseKeeper := &BaseKeeperMock{
// 			GetIBCPathFunc: func(ctx sdk.Context, asset string) string {
// 				panic("mock out the GetIBCPath method")
// 			},
// 			LoggerFunc: func(ctx sdk.Context) log.Logger {
// 				panic("mock out the Logger method")
// 			},
// 			RegisterIBCPathFunc: func(ctx sdk.Context, asset string, path string) error {
// 				panic("mock out the RegisterIBCPath method")
// 			},
// 		}
//
// 		// use mockedBaseKeeper in code that requires axelarnettypes.BaseKeeper
// 		// and then make assertions.
//
// 	}
type BaseKeeperMock struct {
	// GetIBCPathFunc mocks the GetIBCPath method.
	GetIBCPathFunc func(ctx sdk.Context, asset string) string

	// LoggerFunc mocks the Logger method.
	LoggerFunc func(ctx sdk.Context) log.Logger

	// RegisterIBCPathFunc mocks the RegisterIBCPath method.
	RegisterIBCPathFunc func(ctx sdk.Context, asset string, path string) error

	// calls tracks calls to the methods.
	calls struct {
		// GetIBCPath holds details about calls to the GetIBCPath method.
		GetIBCPath []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Asset is the asset argument value.
			Asset string
		}
		// Logger holds details about calls to the Logger method.
		Logger []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// RegisterIBCPath holds details about calls to the RegisterIBCPath method.
		RegisterIBCPath []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Asset is the asset argument value.
			Asset string
			// Path is the path argument value.
			Path string
		}
	}
	lockGetIBCPath      sync.RWMutex
	lockLogger          sync.RWMutex
	lockRegisterIBCPath sync.RWMutex
}

// GetIBCPath calls GetIBCPathFunc.
func (mock *BaseKeeperMock) GetIBCPath(ctx sdk.Context, asset string) string {
	if mock.GetIBCPathFunc == nil {
		panic("BaseKeeperMock.GetIBCPathFunc: method is nil but BaseKeeper.GetIBCPath was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		Asset string
	}{
		Ctx:   ctx,
		Asset: asset,
	}
	mock.lockGetIBCPath.Lock()
	mock.calls.GetIBCPath = append(mock.calls.GetIBCPath, callInfo)
	mock.lockGetIBCPath.Unlock()
	return mock.GetIBCPathFunc(ctx, asset)
}

// GetIBCPathCalls gets all the calls that were made to GetIBCPath.
// Check the length with:
//     len(mockedBaseKeeper.GetIBCPathCalls())
func (mock *BaseKeeperMock) GetIBCPathCalls() []struct {
	Ctx   sdk.Context
	Asset string
} {
	var calls []struct {
		Ctx   sdk.Context
		Asset string
	}
	mock.lockGetIBCPath.RLock()
	calls = mock.calls.GetIBCPath
	mock.lockGetIBCPath.RUnlock()
	return calls
}

// Logger calls LoggerFunc.
func (mock *BaseKeeperMock) Logger(ctx sdk.Context) log.Logger {
	if mock.LoggerFunc == nil {
		panic("BaseKeeperMock.LoggerFunc: method is nil but BaseKeeper.Logger was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockLogger.Lock()
	mock.calls.Logger = append(mock.calls.Logger, callInfo)
	mock.lockLogger.Unlock()
	return mock.LoggerFunc(ctx)
}

// LoggerCalls gets all the calls that were made to Logger.
// Check the length with:
//     len(mockedBaseKeeper.LoggerCalls())
func (mock *BaseKeeperMock) LoggerCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockLogger.RLock()
	calls = mock.calls.Logger
	mock.lockLogger.RUnlock()
	return calls
}

// RegisterIBCPath calls RegisterIBCPathFunc.
func (mock *BaseKeeperMock) RegisterIBCPath(ctx sdk.Context, asset string, path string) error {
	if mock.RegisterIBCPathFunc == nil {
		panic("BaseKeeperMock.RegisterIBCPathFunc: method is nil but BaseKeeper.RegisterIBCPath was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		Asset string
		Path  string
	}{
		Ctx:   ctx,
		Asset: asset,
		Path:  path,
	}
	mock.lockRegisterIBCPath.Lock()
	mock.calls.RegisterIBCPath = append(mock.calls.RegisterIBCPath, callInfo)
	mock.lockRegisterIBCPath.Unlock()
	return mock.RegisterIBCPathFunc(ctx, asset, path)
}

// RegisterIBCPathCalls gets all the calls that were made to RegisterIBCPath.
// Check the length with:
//     len(mockedBaseKeeper.RegisterIBCPathCalls())
func (mock *BaseKeeperMock) RegisterIBCPathCalls() []struct {
	Ctx   sdk.Context
	Asset string
	Path  string
} {
	var calls []struct {
		Ctx   sdk.Context
		Asset string
		Path  string
	}
	mock.lockRegisterIBCPath.RLock()
	calls = mock.calls.RegisterIBCPath
	mock.lockRegisterIBCPath.RUnlock()
	return calls
}

// Ensure, that NexusMock does implement axelarnettypes.Nexus.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.Nexus = &NexusMock{}

// NexusMock is a mock implementation of axelarnettypes.Nexus.
//
// 	func TestSomethingThatUsesNexus(t *testing.T) {
//
// 		// make and configure a mocked axelarnettypes.Nexus
// 		mockedNexus := &NexusMock{
// 			AddToChainTotalFunc: func(ctx sdk.Context, chain nexus.Chain, amount sdk.Coin)  {
// 				panic("mock out the AddToChainTotal method")
// 			},
// 			ArchivePendingTransferFunc: func(ctx sdk.Context, transfer nexus.CrossChainTransfer)  {
// 				panic("mock out the ArchivePendingTransfer method")
// 			},
// 			EnqueueForTransferFunc: func(ctx sdk.Context, sender nexus.CrossChainAddress, amount sdk.Coin) error {
// 				panic("mock out the EnqueueForTransfer method")
// 			},
// 			GetChainFunc: func(ctx sdk.Context, chain string) (nexus.Chain, bool) {
// 				panic("mock out the GetChain method")
// 			},
// 			GetRecipientFunc: func(ctx sdk.Context, sender nexus.CrossChainAddress) (nexus.CrossChainAddress, bool) {
// 				panic("mock out the GetRecipient method")
// 			},
// 			GetTransfersForChainFunc: func(ctx sdk.Context, chain nexus.Chain, state nexus.TransferState) []nexus.CrossChainTransfer {
// 				panic("mock out the GetTransfersForChain method")
// 			},
// 			IsAssetRegisteredFunc: func(ctx sdk.Context, chainName string, denom string) bool {
// 				panic("mock out the IsAssetRegistered method")
// 			},
// 			LinkAddressesFunc: func(ctx sdk.Context, sender nexus.CrossChainAddress, recipient nexus.CrossChainAddress)  {
// 				panic("mock out the LinkAddresses method")
// 			},
// 			RegisterAssetFunc: func(ctx sdk.Context, chainName string, denom string)  {
// 				panic("mock out the RegisterAsset method")
// 			},
// 			SetChainFunc: func(ctx sdk.Context, chain nexus.Chain)  {
// 				panic("mock out the SetChain method")
// 			},
// 		}
//
// 		// use mockedNexus in code that requires axelarnettypes.Nexus
// 		// and then make assertions.
//
// 	}
type NexusMock struct {
	// AddToChainTotalFunc mocks the AddToChainTotal method.
	AddToChainTotalFunc func(ctx sdk.Context, chain nexus.Chain, amount sdk.Coin)

	// ArchivePendingTransferFunc mocks the ArchivePendingTransfer method.
	ArchivePendingTransferFunc func(ctx sdk.Context, transfer nexus.CrossChainTransfer)

	// EnqueueForTransferFunc mocks the EnqueueForTransfer method.
	EnqueueForTransferFunc func(ctx sdk.Context, sender nexus.CrossChainAddress, amount sdk.Coin) error

	// GetChainFunc mocks the GetChain method.
	GetChainFunc func(ctx sdk.Context, chain string) (nexus.Chain, bool)

	// GetRecipientFunc mocks the GetRecipient method.
	GetRecipientFunc func(ctx sdk.Context, sender nexus.CrossChainAddress) (nexus.CrossChainAddress, bool)

	// GetTransfersForChainFunc mocks the GetTransfersForChain method.
	GetTransfersForChainFunc func(ctx sdk.Context, chain nexus.Chain, state nexus.TransferState) []nexus.CrossChainTransfer

	// IsAssetRegisteredFunc mocks the IsAssetRegistered method.
	IsAssetRegisteredFunc func(ctx sdk.Context, chainName string, denom string) bool

	// LinkAddressesFunc mocks the LinkAddresses method.
	LinkAddressesFunc func(ctx sdk.Context, sender nexus.CrossChainAddress, recipient nexus.CrossChainAddress)

	// RegisterAssetFunc mocks the RegisterAsset method.
	RegisterAssetFunc func(ctx sdk.Context, chainName string, denom string)

	// SetChainFunc mocks the SetChain method.
	SetChainFunc func(ctx sdk.Context, chain nexus.Chain)

	// calls tracks calls to the methods.
	calls struct {
		// AddToChainTotal holds details about calls to the AddToChainTotal method.
		AddToChainTotal []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Chain is the chain argument value.
			Chain nexus.Chain
			// Amount is the amount argument value.
			Amount sdk.Coin
		}
		// ArchivePendingTransfer holds details about calls to the ArchivePendingTransfer method.
		ArchivePendingTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Transfer is the transfer argument value.
			Transfer nexus.CrossChainTransfer
		}
		// EnqueueForTransfer holds details about calls to the EnqueueForTransfer method.
		EnqueueForTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Sender is the sender argument value.
			Sender nexus.CrossChainAddress
			// Amount is the amount argument value.
			Amount sdk.Coin
		}
		// GetChain holds details about calls to the GetChain method.
		GetChain []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Chain is the chain argument value.
			Chain string
		}
		// GetRecipient holds details about calls to the GetRecipient method.
		GetRecipient []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Sender is the sender argument value.
			Sender nexus.CrossChainAddress
		}
		// GetTransfersForChain holds details about calls to the GetTransfersForChain method.
		GetTransfersForChain []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Chain is the chain argument value.
			Chain nexus.Chain
			// State is the state argument value.
			State nexus.TransferState
		}
		// IsAssetRegistered holds details about calls to the IsAssetRegistered method.
		IsAssetRegistered []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// ChainName is the chainName argument value.
			ChainName string
			// Denom is the denom argument value.
			Denom string
		}
		// LinkAddresses holds details about calls to the LinkAddresses method.
		LinkAddresses []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Sender is the sender argument value.
			Sender nexus.CrossChainAddress
			// Recipient is the recipient argument value.
			Recipient nexus.CrossChainAddress
		}
		// RegisterAsset holds details about calls to the RegisterAsset method.
		RegisterAsset []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// ChainName is the chainName argument value.
			ChainName string
			// Denom is the denom argument value.
			Denom string
		}
		// SetChain holds details about calls to the SetChain method.
		SetChain []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Chain is the chain argument value.
			Chain nexus.Chain
		}
	}
	lockAddToChainTotal        sync.RWMutex
	lockArchivePendingTransfer sync.RWMutex
	lockEnqueueForTransfer     sync.RWMutex
	lockGetChain               sync.RWMutex
	lockGetRecipient           sync.RWMutex
	lockGetTransfersForChain   sync.RWMutex
	lockIsAssetRegistered      sync.RWMutex
	lockLinkAddresses          sync.RWMutex
	lockRegisterAsset          sync.RWMutex
	lockSetChain               sync.RWMutex
}

// AddToChainTotal calls AddToChainTotalFunc.
func (mock *NexusMock) AddToChainTotal(ctx sdk.Context, chain nexus.Chain, amount sdk.Coin) {
	if mock.AddToChainTotalFunc == nil {
		panic("NexusMock.AddToChainTotalFunc: method is nil but Nexus.AddToChainTotal was just called")
	}
	callInfo := struct {
		Ctx    sdk.Context
		Chain  nexus.Chain
		Amount sdk.Coin
	}{
		Ctx:    ctx,
		Chain:  chain,
		Amount: amount,
	}
	mock.lockAddToChainTotal.Lock()
	mock.calls.AddToChainTotal = append(mock.calls.AddToChainTotal, callInfo)
	mock.lockAddToChainTotal.Unlock()
	mock.AddToChainTotalFunc(ctx, chain, amount)
}

// AddToChainTotalCalls gets all the calls that were made to AddToChainTotal.
// Check the length with:
//     len(mockedNexus.AddToChainTotalCalls())
func (mock *NexusMock) AddToChainTotalCalls() []struct {
	Ctx    sdk.Context
	Chain  nexus.Chain
	Amount sdk.Coin
} {
	var calls []struct {
		Ctx    sdk.Context
		Chain  nexus.Chain
		Amount sdk.Coin
	}
	mock.lockAddToChainTotal.RLock()
	calls = mock.calls.AddToChainTotal
	mock.lockAddToChainTotal.RUnlock()
	return calls
}

// ArchivePendingTransfer calls ArchivePendingTransferFunc.
func (mock *NexusMock) ArchivePendingTransfer(ctx sdk.Context, transfer nexus.CrossChainTransfer) {
	if mock.ArchivePendingTransferFunc == nil {
		panic("NexusMock.ArchivePendingTransferFunc: method is nil but Nexus.ArchivePendingTransfer was just called")
	}
	callInfo := struct {
		Ctx      sdk.Context
		Transfer nexus.CrossChainTransfer
	}{
		Ctx:      ctx,
		Transfer: transfer,
	}
	mock.lockArchivePendingTransfer.Lock()
	mock.calls.ArchivePendingTransfer = append(mock.calls.ArchivePendingTransfer, callInfo)
	mock.lockArchivePendingTransfer.Unlock()
	mock.ArchivePendingTransferFunc(ctx, transfer)
}

// ArchivePendingTransferCalls gets all the calls that were made to ArchivePendingTransfer.
// Check the length with:
//     len(mockedNexus.ArchivePendingTransferCalls())
func (mock *NexusMock) ArchivePendingTransferCalls() []struct {
	Ctx      sdk.Context
	Transfer nexus.CrossChainTransfer
} {
	var calls []struct {
		Ctx      sdk.Context
		Transfer nexus.CrossChainTransfer
	}
	mock.lockArchivePendingTransfer.RLock()
	calls = mock.calls.ArchivePendingTransfer
	mock.lockArchivePendingTransfer.RUnlock()
	return calls
}

// EnqueueForTransfer calls EnqueueForTransferFunc.
func (mock *NexusMock) EnqueueForTransfer(ctx sdk.Context, sender nexus.CrossChainAddress, amount sdk.Coin) error {
	if mock.EnqueueForTransferFunc == nil {
		panic("NexusMock.EnqueueForTransferFunc: method is nil but Nexus.EnqueueForTransfer was just called")
	}
	callInfo := struct {
		Ctx    sdk.Context
		Sender nexus.CrossChainAddress
		Amount sdk.Coin
	}{
		Ctx:    ctx,
		Sender: sender,
		Amount: amount,
	}
	mock.lockEnqueueForTransfer.Lock()
	mock.calls.EnqueueForTransfer = append(mock.calls.EnqueueForTransfer, callInfo)
	mock.lockEnqueueForTransfer.Unlock()
	return mock.EnqueueForTransferFunc(ctx, sender, amount)
}

// EnqueueForTransferCalls gets all the calls that were made to EnqueueForTransfer.
// Check the length with:
//     len(mockedNexus.EnqueueForTransferCalls())
func (mock *NexusMock) EnqueueForTransferCalls() []struct {
	Ctx    sdk.Context
	Sender nexus.CrossChainAddress
	Amount sdk.Coin
} {
	var calls []struct {
		Ctx    sdk.Context
		Sender nexus.CrossChainAddress
		Amount sdk.Coin
	}
	mock.lockEnqueueForTransfer.RLock()
	calls = mock.calls.EnqueueForTransfer
	mock.lockEnqueueForTransfer.RUnlock()
	return calls
}

// GetChain calls GetChainFunc.
func (mock *NexusMock) GetChain(ctx sdk.Context, chain string) (nexus.Chain, bool) {
	if mock.GetChainFunc == nil {
		panic("NexusMock.GetChainFunc: method is nil but Nexus.GetChain was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		Chain string
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockGetChain.Lock()
	mock.calls.GetChain = append(mock.calls.GetChain, callInfo)
	mock.lockGetChain.Unlock()
	return mock.GetChainFunc(ctx, chain)
}

// GetChainCalls gets all the calls that were made to GetChain.
// Check the length with:
//     len(mockedNexus.GetChainCalls())
func (mock *NexusMock) GetChainCalls() []struct {
	Ctx   sdk.Context
	Chain string
} {
	var calls []struct {
		Ctx   sdk.Context
		Chain string
	}
	mock.lockGetChain.RLock()
	calls = mock.calls.GetChain
	mock.lockGetChain.RUnlock()
	return calls
}

// GetRecipient calls GetRecipientFunc.
func (mock *NexusMock) GetRecipient(ctx sdk.Context, sender nexus.CrossChainAddress) (nexus.CrossChainAddress, bool) {
	if mock.GetRecipientFunc == nil {
		panic("NexusMock.GetRecipientFunc: method is nil but Nexus.GetRecipient was just called")
	}
	callInfo := struct {
		Ctx    sdk.Context
		Sender nexus.CrossChainAddress
	}{
		Ctx:    ctx,
		Sender: sender,
	}
	mock.lockGetRecipient.Lock()
	mock.calls.GetRecipient = append(mock.calls.GetRecipient, callInfo)
	mock.lockGetRecipient.Unlock()
	return mock.GetRecipientFunc(ctx, sender)
}

// GetRecipientCalls gets all the calls that were made to GetRecipient.
// Check the length with:
//     len(mockedNexus.GetRecipientCalls())
func (mock *NexusMock) GetRecipientCalls() []struct {
	Ctx    sdk.Context
	Sender nexus.CrossChainAddress
} {
	var calls []struct {
		Ctx    sdk.Context
		Sender nexus.CrossChainAddress
	}
	mock.lockGetRecipient.RLock()
	calls = mock.calls.GetRecipient
	mock.lockGetRecipient.RUnlock()
	return calls
}

// GetTransfersForChain calls GetTransfersForChainFunc.
func (mock *NexusMock) GetTransfersForChain(ctx sdk.Context, chain nexus.Chain, state nexus.TransferState) []nexus.CrossChainTransfer {
	if mock.GetTransfersForChainFunc == nil {
		panic("NexusMock.GetTransfersForChainFunc: method is nil but Nexus.GetTransfersForChain was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		Chain nexus.Chain
		State nexus.TransferState
	}{
		Ctx:   ctx,
		Chain: chain,
		State: state,
	}
	mock.lockGetTransfersForChain.Lock()
	mock.calls.GetTransfersForChain = append(mock.calls.GetTransfersForChain, callInfo)
	mock.lockGetTransfersForChain.Unlock()
	return mock.GetTransfersForChainFunc(ctx, chain, state)
}

// GetTransfersForChainCalls gets all the calls that were made to GetTransfersForChain.
// Check the length with:
//     len(mockedNexus.GetTransfersForChainCalls())
func (mock *NexusMock) GetTransfersForChainCalls() []struct {
	Ctx   sdk.Context
	Chain nexus.Chain
	State nexus.TransferState
} {
	var calls []struct {
		Ctx   sdk.Context
		Chain nexus.Chain
		State nexus.TransferState
	}
	mock.lockGetTransfersForChain.RLock()
	calls = mock.calls.GetTransfersForChain
	mock.lockGetTransfersForChain.RUnlock()
	return calls
}

// IsAssetRegistered calls IsAssetRegisteredFunc.
func (mock *NexusMock) IsAssetRegistered(ctx sdk.Context, chainName string, denom string) bool {
	if mock.IsAssetRegisteredFunc == nil {
		panic("NexusMock.IsAssetRegisteredFunc: method is nil but Nexus.IsAssetRegistered was just called")
	}
	callInfo := struct {
		Ctx       sdk.Context
		ChainName string
		Denom     string
	}{
		Ctx:       ctx,
		ChainName: chainName,
		Denom:     denom,
	}
	mock.lockIsAssetRegistered.Lock()
	mock.calls.IsAssetRegistered = append(mock.calls.IsAssetRegistered, callInfo)
	mock.lockIsAssetRegistered.Unlock()
	return mock.IsAssetRegisteredFunc(ctx, chainName, denom)
}

// IsAssetRegisteredCalls gets all the calls that were made to IsAssetRegistered.
// Check the length with:
//     len(mockedNexus.IsAssetRegisteredCalls())
func (mock *NexusMock) IsAssetRegisteredCalls() []struct {
	Ctx       sdk.Context
	ChainName string
	Denom     string
} {
	var calls []struct {
		Ctx       sdk.Context
		ChainName string
		Denom     string
	}
	mock.lockIsAssetRegistered.RLock()
	calls = mock.calls.IsAssetRegistered
	mock.lockIsAssetRegistered.RUnlock()
	return calls
}

// LinkAddresses calls LinkAddressesFunc.
func (mock *NexusMock) LinkAddresses(ctx sdk.Context, sender nexus.CrossChainAddress, recipient nexus.CrossChainAddress) {
	if mock.LinkAddressesFunc == nil {
		panic("NexusMock.LinkAddressesFunc: method is nil but Nexus.LinkAddresses was just called")
	}
	callInfo := struct {
		Ctx       sdk.Context
		Sender    nexus.CrossChainAddress
		Recipient nexus.CrossChainAddress
	}{
		Ctx:       ctx,
		Sender:    sender,
		Recipient: recipient,
	}
	mock.lockLinkAddresses.Lock()
	mock.calls.LinkAddresses = append(mock.calls.LinkAddresses, callInfo)
	mock.lockLinkAddresses.Unlock()
	mock.LinkAddressesFunc(ctx, sender, recipient)
}

// LinkAddressesCalls gets all the calls that were made to LinkAddresses.
// Check the length with:
//     len(mockedNexus.LinkAddressesCalls())
func (mock *NexusMock) LinkAddressesCalls() []struct {
	Ctx       sdk.Context
	Sender    nexus.CrossChainAddress
	Recipient nexus.CrossChainAddress
} {
	var calls []struct {
		Ctx       sdk.Context
		Sender    nexus.CrossChainAddress
		Recipient nexus.CrossChainAddress
	}
	mock.lockLinkAddresses.RLock()
	calls = mock.calls.LinkAddresses
	mock.lockLinkAddresses.RUnlock()
	return calls
}

// RegisterAsset calls RegisterAssetFunc.
func (mock *NexusMock) RegisterAsset(ctx sdk.Context, chainName string, denom string) {
	if mock.RegisterAssetFunc == nil {
		panic("NexusMock.RegisterAssetFunc: method is nil but Nexus.RegisterAsset was just called")
	}
	callInfo := struct {
		Ctx       sdk.Context
		ChainName string
		Denom     string
	}{
		Ctx:       ctx,
		ChainName: chainName,
		Denom:     denom,
	}
	mock.lockRegisterAsset.Lock()
	mock.calls.RegisterAsset = append(mock.calls.RegisterAsset, callInfo)
	mock.lockRegisterAsset.Unlock()
	mock.RegisterAssetFunc(ctx, chainName, denom)
}

// RegisterAssetCalls gets all the calls that were made to RegisterAsset.
// Check the length with:
//     len(mockedNexus.RegisterAssetCalls())
func (mock *NexusMock) RegisterAssetCalls() []struct {
	Ctx       sdk.Context
	ChainName string
	Denom     string
} {
	var calls []struct {
		Ctx       sdk.Context
		ChainName string
		Denom     string
	}
	mock.lockRegisterAsset.RLock()
	calls = mock.calls.RegisterAsset
	mock.lockRegisterAsset.RUnlock()
	return calls
}

// SetChain calls SetChainFunc.
func (mock *NexusMock) SetChain(ctx sdk.Context, chain nexus.Chain) {
	if mock.SetChainFunc == nil {
		panic("NexusMock.SetChainFunc: method is nil but Nexus.SetChain was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		Chain nexus.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockSetChain.Lock()
	mock.calls.SetChain = append(mock.calls.SetChain, callInfo)
	mock.lockSetChain.Unlock()
	mock.SetChainFunc(ctx, chain)
}

// SetChainCalls gets all the calls that were made to SetChain.
// Check the length with:
//     len(mockedNexus.SetChainCalls())
func (mock *NexusMock) SetChainCalls() []struct {
	Ctx   sdk.Context
	Chain nexus.Chain
} {
	var calls []struct {
		Ctx   sdk.Context
		Chain nexus.Chain
	}
	mock.lockSetChain.RLock()
	calls = mock.calls.SetChain
	mock.lockSetChain.RUnlock()
	return calls
}

// Ensure, that BankKeeperMock does implement axelarnettypes.BankKeeper.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.BankKeeper = &BankKeeperMock{}

// BankKeeperMock is a mock implementation of axelarnettypes.BankKeeper.
//
// 	func TestSomethingThatUsesBankKeeper(t *testing.T) {
//
// 		// make and configure a mocked axelarnettypes.BankKeeper
// 		mockedBankKeeper := &BankKeeperMock{
// 			BurnCoinsFunc: func(ctx sdk.Context, moduleName string, amt sdk.Coins) error {
// 				panic("mock out the BurnCoins method")
// 			},
// 			MintCoinsFunc: func(ctx sdk.Context, moduleName string, amt sdk.Coins) error {
// 				panic("mock out the MintCoins method")
// 			},
// 			SendCoinsFunc: func(ctx sdk.Context, fromAddr sdk.AccAddress, toAddr sdk.AccAddress, amt sdk.Coins) error {
// 				panic("mock out the SendCoins method")
// 			},
// 			SendCoinsFromAccountToModuleFunc: func(ctx sdk.Context, senderAddr sdk.AccAddress, recipientModule string, amt sdk.Coins) error {
// 				panic("mock out the SendCoinsFromAccountToModule method")
// 			},
// 			SendCoinsFromModuleToAccountFunc: func(ctx sdk.Context, senderModule string, recipientAddr sdk.AccAddress, amt sdk.Coins) error {
// 				panic("mock out the SendCoinsFromModuleToAccount method")
// 			},
// 		}
//
// 		// use mockedBankKeeper in code that requires axelarnettypes.BankKeeper
// 		// and then make assertions.
//
// 	}
type BankKeeperMock struct {
	// BurnCoinsFunc mocks the BurnCoins method.
	BurnCoinsFunc func(ctx sdk.Context, moduleName string, amt sdk.Coins) error

	// MintCoinsFunc mocks the MintCoins method.
	MintCoinsFunc func(ctx sdk.Context, moduleName string, amt sdk.Coins) error

	// SendCoinsFunc mocks the SendCoins method.
	SendCoinsFunc func(ctx sdk.Context, fromAddr sdk.AccAddress, toAddr sdk.AccAddress, amt sdk.Coins) error

	// SendCoinsFromAccountToModuleFunc mocks the SendCoinsFromAccountToModule method.
	SendCoinsFromAccountToModuleFunc func(ctx sdk.Context, senderAddr sdk.AccAddress, recipientModule string, amt sdk.Coins) error

	// SendCoinsFromModuleToAccountFunc mocks the SendCoinsFromModuleToAccount method.
	SendCoinsFromModuleToAccountFunc func(ctx sdk.Context, senderModule string, recipientAddr sdk.AccAddress, amt sdk.Coins) error

	// calls tracks calls to the methods.
	calls struct {
		// BurnCoins holds details about calls to the BurnCoins method.
		BurnCoins []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// ModuleName is the moduleName argument value.
			ModuleName string
			// Amt is the amt argument value.
			Amt sdk.Coins
		}
		// MintCoins holds details about calls to the MintCoins method.
		MintCoins []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// ModuleName is the moduleName argument value.
			ModuleName string
			// Amt is the amt argument value.
			Amt sdk.Coins
		}
		// SendCoins holds details about calls to the SendCoins method.
		SendCoins []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// FromAddr is the fromAddr argument value.
			FromAddr sdk.AccAddress
			// ToAddr is the toAddr argument value.
			ToAddr sdk.AccAddress
			// Amt is the amt argument value.
			Amt sdk.Coins
		}
		// SendCoinsFromAccountToModule holds details about calls to the SendCoinsFromAccountToModule method.
		SendCoinsFromAccountToModule []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// SenderAddr is the senderAddr argument value.
			SenderAddr sdk.AccAddress
			// RecipientModule is the recipientModule argument value.
			RecipientModule string
			// Amt is the amt argument value.
			Amt sdk.Coins
		}
		// SendCoinsFromModuleToAccount holds details about calls to the SendCoinsFromModuleToAccount method.
		SendCoinsFromModuleToAccount []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// SenderModule is the senderModule argument value.
			SenderModule string
			// RecipientAddr is the recipientAddr argument value.
			RecipientAddr sdk.AccAddress
			// Amt is the amt argument value.
			Amt sdk.Coins
		}
	}
	lockBurnCoins                    sync.RWMutex
	lockMintCoins                    sync.RWMutex
	lockSendCoins                    sync.RWMutex
	lockSendCoinsFromAccountToModule sync.RWMutex
	lockSendCoinsFromModuleToAccount sync.RWMutex
}

// BurnCoins calls BurnCoinsFunc.
func (mock *BankKeeperMock) BurnCoins(ctx sdk.Context, moduleName string, amt sdk.Coins) error {
	if mock.BurnCoinsFunc == nil {
		panic("BankKeeperMock.BurnCoinsFunc: method is nil but BankKeeper.BurnCoins was just called")
	}
	callInfo := struct {
		Ctx        sdk.Context
		ModuleName string
		Amt        sdk.Coins
	}{
		Ctx:        ctx,
		ModuleName: moduleName,
		Amt:        amt,
	}
	mock.lockBurnCoins.Lock()
	mock.calls.BurnCoins = append(mock.calls.BurnCoins, callInfo)
	mock.lockBurnCoins.Unlock()
	return mock.BurnCoinsFunc(ctx, moduleName, amt)
}

// BurnCoinsCalls gets all the calls that were made to BurnCoins.
// Check the length with:
//     len(mockedBankKeeper.BurnCoinsCalls())
func (mock *BankKeeperMock) BurnCoinsCalls() []struct {
	Ctx        sdk.Context
	ModuleName string
	Amt        sdk.Coins
} {
	var calls []struct {
		Ctx        sdk.Context
		ModuleName string
		Amt        sdk.Coins
	}
	mock.lockBurnCoins.RLock()
	calls = mock.calls.BurnCoins
	mock.lockBurnCoins.RUnlock()
	return calls
}

// MintCoins calls MintCoinsFunc.
func (mock *BankKeeperMock) MintCoins(ctx sdk.Context, moduleName string, amt sdk.Coins) error {
	if mock.MintCoinsFunc == nil {
		panic("BankKeeperMock.MintCoinsFunc: method is nil but BankKeeper.MintCoins was just called")
	}
	callInfo := struct {
		Ctx        sdk.Context
		ModuleName string
		Amt        sdk.Coins
	}{
		Ctx:        ctx,
		ModuleName: moduleName,
		Amt:        amt,
	}
	mock.lockMintCoins.Lock()
	mock.calls.MintCoins = append(mock.calls.MintCoins, callInfo)
	mock.lockMintCoins.Unlock()
	return mock.MintCoinsFunc(ctx, moduleName, amt)
}

// MintCoinsCalls gets all the calls that were made to MintCoins.
// Check the length with:
//     len(mockedBankKeeper.MintCoinsCalls())
func (mock *BankKeeperMock) MintCoinsCalls() []struct {
	Ctx        sdk.Context
	ModuleName string
	Amt        sdk.Coins
} {
	var calls []struct {
		Ctx        sdk.Context
		ModuleName string
		Amt        sdk.Coins
	}
	mock.lockMintCoins.RLock()
	calls = mock.calls.MintCoins
	mock.lockMintCoins.RUnlock()
	return calls
}

// SendCoins calls SendCoinsFunc.
func (mock *BankKeeperMock) SendCoins(ctx sdk.Context, fromAddr sdk.AccAddress, toAddr sdk.AccAddress, amt sdk.Coins) error {
	if mock.SendCoinsFunc == nil {
		panic("BankKeeperMock.SendCoinsFunc: method is nil but BankKeeper.SendCoins was just called")
	}
	callInfo := struct {
		Ctx      sdk.Context
		FromAddr sdk.AccAddress
		ToAddr   sdk.AccAddress
		Amt      sdk.Coins
	}{
		Ctx:      ctx,
		FromAddr: fromAddr,
		ToAddr:   toAddr,
		Amt:      amt,
	}
	mock.lockSendCoins.Lock()
	mock.calls.SendCoins = append(mock.calls.SendCoins, callInfo)
	mock.lockSendCoins.Unlock()
	return mock.SendCoinsFunc(ctx, fromAddr, toAddr, amt)
}

// SendCoinsCalls gets all the calls that were made to SendCoins.
// Check the length with:
//     len(mockedBankKeeper.SendCoinsCalls())
func (mock *BankKeeperMock) SendCoinsCalls() []struct {
	Ctx      sdk.Context
	FromAddr sdk.AccAddress
	ToAddr   sdk.AccAddress
	Amt      sdk.Coins
} {
	var calls []struct {
		Ctx      sdk.Context
		FromAddr sdk.AccAddress
		ToAddr   sdk.AccAddress
		Amt      sdk.Coins
	}
	mock.lockSendCoins.RLock()
	calls = mock.calls.SendCoins
	mock.lockSendCoins.RUnlock()
	return calls
}

// SendCoinsFromAccountToModule calls SendCoinsFromAccountToModuleFunc.
func (mock *BankKeeperMock) SendCoinsFromAccountToModule(ctx sdk.Context, senderAddr sdk.AccAddress, recipientModule string, amt sdk.Coins) error {
	if mock.SendCoinsFromAccountToModuleFunc == nil {
		panic("BankKeeperMock.SendCoinsFromAccountToModuleFunc: method is nil but BankKeeper.SendCoinsFromAccountToModule was just called")
	}
	callInfo := struct {
		Ctx             sdk.Context
		SenderAddr      sdk.AccAddress
		RecipientModule string
		Amt             sdk.Coins
	}{
		Ctx:             ctx,
		SenderAddr:      senderAddr,
		RecipientModule: recipientModule,
		Amt:             amt,
	}
	mock.lockSendCoinsFromAccountToModule.Lock()
	mock.calls.SendCoinsFromAccountToModule = append(mock.calls.SendCoinsFromAccountToModule, callInfo)
	mock.lockSendCoinsFromAccountToModule.Unlock()
	return mock.SendCoinsFromAccountToModuleFunc(ctx, senderAddr, recipientModule, amt)
}

// SendCoinsFromAccountToModuleCalls gets all the calls that were made to SendCoinsFromAccountToModule.
// Check the length with:
//     len(mockedBankKeeper.SendCoinsFromAccountToModuleCalls())
func (mock *BankKeeperMock) SendCoinsFromAccountToModuleCalls() []struct {
	Ctx             sdk.Context
	SenderAddr      sdk.AccAddress
	RecipientModule string
	Amt             sdk.Coins
} {
	var calls []struct {
		Ctx             sdk.Context
		SenderAddr      sdk.AccAddress
		RecipientModule string
		Amt             sdk.Coins
	}
	mock.lockSendCoinsFromAccountToModule.RLock()
	calls = mock.calls.SendCoinsFromAccountToModule
	mock.lockSendCoinsFromAccountToModule.RUnlock()
	return calls
}

// SendCoinsFromModuleToAccount calls SendCoinsFromModuleToAccountFunc.
func (mock *BankKeeperMock) SendCoinsFromModuleToAccount(ctx sdk.Context, senderModule string, recipientAddr sdk.AccAddress, amt sdk.Coins) error {
	if mock.SendCoinsFromModuleToAccountFunc == nil {
		panic("BankKeeperMock.SendCoinsFromModuleToAccountFunc: method is nil but BankKeeper.SendCoinsFromModuleToAccount was just called")
	}
	callInfo := struct {
		Ctx           sdk.Context
		SenderModule  string
		RecipientAddr sdk.AccAddress
		Amt           sdk.Coins
	}{
		Ctx:           ctx,
		SenderModule:  senderModule,
		RecipientAddr: recipientAddr,
		Amt:           amt,
	}
	mock.lockSendCoinsFromModuleToAccount.Lock()
	mock.calls.SendCoinsFromModuleToAccount = append(mock.calls.SendCoinsFromModuleToAccount, callInfo)
	mock.lockSendCoinsFromModuleToAccount.Unlock()
	return mock.SendCoinsFromModuleToAccountFunc(ctx, senderModule, recipientAddr, amt)
}

// SendCoinsFromModuleToAccountCalls gets all the calls that were made to SendCoinsFromModuleToAccount.
// Check the length with:
//     len(mockedBankKeeper.SendCoinsFromModuleToAccountCalls())
func (mock *BankKeeperMock) SendCoinsFromModuleToAccountCalls() []struct {
	Ctx           sdk.Context
	SenderModule  string
	RecipientAddr sdk.AccAddress
	Amt           sdk.Coins
} {
	var calls []struct {
		Ctx           sdk.Context
		SenderModule  string
		RecipientAddr sdk.AccAddress
		Amt           sdk.Coins
	}
	mock.lockSendCoinsFromModuleToAccount.RLock()
	calls = mock.calls.SendCoinsFromModuleToAccount
	mock.lockSendCoinsFromModuleToAccount.RUnlock()
	return calls
}

// Ensure, that IBCTransferKeeperMock does implement axelarnettypes.IBCTransferKeeper.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.IBCTransferKeeper = &IBCTransferKeeperMock{}

// IBCTransferKeeperMock is a mock implementation of axelarnettypes.IBCTransferKeeper.
//
// 	func TestSomethingThatUsesIBCTransferKeeper(t *testing.T) {
//
// 		// make and configure a mocked axelarnettypes.IBCTransferKeeper
// 		mockedIBCTransferKeeper := &IBCTransferKeeperMock{
// 			GetDenomTraceFunc: func(ctx sdk.Context, denomTraceHash tmbytes.HexBytes) (transfertypes.DenomTrace, bool) {
// 				panic("mock out the GetDenomTrace method")
// 			},
// 		}
//
// 		// use mockedIBCTransferKeeper in code that requires axelarnettypes.IBCTransferKeeper
// 		// and then make assertions.
//
// 	}
type IBCTransferKeeperMock struct {
	// GetDenomTraceFunc mocks the GetDenomTrace method.
	GetDenomTraceFunc func(ctx sdk.Context, denomTraceHash tmbytes.HexBytes) (transfertypes.DenomTrace, bool)

	// calls tracks calls to the methods.
	calls struct {
		// GetDenomTrace holds details about calls to the GetDenomTrace method.
		GetDenomTrace []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// DenomTraceHash is the denomTraceHash argument value.
			DenomTraceHash tmbytes.HexBytes
		}
	}
	lockGetDenomTrace sync.RWMutex
}

// GetDenomTrace calls GetDenomTraceFunc.
func (mock *IBCTransferKeeperMock) GetDenomTrace(ctx sdk.Context, denomTraceHash tmbytes.HexBytes) (transfertypes.DenomTrace, bool) {
	if mock.GetDenomTraceFunc == nil {
		panic("IBCTransferKeeperMock.GetDenomTraceFunc: method is nil but IBCTransferKeeper.GetDenomTrace was just called")
	}
	callInfo := struct {
		Ctx            sdk.Context
		DenomTraceHash tmbytes.HexBytes
	}{
		Ctx:            ctx,
		DenomTraceHash: denomTraceHash,
	}
	mock.lockGetDenomTrace.Lock()
	mock.calls.GetDenomTrace = append(mock.calls.GetDenomTrace, callInfo)
	mock.lockGetDenomTrace.Unlock()
	return mock.GetDenomTraceFunc(ctx, denomTraceHash)
}

// GetDenomTraceCalls gets all the calls that were made to GetDenomTrace.
// Check the length with:
//     len(mockedIBCTransferKeeper.GetDenomTraceCalls())
func (mock *IBCTransferKeeperMock) GetDenomTraceCalls() []struct {
	Ctx            sdk.Context
	DenomTraceHash tmbytes.HexBytes
} {
	var calls []struct {
		Ctx            sdk.Context
		DenomTraceHash tmbytes.HexBytes
	}
	mock.lockGetDenomTrace.RLock()
	calls = mock.calls.GetDenomTrace
	mock.lockGetDenomTrace.RUnlock()
	return calls
}
