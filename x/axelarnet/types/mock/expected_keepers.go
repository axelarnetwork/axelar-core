// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	context "context"
	utils "github.com/axelarnetwork/axelar-core/utils"
	axelarnettypes "github.com/axelarnetwork/axelar-core/x/axelarnet/types"
	github_com_axelarnetwork_axelar_core_x_nexus_exported "github.com/axelarnetwork/axelar-core/x/nexus/exported"
	cosmossdktypes "github.com/cosmos/cosmos-sdk/types"
	"github.com/cosmos/cosmos-sdk/types/query"
	"github.com/cosmos/cosmos-sdk/x/auth/types"
	capabilitytypes "github.com/cosmos/cosmos-sdk/x/capability/types"
	gov "github.com/cosmos/cosmos-sdk/x/gov/types"
	ibctransfertypes "github.com/cosmos/ibc-go/v4/modules/apps/transfer/types"
	clienttypes "github.com/cosmos/ibc-go/v4/modules/core/02-client/types"
	channeltypes "github.com/cosmos/ibc-go/v4/modules/core/04-channel/types"
	ibcexported "github.com/cosmos/ibc-go/v4/modules/core/exported"
	tmbytes "github.com/tendermint/tendermint/libs/bytes"
	"github.com/tendermint/tendermint/libs/log"
	"sync"
	time "time"
)

// Ensure, that BaseKeeperMock does implement axelarnettypes.BaseKeeper.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.BaseKeeper = &BaseKeeperMock{}

// BaseKeeperMock is a mock implementation of axelarnettypes.BaseKeeper.
//
//	func TestSomethingThatUsesBaseKeeper(t *testing.T) {
//
//		// make and configure a mocked axelarnettypes.BaseKeeper
//		mockedBaseKeeper := &BaseKeeperMock{
//			EnqueueIBCTransferFunc: func(ctx cosmossdktypes.Context, transfer axelarnettypes.IBCTransfer) error {
//				panic("mock out the EnqueueIBCTransfer method")
//			},
//			GetChainNameByIBCPathFunc: func(ctx cosmossdktypes.Context, ibcPath string) (github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName, bool) {
//				panic("mock out the GetChainNameByIBCPath method")
//			},
//			GetCosmosChainByNameFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (axelarnettypes.CosmosChain, bool) {
//				panic("mock out the GetCosmosChainByName method")
//			},
//			GetCosmosChainsFunc: func(ctx cosmossdktypes.Context) []github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName {
//				panic("mock out the GetCosmosChains method")
//			},
//			GetEndBlockerLimitFunc: func(ctx cosmossdktypes.Context) uint64 {
//				panic("mock out the GetEndBlockerLimit method")
//			},
//			GetIBCPathFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (string, bool) {
//				panic("mock out the GetIBCPath method")
//			},
//			GetIBCTransferQueueFunc: func(ctx cosmossdktypes.Context) utils.KVQueue {
//				panic("mock out the GetIBCTransferQueue method")
//			},
//			GetParamsFunc: func(ctx cosmossdktypes.Context) axelarnettypes.Params {
//				panic("mock out the GetParams method")
//			},
//			GetRouteTimeoutWindowFunc: func(ctx cosmossdktypes.Context) uint64 {
//				panic("mock out the GetRouteTimeoutWindow method")
//			},
//			GetTransferLimitFunc: func(ctx cosmossdktypes.Context) uint64 {
//				panic("mock out the GetTransferLimit method")
//			},
//			LoggerFunc: func(ctx cosmossdktypes.Context) log.Logger {
//				panic("mock out the Logger method")
//			},
//			SetSeqIDMappingFunc: func(ctx cosmossdktypes.Context, t axelarnettypes.IBCTransfer) error {
//				panic("mock out the SetSeqIDMapping method")
//			},
//			SetTransferFailedFunc: func(ctx cosmossdktypes.Context, transferID github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferID) error {
//				panic("mock out the SetTransferFailed method")
//			},
//		}
//
//		// use mockedBaseKeeper in code that requires axelarnettypes.BaseKeeper
//		// and then make assertions.
//
//	}
type BaseKeeperMock struct {
	// EnqueueIBCTransferFunc mocks the EnqueueIBCTransfer method.
	EnqueueIBCTransferFunc func(ctx cosmossdktypes.Context, transfer axelarnettypes.IBCTransfer) error

	// GetChainNameByIBCPathFunc mocks the GetChainNameByIBCPath method.
	GetChainNameByIBCPathFunc func(ctx cosmossdktypes.Context, ibcPath string) (github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName, bool)

	// GetCosmosChainByNameFunc mocks the GetCosmosChainByName method.
	GetCosmosChainByNameFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (axelarnettypes.CosmosChain, bool)

	// GetCosmosChainsFunc mocks the GetCosmosChains method.
	GetCosmosChainsFunc func(ctx cosmossdktypes.Context) []github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName

	// GetEndBlockerLimitFunc mocks the GetEndBlockerLimit method.
	GetEndBlockerLimitFunc func(ctx cosmossdktypes.Context) uint64

	// GetIBCPathFunc mocks the GetIBCPath method.
	GetIBCPathFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (string, bool)

	// GetIBCTransferQueueFunc mocks the GetIBCTransferQueue method.
	GetIBCTransferQueueFunc func(ctx cosmossdktypes.Context) utils.KVQueue

	// GetParamsFunc mocks the GetParams method.
	GetParamsFunc func(ctx cosmossdktypes.Context) axelarnettypes.Params

	// GetRouteTimeoutWindowFunc mocks the GetRouteTimeoutWindow method.
	GetRouteTimeoutWindowFunc func(ctx cosmossdktypes.Context) uint64

	// GetTransferLimitFunc mocks the GetTransferLimit method.
	GetTransferLimitFunc func(ctx cosmossdktypes.Context) uint64

	// LoggerFunc mocks the Logger method.
	LoggerFunc func(ctx cosmossdktypes.Context) log.Logger

	// SetSeqIDMappingFunc mocks the SetSeqIDMapping method.
	SetSeqIDMappingFunc func(ctx cosmossdktypes.Context, t axelarnettypes.IBCTransfer) error

	// SetTransferFailedFunc mocks the SetTransferFailed method.
	SetTransferFailedFunc func(ctx cosmossdktypes.Context, transferID github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferID) error

	// calls tracks calls to the methods.
	calls struct {
		// EnqueueIBCTransfer holds details about calls to the EnqueueIBCTransfer method.
		EnqueueIBCTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Transfer is the transfer argument value.
			Transfer axelarnettypes.IBCTransfer
		}
		// GetChainNameByIBCPath holds details about calls to the GetChainNameByIBCPath method.
		GetChainNameByIBCPath []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// IbcPath is the ibcPath argument value.
			IbcPath string
		}
		// GetCosmosChainByName holds details about calls to the GetCosmosChainByName method.
		GetCosmosChainByName []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
		}
		// GetCosmosChains holds details about calls to the GetCosmosChains method.
		GetCosmosChains []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// GetEndBlockerLimit holds details about calls to the GetEndBlockerLimit method.
		GetEndBlockerLimit []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// GetIBCPath holds details about calls to the GetIBCPath method.
		GetIBCPath []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
		}
		// GetIBCTransferQueue holds details about calls to the GetIBCTransferQueue method.
		GetIBCTransferQueue []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// GetParams holds details about calls to the GetParams method.
		GetParams []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// GetRouteTimeoutWindow holds details about calls to the GetRouteTimeoutWindow method.
		GetRouteTimeoutWindow []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// GetTransferLimit holds details about calls to the GetTransferLimit method.
		GetTransferLimit []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// Logger holds details about calls to the Logger method.
		Logger []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// SetSeqIDMapping holds details about calls to the SetSeqIDMapping method.
		SetSeqIDMapping []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// T is the t argument value.
			T axelarnettypes.IBCTransfer
		}
		// SetTransferFailed holds details about calls to the SetTransferFailed method.
		SetTransferFailed []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// TransferID is the transferID argument value.
			TransferID github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferID
		}
	}
	lockEnqueueIBCTransfer    sync.RWMutex
	lockGetChainNameByIBCPath sync.RWMutex
	lockGetCosmosChainByName  sync.RWMutex
	lockGetCosmosChains       sync.RWMutex
	lockGetEndBlockerLimit    sync.RWMutex
	lockGetIBCPath            sync.RWMutex
	lockGetIBCTransferQueue   sync.RWMutex
	lockGetParams             sync.RWMutex
	lockGetRouteTimeoutWindow sync.RWMutex
	lockGetTransferLimit      sync.RWMutex
	lockLogger                sync.RWMutex
	lockSetSeqIDMapping       sync.RWMutex
	lockSetTransferFailed     sync.RWMutex
}

// EnqueueIBCTransfer calls EnqueueIBCTransferFunc.
func (mock *BaseKeeperMock) EnqueueIBCTransfer(ctx cosmossdktypes.Context, transfer axelarnettypes.IBCTransfer) error {
	if mock.EnqueueIBCTransferFunc == nil {
		panic("BaseKeeperMock.EnqueueIBCTransferFunc: method is nil but BaseKeeper.EnqueueIBCTransfer was just called")
	}
	callInfo := struct {
		Ctx      cosmossdktypes.Context
		Transfer axelarnettypes.IBCTransfer
	}{
		Ctx:      ctx,
		Transfer: transfer,
	}
	mock.lockEnqueueIBCTransfer.Lock()
	mock.calls.EnqueueIBCTransfer = append(mock.calls.EnqueueIBCTransfer, callInfo)
	mock.lockEnqueueIBCTransfer.Unlock()
	return mock.EnqueueIBCTransferFunc(ctx, transfer)
}

// EnqueueIBCTransferCalls gets all the calls that were made to EnqueueIBCTransfer.
// Check the length with:
//
//	len(mockedBaseKeeper.EnqueueIBCTransferCalls())
func (mock *BaseKeeperMock) EnqueueIBCTransferCalls() []struct {
	Ctx      cosmossdktypes.Context
	Transfer axelarnettypes.IBCTransfer
} {
	var calls []struct {
		Ctx      cosmossdktypes.Context
		Transfer axelarnettypes.IBCTransfer
	}
	mock.lockEnqueueIBCTransfer.RLock()
	calls = mock.calls.EnqueueIBCTransfer
	mock.lockEnqueueIBCTransfer.RUnlock()
	return calls
}

// GetChainNameByIBCPath calls GetChainNameByIBCPathFunc.
func (mock *BaseKeeperMock) GetChainNameByIBCPath(ctx cosmossdktypes.Context, ibcPath string) (github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName, bool) {
	if mock.GetChainNameByIBCPathFunc == nil {
		panic("BaseKeeperMock.GetChainNameByIBCPathFunc: method is nil but BaseKeeper.GetChainNameByIBCPath was just called")
	}
	callInfo := struct {
		Ctx     cosmossdktypes.Context
		IbcPath string
	}{
		Ctx:     ctx,
		IbcPath: ibcPath,
	}
	mock.lockGetChainNameByIBCPath.Lock()
	mock.calls.GetChainNameByIBCPath = append(mock.calls.GetChainNameByIBCPath, callInfo)
	mock.lockGetChainNameByIBCPath.Unlock()
	return mock.GetChainNameByIBCPathFunc(ctx, ibcPath)
}

// GetChainNameByIBCPathCalls gets all the calls that were made to GetChainNameByIBCPath.
// Check the length with:
//
//	len(mockedBaseKeeper.GetChainNameByIBCPathCalls())
func (mock *BaseKeeperMock) GetChainNameByIBCPathCalls() []struct {
	Ctx     cosmossdktypes.Context
	IbcPath string
} {
	var calls []struct {
		Ctx     cosmossdktypes.Context
		IbcPath string
	}
	mock.lockGetChainNameByIBCPath.RLock()
	calls = mock.calls.GetChainNameByIBCPath
	mock.lockGetChainNameByIBCPath.RUnlock()
	return calls
}

// GetCosmosChainByName calls GetCosmosChainByNameFunc.
func (mock *BaseKeeperMock) GetCosmosChainByName(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (axelarnettypes.CosmosChain, bool) {
	if mock.GetCosmosChainByNameFunc == nil {
		panic("BaseKeeperMock.GetCosmosChainByNameFunc: method is nil but BaseKeeper.GetCosmosChainByName was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockGetCosmosChainByName.Lock()
	mock.calls.GetCosmosChainByName = append(mock.calls.GetCosmosChainByName, callInfo)
	mock.lockGetCosmosChainByName.Unlock()
	return mock.GetCosmosChainByNameFunc(ctx, chain)
}

// GetCosmosChainByNameCalls gets all the calls that were made to GetCosmosChainByName.
// Check the length with:
//
//	len(mockedBaseKeeper.GetCosmosChainByNameCalls())
func (mock *BaseKeeperMock) GetCosmosChainByNameCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}
	mock.lockGetCosmosChainByName.RLock()
	calls = mock.calls.GetCosmosChainByName
	mock.lockGetCosmosChainByName.RUnlock()
	return calls
}

// GetCosmosChains calls GetCosmosChainsFunc.
func (mock *BaseKeeperMock) GetCosmosChains(ctx cosmossdktypes.Context) []github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName {
	if mock.GetCosmosChainsFunc == nil {
		panic("BaseKeeperMock.GetCosmosChainsFunc: method is nil but BaseKeeper.GetCosmosChains was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetCosmosChains.Lock()
	mock.calls.GetCosmosChains = append(mock.calls.GetCosmosChains, callInfo)
	mock.lockGetCosmosChains.Unlock()
	return mock.GetCosmosChainsFunc(ctx)
}

// GetCosmosChainsCalls gets all the calls that were made to GetCosmosChains.
// Check the length with:
//
//	len(mockedBaseKeeper.GetCosmosChainsCalls())
func (mock *BaseKeeperMock) GetCosmosChainsCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockGetCosmosChains.RLock()
	calls = mock.calls.GetCosmosChains
	mock.lockGetCosmosChains.RUnlock()
	return calls
}

// GetEndBlockerLimit calls GetEndBlockerLimitFunc.
func (mock *BaseKeeperMock) GetEndBlockerLimit(ctx cosmossdktypes.Context) uint64 {
	if mock.GetEndBlockerLimitFunc == nil {
		panic("BaseKeeperMock.GetEndBlockerLimitFunc: method is nil but BaseKeeper.GetEndBlockerLimit was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetEndBlockerLimit.Lock()
	mock.calls.GetEndBlockerLimit = append(mock.calls.GetEndBlockerLimit, callInfo)
	mock.lockGetEndBlockerLimit.Unlock()
	return mock.GetEndBlockerLimitFunc(ctx)
}

// GetEndBlockerLimitCalls gets all the calls that were made to GetEndBlockerLimit.
// Check the length with:
//
//	len(mockedBaseKeeper.GetEndBlockerLimitCalls())
func (mock *BaseKeeperMock) GetEndBlockerLimitCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockGetEndBlockerLimit.RLock()
	calls = mock.calls.GetEndBlockerLimit
	mock.lockGetEndBlockerLimit.RUnlock()
	return calls
}

// GetIBCPath calls GetIBCPathFunc.
func (mock *BaseKeeperMock) GetIBCPath(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (string, bool) {
	if mock.GetIBCPathFunc == nil {
		panic("BaseKeeperMock.GetIBCPathFunc: method is nil but BaseKeeper.GetIBCPath was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockGetIBCPath.Lock()
	mock.calls.GetIBCPath = append(mock.calls.GetIBCPath, callInfo)
	mock.lockGetIBCPath.Unlock()
	return mock.GetIBCPathFunc(ctx, chain)
}

// GetIBCPathCalls gets all the calls that were made to GetIBCPath.
// Check the length with:
//
//	len(mockedBaseKeeper.GetIBCPathCalls())
func (mock *BaseKeeperMock) GetIBCPathCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}
	mock.lockGetIBCPath.RLock()
	calls = mock.calls.GetIBCPath
	mock.lockGetIBCPath.RUnlock()
	return calls
}

// GetIBCTransferQueue calls GetIBCTransferQueueFunc.
func (mock *BaseKeeperMock) GetIBCTransferQueue(ctx cosmossdktypes.Context) utils.KVQueue {
	if mock.GetIBCTransferQueueFunc == nil {
		panic("BaseKeeperMock.GetIBCTransferQueueFunc: method is nil but BaseKeeper.GetIBCTransferQueue was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetIBCTransferQueue.Lock()
	mock.calls.GetIBCTransferQueue = append(mock.calls.GetIBCTransferQueue, callInfo)
	mock.lockGetIBCTransferQueue.Unlock()
	return mock.GetIBCTransferQueueFunc(ctx)
}

// GetIBCTransferQueueCalls gets all the calls that were made to GetIBCTransferQueue.
// Check the length with:
//
//	len(mockedBaseKeeper.GetIBCTransferQueueCalls())
func (mock *BaseKeeperMock) GetIBCTransferQueueCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockGetIBCTransferQueue.RLock()
	calls = mock.calls.GetIBCTransferQueue
	mock.lockGetIBCTransferQueue.RUnlock()
	return calls
}

// GetParams calls GetParamsFunc.
func (mock *BaseKeeperMock) GetParams(ctx cosmossdktypes.Context) axelarnettypes.Params {
	if mock.GetParamsFunc == nil {
		panic("BaseKeeperMock.GetParamsFunc: method is nil but BaseKeeper.GetParams was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetParams.Lock()
	mock.calls.GetParams = append(mock.calls.GetParams, callInfo)
	mock.lockGetParams.Unlock()
	return mock.GetParamsFunc(ctx)
}

// GetParamsCalls gets all the calls that were made to GetParams.
// Check the length with:
//
//	len(mockedBaseKeeper.GetParamsCalls())
func (mock *BaseKeeperMock) GetParamsCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockGetParams.RLock()
	calls = mock.calls.GetParams
	mock.lockGetParams.RUnlock()
	return calls
}

// GetRouteTimeoutWindow calls GetRouteTimeoutWindowFunc.
func (mock *BaseKeeperMock) GetRouteTimeoutWindow(ctx cosmossdktypes.Context) uint64 {
	if mock.GetRouteTimeoutWindowFunc == nil {
		panic("BaseKeeperMock.GetRouteTimeoutWindowFunc: method is nil but BaseKeeper.GetRouteTimeoutWindow was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetRouteTimeoutWindow.Lock()
	mock.calls.GetRouteTimeoutWindow = append(mock.calls.GetRouteTimeoutWindow, callInfo)
	mock.lockGetRouteTimeoutWindow.Unlock()
	return mock.GetRouteTimeoutWindowFunc(ctx)
}

// GetRouteTimeoutWindowCalls gets all the calls that were made to GetRouteTimeoutWindow.
// Check the length with:
//
//	len(mockedBaseKeeper.GetRouteTimeoutWindowCalls())
func (mock *BaseKeeperMock) GetRouteTimeoutWindowCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockGetRouteTimeoutWindow.RLock()
	calls = mock.calls.GetRouteTimeoutWindow
	mock.lockGetRouteTimeoutWindow.RUnlock()
	return calls
}

// GetTransferLimit calls GetTransferLimitFunc.
func (mock *BaseKeeperMock) GetTransferLimit(ctx cosmossdktypes.Context) uint64 {
	if mock.GetTransferLimitFunc == nil {
		panic("BaseKeeperMock.GetTransferLimitFunc: method is nil but BaseKeeper.GetTransferLimit was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetTransferLimit.Lock()
	mock.calls.GetTransferLimit = append(mock.calls.GetTransferLimit, callInfo)
	mock.lockGetTransferLimit.Unlock()
	return mock.GetTransferLimitFunc(ctx)
}

// GetTransferLimitCalls gets all the calls that were made to GetTransferLimit.
// Check the length with:
//
//	len(mockedBaseKeeper.GetTransferLimitCalls())
func (mock *BaseKeeperMock) GetTransferLimitCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockGetTransferLimit.RLock()
	calls = mock.calls.GetTransferLimit
	mock.lockGetTransferLimit.RUnlock()
	return calls
}

// Logger calls LoggerFunc.
func (mock *BaseKeeperMock) Logger(ctx cosmossdktypes.Context) log.Logger {
	if mock.LoggerFunc == nil {
		panic("BaseKeeperMock.LoggerFunc: method is nil but BaseKeeper.Logger was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockLogger.Lock()
	mock.calls.Logger = append(mock.calls.Logger, callInfo)
	mock.lockLogger.Unlock()
	return mock.LoggerFunc(ctx)
}

// LoggerCalls gets all the calls that were made to Logger.
// Check the length with:
//
//	len(mockedBaseKeeper.LoggerCalls())
func (mock *BaseKeeperMock) LoggerCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockLogger.RLock()
	calls = mock.calls.Logger
	mock.lockLogger.RUnlock()
	return calls
}

// SetSeqIDMapping calls SetSeqIDMappingFunc.
func (mock *BaseKeeperMock) SetSeqIDMapping(ctx cosmossdktypes.Context, t axelarnettypes.IBCTransfer) error {
	if mock.SetSeqIDMappingFunc == nil {
		panic("BaseKeeperMock.SetSeqIDMappingFunc: method is nil but BaseKeeper.SetSeqIDMapping was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
		T   axelarnettypes.IBCTransfer
	}{
		Ctx: ctx,
		T:   t,
	}
	mock.lockSetSeqIDMapping.Lock()
	mock.calls.SetSeqIDMapping = append(mock.calls.SetSeqIDMapping, callInfo)
	mock.lockSetSeqIDMapping.Unlock()
	return mock.SetSeqIDMappingFunc(ctx, t)
}

// SetSeqIDMappingCalls gets all the calls that were made to SetSeqIDMapping.
// Check the length with:
//
//	len(mockedBaseKeeper.SetSeqIDMappingCalls())
func (mock *BaseKeeperMock) SetSeqIDMappingCalls() []struct {
	Ctx cosmossdktypes.Context
	T   axelarnettypes.IBCTransfer
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
		T   axelarnettypes.IBCTransfer
	}
	mock.lockSetSeqIDMapping.RLock()
	calls = mock.calls.SetSeqIDMapping
	mock.lockSetSeqIDMapping.RUnlock()
	return calls
}

// SetTransferFailed calls SetTransferFailedFunc.
func (mock *BaseKeeperMock) SetTransferFailed(ctx cosmossdktypes.Context, transferID github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferID) error {
	if mock.SetTransferFailedFunc == nil {
		panic("BaseKeeperMock.SetTransferFailedFunc: method is nil but BaseKeeper.SetTransferFailed was just called")
	}
	callInfo := struct {
		Ctx        cosmossdktypes.Context
		TransferID github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferID
	}{
		Ctx:        ctx,
		TransferID: transferID,
	}
	mock.lockSetTransferFailed.Lock()
	mock.calls.SetTransferFailed = append(mock.calls.SetTransferFailed, callInfo)
	mock.lockSetTransferFailed.Unlock()
	return mock.SetTransferFailedFunc(ctx, transferID)
}

// SetTransferFailedCalls gets all the calls that were made to SetTransferFailed.
// Check the length with:
//
//	len(mockedBaseKeeper.SetTransferFailedCalls())
func (mock *BaseKeeperMock) SetTransferFailedCalls() []struct {
	Ctx        cosmossdktypes.Context
	TransferID github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferID
} {
	var calls []struct {
		Ctx        cosmossdktypes.Context
		TransferID github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferID
	}
	mock.lockSetTransferFailed.RLock()
	calls = mock.calls.SetTransferFailed
	mock.lockSetTransferFailed.RUnlock()
	return calls
}

// Ensure, that NexusMock does implement axelarnettypes.Nexus.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.Nexus = &NexusMock{}

// NexusMock is a mock implementation of axelarnettypes.Nexus.
//
//	func TestSomethingThatUsesNexus(t *testing.T) {
//
//		// make and configure a mocked axelarnettypes.Nexus
//		mockedNexus := &NexusMock{
//			ActivateChainFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain)  {
//				panic("mock out the ActivateChain method")
//			},
//			ArchivePendingTransferFunc: func(ctx cosmossdktypes.Context, transfer github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainTransfer)  {
//				panic("mock out the ArchivePendingTransfer method")
//			},
//			EnqueueForTransferFunc: func(ctx cosmossdktypes.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, amount cosmossdktypes.Coin) (github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferID, error) {
//				panic("mock out the EnqueueForTransfer method")
//			},
//			EnqueueTransferFunc: func(ctx cosmossdktypes.Context, senderChain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, asset cosmossdktypes.Coin) (github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferID, error) {
//				panic("mock out the EnqueueTransfer method")
//			},
//			GenerateMessageIDFunc: func(ctx cosmossdktypes.Context) (string, []byte, uint64) {
//				panic("mock out the GenerateMessageID method")
//			},
//			GetChainFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, bool) {
//				panic("mock out the GetChain method")
//			},
//			GetChainByNativeAssetFunc: func(ctx cosmossdktypes.Context, asset string) (github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, bool) {
//				panic("mock out the GetChainByNativeAsset method")
//			},
//			GetMessageFunc: func(ctx cosmossdktypes.Context, id string) (github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage, bool) {
//				panic("mock out the GetMessage method")
//			},
//			GetRecipientFunc: func(ctx cosmossdktypes.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress) (github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, bool) {
//				panic("mock out the GetRecipient method")
//			},
//			GetTransferFeesFunc: func(ctx cosmossdktypes.Context) cosmossdktypes.Coins {
//				panic("mock out the GetTransferFees method")
//			},
//			GetTransfersForChainPaginatedFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, state github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferState, pageRequest *query.PageRequest) ([]github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainTransfer, *query.PageResponse, error) {
//				panic("mock out the GetTransfersForChainPaginated method")
//			},
//			IsAssetRegisteredFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, denom string) bool {
//				panic("mock out the IsAssetRegistered method")
//			},
//			IsChainActivatedFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) bool {
//				panic("mock out the IsChainActivated method")
//			},
//			LinkAddressesFunc: func(ctx cosmossdktypes.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress) error {
//				panic("mock out the LinkAddresses method")
//			},
//			RateLimitTransferFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName, asset cosmossdktypes.Coin, direction github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferDirection) error {
//				panic("mock out the RateLimitTransfer method")
//			},
//			RegisterAssetFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, asset github_com_axelarnetwork_axelar_core_x_nexus_exported.Asset, limit cosmossdktypes.Uint, window time.Duration) error {
//				panic("mock out the RegisterAsset method")
//			},
//			RouteMessageFunc: func(ctx cosmossdktypes.Context, id string, routingCtx ...github_com_axelarnetwork_axelar_core_x_nexus_exported.RoutingContext) error {
//				panic("mock out the RouteMessage method")
//			},
//			SetChainFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain)  {
//				panic("mock out the SetChain method")
//			},
//			SetMessageExecutedFunc: func(ctx cosmossdktypes.Context, id string) error {
//				panic("mock out the SetMessageExecuted method")
//			},
//			SetMessageFailedFunc: func(ctx cosmossdktypes.Context, id string) error {
//				panic("mock out the SetMessageFailed method")
//			},
//			SetNewMessageFunc: func(ctx cosmossdktypes.Context, m github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage) error {
//				panic("mock out the SetNewMessage method")
//			},
//			SubTransferFeeFunc: func(ctx cosmossdktypes.Context, coin cosmossdktypes.Coin)  {
//				panic("mock out the SubTransferFee method")
//			},
//			ValidateAddressFunc: func(ctx cosmossdktypes.Context, address github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress) error {
//				panic("mock out the ValidateAddress method")
//			},
//		}
//
//		// use mockedNexus in code that requires axelarnettypes.Nexus
//		// and then make assertions.
//
//	}
type NexusMock struct {
	// ActivateChainFunc mocks the ActivateChain method.
	ActivateChainFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain)

	// ArchivePendingTransferFunc mocks the ArchivePendingTransfer method.
	ArchivePendingTransferFunc func(ctx cosmossdktypes.Context, transfer github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainTransfer)

	// EnqueueForTransferFunc mocks the EnqueueForTransfer method.
	EnqueueForTransferFunc func(ctx cosmossdktypes.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, amount cosmossdktypes.Coin) (github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferID, error)

	// EnqueueTransferFunc mocks the EnqueueTransfer method.
	EnqueueTransferFunc func(ctx cosmossdktypes.Context, senderChain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, asset cosmossdktypes.Coin) (github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferID, error)

	// GenerateMessageIDFunc mocks the GenerateMessageID method.
	GenerateMessageIDFunc func(ctx cosmossdktypes.Context) (string, []byte, uint64)

	// GetChainFunc mocks the GetChain method.
	GetChainFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, bool)

	// GetChainByNativeAssetFunc mocks the GetChainByNativeAsset method.
	GetChainByNativeAssetFunc func(ctx cosmossdktypes.Context, asset string) (github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, bool)

	// GetMessageFunc mocks the GetMessage method.
	GetMessageFunc func(ctx cosmossdktypes.Context, id string) (github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage, bool)

	// GetRecipientFunc mocks the GetRecipient method.
	GetRecipientFunc func(ctx cosmossdktypes.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress) (github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, bool)

	// GetTransferFeesFunc mocks the GetTransferFees method.
	GetTransferFeesFunc func(ctx cosmossdktypes.Context) cosmossdktypes.Coins

	// GetTransfersForChainPaginatedFunc mocks the GetTransfersForChainPaginated method.
	GetTransfersForChainPaginatedFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, state github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferState, pageRequest *query.PageRequest) ([]github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainTransfer, *query.PageResponse, error)

	// IsAssetRegisteredFunc mocks the IsAssetRegistered method.
	IsAssetRegisteredFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, denom string) bool

	// IsChainActivatedFunc mocks the IsChainActivated method.
	IsChainActivatedFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) bool

	// LinkAddressesFunc mocks the LinkAddresses method.
	LinkAddressesFunc func(ctx cosmossdktypes.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress) error

	// RateLimitTransferFunc mocks the RateLimitTransfer method.
	RateLimitTransferFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName, asset cosmossdktypes.Coin, direction github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferDirection) error

	// RegisterAssetFunc mocks the RegisterAsset method.
	RegisterAssetFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, asset github_com_axelarnetwork_axelar_core_x_nexus_exported.Asset, limit cosmossdktypes.Uint, window time.Duration) error

	// RouteMessageFunc mocks the RouteMessage method.
	RouteMessageFunc func(ctx cosmossdktypes.Context, id string, routingCtx ...github_com_axelarnetwork_axelar_core_x_nexus_exported.RoutingContext) error

	// SetChainFunc mocks the SetChain method.
	SetChainFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain)

	// SetMessageExecutedFunc mocks the SetMessageExecuted method.
	SetMessageExecutedFunc func(ctx cosmossdktypes.Context, id string) error

	// SetMessageFailedFunc mocks the SetMessageFailed method.
	SetMessageFailedFunc func(ctx cosmossdktypes.Context, id string) error

	// SetNewMessageFunc mocks the SetNewMessage method.
	SetNewMessageFunc func(ctx cosmossdktypes.Context, m github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage) error

	// SubTransferFeeFunc mocks the SubTransferFee method.
	SubTransferFeeFunc func(ctx cosmossdktypes.Context, coin cosmossdktypes.Coin)

	// ValidateAddressFunc mocks the ValidateAddress method.
	ValidateAddressFunc func(ctx cosmossdktypes.Context, address github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress) error

	// calls tracks calls to the methods.
	calls struct {
		// ActivateChain holds details about calls to the ActivateChain method.
		ActivateChain []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		}
		// ArchivePendingTransfer holds details about calls to the ArchivePendingTransfer method.
		ArchivePendingTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Transfer is the transfer argument value.
			Transfer github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainTransfer
		}
		// EnqueueForTransfer holds details about calls to the EnqueueForTransfer method.
		EnqueueForTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Sender is the sender argument value.
			Sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
			// Amount is the amount argument value.
			Amount cosmossdktypes.Coin
		}
		// EnqueueTransfer holds details about calls to the EnqueueTransfer method.
		EnqueueTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// SenderChain is the senderChain argument value.
			SenderChain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
			// Recipient is the recipient argument value.
			Recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
			// Asset is the asset argument value.
			Asset cosmossdktypes.Coin
		}
		// GenerateMessageID holds details about calls to the GenerateMessageID method.
		GenerateMessageID []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// GetChain holds details about calls to the GetChain method.
		GetChain []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
		}
		// GetChainByNativeAsset holds details about calls to the GetChainByNativeAsset method.
		GetChainByNativeAsset []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Asset is the asset argument value.
			Asset string
		}
		// GetMessage holds details about calls to the GetMessage method.
		GetMessage []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ID is the id argument value.
			ID string
		}
		// GetRecipient holds details about calls to the GetRecipient method.
		GetRecipient []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Sender is the sender argument value.
			Sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
		}
		// GetTransferFees holds details about calls to the GetTransferFees method.
		GetTransferFees []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// GetTransfersForChainPaginated holds details about calls to the GetTransfersForChainPaginated method.
		GetTransfersForChainPaginated []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
			// State is the state argument value.
			State github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferState
			// PageRequest is the pageRequest argument value.
			PageRequest *query.PageRequest
		}
		// IsAssetRegistered holds details about calls to the IsAssetRegistered method.
		IsAssetRegistered []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
			// Denom is the denom argument value.
			Denom string
		}
		// IsChainActivated holds details about calls to the IsChainActivated method.
		IsChainActivated []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		}
		// LinkAddresses holds details about calls to the LinkAddresses method.
		LinkAddresses []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Sender is the sender argument value.
			Sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
			// Recipient is the recipient argument value.
			Recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
		}
		// RateLimitTransfer holds details about calls to the RateLimitTransfer method.
		RateLimitTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
			// Asset is the asset argument value.
			Asset cosmossdktypes.Coin
			// Direction is the direction argument value.
			Direction github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferDirection
		}
		// RegisterAsset holds details about calls to the RegisterAsset method.
		RegisterAsset []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
			// Asset is the asset argument value.
			Asset github_com_axelarnetwork_axelar_core_x_nexus_exported.Asset
			// Limit is the limit argument value.
			Limit cosmossdktypes.Uint
			// Window is the window argument value.
			Window time.Duration
		}
		// RouteMessage holds details about calls to the RouteMessage method.
		RouteMessage []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ID is the id argument value.
			ID string
			// RoutingCtx is the routingCtx argument value.
			RoutingCtx []github_com_axelarnetwork_axelar_core_x_nexus_exported.RoutingContext
		}
		// SetChain holds details about calls to the SetChain method.
		SetChain []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		}
		// SetMessageExecuted holds details about calls to the SetMessageExecuted method.
		SetMessageExecuted []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ID is the id argument value.
			ID string
		}
		// SetMessageFailed holds details about calls to the SetMessageFailed method.
		SetMessageFailed []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ID is the id argument value.
			ID string
		}
		// SetNewMessage holds details about calls to the SetNewMessage method.
		SetNewMessage []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// M is the m argument value.
			M github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage
		}
		// SubTransferFee holds details about calls to the SubTransferFee method.
		SubTransferFee []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Coin is the coin argument value.
			Coin cosmossdktypes.Coin
		}
		// ValidateAddress holds details about calls to the ValidateAddress method.
		ValidateAddress []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Address is the address argument value.
			Address github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
		}
	}
	lockActivateChain                 sync.RWMutex
	lockArchivePendingTransfer        sync.RWMutex
	lockEnqueueForTransfer            sync.RWMutex
	lockEnqueueTransfer               sync.RWMutex
	lockGenerateMessageID             sync.RWMutex
	lockGetChain                      sync.RWMutex
	lockGetChainByNativeAsset         sync.RWMutex
	lockGetMessage                    sync.RWMutex
	lockGetRecipient                  sync.RWMutex
	lockGetTransferFees               sync.RWMutex
	lockGetTransfersForChainPaginated sync.RWMutex
	lockIsAssetRegistered             sync.RWMutex
	lockIsChainActivated              sync.RWMutex
	lockLinkAddresses                 sync.RWMutex
	lockRateLimitTransfer             sync.RWMutex
	lockRegisterAsset                 sync.RWMutex
	lockRouteMessage                  sync.RWMutex
	lockSetChain                      sync.RWMutex
	lockSetMessageExecuted            sync.RWMutex
	lockSetMessageFailed              sync.RWMutex
	lockSetNewMessage                 sync.RWMutex
	lockSubTransferFee                sync.RWMutex
	lockValidateAddress               sync.RWMutex
}

// ActivateChain calls ActivateChainFunc.
func (mock *NexusMock) ActivateChain(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) {
	if mock.ActivateChainFunc == nil {
		panic("NexusMock.ActivateChainFunc: method is nil but Nexus.ActivateChain was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockActivateChain.Lock()
	mock.calls.ActivateChain = append(mock.calls.ActivateChain, callInfo)
	mock.lockActivateChain.Unlock()
	mock.ActivateChainFunc(ctx, chain)
}

// ActivateChainCalls gets all the calls that were made to ActivateChain.
// Check the length with:
//
//	len(mockedNexus.ActivateChainCalls())
func (mock *NexusMock) ActivateChainCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}
	mock.lockActivateChain.RLock()
	calls = mock.calls.ActivateChain
	mock.lockActivateChain.RUnlock()
	return calls
}

// ArchivePendingTransfer calls ArchivePendingTransferFunc.
func (mock *NexusMock) ArchivePendingTransfer(ctx cosmossdktypes.Context, transfer github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainTransfer) {
	if mock.ArchivePendingTransferFunc == nil {
		panic("NexusMock.ArchivePendingTransferFunc: method is nil but Nexus.ArchivePendingTransfer was just called")
	}
	callInfo := struct {
		Ctx      cosmossdktypes.Context
		Transfer github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainTransfer
	}{
		Ctx:      ctx,
		Transfer: transfer,
	}
	mock.lockArchivePendingTransfer.Lock()
	mock.calls.ArchivePendingTransfer = append(mock.calls.ArchivePendingTransfer, callInfo)
	mock.lockArchivePendingTransfer.Unlock()
	mock.ArchivePendingTransferFunc(ctx, transfer)
}

// ArchivePendingTransferCalls gets all the calls that were made to ArchivePendingTransfer.
// Check the length with:
//
//	len(mockedNexus.ArchivePendingTransferCalls())
func (mock *NexusMock) ArchivePendingTransferCalls() []struct {
	Ctx      cosmossdktypes.Context
	Transfer github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainTransfer
} {
	var calls []struct {
		Ctx      cosmossdktypes.Context
		Transfer github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainTransfer
	}
	mock.lockArchivePendingTransfer.RLock()
	calls = mock.calls.ArchivePendingTransfer
	mock.lockArchivePendingTransfer.RUnlock()
	return calls
}

// EnqueueForTransfer calls EnqueueForTransferFunc.
func (mock *NexusMock) EnqueueForTransfer(ctx cosmossdktypes.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, amount cosmossdktypes.Coin) (github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferID, error) {
	if mock.EnqueueForTransferFunc == nil {
		panic("NexusMock.EnqueueForTransferFunc: method is nil but Nexus.EnqueueForTransfer was just called")
	}
	callInfo := struct {
		Ctx    cosmossdktypes.Context
		Sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
		Amount cosmossdktypes.Coin
	}{
		Ctx:    ctx,
		Sender: sender,
		Amount: amount,
	}
	mock.lockEnqueueForTransfer.Lock()
	mock.calls.EnqueueForTransfer = append(mock.calls.EnqueueForTransfer, callInfo)
	mock.lockEnqueueForTransfer.Unlock()
	return mock.EnqueueForTransferFunc(ctx, sender, amount)
}

// EnqueueForTransferCalls gets all the calls that were made to EnqueueForTransfer.
// Check the length with:
//
//	len(mockedNexus.EnqueueForTransferCalls())
func (mock *NexusMock) EnqueueForTransferCalls() []struct {
	Ctx    cosmossdktypes.Context
	Sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
	Amount cosmossdktypes.Coin
} {
	var calls []struct {
		Ctx    cosmossdktypes.Context
		Sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
		Amount cosmossdktypes.Coin
	}
	mock.lockEnqueueForTransfer.RLock()
	calls = mock.calls.EnqueueForTransfer
	mock.lockEnqueueForTransfer.RUnlock()
	return calls
}

// EnqueueTransfer calls EnqueueTransferFunc.
func (mock *NexusMock) EnqueueTransfer(ctx cosmossdktypes.Context, senderChain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, asset cosmossdktypes.Coin) (github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferID, error) {
	if mock.EnqueueTransferFunc == nil {
		panic("NexusMock.EnqueueTransferFunc: method is nil but Nexus.EnqueueTransfer was just called")
	}
	callInfo := struct {
		Ctx         cosmossdktypes.Context
		SenderChain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Recipient   github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
		Asset       cosmossdktypes.Coin
	}{
		Ctx:         ctx,
		SenderChain: senderChain,
		Recipient:   recipient,
		Asset:       asset,
	}
	mock.lockEnqueueTransfer.Lock()
	mock.calls.EnqueueTransfer = append(mock.calls.EnqueueTransfer, callInfo)
	mock.lockEnqueueTransfer.Unlock()
	return mock.EnqueueTransferFunc(ctx, senderChain, recipient, asset)
}

// EnqueueTransferCalls gets all the calls that were made to EnqueueTransfer.
// Check the length with:
//
//	len(mockedNexus.EnqueueTransferCalls())
func (mock *NexusMock) EnqueueTransferCalls() []struct {
	Ctx         cosmossdktypes.Context
	SenderChain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	Recipient   github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
	Asset       cosmossdktypes.Coin
} {
	var calls []struct {
		Ctx         cosmossdktypes.Context
		SenderChain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Recipient   github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
		Asset       cosmossdktypes.Coin
	}
	mock.lockEnqueueTransfer.RLock()
	calls = mock.calls.EnqueueTransfer
	mock.lockEnqueueTransfer.RUnlock()
	return calls
}

// GenerateMessageID calls GenerateMessageIDFunc.
func (mock *NexusMock) GenerateMessageID(ctx cosmossdktypes.Context) (string, []byte, uint64) {
	if mock.GenerateMessageIDFunc == nil {
		panic("NexusMock.GenerateMessageIDFunc: method is nil but Nexus.GenerateMessageID was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockGenerateMessageID.Lock()
	mock.calls.GenerateMessageID = append(mock.calls.GenerateMessageID, callInfo)
	mock.lockGenerateMessageID.Unlock()
	return mock.GenerateMessageIDFunc(ctx)
}

// GenerateMessageIDCalls gets all the calls that were made to GenerateMessageID.
// Check the length with:
//
//	len(mockedNexus.GenerateMessageIDCalls())
func (mock *NexusMock) GenerateMessageIDCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockGenerateMessageID.RLock()
	calls = mock.calls.GenerateMessageID
	mock.lockGenerateMessageID.RUnlock()
	return calls
}

// GetChain calls GetChainFunc.
func (mock *NexusMock) GetChain(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, bool) {
	if mock.GetChainFunc == nil {
		panic("NexusMock.GetChainFunc: method is nil but Nexus.GetChain was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockGetChain.Lock()
	mock.calls.GetChain = append(mock.calls.GetChain, callInfo)
	mock.lockGetChain.Unlock()
	return mock.GetChainFunc(ctx, chain)
}

// GetChainCalls gets all the calls that were made to GetChain.
// Check the length with:
//
//	len(mockedNexus.GetChainCalls())
func (mock *NexusMock) GetChainCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}
	mock.lockGetChain.RLock()
	calls = mock.calls.GetChain
	mock.lockGetChain.RUnlock()
	return calls
}

// GetChainByNativeAsset calls GetChainByNativeAssetFunc.
func (mock *NexusMock) GetChainByNativeAsset(ctx cosmossdktypes.Context, asset string) (github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, bool) {
	if mock.GetChainByNativeAssetFunc == nil {
		panic("NexusMock.GetChainByNativeAssetFunc: method is nil but Nexus.GetChainByNativeAsset was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Asset string
	}{
		Ctx:   ctx,
		Asset: asset,
	}
	mock.lockGetChainByNativeAsset.Lock()
	mock.calls.GetChainByNativeAsset = append(mock.calls.GetChainByNativeAsset, callInfo)
	mock.lockGetChainByNativeAsset.Unlock()
	return mock.GetChainByNativeAssetFunc(ctx, asset)
}

// GetChainByNativeAssetCalls gets all the calls that were made to GetChainByNativeAsset.
// Check the length with:
//
//	len(mockedNexus.GetChainByNativeAssetCalls())
func (mock *NexusMock) GetChainByNativeAssetCalls() []struct {
	Ctx   cosmossdktypes.Context
	Asset string
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Asset string
	}
	mock.lockGetChainByNativeAsset.RLock()
	calls = mock.calls.GetChainByNativeAsset
	mock.lockGetChainByNativeAsset.RUnlock()
	return calls
}

// GetMessage calls GetMessageFunc.
func (mock *NexusMock) GetMessage(ctx cosmossdktypes.Context, id string) (github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage, bool) {
	if mock.GetMessageFunc == nil {
		panic("NexusMock.GetMessageFunc: method is nil but Nexus.GetMessage was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetMessage.Lock()
	mock.calls.GetMessage = append(mock.calls.GetMessage, callInfo)
	mock.lockGetMessage.Unlock()
	return mock.GetMessageFunc(ctx, id)
}

// GetMessageCalls gets all the calls that were made to GetMessage.
// Check the length with:
//
//	len(mockedNexus.GetMessageCalls())
func (mock *NexusMock) GetMessageCalls() []struct {
	Ctx cosmossdktypes.Context
	ID  string
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
		ID  string
	}
	mock.lockGetMessage.RLock()
	calls = mock.calls.GetMessage
	mock.lockGetMessage.RUnlock()
	return calls
}

// GetRecipient calls GetRecipientFunc.
func (mock *NexusMock) GetRecipient(ctx cosmossdktypes.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress) (github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, bool) {
	if mock.GetRecipientFunc == nil {
		panic("NexusMock.GetRecipientFunc: method is nil but Nexus.GetRecipient was just called")
	}
	callInfo := struct {
		Ctx    cosmossdktypes.Context
		Sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
	}{
		Ctx:    ctx,
		Sender: sender,
	}
	mock.lockGetRecipient.Lock()
	mock.calls.GetRecipient = append(mock.calls.GetRecipient, callInfo)
	mock.lockGetRecipient.Unlock()
	return mock.GetRecipientFunc(ctx, sender)
}

// GetRecipientCalls gets all the calls that were made to GetRecipient.
// Check the length with:
//
//	len(mockedNexus.GetRecipientCalls())
func (mock *NexusMock) GetRecipientCalls() []struct {
	Ctx    cosmossdktypes.Context
	Sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
} {
	var calls []struct {
		Ctx    cosmossdktypes.Context
		Sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
	}
	mock.lockGetRecipient.RLock()
	calls = mock.calls.GetRecipient
	mock.lockGetRecipient.RUnlock()
	return calls
}

// GetTransferFees calls GetTransferFeesFunc.
func (mock *NexusMock) GetTransferFees(ctx cosmossdktypes.Context) cosmossdktypes.Coins {
	if mock.GetTransferFeesFunc == nil {
		panic("NexusMock.GetTransferFeesFunc: method is nil but Nexus.GetTransferFees was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetTransferFees.Lock()
	mock.calls.GetTransferFees = append(mock.calls.GetTransferFees, callInfo)
	mock.lockGetTransferFees.Unlock()
	return mock.GetTransferFeesFunc(ctx)
}

// GetTransferFeesCalls gets all the calls that were made to GetTransferFees.
// Check the length with:
//
//	len(mockedNexus.GetTransferFeesCalls())
func (mock *NexusMock) GetTransferFeesCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockGetTransferFees.RLock()
	calls = mock.calls.GetTransferFees
	mock.lockGetTransferFees.RUnlock()
	return calls
}

// GetTransfersForChainPaginated calls GetTransfersForChainPaginatedFunc.
func (mock *NexusMock) GetTransfersForChainPaginated(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, state github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferState, pageRequest *query.PageRequest) ([]github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainTransfer, *query.PageResponse, error) {
	if mock.GetTransfersForChainPaginatedFunc == nil {
		panic("NexusMock.GetTransfersForChainPaginatedFunc: method is nil but Nexus.GetTransfersForChainPaginated was just called")
	}
	callInfo := struct {
		Ctx         cosmossdktypes.Context
		Chain       github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		State       github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferState
		PageRequest *query.PageRequest
	}{
		Ctx:         ctx,
		Chain:       chain,
		State:       state,
		PageRequest: pageRequest,
	}
	mock.lockGetTransfersForChainPaginated.Lock()
	mock.calls.GetTransfersForChainPaginated = append(mock.calls.GetTransfersForChainPaginated, callInfo)
	mock.lockGetTransfersForChainPaginated.Unlock()
	return mock.GetTransfersForChainPaginatedFunc(ctx, chain, state, pageRequest)
}

// GetTransfersForChainPaginatedCalls gets all the calls that were made to GetTransfersForChainPaginated.
// Check the length with:
//
//	len(mockedNexus.GetTransfersForChainPaginatedCalls())
func (mock *NexusMock) GetTransfersForChainPaginatedCalls() []struct {
	Ctx         cosmossdktypes.Context
	Chain       github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	State       github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferState
	PageRequest *query.PageRequest
} {
	var calls []struct {
		Ctx         cosmossdktypes.Context
		Chain       github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		State       github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferState
		PageRequest *query.PageRequest
	}
	mock.lockGetTransfersForChainPaginated.RLock()
	calls = mock.calls.GetTransfersForChainPaginated
	mock.lockGetTransfersForChainPaginated.RUnlock()
	return calls
}

// IsAssetRegistered calls IsAssetRegisteredFunc.
func (mock *NexusMock) IsAssetRegistered(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, denom string) bool {
	if mock.IsAssetRegisteredFunc == nil {
		panic("NexusMock.IsAssetRegisteredFunc: method is nil but Nexus.IsAssetRegistered was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Denom string
	}{
		Ctx:   ctx,
		Chain: chain,
		Denom: denom,
	}
	mock.lockIsAssetRegistered.Lock()
	mock.calls.IsAssetRegistered = append(mock.calls.IsAssetRegistered, callInfo)
	mock.lockIsAssetRegistered.Unlock()
	return mock.IsAssetRegisteredFunc(ctx, chain, denom)
}

// IsAssetRegisteredCalls gets all the calls that were made to IsAssetRegistered.
// Check the length with:
//
//	len(mockedNexus.IsAssetRegisteredCalls())
func (mock *NexusMock) IsAssetRegisteredCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	Denom string
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Denom string
	}
	mock.lockIsAssetRegistered.RLock()
	calls = mock.calls.IsAssetRegistered
	mock.lockIsAssetRegistered.RUnlock()
	return calls
}

// IsChainActivated calls IsChainActivatedFunc.
func (mock *NexusMock) IsChainActivated(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) bool {
	if mock.IsChainActivatedFunc == nil {
		panic("NexusMock.IsChainActivatedFunc: method is nil but Nexus.IsChainActivated was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockIsChainActivated.Lock()
	mock.calls.IsChainActivated = append(mock.calls.IsChainActivated, callInfo)
	mock.lockIsChainActivated.Unlock()
	return mock.IsChainActivatedFunc(ctx, chain)
}

// IsChainActivatedCalls gets all the calls that were made to IsChainActivated.
// Check the length with:
//
//	len(mockedNexus.IsChainActivatedCalls())
func (mock *NexusMock) IsChainActivatedCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}
	mock.lockIsChainActivated.RLock()
	calls = mock.calls.IsChainActivated
	mock.lockIsChainActivated.RUnlock()
	return calls
}

// LinkAddresses calls LinkAddressesFunc.
func (mock *NexusMock) LinkAddresses(ctx cosmossdktypes.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress) error {
	if mock.LinkAddressesFunc == nil {
		panic("NexusMock.LinkAddressesFunc: method is nil but Nexus.LinkAddresses was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		Sender    github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
		Recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
	}{
		Ctx:       ctx,
		Sender:    sender,
		Recipient: recipient,
	}
	mock.lockLinkAddresses.Lock()
	mock.calls.LinkAddresses = append(mock.calls.LinkAddresses, callInfo)
	mock.lockLinkAddresses.Unlock()
	return mock.LinkAddressesFunc(ctx, sender, recipient)
}

// LinkAddressesCalls gets all the calls that were made to LinkAddresses.
// Check the length with:
//
//	len(mockedNexus.LinkAddressesCalls())
func (mock *NexusMock) LinkAddressesCalls() []struct {
	Ctx       cosmossdktypes.Context
	Sender    github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
	Recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		Sender    github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
		Recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
	}
	mock.lockLinkAddresses.RLock()
	calls = mock.calls.LinkAddresses
	mock.lockLinkAddresses.RUnlock()
	return calls
}

// RateLimitTransfer calls RateLimitTransferFunc.
func (mock *NexusMock) RateLimitTransfer(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName, asset cosmossdktypes.Coin, direction github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferDirection) error {
	if mock.RateLimitTransferFunc == nil {
		panic("NexusMock.RateLimitTransferFunc: method is nil but Nexus.RateLimitTransfer was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		Chain     github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
		Asset     cosmossdktypes.Coin
		Direction github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferDirection
	}{
		Ctx:       ctx,
		Chain:     chain,
		Asset:     asset,
		Direction: direction,
	}
	mock.lockRateLimitTransfer.Lock()
	mock.calls.RateLimitTransfer = append(mock.calls.RateLimitTransfer, callInfo)
	mock.lockRateLimitTransfer.Unlock()
	return mock.RateLimitTransferFunc(ctx, chain, asset, direction)
}

// RateLimitTransferCalls gets all the calls that were made to RateLimitTransfer.
// Check the length with:
//
//	len(mockedNexus.RateLimitTransferCalls())
func (mock *NexusMock) RateLimitTransferCalls() []struct {
	Ctx       cosmossdktypes.Context
	Chain     github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	Asset     cosmossdktypes.Coin
	Direction github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferDirection
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		Chain     github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
		Asset     cosmossdktypes.Coin
		Direction github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferDirection
	}
	mock.lockRateLimitTransfer.RLock()
	calls = mock.calls.RateLimitTransfer
	mock.lockRateLimitTransfer.RUnlock()
	return calls
}

// RegisterAsset calls RegisterAssetFunc.
func (mock *NexusMock) RegisterAsset(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, asset github_com_axelarnetwork_axelar_core_x_nexus_exported.Asset, limit cosmossdktypes.Uint, window time.Duration) error {
	if mock.RegisterAssetFunc == nil {
		panic("NexusMock.RegisterAssetFunc: method is nil but Nexus.RegisterAsset was just called")
	}
	callInfo := struct {
		Ctx    cosmossdktypes.Context
		Chain  github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Asset  github_com_axelarnetwork_axelar_core_x_nexus_exported.Asset
		Limit  cosmossdktypes.Uint
		Window time.Duration
	}{
		Ctx:    ctx,
		Chain:  chain,
		Asset:  asset,
		Limit:  limit,
		Window: window,
	}
	mock.lockRegisterAsset.Lock()
	mock.calls.RegisterAsset = append(mock.calls.RegisterAsset, callInfo)
	mock.lockRegisterAsset.Unlock()
	return mock.RegisterAssetFunc(ctx, chain, asset, limit, window)
}

// RegisterAssetCalls gets all the calls that were made to RegisterAsset.
// Check the length with:
//
//	len(mockedNexus.RegisterAssetCalls())
func (mock *NexusMock) RegisterAssetCalls() []struct {
	Ctx    cosmossdktypes.Context
	Chain  github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	Asset  github_com_axelarnetwork_axelar_core_x_nexus_exported.Asset
	Limit  cosmossdktypes.Uint
	Window time.Duration
} {
	var calls []struct {
		Ctx    cosmossdktypes.Context
		Chain  github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Asset  github_com_axelarnetwork_axelar_core_x_nexus_exported.Asset
		Limit  cosmossdktypes.Uint
		Window time.Duration
	}
	mock.lockRegisterAsset.RLock()
	calls = mock.calls.RegisterAsset
	mock.lockRegisterAsset.RUnlock()
	return calls
}

// RouteMessage calls RouteMessageFunc.
func (mock *NexusMock) RouteMessage(ctx cosmossdktypes.Context, id string, routingCtx ...github_com_axelarnetwork_axelar_core_x_nexus_exported.RoutingContext) error {
	if mock.RouteMessageFunc == nil {
		panic("NexusMock.RouteMessageFunc: method is nil but Nexus.RouteMessage was just called")
	}
	callInfo := struct {
		Ctx        cosmossdktypes.Context
		ID         string
		RoutingCtx []github_com_axelarnetwork_axelar_core_x_nexus_exported.RoutingContext
	}{
		Ctx:        ctx,
		ID:         id,
		RoutingCtx: routingCtx,
	}
	mock.lockRouteMessage.Lock()
	mock.calls.RouteMessage = append(mock.calls.RouteMessage, callInfo)
	mock.lockRouteMessage.Unlock()
	return mock.RouteMessageFunc(ctx, id, routingCtx...)
}

// RouteMessageCalls gets all the calls that were made to RouteMessage.
// Check the length with:
//
//	len(mockedNexus.RouteMessageCalls())
func (mock *NexusMock) RouteMessageCalls() []struct {
	Ctx        cosmossdktypes.Context
	ID         string
	RoutingCtx []github_com_axelarnetwork_axelar_core_x_nexus_exported.RoutingContext
} {
	var calls []struct {
		Ctx        cosmossdktypes.Context
		ID         string
		RoutingCtx []github_com_axelarnetwork_axelar_core_x_nexus_exported.RoutingContext
	}
	mock.lockRouteMessage.RLock()
	calls = mock.calls.RouteMessage
	mock.lockRouteMessage.RUnlock()
	return calls
}

// SetChain calls SetChainFunc.
func (mock *NexusMock) SetChain(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) {
	if mock.SetChainFunc == nil {
		panic("NexusMock.SetChainFunc: method is nil but Nexus.SetChain was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockSetChain.Lock()
	mock.calls.SetChain = append(mock.calls.SetChain, callInfo)
	mock.lockSetChain.Unlock()
	mock.SetChainFunc(ctx, chain)
}

// SetChainCalls gets all the calls that were made to SetChain.
// Check the length with:
//
//	len(mockedNexus.SetChainCalls())
func (mock *NexusMock) SetChainCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}
	mock.lockSetChain.RLock()
	calls = mock.calls.SetChain
	mock.lockSetChain.RUnlock()
	return calls
}

// SetMessageExecuted calls SetMessageExecutedFunc.
func (mock *NexusMock) SetMessageExecuted(ctx cosmossdktypes.Context, id string) error {
	if mock.SetMessageExecutedFunc == nil {
		panic("NexusMock.SetMessageExecutedFunc: method is nil but Nexus.SetMessageExecuted was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockSetMessageExecuted.Lock()
	mock.calls.SetMessageExecuted = append(mock.calls.SetMessageExecuted, callInfo)
	mock.lockSetMessageExecuted.Unlock()
	return mock.SetMessageExecutedFunc(ctx, id)
}

// SetMessageExecutedCalls gets all the calls that were made to SetMessageExecuted.
// Check the length with:
//
//	len(mockedNexus.SetMessageExecutedCalls())
func (mock *NexusMock) SetMessageExecutedCalls() []struct {
	Ctx cosmossdktypes.Context
	ID  string
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
		ID  string
	}
	mock.lockSetMessageExecuted.RLock()
	calls = mock.calls.SetMessageExecuted
	mock.lockSetMessageExecuted.RUnlock()
	return calls
}

// SetMessageFailed calls SetMessageFailedFunc.
func (mock *NexusMock) SetMessageFailed(ctx cosmossdktypes.Context, id string) error {
	if mock.SetMessageFailedFunc == nil {
		panic("NexusMock.SetMessageFailedFunc: method is nil but Nexus.SetMessageFailed was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockSetMessageFailed.Lock()
	mock.calls.SetMessageFailed = append(mock.calls.SetMessageFailed, callInfo)
	mock.lockSetMessageFailed.Unlock()
	return mock.SetMessageFailedFunc(ctx, id)
}

// SetMessageFailedCalls gets all the calls that were made to SetMessageFailed.
// Check the length with:
//
//	len(mockedNexus.SetMessageFailedCalls())
func (mock *NexusMock) SetMessageFailedCalls() []struct {
	Ctx cosmossdktypes.Context
	ID  string
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
		ID  string
	}
	mock.lockSetMessageFailed.RLock()
	calls = mock.calls.SetMessageFailed
	mock.lockSetMessageFailed.RUnlock()
	return calls
}

// SetNewMessage calls SetNewMessageFunc.
func (mock *NexusMock) SetNewMessage(ctx cosmossdktypes.Context, m github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage) error {
	if mock.SetNewMessageFunc == nil {
		panic("NexusMock.SetNewMessageFunc: method is nil but Nexus.SetNewMessage was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
		M   github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage
	}{
		Ctx: ctx,
		M:   m,
	}
	mock.lockSetNewMessage.Lock()
	mock.calls.SetNewMessage = append(mock.calls.SetNewMessage, callInfo)
	mock.lockSetNewMessage.Unlock()
	return mock.SetNewMessageFunc(ctx, m)
}

// SetNewMessageCalls gets all the calls that were made to SetNewMessage.
// Check the length with:
//
//	len(mockedNexus.SetNewMessageCalls())
func (mock *NexusMock) SetNewMessageCalls() []struct {
	Ctx cosmossdktypes.Context
	M   github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
		M   github_com_axelarnetwork_axelar_core_x_nexus_exported.GeneralMessage
	}
	mock.lockSetNewMessage.RLock()
	calls = mock.calls.SetNewMessage
	mock.lockSetNewMessage.RUnlock()
	return calls
}

// SubTransferFee calls SubTransferFeeFunc.
func (mock *NexusMock) SubTransferFee(ctx cosmossdktypes.Context, coin cosmossdktypes.Coin) {
	if mock.SubTransferFeeFunc == nil {
		panic("NexusMock.SubTransferFeeFunc: method is nil but Nexus.SubTransferFee was just called")
	}
	callInfo := struct {
		Ctx  cosmossdktypes.Context
		Coin cosmossdktypes.Coin
	}{
		Ctx:  ctx,
		Coin: coin,
	}
	mock.lockSubTransferFee.Lock()
	mock.calls.SubTransferFee = append(mock.calls.SubTransferFee, callInfo)
	mock.lockSubTransferFee.Unlock()
	mock.SubTransferFeeFunc(ctx, coin)
}

// SubTransferFeeCalls gets all the calls that were made to SubTransferFee.
// Check the length with:
//
//	len(mockedNexus.SubTransferFeeCalls())
func (mock *NexusMock) SubTransferFeeCalls() []struct {
	Ctx  cosmossdktypes.Context
	Coin cosmossdktypes.Coin
} {
	var calls []struct {
		Ctx  cosmossdktypes.Context
		Coin cosmossdktypes.Coin
	}
	mock.lockSubTransferFee.RLock()
	calls = mock.calls.SubTransferFee
	mock.lockSubTransferFee.RUnlock()
	return calls
}

// ValidateAddress calls ValidateAddressFunc.
func (mock *NexusMock) ValidateAddress(ctx cosmossdktypes.Context, address github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress) error {
	if mock.ValidateAddressFunc == nil {
		panic("NexusMock.ValidateAddressFunc: method is nil but Nexus.ValidateAddress was just called")
	}
	callInfo := struct {
		Ctx     cosmossdktypes.Context
		Address github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
	}{
		Ctx:     ctx,
		Address: address,
	}
	mock.lockValidateAddress.Lock()
	mock.calls.ValidateAddress = append(mock.calls.ValidateAddress, callInfo)
	mock.lockValidateAddress.Unlock()
	return mock.ValidateAddressFunc(ctx, address)
}

// ValidateAddressCalls gets all the calls that were made to ValidateAddress.
// Check the length with:
//
//	len(mockedNexus.ValidateAddressCalls())
func (mock *NexusMock) ValidateAddressCalls() []struct {
	Ctx     cosmossdktypes.Context
	Address github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
} {
	var calls []struct {
		Ctx     cosmossdktypes.Context
		Address github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
	}
	mock.lockValidateAddress.RLock()
	calls = mock.calls.ValidateAddress
	mock.lockValidateAddress.RUnlock()
	return calls
}

// Ensure, that BankKeeperMock does implement axelarnettypes.BankKeeper.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.BankKeeper = &BankKeeperMock{}

// BankKeeperMock is a mock implementation of axelarnettypes.BankKeeper.
//
//	func TestSomethingThatUsesBankKeeper(t *testing.T) {
//
//		// make and configure a mocked axelarnettypes.BankKeeper
//		mockedBankKeeper := &BankKeeperMock{
//			BlockedAddrFunc: func(addr cosmossdktypes.AccAddress) bool {
//				panic("mock out the BlockedAddr method")
//			},
//			BurnCoinsFunc: func(ctx cosmossdktypes.Context, moduleName string, amt cosmossdktypes.Coins) error {
//				panic("mock out the BurnCoins method")
//			},
//			IsSendEnabledCoinFunc: func(ctx cosmossdktypes.Context, coin cosmossdktypes.Coin) bool {
//				panic("mock out the IsSendEnabledCoin method")
//			},
//			IsSendEnabledCoinsFunc: func(ctx cosmossdktypes.Context, coins ...cosmossdktypes.Coin) error {
//				panic("mock out the IsSendEnabledCoins method")
//			},
//			MintCoinsFunc: func(ctx cosmossdktypes.Context, moduleName string, amt cosmossdktypes.Coins) error {
//				panic("mock out the MintCoins method")
//			},
//			SendCoinsFunc: func(ctx cosmossdktypes.Context, fromAddr cosmossdktypes.AccAddress, toAddr cosmossdktypes.AccAddress, amt cosmossdktypes.Coins) error {
//				panic("mock out the SendCoins method")
//			},
//			SendCoinsFromAccountToModuleFunc: func(ctx cosmossdktypes.Context, senderAddr cosmossdktypes.AccAddress, recipientModule string, amt cosmossdktypes.Coins) error {
//				panic("mock out the SendCoinsFromAccountToModule method")
//			},
//			SendCoinsFromModuleToAccountFunc: func(ctx cosmossdktypes.Context, senderModule string, recipientAddr cosmossdktypes.AccAddress, amt cosmossdktypes.Coins) error {
//				panic("mock out the SendCoinsFromModuleToAccount method")
//			},
//			SpendableBalanceFunc: func(ctx cosmossdktypes.Context, address cosmossdktypes.AccAddress, denom string) cosmossdktypes.Coin {
//				panic("mock out the SpendableBalance method")
//			},
//		}
//
//		// use mockedBankKeeper in code that requires axelarnettypes.BankKeeper
//		// and then make assertions.
//
//	}
type BankKeeperMock struct {
	// BlockedAddrFunc mocks the BlockedAddr method.
	BlockedAddrFunc func(addr cosmossdktypes.AccAddress) bool

	// BurnCoinsFunc mocks the BurnCoins method.
	BurnCoinsFunc func(ctx cosmossdktypes.Context, moduleName string, amt cosmossdktypes.Coins) error

	// IsSendEnabledCoinFunc mocks the IsSendEnabledCoin method.
	IsSendEnabledCoinFunc func(ctx cosmossdktypes.Context, coin cosmossdktypes.Coin) bool

	// IsSendEnabledCoinsFunc mocks the IsSendEnabledCoins method.
	IsSendEnabledCoinsFunc func(ctx cosmossdktypes.Context, coins ...cosmossdktypes.Coin) error

	// MintCoinsFunc mocks the MintCoins method.
	MintCoinsFunc func(ctx cosmossdktypes.Context, moduleName string, amt cosmossdktypes.Coins) error

	// SendCoinsFunc mocks the SendCoins method.
	SendCoinsFunc func(ctx cosmossdktypes.Context, fromAddr cosmossdktypes.AccAddress, toAddr cosmossdktypes.AccAddress, amt cosmossdktypes.Coins) error

	// SendCoinsFromAccountToModuleFunc mocks the SendCoinsFromAccountToModule method.
	SendCoinsFromAccountToModuleFunc func(ctx cosmossdktypes.Context, senderAddr cosmossdktypes.AccAddress, recipientModule string, amt cosmossdktypes.Coins) error

	// SendCoinsFromModuleToAccountFunc mocks the SendCoinsFromModuleToAccount method.
	SendCoinsFromModuleToAccountFunc func(ctx cosmossdktypes.Context, senderModule string, recipientAddr cosmossdktypes.AccAddress, amt cosmossdktypes.Coins) error

	// SpendableBalanceFunc mocks the SpendableBalance method.
	SpendableBalanceFunc func(ctx cosmossdktypes.Context, address cosmossdktypes.AccAddress, denom string) cosmossdktypes.Coin

	// calls tracks calls to the methods.
	calls struct {
		// BlockedAddr holds details about calls to the BlockedAddr method.
		BlockedAddr []struct {
			// Addr is the addr argument value.
			Addr cosmossdktypes.AccAddress
		}
		// BurnCoins holds details about calls to the BurnCoins method.
		BurnCoins []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ModuleName is the moduleName argument value.
			ModuleName string
			// Amt is the amt argument value.
			Amt cosmossdktypes.Coins
		}
		// IsSendEnabledCoin holds details about calls to the IsSendEnabledCoin method.
		IsSendEnabledCoin []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Coin is the coin argument value.
			Coin cosmossdktypes.Coin
		}
		// IsSendEnabledCoins holds details about calls to the IsSendEnabledCoins method.
		IsSendEnabledCoins []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Coins is the coins argument value.
			Coins []cosmossdktypes.Coin
		}
		// MintCoins holds details about calls to the MintCoins method.
		MintCoins []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ModuleName is the moduleName argument value.
			ModuleName string
			// Amt is the amt argument value.
			Amt cosmossdktypes.Coins
		}
		// SendCoins holds details about calls to the SendCoins method.
		SendCoins []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// FromAddr is the fromAddr argument value.
			FromAddr cosmossdktypes.AccAddress
			// ToAddr is the toAddr argument value.
			ToAddr cosmossdktypes.AccAddress
			// Amt is the amt argument value.
			Amt cosmossdktypes.Coins
		}
		// SendCoinsFromAccountToModule holds details about calls to the SendCoinsFromAccountToModule method.
		SendCoinsFromAccountToModule []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// SenderAddr is the senderAddr argument value.
			SenderAddr cosmossdktypes.AccAddress
			// RecipientModule is the recipientModule argument value.
			RecipientModule string
			// Amt is the amt argument value.
			Amt cosmossdktypes.Coins
		}
		// SendCoinsFromModuleToAccount holds details about calls to the SendCoinsFromModuleToAccount method.
		SendCoinsFromModuleToAccount []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// SenderModule is the senderModule argument value.
			SenderModule string
			// RecipientAddr is the recipientAddr argument value.
			RecipientAddr cosmossdktypes.AccAddress
			// Amt is the amt argument value.
			Amt cosmossdktypes.Coins
		}
		// SpendableBalance holds details about calls to the SpendableBalance method.
		SpendableBalance []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Address is the address argument value.
			Address cosmossdktypes.AccAddress
			// Denom is the denom argument value.
			Denom string
		}
	}
	lockBlockedAddr                  sync.RWMutex
	lockBurnCoins                    sync.RWMutex
	lockIsSendEnabledCoin            sync.RWMutex
	lockIsSendEnabledCoins           sync.RWMutex
	lockMintCoins                    sync.RWMutex
	lockSendCoins                    sync.RWMutex
	lockSendCoinsFromAccountToModule sync.RWMutex
	lockSendCoinsFromModuleToAccount sync.RWMutex
	lockSpendableBalance             sync.RWMutex
}

// BlockedAddr calls BlockedAddrFunc.
func (mock *BankKeeperMock) BlockedAddr(addr cosmossdktypes.AccAddress) bool {
	if mock.BlockedAddrFunc == nil {
		panic("BankKeeperMock.BlockedAddrFunc: method is nil but BankKeeper.BlockedAddr was just called")
	}
	callInfo := struct {
		Addr cosmossdktypes.AccAddress
	}{
		Addr: addr,
	}
	mock.lockBlockedAddr.Lock()
	mock.calls.BlockedAddr = append(mock.calls.BlockedAddr, callInfo)
	mock.lockBlockedAddr.Unlock()
	return mock.BlockedAddrFunc(addr)
}

// BlockedAddrCalls gets all the calls that were made to BlockedAddr.
// Check the length with:
//
//	len(mockedBankKeeper.BlockedAddrCalls())
func (mock *BankKeeperMock) BlockedAddrCalls() []struct {
	Addr cosmossdktypes.AccAddress
} {
	var calls []struct {
		Addr cosmossdktypes.AccAddress
	}
	mock.lockBlockedAddr.RLock()
	calls = mock.calls.BlockedAddr
	mock.lockBlockedAddr.RUnlock()
	return calls
}

// BurnCoins calls BurnCoinsFunc.
func (mock *BankKeeperMock) BurnCoins(ctx cosmossdktypes.Context, moduleName string, amt cosmossdktypes.Coins) error {
	if mock.BurnCoinsFunc == nil {
		panic("BankKeeperMock.BurnCoinsFunc: method is nil but BankKeeper.BurnCoins was just called")
	}
	callInfo := struct {
		Ctx        cosmossdktypes.Context
		ModuleName string
		Amt        cosmossdktypes.Coins
	}{
		Ctx:        ctx,
		ModuleName: moduleName,
		Amt:        amt,
	}
	mock.lockBurnCoins.Lock()
	mock.calls.BurnCoins = append(mock.calls.BurnCoins, callInfo)
	mock.lockBurnCoins.Unlock()
	return mock.BurnCoinsFunc(ctx, moduleName, amt)
}

// BurnCoinsCalls gets all the calls that were made to BurnCoins.
// Check the length with:
//
//	len(mockedBankKeeper.BurnCoinsCalls())
func (mock *BankKeeperMock) BurnCoinsCalls() []struct {
	Ctx        cosmossdktypes.Context
	ModuleName string
	Amt        cosmossdktypes.Coins
} {
	var calls []struct {
		Ctx        cosmossdktypes.Context
		ModuleName string
		Amt        cosmossdktypes.Coins
	}
	mock.lockBurnCoins.RLock()
	calls = mock.calls.BurnCoins
	mock.lockBurnCoins.RUnlock()
	return calls
}

// IsSendEnabledCoin calls IsSendEnabledCoinFunc.
func (mock *BankKeeperMock) IsSendEnabledCoin(ctx cosmossdktypes.Context, coin cosmossdktypes.Coin) bool {
	if mock.IsSendEnabledCoinFunc == nil {
		panic("BankKeeperMock.IsSendEnabledCoinFunc: method is nil but BankKeeper.IsSendEnabledCoin was just called")
	}
	callInfo := struct {
		Ctx  cosmossdktypes.Context
		Coin cosmossdktypes.Coin
	}{
		Ctx:  ctx,
		Coin: coin,
	}
	mock.lockIsSendEnabledCoin.Lock()
	mock.calls.IsSendEnabledCoin = append(mock.calls.IsSendEnabledCoin, callInfo)
	mock.lockIsSendEnabledCoin.Unlock()
	return mock.IsSendEnabledCoinFunc(ctx, coin)
}

// IsSendEnabledCoinCalls gets all the calls that were made to IsSendEnabledCoin.
// Check the length with:
//
//	len(mockedBankKeeper.IsSendEnabledCoinCalls())
func (mock *BankKeeperMock) IsSendEnabledCoinCalls() []struct {
	Ctx  cosmossdktypes.Context
	Coin cosmossdktypes.Coin
} {
	var calls []struct {
		Ctx  cosmossdktypes.Context
		Coin cosmossdktypes.Coin
	}
	mock.lockIsSendEnabledCoin.RLock()
	calls = mock.calls.IsSendEnabledCoin
	mock.lockIsSendEnabledCoin.RUnlock()
	return calls
}

// IsSendEnabledCoins calls IsSendEnabledCoinsFunc.
func (mock *BankKeeperMock) IsSendEnabledCoins(ctx cosmossdktypes.Context, coins ...cosmossdktypes.Coin) error {
	if mock.IsSendEnabledCoinsFunc == nil {
		panic("BankKeeperMock.IsSendEnabledCoinsFunc: method is nil but BankKeeper.IsSendEnabledCoins was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Coins []cosmossdktypes.Coin
	}{
		Ctx:   ctx,
		Coins: coins,
	}
	mock.lockIsSendEnabledCoins.Lock()
	mock.calls.IsSendEnabledCoins = append(mock.calls.IsSendEnabledCoins, callInfo)
	mock.lockIsSendEnabledCoins.Unlock()
	return mock.IsSendEnabledCoinsFunc(ctx, coins...)
}

// IsSendEnabledCoinsCalls gets all the calls that were made to IsSendEnabledCoins.
// Check the length with:
//
//	len(mockedBankKeeper.IsSendEnabledCoinsCalls())
func (mock *BankKeeperMock) IsSendEnabledCoinsCalls() []struct {
	Ctx   cosmossdktypes.Context
	Coins []cosmossdktypes.Coin
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Coins []cosmossdktypes.Coin
	}
	mock.lockIsSendEnabledCoins.RLock()
	calls = mock.calls.IsSendEnabledCoins
	mock.lockIsSendEnabledCoins.RUnlock()
	return calls
}

// MintCoins calls MintCoinsFunc.
func (mock *BankKeeperMock) MintCoins(ctx cosmossdktypes.Context, moduleName string, amt cosmossdktypes.Coins) error {
	if mock.MintCoinsFunc == nil {
		panic("BankKeeperMock.MintCoinsFunc: method is nil but BankKeeper.MintCoins was just called")
	}
	callInfo := struct {
		Ctx        cosmossdktypes.Context
		ModuleName string
		Amt        cosmossdktypes.Coins
	}{
		Ctx:        ctx,
		ModuleName: moduleName,
		Amt:        amt,
	}
	mock.lockMintCoins.Lock()
	mock.calls.MintCoins = append(mock.calls.MintCoins, callInfo)
	mock.lockMintCoins.Unlock()
	return mock.MintCoinsFunc(ctx, moduleName, amt)
}

// MintCoinsCalls gets all the calls that were made to MintCoins.
// Check the length with:
//
//	len(mockedBankKeeper.MintCoinsCalls())
func (mock *BankKeeperMock) MintCoinsCalls() []struct {
	Ctx        cosmossdktypes.Context
	ModuleName string
	Amt        cosmossdktypes.Coins
} {
	var calls []struct {
		Ctx        cosmossdktypes.Context
		ModuleName string
		Amt        cosmossdktypes.Coins
	}
	mock.lockMintCoins.RLock()
	calls = mock.calls.MintCoins
	mock.lockMintCoins.RUnlock()
	return calls
}

// SendCoins calls SendCoinsFunc.
func (mock *BankKeeperMock) SendCoins(ctx cosmossdktypes.Context, fromAddr cosmossdktypes.AccAddress, toAddr cosmossdktypes.AccAddress, amt cosmossdktypes.Coins) error {
	if mock.SendCoinsFunc == nil {
		panic("BankKeeperMock.SendCoinsFunc: method is nil but BankKeeper.SendCoins was just called")
	}
	callInfo := struct {
		Ctx      cosmossdktypes.Context
		FromAddr cosmossdktypes.AccAddress
		ToAddr   cosmossdktypes.AccAddress
		Amt      cosmossdktypes.Coins
	}{
		Ctx:      ctx,
		FromAddr: fromAddr,
		ToAddr:   toAddr,
		Amt:      amt,
	}
	mock.lockSendCoins.Lock()
	mock.calls.SendCoins = append(mock.calls.SendCoins, callInfo)
	mock.lockSendCoins.Unlock()
	return mock.SendCoinsFunc(ctx, fromAddr, toAddr, amt)
}

// SendCoinsCalls gets all the calls that were made to SendCoins.
// Check the length with:
//
//	len(mockedBankKeeper.SendCoinsCalls())
func (mock *BankKeeperMock) SendCoinsCalls() []struct {
	Ctx      cosmossdktypes.Context
	FromAddr cosmossdktypes.AccAddress
	ToAddr   cosmossdktypes.AccAddress
	Amt      cosmossdktypes.Coins
} {
	var calls []struct {
		Ctx      cosmossdktypes.Context
		FromAddr cosmossdktypes.AccAddress
		ToAddr   cosmossdktypes.AccAddress
		Amt      cosmossdktypes.Coins
	}
	mock.lockSendCoins.RLock()
	calls = mock.calls.SendCoins
	mock.lockSendCoins.RUnlock()
	return calls
}

// SendCoinsFromAccountToModule calls SendCoinsFromAccountToModuleFunc.
func (mock *BankKeeperMock) SendCoinsFromAccountToModule(ctx cosmossdktypes.Context, senderAddr cosmossdktypes.AccAddress, recipientModule string, amt cosmossdktypes.Coins) error {
	if mock.SendCoinsFromAccountToModuleFunc == nil {
		panic("BankKeeperMock.SendCoinsFromAccountToModuleFunc: method is nil but BankKeeper.SendCoinsFromAccountToModule was just called")
	}
	callInfo := struct {
		Ctx             cosmossdktypes.Context
		SenderAddr      cosmossdktypes.AccAddress
		RecipientModule string
		Amt             cosmossdktypes.Coins
	}{
		Ctx:             ctx,
		SenderAddr:      senderAddr,
		RecipientModule: recipientModule,
		Amt:             amt,
	}
	mock.lockSendCoinsFromAccountToModule.Lock()
	mock.calls.SendCoinsFromAccountToModule = append(mock.calls.SendCoinsFromAccountToModule, callInfo)
	mock.lockSendCoinsFromAccountToModule.Unlock()
	return mock.SendCoinsFromAccountToModuleFunc(ctx, senderAddr, recipientModule, amt)
}

// SendCoinsFromAccountToModuleCalls gets all the calls that were made to SendCoinsFromAccountToModule.
// Check the length with:
//
//	len(mockedBankKeeper.SendCoinsFromAccountToModuleCalls())
func (mock *BankKeeperMock) SendCoinsFromAccountToModuleCalls() []struct {
	Ctx             cosmossdktypes.Context
	SenderAddr      cosmossdktypes.AccAddress
	RecipientModule string
	Amt             cosmossdktypes.Coins
} {
	var calls []struct {
		Ctx             cosmossdktypes.Context
		SenderAddr      cosmossdktypes.AccAddress
		RecipientModule string
		Amt             cosmossdktypes.Coins
	}
	mock.lockSendCoinsFromAccountToModule.RLock()
	calls = mock.calls.SendCoinsFromAccountToModule
	mock.lockSendCoinsFromAccountToModule.RUnlock()
	return calls
}

// SendCoinsFromModuleToAccount calls SendCoinsFromModuleToAccountFunc.
func (mock *BankKeeperMock) SendCoinsFromModuleToAccount(ctx cosmossdktypes.Context, senderModule string, recipientAddr cosmossdktypes.AccAddress, amt cosmossdktypes.Coins) error {
	if mock.SendCoinsFromModuleToAccountFunc == nil {
		panic("BankKeeperMock.SendCoinsFromModuleToAccountFunc: method is nil but BankKeeper.SendCoinsFromModuleToAccount was just called")
	}
	callInfo := struct {
		Ctx           cosmossdktypes.Context
		SenderModule  string
		RecipientAddr cosmossdktypes.AccAddress
		Amt           cosmossdktypes.Coins
	}{
		Ctx:           ctx,
		SenderModule:  senderModule,
		RecipientAddr: recipientAddr,
		Amt:           amt,
	}
	mock.lockSendCoinsFromModuleToAccount.Lock()
	mock.calls.SendCoinsFromModuleToAccount = append(mock.calls.SendCoinsFromModuleToAccount, callInfo)
	mock.lockSendCoinsFromModuleToAccount.Unlock()
	return mock.SendCoinsFromModuleToAccountFunc(ctx, senderModule, recipientAddr, amt)
}

// SendCoinsFromModuleToAccountCalls gets all the calls that were made to SendCoinsFromModuleToAccount.
// Check the length with:
//
//	len(mockedBankKeeper.SendCoinsFromModuleToAccountCalls())
func (mock *BankKeeperMock) SendCoinsFromModuleToAccountCalls() []struct {
	Ctx           cosmossdktypes.Context
	SenderModule  string
	RecipientAddr cosmossdktypes.AccAddress
	Amt           cosmossdktypes.Coins
} {
	var calls []struct {
		Ctx           cosmossdktypes.Context
		SenderModule  string
		RecipientAddr cosmossdktypes.AccAddress
		Amt           cosmossdktypes.Coins
	}
	mock.lockSendCoinsFromModuleToAccount.RLock()
	calls = mock.calls.SendCoinsFromModuleToAccount
	mock.lockSendCoinsFromModuleToAccount.RUnlock()
	return calls
}

// SpendableBalance calls SpendableBalanceFunc.
func (mock *BankKeeperMock) SpendableBalance(ctx cosmossdktypes.Context, address cosmossdktypes.AccAddress, denom string) cosmossdktypes.Coin {
	if mock.SpendableBalanceFunc == nil {
		panic("BankKeeperMock.SpendableBalanceFunc: method is nil but BankKeeper.SpendableBalance was just called")
	}
	callInfo := struct {
		Ctx     cosmossdktypes.Context
		Address cosmossdktypes.AccAddress
		Denom   string
	}{
		Ctx:     ctx,
		Address: address,
		Denom:   denom,
	}
	mock.lockSpendableBalance.Lock()
	mock.calls.SpendableBalance = append(mock.calls.SpendableBalance, callInfo)
	mock.lockSpendableBalance.Unlock()
	return mock.SpendableBalanceFunc(ctx, address, denom)
}

// SpendableBalanceCalls gets all the calls that were made to SpendableBalance.
// Check the length with:
//
//	len(mockedBankKeeper.SpendableBalanceCalls())
func (mock *BankKeeperMock) SpendableBalanceCalls() []struct {
	Ctx     cosmossdktypes.Context
	Address cosmossdktypes.AccAddress
	Denom   string
} {
	var calls []struct {
		Ctx     cosmossdktypes.Context
		Address cosmossdktypes.AccAddress
		Denom   string
	}
	mock.lockSpendableBalance.RLock()
	calls = mock.calls.SpendableBalance
	mock.lockSpendableBalance.RUnlock()
	return calls
}

// Ensure, that IBCTransferKeeperMock does implement axelarnettypes.IBCTransferKeeper.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.IBCTransferKeeper = &IBCTransferKeeperMock{}

// IBCTransferKeeperMock is a mock implementation of axelarnettypes.IBCTransferKeeper.
//
//	func TestSomethingThatUsesIBCTransferKeeper(t *testing.T) {
//
//		// make and configure a mocked axelarnettypes.IBCTransferKeeper
//		mockedIBCTransferKeeper := &IBCTransferKeeperMock{
//			GetDenomTraceFunc: func(ctx cosmossdktypes.Context, denomTraceHash tmbytes.HexBytes) (ibctransfertypes.DenomTrace, bool) {
//				panic("mock out the GetDenomTrace method")
//			},
//			SendTransferFunc: func(ctx cosmossdktypes.Context, sourcePort string, sourceChannel string, token cosmossdktypes.Coin, sender cosmossdktypes.AccAddress, receiver string, timeoutHeight clienttypes.Height, timeoutTimestamp uint64) error {
//				panic("mock out the SendTransfer method")
//			},
//			TransferFunc: func(goCtx context.Context, msg *ibctransfertypes.MsgTransfer) (*ibctransfertypes.MsgTransferResponse, error) {
//				panic("mock out the Transfer method")
//			},
//		}
//
//		// use mockedIBCTransferKeeper in code that requires axelarnettypes.IBCTransferKeeper
//		// and then make assertions.
//
//	}
type IBCTransferKeeperMock struct {
	// GetDenomTraceFunc mocks the GetDenomTrace method.
	GetDenomTraceFunc func(ctx cosmossdktypes.Context, denomTraceHash tmbytes.HexBytes) (ibctransfertypes.DenomTrace, bool)

	// SendTransferFunc mocks the SendTransfer method.
	SendTransferFunc func(ctx cosmossdktypes.Context, sourcePort string, sourceChannel string, token cosmossdktypes.Coin, sender cosmossdktypes.AccAddress, receiver string, timeoutHeight clienttypes.Height, timeoutTimestamp uint64) error

	// TransferFunc mocks the Transfer method.
	TransferFunc func(goCtx context.Context, msg *ibctransfertypes.MsgTransfer) (*ibctransfertypes.MsgTransferResponse, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetDenomTrace holds details about calls to the GetDenomTrace method.
		GetDenomTrace []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// DenomTraceHash is the denomTraceHash argument value.
			DenomTraceHash tmbytes.HexBytes
		}
		// SendTransfer holds details about calls to the SendTransfer method.
		SendTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// SourcePort is the sourcePort argument value.
			SourcePort string
			// SourceChannel is the sourceChannel argument value.
			SourceChannel string
			// Token is the token argument value.
			Token cosmossdktypes.Coin
			// Sender is the sender argument value.
			Sender cosmossdktypes.AccAddress
			// Receiver is the receiver argument value.
			Receiver string
			// TimeoutHeight is the timeoutHeight argument value.
			TimeoutHeight clienttypes.Height
			// TimeoutTimestamp is the timeoutTimestamp argument value.
			TimeoutTimestamp uint64
		}
		// Transfer holds details about calls to the Transfer method.
		Transfer []struct {
			// GoCtx is the goCtx argument value.
			GoCtx context.Context
			// Msg is the msg argument value.
			Msg *ibctransfertypes.MsgTransfer
		}
	}
	lockGetDenomTrace sync.RWMutex
	lockSendTransfer  sync.RWMutex
	lockTransfer      sync.RWMutex
}

// GetDenomTrace calls GetDenomTraceFunc.
func (mock *IBCTransferKeeperMock) GetDenomTrace(ctx cosmossdktypes.Context, denomTraceHash tmbytes.HexBytes) (ibctransfertypes.DenomTrace, bool) {
	if mock.GetDenomTraceFunc == nil {
		panic("IBCTransferKeeperMock.GetDenomTraceFunc: method is nil but IBCTransferKeeper.GetDenomTrace was just called")
	}
	callInfo := struct {
		Ctx            cosmossdktypes.Context
		DenomTraceHash tmbytes.HexBytes
	}{
		Ctx:            ctx,
		DenomTraceHash: denomTraceHash,
	}
	mock.lockGetDenomTrace.Lock()
	mock.calls.GetDenomTrace = append(mock.calls.GetDenomTrace, callInfo)
	mock.lockGetDenomTrace.Unlock()
	return mock.GetDenomTraceFunc(ctx, denomTraceHash)
}

// GetDenomTraceCalls gets all the calls that were made to GetDenomTrace.
// Check the length with:
//
//	len(mockedIBCTransferKeeper.GetDenomTraceCalls())
func (mock *IBCTransferKeeperMock) GetDenomTraceCalls() []struct {
	Ctx            cosmossdktypes.Context
	DenomTraceHash tmbytes.HexBytes
} {
	var calls []struct {
		Ctx            cosmossdktypes.Context
		DenomTraceHash tmbytes.HexBytes
	}
	mock.lockGetDenomTrace.RLock()
	calls = mock.calls.GetDenomTrace
	mock.lockGetDenomTrace.RUnlock()
	return calls
}

// SendTransfer calls SendTransferFunc.
func (mock *IBCTransferKeeperMock) SendTransfer(ctx cosmossdktypes.Context, sourcePort string, sourceChannel string, token cosmossdktypes.Coin, sender cosmossdktypes.AccAddress, receiver string, timeoutHeight clienttypes.Height, timeoutTimestamp uint64) error {
	if mock.SendTransferFunc == nil {
		panic("IBCTransferKeeperMock.SendTransferFunc: method is nil but IBCTransferKeeper.SendTransfer was just called")
	}
	callInfo := struct {
		Ctx              cosmossdktypes.Context
		SourcePort       string
		SourceChannel    string
		Token            cosmossdktypes.Coin
		Sender           cosmossdktypes.AccAddress
		Receiver         string
		TimeoutHeight    clienttypes.Height
		TimeoutTimestamp uint64
	}{
		Ctx:              ctx,
		SourcePort:       sourcePort,
		SourceChannel:    sourceChannel,
		Token:            token,
		Sender:           sender,
		Receiver:         receiver,
		TimeoutHeight:    timeoutHeight,
		TimeoutTimestamp: timeoutTimestamp,
	}
	mock.lockSendTransfer.Lock()
	mock.calls.SendTransfer = append(mock.calls.SendTransfer, callInfo)
	mock.lockSendTransfer.Unlock()
	return mock.SendTransferFunc(ctx, sourcePort, sourceChannel, token, sender, receiver, timeoutHeight, timeoutTimestamp)
}

// SendTransferCalls gets all the calls that were made to SendTransfer.
// Check the length with:
//
//	len(mockedIBCTransferKeeper.SendTransferCalls())
func (mock *IBCTransferKeeperMock) SendTransferCalls() []struct {
	Ctx              cosmossdktypes.Context
	SourcePort       string
	SourceChannel    string
	Token            cosmossdktypes.Coin
	Sender           cosmossdktypes.AccAddress
	Receiver         string
	TimeoutHeight    clienttypes.Height
	TimeoutTimestamp uint64
} {
	var calls []struct {
		Ctx              cosmossdktypes.Context
		SourcePort       string
		SourceChannel    string
		Token            cosmossdktypes.Coin
		Sender           cosmossdktypes.AccAddress
		Receiver         string
		TimeoutHeight    clienttypes.Height
		TimeoutTimestamp uint64
	}
	mock.lockSendTransfer.RLock()
	calls = mock.calls.SendTransfer
	mock.lockSendTransfer.RUnlock()
	return calls
}

// Transfer calls TransferFunc.
func (mock *IBCTransferKeeperMock) Transfer(goCtx context.Context, msg *ibctransfertypes.MsgTransfer) (*ibctransfertypes.MsgTransferResponse, error) {
	if mock.TransferFunc == nil {
		panic("IBCTransferKeeperMock.TransferFunc: method is nil but IBCTransferKeeper.Transfer was just called")
	}
	callInfo := struct {
		GoCtx context.Context
		Msg   *ibctransfertypes.MsgTransfer
	}{
		GoCtx: goCtx,
		Msg:   msg,
	}
	mock.lockTransfer.Lock()
	mock.calls.Transfer = append(mock.calls.Transfer, callInfo)
	mock.lockTransfer.Unlock()
	return mock.TransferFunc(goCtx, msg)
}

// TransferCalls gets all the calls that were made to Transfer.
// Check the length with:
//
//	len(mockedIBCTransferKeeper.TransferCalls())
func (mock *IBCTransferKeeperMock) TransferCalls() []struct {
	GoCtx context.Context
	Msg   *ibctransfertypes.MsgTransfer
} {
	var calls []struct {
		GoCtx context.Context
		Msg   *ibctransfertypes.MsgTransfer
	}
	mock.lockTransfer.RLock()
	calls = mock.calls.Transfer
	mock.lockTransfer.RUnlock()
	return calls
}

// Ensure, that ChannelKeeperMock does implement axelarnettypes.ChannelKeeper.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.ChannelKeeper = &ChannelKeeperMock{}

// ChannelKeeperMock is a mock implementation of axelarnettypes.ChannelKeeper.
//
//	func TestSomethingThatUsesChannelKeeper(t *testing.T) {
//
//		// make and configure a mocked axelarnettypes.ChannelKeeper
//		mockedChannelKeeper := &ChannelKeeperMock{
//			GetAppVersionFunc: func(ctx cosmossdktypes.Context, portID string, channelID string) (string, bool) {
//				panic("mock out the GetAppVersion method")
//			},
//			GetChannelFunc: func(ctx cosmossdktypes.Context, srcPort string, srcChan string) (channeltypes.Channel, bool) {
//				panic("mock out the GetChannel method")
//			},
//			GetChannelClientStateFunc: func(ctx cosmossdktypes.Context, portID string, channelID string) (string, ibcexported.ClientState, error) {
//				panic("mock out the GetChannelClientState method")
//			},
//			GetNextSequenceSendFunc: func(ctx cosmossdktypes.Context, portID string, channelID string) (uint64, bool) {
//				panic("mock out the GetNextSequenceSend method")
//			},
//			SendPacketFunc: func(ctx cosmossdktypes.Context, channelCap *capabilitytypes.Capability, packet ibcexported.PacketI) error {
//				panic("mock out the SendPacket method")
//			},
//			WriteAcknowledgementFunc: func(ctx cosmossdktypes.Context, chanCap *capabilitytypes.Capability, packet ibcexported.PacketI, ack ibcexported.Acknowledgement) error {
//				panic("mock out the WriteAcknowledgement method")
//			},
//		}
//
//		// use mockedChannelKeeper in code that requires axelarnettypes.ChannelKeeper
//		// and then make assertions.
//
//	}
type ChannelKeeperMock struct {
	// GetAppVersionFunc mocks the GetAppVersion method.
	GetAppVersionFunc func(ctx cosmossdktypes.Context, portID string, channelID string) (string, bool)

	// GetChannelFunc mocks the GetChannel method.
	GetChannelFunc func(ctx cosmossdktypes.Context, srcPort string, srcChan string) (channeltypes.Channel, bool)

	// GetChannelClientStateFunc mocks the GetChannelClientState method.
	GetChannelClientStateFunc func(ctx cosmossdktypes.Context, portID string, channelID string) (string, ibcexported.ClientState, error)

	// GetNextSequenceSendFunc mocks the GetNextSequenceSend method.
	GetNextSequenceSendFunc func(ctx cosmossdktypes.Context, portID string, channelID string) (uint64, bool)

	// SendPacketFunc mocks the SendPacket method.
	SendPacketFunc func(ctx cosmossdktypes.Context, channelCap *capabilitytypes.Capability, packet ibcexported.PacketI) error

	// WriteAcknowledgementFunc mocks the WriteAcknowledgement method.
	WriteAcknowledgementFunc func(ctx cosmossdktypes.Context, chanCap *capabilitytypes.Capability, packet ibcexported.PacketI, ack ibcexported.Acknowledgement) error

	// calls tracks calls to the methods.
	calls struct {
		// GetAppVersion holds details about calls to the GetAppVersion method.
		GetAppVersion []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// PortID is the portID argument value.
			PortID string
			// ChannelID is the channelID argument value.
			ChannelID string
		}
		// GetChannel holds details about calls to the GetChannel method.
		GetChannel []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// SrcPort is the srcPort argument value.
			SrcPort string
			// SrcChan is the srcChan argument value.
			SrcChan string
		}
		// GetChannelClientState holds details about calls to the GetChannelClientState method.
		GetChannelClientState []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// PortID is the portID argument value.
			PortID string
			// ChannelID is the channelID argument value.
			ChannelID string
		}
		// GetNextSequenceSend holds details about calls to the GetNextSequenceSend method.
		GetNextSequenceSend []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// PortID is the portID argument value.
			PortID string
			// ChannelID is the channelID argument value.
			ChannelID string
		}
		// SendPacket holds details about calls to the SendPacket method.
		SendPacket []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ChannelCap is the channelCap argument value.
			ChannelCap *capabilitytypes.Capability
			// Packet is the packet argument value.
			Packet ibcexported.PacketI
		}
		// WriteAcknowledgement holds details about calls to the WriteAcknowledgement method.
		WriteAcknowledgement []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ChanCap is the chanCap argument value.
			ChanCap *capabilitytypes.Capability
			// Packet is the packet argument value.
			Packet ibcexported.PacketI
			// Ack is the ack argument value.
			Ack ibcexported.Acknowledgement
		}
	}
	lockGetAppVersion         sync.RWMutex
	lockGetChannel            sync.RWMutex
	lockGetChannelClientState sync.RWMutex
	lockGetNextSequenceSend   sync.RWMutex
	lockSendPacket            sync.RWMutex
	lockWriteAcknowledgement  sync.RWMutex
}

// GetAppVersion calls GetAppVersionFunc.
func (mock *ChannelKeeperMock) GetAppVersion(ctx cosmossdktypes.Context, portID string, channelID string) (string, bool) {
	if mock.GetAppVersionFunc == nil {
		panic("ChannelKeeperMock.GetAppVersionFunc: method is nil but ChannelKeeper.GetAppVersion was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		PortID    string
		ChannelID string
	}{
		Ctx:       ctx,
		PortID:    portID,
		ChannelID: channelID,
	}
	mock.lockGetAppVersion.Lock()
	mock.calls.GetAppVersion = append(mock.calls.GetAppVersion, callInfo)
	mock.lockGetAppVersion.Unlock()
	return mock.GetAppVersionFunc(ctx, portID, channelID)
}

// GetAppVersionCalls gets all the calls that were made to GetAppVersion.
// Check the length with:
//
//	len(mockedChannelKeeper.GetAppVersionCalls())
func (mock *ChannelKeeperMock) GetAppVersionCalls() []struct {
	Ctx       cosmossdktypes.Context
	PortID    string
	ChannelID string
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		PortID    string
		ChannelID string
	}
	mock.lockGetAppVersion.RLock()
	calls = mock.calls.GetAppVersion
	mock.lockGetAppVersion.RUnlock()
	return calls
}

// GetChannel calls GetChannelFunc.
func (mock *ChannelKeeperMock) GetChannel(ctx cosmossdktypes.Context, srcPort string, srcChan string) (channeltypes.Channel, bool) {
	if mock.GetChannelFunc == nil {
		panic("ChannelKeeperMock.GetChannelFunc: method is nil but ChannelKeeper.GetChannel was just called")
	}
	callInfo := struct {
		Ctx     cosmossdktypes.Context
		SrcPort string
		SrcChan string
	}{
		Ctx:     ctx,
		SrcPort: srcPort,
		SrcChan: srcChan,
	}
	mock.lockGetChannel.Lock()
	mock.calls.GetChannel = append(mock.calls.GetChannel, callInfo)
	mock.lockGetChannel.Unlock()
	return mock.GetChannelFunc(ctx, srcPort, srcChan)
}

// GetChannelCalls gets all the calls that were made to GetChannel.
// Check the length with:
//
//	len(mockedChannelKeeper.GetChannelCalls())
func (mock *ChannelKeeperMock) GetChannelCalls() []struct {
	Ctx     cosmossdktypes.Context
	SrcPort string
	SrcChan string
} {
	var calls []struct {
		Ctx     cosmossdktypes.Context
		SrcPort string
		SrcChan string
	}
	mock.lockGetChannel.RLock()
	calls = mock.calls.GetChannel
	mock.lockGetChannel.RUnlock()
	return calls
}

// GetChannelClientState calls GetChannelClientStateFunc.
func (mock *ChannelKeeperMock) GetChannelClientState(ctx cosmossdktypes.Context, portID string, channelID string) (string, ibcexported.ClientState, error) {
	if mock.GetChannelClientStateFunc == nil {
		panic("ChannelKeeperMock.GetChannelClientStateFunc: method is nil but ChannelKeeper.GetChannelClientState was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		PortID    string
		ChannelID string
	}{
		Ctx:       ctx,
		PortID:    portID,
		ChannelID: channelID,
	}
	mock.lockGetChannelClientState.Lock()
	mock.calls.GetChannelClientState = append(mock.calls.GetChannelClientState, callInfo)
	mock.lockGetChannelClientState.Unlock()
	return mock.GetChannelClientStateFunc(ctx, portID, channelID)
}

// GetChannelClientStateCalls gets all the calls that were made to GetChannelClientState.
// Check the length with:
//
//	len(mockedChannelKeeper.GetChannelClientStateCalls())
func (mock *ChannelKeeperMock) GetChannelClientStateCalls() []struct {
	Ctx       cosmossdktypes.Context
	PortID    string
	ChannelID string
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		PortID    string
		ChannelID string
	}
	mock.lockGetChannelClientState.RLock()
	calls = mock.calls.GetChannelClientState
	mock.lockGetChannelClientState.RUnlock()
	return calls
}

// GetNextSequenceSend calls GetNextSequenceSendFunc.
func (mock *ChannelKeeperMock) GetNextSequenceSend(ctx cosmossdktypes.Context, portID string, channelID string) (uint64, bool) {
	if mock.GetNextSequenceSendFunc == nil {
		panic("ChannelKeeperMock.GetNextSequenceSendFunc: method is nil but ChannelKeeper.GetNextSequenceSend was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		PortID    string
		ChannelID string
	}{
		Ctx:       ctx,
		PortID:    portID,
		ChannelID: channelID,
	}
	mock.lockGetNextSequenceSend.Lock()
	mock.calls.GetNextSequenceSend = append(mock.calls.GetNextSequenceSend, callInfo)
	mock.lockGetNextSequenceSend.Unlock()
	return mock.GetNextSequenceSendFunc(ctx, portID, channelID)
}

// GetNextSequenceSendCalls gets all the calls that were made to GetNextSequenceSend.
// Check the length with:
//
//	len(mockedChannelKeeper.GetNextSequenceSendCalls())
func (mock *ChannelKeeperMock) GetNextSequenceSendCalls() []struct {
	Ctx       cosmossdktypes.Context
	PortID    string
	ChannelID string
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		PortID    string
		ChannelID string
	}
	mock.lockGetNextSequenceSend.RLock()
	calls = mock.calls.GetNextSequenceSend
	mock.lockGetNextSequenceSend.RUnlock()
	return calls
}

// SendPacket calls SendPacketFunc.
func (mock *ChannelKeeperMock) SendPacket(ctx cosmossdktypes.Context, channelCap *capabilitytypes.Capability, packet ibcexported.PacketI) error {
	if mock.SendPacketFunc == nil {
		panic("ChannelKeeperMock.SendPacketFunc: method is nil but ChannelKeeper.SendPacket was just called")
	}
	callInfo := struct {
		Ctx        cosmossdktypes.Context
		ChannelCap *capabilitytypes.Capability
		Packet     ibcexported.PacketI
	}{
		Ctx:        ctx,
		ChannelCap: channelCap,
		Packet:     packet,
	}
	mock.lockSendPacket.Lock()
	mock.calls.SendPacket = append(mock.calls.SendPacket, callInfo)
	mock.lockSendPacket.Unlock()
	return mock.SendPacketFunc(ctx, channelCap, packet)
}

// SendPacketCalls gets all the calls that were made to SendPacket.
// Check the length with:
//
//	len(mockedChannelKeeper.SendPacketCalls())
func (mock *ChannelKeeperMock) SendPacketCalls() []struct {
	Ctx        cosmossdktypes.Context
	ChannelCap *capabilitytypes.Capability
	Packet     ibcexported.PacketI
} {
	var calls []struct {
		Ctx        cosmossdktypes.Context
		ChannelCap *capabilitytypes.Capability
		Packet     ibcexported.PacketI
	}
	mock.lockSendPacket.RLock()
	calls = mock.calls.SendPacket
	mock.lockSendPacket.RUnlock()
	return calls
}

// WriteAcknowledgement calls WriteAcknowledgementFunc.
func (mock *ChannelKeeperMock) WriteAcknowledgement(ctx cosmossdktypes.Context, chanCap *capabilitytypes.Capability, packet ibcexported.PacketI, ack ibcexported.Acknowledgement) error {
	if mock.WriteAcknowledgementFunc == nil {
		panic("ChannelKeeperMock.WriteAcknowledgementFunc: method is nil but ChannelKeeper.WriteAcknowledgement was just called")
	}
	callInfo := struct {
		Ctx     cosmossdktypes.Context
		ChanCap *capabilitytypes.Capability
		Packet  ibcexported.PacketI
		Ack     ibcexported.Acknowledgement
	}{
		Ctx:     ctx,
		ChanCap: chanCap,
		Packet:  packet,
		Ack:     ack,
	}
	mock.lockWriteAcknowledgement.Lock()
	mock.calls.WriteAcknowledgement = append(mock.calls.WriteAcknowledgement, callInfo)
	mock.lockWriteAcknowledgement.Unlock()
	return mock.WriteAcknowledgementFunc(ctx, chanCap, packet, ack)
}

// WriteAcknowledgementCalls gets all the calls that were made to WriteAcknowledgement.
// Check the length with:
//
//	len(mockedChannelKeeper.WriteAcknowledgementCalls())
func (mock *ChannelKeeperMock) WriteAcknowledgementCalls() []struct {
	Ctx     cosmossdktypes.Context
	ChanCap *capabilitytypes.Capability
	Packet  ibcexported.PacketI
	Ack     ibcexported.Acknowledgement
} {
	var calls []struct {
		Ctx     cosmossdktypes.Context
		ChanCap *capabilitytypes.Capability
		Packet  ibcexported.PacketI
		Ack     ibcexported.Acknowledgement
	}
	mock.lockWriteAcknowledgement.RLock()
	calls = mock.calls.WriteAcknowledgement
	mock.lockWriteAcknowledgement.RUnlock()
	return calls
}

// Ensure, that AccountKeeperMock does implement axelarnettypes.AccountKeeper.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.AccountKeeper = &AccountKeeperMock{}

// AccountKeeperMock is a mock implementation of axelarnettypes.AccountKeeper.
//
//	func TestSomethingThatUsesAccountKeeper(t *testing.T) {
//
//		// make and configure a mocked axelarnettypes.AccountKeeper
//		mockedAccountKeeper := &AccountKeeperMock{
//			GetModuleAccountFunc: func(ctx cosmossdktypes.Context, moduleName string) types.ModuleAccountI {
//				panic("mock out the GetModuleAccount method")
//			},
//			GetModuleAddressFunc: func(moduleName string) cosmossdktypes.AccAddress {
//				panic("mock out the GetModuleAddress method")
//			},
//		}
//
//		// use mockedAccountKeeper in code that requires axelarnettypes.AccountKeeper
//		// and then make assertions.
//
//	}
type AccountKeeperMock struct {
	// GetModuleAccountFunc mocks the GetModuleAccount method.
	GetModuleAccountFunc func(ctx cosmossdktypes.Context, moduleName string) types.ModuleAccountI

	// GetModuleAddressFunc mocks the GetModuleAddress method.
	GetModuleAddressFunc func(moduleName string) cosmossdktypes.AccAddress

	// calls tracks calls to the methods.
	calls struct {
		// GetModuleAccount holds details about calls to the GetModuleAccount method.
		GetModuleAccount []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ModuleName is the moduleName argument value.
			ModuleName string
		}
		// GetModuleAddress holds details about calls to the GetModuleAddress method.
		GetModuleAddress []struct {
			// ModuleName is the moduleName argument value.
			ModuleName string
		}
	}
	lockGetModuleAccount sync.RWMutex
	lockGetModuleAddress sync.RWMutex
}

// GetModuleAccount calls GetModuleAccountFunc.
func (mock *AccountKeeperMock) GetModuleAccount(ctx cosmossdktypes.Context, moduleName string) types.ModuleAccountI {
	if mock.GetModuleAccountFunc == nil {
		panic("AccountKeeperMock.GetModuleAccountFunc: method is nil but AccountKeeper.GetModuleAccount was just called")
	}
	callInfo := struct {
		Ctx        cosmossdktypes.Context
		ModuleName string
	}{
		Ctx:        ctx,
		ModuleName: moduleName,
	}
	mock.lockGetModuleAccount.Lock()
	mock.calls.GetModuleAccount = append(mock.calls.GetModuleAccount, callInfo)
	mock.lockGetModuleAccount.Unlock()
	return mock.GetModuleAccountFunc(ctx, moduleName)
}

// GetModuleAccountCalls gets all the calls that were made to GetModuleAccount.
// Check the length with:
//
//	len(mockedAccountKeeper.GetModuleAccountCalls())
func (mock *AccountKeeperMock) GetModuleAccountCalls() []struct {
	Ctx        cosmossdktypes.Context
	ModuleName string
} {
	var calls []struct {
		Ctx        cosmossdktypes.Context
		ModuleName string
	}
	mock.lockGetModuleAccount.RLock()
	calls = mock.calls.GetModuleAccount
	mock.lockGetModuleAccount.RUnlock()
	return calls
}

// GetModuleAddress calls GetModuleAddressFunc.
func (mock *AccountKeeperMock) GetModuleAddress(moduleName string) cosmossdktypes.AccAddress {
	if mock.GetModuleAddressFunc == nil {
		panic("AccountKeeperMock.GetModuleAddressFunc: method is nil but AccountKeeper.GetModuleAddress was just called")
	}
	callInfo := struct {
		ModuleName string
	}{
		ModuleName: moduleName,
	}
	mock.lockGetModuleAddress.Lock()
	mock.calls.GetModuleAddress = append(mock.calls.GetModuleAddress, callInfo)
	mock.lockGetModuleAddress.Unlock()
	return mock.GetModuleAddressFunc(moduleName)
}

// GetModuleAddressCalls gets all the calls that were made to GetModuleAddress.
// Check the length with:
//
//	len(mockedAccountKeeper.GetModuleAddressCalls())
func (mock *AccountKeeperMock) GetModuleAddressCalls() []struct {
	ModuleName string
} {
	var calls []struct {
		ModuleName string
	}
	mock.lockGetModuleAddress.RLock()
	calls = mock.calls.GetModuleAddress
	mock.lockGetModuleAddress.RUnlock()
	return calls
}

// Ensure, that PortKeeperMock does implement axelarnettypes.PortKeeper.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.PortKeeper = &PortKeeperMock{}

// PortKeeperMock is a mock implementation of axelarnettypes.PortKeeper.
//
//	func TestSomethingThatUsesPortKeeper(t *testing.T) {
//
//		// make and configure a mocked axelarnettypes.PortKeeper
//		mockedPortKeeper := &PortKeeperMock{
//			BindPortFunc: func(ctx cosmossdktypes.Context, portID string) *capabilitytypes.Capability {
//				panic("mock out the BindPort method")
//			},
//		}
//
//		// use mockedPortKeeper in code that requires axelarnettypes.PortKeeper
//		// and then make assertions.
//
//	}
type PortKeeperMock struct {
	// BindPortFunc mocks the BindPort method.
	BindPortFunc func(ctx cosmossdktypes.Context, portID string) *capabilitytypes.Capability

	// calls tracks calls to the methods.
	calls struct {
		// BindPort holds details about calls to the BindPort method.
		BindPort []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// PortID is the portID argument value.
			PortID string
		}
	}
	lockBindPort sync.RWMutex
}

// BindPort calls BindPortFunc.
func (mock *PortKeeperMock) BindPort(ctx cosmossdktypes.Context, portID string) *capabilitytypes.Capability {
	if mock.BindPortFunc == nil {
		panic("PortKeeperMock.BindPortFunc: method is nil but PortKeeper.BindPort was just called")
	}
	callInfo := struct {
		Ctx    cosmossdktypes.Context
		PortID string
	}{
		Ctx:    ctx,
		PortID: portID,
	}
	mock.lockBindPort.Lock()
	mock.calls.BindPort = append(mock.calls.BindPort, callInfo)
	mock.lockBindPort.Unlock()
	return mock.BindPortFunc(ctx, portID)
}

// BindPortCalls gets all the calls that were made to BindPort.
// Check the length with:
//
//	len(mockedPortKeeper.BindPortCalls())
func (mock *PortKeeperMock) BindPortCalls() []struct {
	Ctx    cosmossdktypes.Context
	PortID string
} {
	var calls []struct {
		Ctx    cosmossdktypes.Context
		PortID string
	}
	mock.lockBindPort.RLock()
	calls = mock.calls.BindPort
	mock.lockBindPort.RUnlock()
	return calls
}

// Ensure, that GovKeeperMock does implement axelarnettypes.GovKeeper.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.GovKeeper = &GovKeeperMock{}

// GovKeeperMock is a mock implementation of axelarnettypes.GovKeeper.
//
//	func TestSomethingThatUsesGovKeeper(t *testing.T) {
//
//		// make and configure a mocked axelarnettypes.GovKeeper
//		mockedGovKeeper := &GovKeeperMock{
//			GetProposalFunc: func(ctx cosmossdktypes.Context, proposalID uint64) (gov.Proposal, bool) {
//				panic("mock out the GetProposal method")
//			},
//		}
//
//		// use mockedGovKeeper in code that requires axelarnettypes.GovKeeper
//		// and then make assertions.
//
//	}
type GovKeeperMock struct {
	// GetProposalFunc mocks the GetProposal method.
	GetProposalFunc func(ctx cosmossdktypes.Context, proposalID uint64) (gov.Proposal, bool)

	// calls tracks calls to the methods.
	calls struct {
		// GetProposal holds details about calls to the GetProposal method.
		GetProposal []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ProposalID is the proposalID argument value.
			ProposalID uint64
		}
	}
	lockGetProposal sync.RWMutex
}

// GetProposal calls GetProposalFunc.
func (mock *GovKeeperMock) GetProposal(ctx cosmossdktypes.Context, proposalID uint64) (gov.Proposal, bool) {
	if mock.GetProposalFunc == nil {
		panic("GovKeeperMock.GetProposalFunc: method is nil but GovKeeper.GetProposal was just called")
	}
	callInfo := struct {
		Ctx        cosmossdktypes.Context
		ProposalID uint64
	}{
		Ctx:        ctx,
		ProposalID: proposalID,
	}
	mock.lockGetProposal.Lock()
	mock.calls.GetProposal = append(mock.calls.GetProposal, callInfo)
	mock.lockGetProposal.Unlock()
	return mock.GetProposalFunc(ctx, proposalID)
}

// GetProposalCalls gets all the calls that were made to GetProposal.
// Check the length with:
//
//	len(mockedGovKeeper.GetProposalCalls())
func (mock *GovKeeperMock) GetProposalCalls() []struct {
	Ctx        cosmossdktypes.Context
	ProposalID uint64
} {
	var calls []struct {
		Ctx        cosmossdktypes.Context
		ProposalID uint64
	}
	mock.lockGetProposal.RLock()
	calls = mock.calls.GetProposal
	mock.lockGetProposal.RUnlock()
	return calls
}

// Ensure, that FeegrantKeeperMock does implement axelarnettypes.FeegrantKeeper.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.FeegrantKeeper = &FeegrantKeeperMock{}

// FeegrantKeeperMock is a mock implementation of axelarnettypes.FeegrantKeeper.
//
//	func TestSomethingThatUsesFeegrantKeeper(t *testing.T) {
//
//		// make and configure a mocked axelarnettypes.FeegrantKeeper
//		mockedFeegrantKeeper := &FeegrantKeeperMock{
//			UseGrantedFeesFunc: func(ctx cosmossdktypes.Context, granter cosmossdktypes.AccAddress, grantee cosmossdktypes.AccAddress, fee cosmossdktypes.Coins, msgs []cosmossdktypes.Msg) error {
//				panic("mock out the UseGrantedFees method")
//			},
//		}
//
//		// use mockedFeegrantKeeper in code that requires axelarnettypes.FeegrantKeeper
//		// and then make assertions.
//
//	}
type FeegrantKeeperMock struct {
	// UseGrantedFeesFunc mocks the UseGrantedFees method.
	UseGrantedFeesFunc func(ctx cosmossdktypes.Context, granter cosmossdktypes.AccAddress, grantee cosmossdktypes.AccAddress, fee cosmossdktypes.Coins, msgs []cosmossdktypes.Msg) error

	// calls tracks calls to the methods.
	calls struct {
		// UseGrantedFees holds details about calls to the UseGrantedFees method.
		UseGrantedFees []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Granter is the granter argument value.
			Granter cosmossdktypes.AccAddress
			// Grantee is the grantee argument value.
			Grantee cosmossdktypes.AccAddress
			// Fee is the fee argument value.
			Fee cosmossdktypes.Coins
			// Msgs is the msgs argument value.
			Msgs []cosmossdktypes.Msg
		}
	}
	lockUseGrantedFees sync.RWMutex
}

// UseGrantedFees calls UseGrantedFeesFunc.
func (mock *FeegrantKeeperMock) UseGrantedFees(ctx cosmossdktypes.Context, granter cosmossdktypes.AccAddress, grantee cosmossdktypes.AccAddress, fee cosmossdktypes.Coins, msgs []cosmossdktypes.Msg) error {
	if mock.UseGrantedFeesFunc == nil {
		panic("FeegrantKeeperMock.UseGrantedFeesFunc: method is nil but FeegrantKeeper.UseGrantedFees was just called")
	}
	callInfo := struct {
		Ctx     cosmossdktypes.Context
		Granter cosmossdktypes.AccAddress
		Grantee cosmossdktypes.AccAddress
		Fee     cosmossdktypes.Coins
		Msgs    []cosmossdktypes.Msg
	}{
		Ctx:     ctx,
		Granter: granter,
		Grantee: grantee,
		Fee:     fee,
		Msgs:    msgs,
	}
	mock.lockUseGrantedFees.Lock()
	mock.calls.UseGrantedFees = append(mock.calls.UseGrantedFees, callInfo)
	mock.lockUseGrantedFees.Unlock()
	return mock.UseGrantedFeesFunc(ctx, granter, grantee, fee, msgs)
}

// UseGrantedFeesCalls gets all the calls that were made to UseGrantedFees.
// Check the length with:
//
//	len(mockedFeegrantKeeper.UseGrantedFeesCalls())
func (mock *FeegrantKeeperMock) UseGrantedFeesCalls() []struct {
	Ctx     cosmossdktypes.Context
	Granter cosmossdktypes.AccAddress
	Grantee cosmossdktypes.AccAddress
	Fee     cosmossdktypes.Coins
	Msgs    []cosmossdktypes.Msg
} {
	var calls []struct {
		Ctx     cosmossdktypes.Context
		Granter cosmossdktypes.AccAddress
		Grantee cosmossdktypes.AccAddress
		Fee     cosmossdktypes.Coins
		Msgs    []cosmossdktypes.Msg
	}
	mock.lockUseGrantedFees.RLock()
	calls = mock.calls.UseGrantedFees
	mock.lockUseGrantedFees.RUnlock()
	return calls
}

// Ensure, that IBCKeeperMock does implement axelarnettypes.IBCKeeper.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.IBCKeeper = &IBCKeeperMock{}

// IBCKeeperMock is a mock implementation of axelarnettypes.IBCKeeper.
//
//	func TestSomethingThatUsesIBCKeeper(t *testing.T) {
//
//		// make and configure a mocked axelarnettypes.IBCKeeper
//		mockedIBCKeeper := &IBCKeeperMock{
//			SendMessageFunc: func(c context.Context, recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, asset cosmossdktypes.Coin, payload string, id string) error {
//				panic("mock out the SendMessage method")
//			},
//		}
//
//		// use mockedIBCKeeper in code that requires axelarnettypes.IBCKeeper
//		// and then make assertions.
//
//	}
type IBCKeeperMock struct {
	// SendMessageFunc mocks the SendMessage method.
	SendMessageFunc func(c context.Context, recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, asset cosmossdktypes.Coin, payload string, id string) error

	// calls tracks calls to the methods.
	calls struct {
		// SendMessage holds details about calls to the SendMessage method.
		SendMessage []struct {
			// C is the c argument value.
			C context.Context
			// Recipient is the recipient argument value.
			Recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
			// Asset is the asset argument value.
			Asset cosmossdktypes.Coin
			// Payload is the payload argument value.
			Payload string
			// ID is the id argument value.
			ID string
		}
	}
	lockSendMessage sync.RWMutex
}

// SendMessage calls SendMessageFunc.
func (mock *IBCKeeperMock) SendMessage(c context.Context, recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, asset cosmossdktypes.Coin, payload string, id string) error {
	if mock.SendMessageFunc == nil {
		panic("IBCKeeperMock.SendMessageFunc: method is nil but IBCKeeper.SendMessage was just called")
	}
	callInfo := struct {
		C         context.Context
		Recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
		Asset     cosmossdktypes.Coin
		Payload   string
		ID        string
	}{
		C:         c,
		Recipient: recipient,
		Asset:     asset,
		Payload:   payload,
		ID:        id,
	}
	mock.lockSendMessage.Lock()
	mock.calls.SendMessage = append(mock.calls.SendMessage, callInfo)
	mock.lockSendMessage.Unlock()
	return mock.SendMessageFunc(c, recipient, asset, payload, id)
}

// SendMessageCalls gets all the calls that were made to SendMessage.
// Check the length with:
//
//	len(mockedIBCKeeper.SendMessageCalls())
func (mock *IBCKeeperMock) SendMessageCalls() []struct {
	C         context.Context
	Recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
	Asset     cosmossdktypes.Coin
	Payload   string
	ID        string
} {
	var calls []struct {
		C         context.Context
		Recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
		Asset     cosmossdktypes.Coin
		Payload   string
		ID        string
	}
	mock.lockSendMessage.RLock()
	calls = mock.calls.SendMessage
	mock.lockSendMessage.RUnlock()
	return calls
}
