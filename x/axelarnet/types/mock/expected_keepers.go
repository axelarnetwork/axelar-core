// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	utils "github.com/axelarnetwork/axelar-core/utils"
	axelarnettypes "github.com/axelarnetwork/axelar-core/x/axelarnet/types"
	github_com_axelarnetwork_axelar_core_x_nexus_exported "github.com/axelarnetwork/axelar-core/x/nexus/exported"
	cosmossdktypes "github.com/cosmos/cosmos-sdk/types"
	"github.com/cosmos/cosmos-sdk/types/query"
	"github.com/cosmos/cosmos-sdk/x/auth/types"
	capabilitytypes "github.com/cosmos/cosmos-sdk/x/capability/types"
	ibctypes "github.com/cosmos/ibc-go/v2/modules/apps/transfer/types"
	clienttypes "github.com/cosmos/ibc-go/v2/modules/core/02-client/types"
	channeltypes "github.com/cosmos/ibc-go/v2/modules/core/04-channel/types"
	ibcexported "github.com/cosmos/ibc-go/v2/modules/core/exported"
	tmbytes "github.com/tendermint/tendermint/libs/bytes"
	"github.com/tendermint/tendermint/libs/log"
	"sync"
)

// Ensure, that BaseKeeperMock does implement axelarnettypes.BaseKeeper.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.BaseKeeper = &BaseKeeperMock{}

// BaseKeeperMock is a mock implementation of axelarnettypes.BaseKeeper.
//
// 	func TestSomethingThatUsesBaseKeeper(t *testing.T) {
//
// 		// make and configure a mocked axelarnettypes.BaseKeeper
// 		mockedBaseKeeper := &BaseKeeperMock{
// 			EnqueueIBCTransferFunc: func(ctx cosmossdktypes.Context, transfer axelarnettypes.IBCTransfer) error {
// 				panic("mock out the EnqueueIBCTransfer method")
// 			},
// 			GetCosmosChainByNameFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (axelarnettypes.CosmosChain, bool) {
// 				panic("mock out the GetCosmosChainByName method")
// 			},
// 			GetCosmosChainsFunc: func(ctx cosmossdktypes.Context) []github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName {
// 				panic("mock out the GetCosmosChains method")
// 			},
// 			GetEndBlockerLimitFunc: func(ctx cosmossdktypes.Context) uint64 {
// 				panic("mock out the GetEndBlockerLimit method")
// 			},
// 			GetIBCTransferQueueFunc: func(ctx cosmossdktypes.Context) utils.KVQueue {
// 				panic("mock out the GetIBCTransferQueue method")
// 			},
// 			GetRouteTimeoutWindowFunc: func(ctx cosmossdktypes.Context) uint64 {
// 				panic("mock out the GetRouteTimeoutWindow method")
// 			},
// 			GetTransferLimitFunc: func(ctx cosmossdktypes.Context) uint64 {
// 				panic("mock out the GetTransferLimit method")
// 			},
// 			LoggerFunc: func(ctx cosmossdktypes.Context) log.Logger {
// 				panic("mock out the Logger method")
// 			},
// 			SetSeqIDMappingFunc: func(ctx cosmossdktypes.Context, t axelarnettypes.IBCTransfer) error {
// 				panic("mock out the SetSeqIDMapping method")
// 			},
// 			SetTransferFailedFunc: func(ctx cosmossdktypes.Context, transferID github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferID) error {
// 				panic("mock out the SetTransferFailed method")
// 			},
// 		}
//
// 		// use mockedBaseKeeper in code that requires axelarnettypes.BaseKeeper
// 		// and then make assertions.
//
// 	}
type BaseKeeperMock struct {
	// EnqueueIBCTransferFunc mocks the EnqueueIBCTransfer method.
	EnqueueIBCTransferFunc func(ctx cosmossdktypes.Context, transfer axelarnettypes.IBCTransfer) error

	// GetCosmosChainByNameFunc mocks the GetCosmosChainByName method.
	GetCosmosChainByNameFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (axelarnettypes.CosmosChain, bool)

	// GetCosmosChainsFunc mocks the GetCosmosChains method.
	GetCosmosChainsFunc func(ctx cosmossdktypes.Context) []github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName

	// GetEndBlockerLimitFunc mocks the GetEndBlockerLimit method.
	GetEndBlockerLimitFunc func(ctx cosmossdktypes.Context) uint64

	// GetIBCTransferQueueFunc mocks the GetIBCTransferQueue method.
	GetIBCTransferQueueFunc func(ctx cosmossdktypes.Context) utils.KVQueue

	// GetRouteTimeoutWindowFunc mocks the GetRouteTimeoutWindow method.
	GetRouteTimeoutWindowFunc func(ctx cosmossdktypes.Context) uint64

	// GetTransferLimitFunc mocks the GetTransferLimit method.
	GetTransferLimitFunc func(ctx cosmossdktypes.Context) uint64

	// LoggerFunc mocks the Logger method.
	LoggerFunc func(ctx cosmossdktypes.Context) log.Logger

	// SetSeqIDMappingFunc mocks the SetSeqIDMapping method.
	SetSeqIDMappingFunc func(ctx cosmossdktypes.Context, t axelarnettypes.IBCTransfer) error

	// SetTransferFailedFunc mocks the SetTransferFailed method.
	SetTransferFailedFunc func(ctx cosmossdktypes.Context, transferID github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferID) error

	// calls tracks calls to the methods.
	calls struct {
		// EnqueueIBCTransfer holds details about calls to the EnqueueIBCTransfer method.
		EnqueueIBCTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Transfer is the transfer argument value.
			Transfer axelarnettypes.IBCTransfer
		}
		// GetCosmosChainByName holds details about calls to the GetCosmosChainByName method.
		GetCosmosChainByName []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
		}
		// GetCosmosChains holds details about calls to the GetCosmosChains method.
		GetCosmosChains []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// GetEndBlockerLimit holds details about calls to the GetEndBlockerLimit method.
		GetEndBlockerLimit []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// GetIBCTransferQueue holds details about calls to the GetIBCTransferQueue method.
		GetIBCTransferQueue []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// GetRouteTimeoutWindow holds details about calls to the GetRouteTimeoutWindow method.
		GetRouteTimeoutWindow []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// GetTransferLimit holds details about calls to the GetTransferLimit method.
		GetTransferLimit []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// Logger holds details about calls to the Logger method.
		Logger []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// SetSeqIDMapping holds details about calls to the SetSeqIDMapping method.
		SetSeqIDMapping []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// T is the t argument value.
			T axelarnettypes.IBCTransfer
		}
		// SetTransferFailed holds details about calls to the SetTransferFailed method.
		SetTransferFailed []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// TransferID is the transferID argument value.
			TransferID github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferID
		}
	}
	lockEnqueueIBCTransfer    sync.RWMutex
	lockGetCosmosChainByName  sync.RWMutex
	lockGetCosmosChains       sync.RWMutex
	lockGetEndBlockerLimit    sync.RWMutex
	lockGetIBCTransferQueue   sync.RWMutex
	lockGetRouteTimeoutWindow sync.RWMutex
	lockGetTransferLimit      sync.RWMutex
	lockLogger                sync.RWMutex
	lockSetSeqIDMapping       sync.RWMutex
	lockSetTransferFailed     sync.RWMutex
}

// EnqueueIBCTransfer calls EnqueueIBCTransferFunc.
func (mock *BaseKeeperMock) EnqueueIBCTransfer(ctx cosmossdktypes.Context, transfer axelarnettypes.IBCTransfer) error {
	if mock.EnqueueIBCTransferFunc == nil {
		panic("BaseKeeperMock.EnqueueIBCTransferFunc: method is nil but BaseKeeper.EnqueueIBCTransfer was just called")
	}
	callInfo := struct {
		Ctx      cosmossdktypes.Context
		Transfer axelarnettypes.IBCTransfer
	}{
		Ctx:      ctx,
		Transfer: transfer,
	}
	mock.lockEnqueueIBCTransfer.Lock()
	mock.calls.EnqueueIBCTransfer = append(mock.calls.EnqueueIBCTransfer, callInfo)
	mock.lockEnqueueIBCTransfer.Unlock()
	return mock.EnqueueIBCTransferFunc(ctx, transfer)
}

// EnqueueIBCTransferCalls gets all the calls that were made to EnqueueIBCTransfer.
// Check the length with:
//     len(mockedBaseKeeper.EnqueueIBCTransferCalls())
func (mock *BaseKeeperMock) EnqueueIBCTransferCalls() []struct {
	Ctx      cosmossdktypes.Context
	Transfer axelarnettypes.IBCTransfer
} {
	var calls []struct {
		Ctx      cosmossdktypes.Context
		Transfer axelarnettypes.IBCTransfer
	}
	mock.lockEnqueueIBCTransfer.RLock()
	calls = mock.calls.EnqueueIBCTransfer
	mock.lockEnqueueIBCTransfer.RUnlock()
	return calls
}

// GetCosmosChainByName calls GetCosmosChainByNameFunc.
func (mock *BaseKeeperMock) GetCosmosChainByName(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (axelarnettypes.CosmosChain, bool) {
	if mock.GetCosmosChainByNameFunc == nil {
		panic("BaseKeeperMock.GetCosmosChainByNameFunc: method is nil but BaseKeeper.GetCosmosChainByName was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockGetCosmosChainByName.Lock()
	mock.calls.GetCosmosChainByName = append(mock.calls.GetCosmosChainByName, callInfo)
	mock.lockGetCosmosChainByName.Unlock()
	return mock.GetCosmosChainByNameFunc(ctx, chain)
}

// GetCosmosChainByNameCalls gets all the calls that were made to GetCosmosChainByName.
// Check the length with:
//     len(mockedBaseKeeper.GetCosmosChainByNameCalls())
func (mock *BaseKeeperMock) GetCosmosChainByNameCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}
	mock.lockGetCosmosChainByName.RLock()
	calls = mock.calls.GetCosmosChainByName
	mock.lockGetCosmosChainByName.RUnlock()
	return calls
}

// GetCosmosChains calls GetCosmosChainsFunc.
func (mock *BaseKeeperMock) GetCosmosChains(ctx cosmossdktypes.Context) []github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName {
	if mock.GetCosmosChainsFunc == nil {
		panic("BaseKeeperMock.GetCosmosChainsFunc: method is nil but BaseKeeper.GetCosmosChains was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetCosmosChains.Lock()
	mock.calls.GetCosmosChains = append(mock.calls.GetCosmosChains, callInfo)
	mock.lockGetCosmosChains.Unlock()
	return mock.GetCosmosChainsFunc(ctx)
}

// GetCosmosChainsCalls gets all the calls that were made to GetCosmosChains.
// Check the length with:
//     len(mockedBaseKeeper.GetCosmosChainsCalls())
func (mock *BaseKeeperMock) GetCosmosChainsCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockGetCosmosChains.RLock()
	calls = mock.calls.GetCosmosChains
	mock.lockGetCosmosChains.RUnlock()
	return calls
}

// GetEndBlockerLimit calls GetEndBlockerLimitFunc.
func (mock *BaseKeeperMock) GetEndBlockerLimit(ctx cosmossdktypes.Context) uint64 {
	if mock.GetEndBlockerLimitFunc == nil {
		panic("BaseKeeperMock.GetEndBlockerLimitFunc: method is nil but BaseKeeper.GetEndBlockerLimit was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetEndBlockerLimit.Lock()
	mock.calls.GetEndBlockerLimit = append(mock.calls.GetEndBlockerLimit, callInfo)
	mock.lockGetEndBlockerLimit.Unlock()
	return mock.GetEndBlockerLimitFunc(ctx)
}

// GetEndBlockerLimitCalls gets all the calls that were made to GetEndBlockerLimit.
// Check the length with:
//     len(mockedBaseKeeper.GetEndBlockerLimitCalls())
func (mock *BaseKeeperMock) GetEndBlockerLimitCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockGetEndBlockerLimit.RLock()
	calls = mock.calls.GetEndBlockerLimit
	mock.lockGetEndBlockerLimit.RUnlock()
	return calls
}

// GetIBCTransferQueue calls GetIBCTransferQueueFunc.
func (mock *BaseKeeperMock) GetIBCTransferQueue(ctx cosmossdktypes.Context) utils.KVQueue {
	if mock.GetIBCTransferQueueFunc == nil {
		panic("BaseKeeperMock.GetIBCTransferQueueFunc: method is nil but BaseKeeper.GetIBCTransferQueue was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetIBCTransferQueue.Lock()
	mock.calls.GetIBCTransferQueue = append(mock.calls.GetIBCTransferQueue, callInfo)
	mock.lockGetIBCTransferQueue.Unlock()
	return mock.GetIBCTransferQueueFunc(ctx)
}

// GetIBCTransferQueueCalls gets all the calls that were made to GetIBCTransferQueue.
// Check the length with:
//     len(mockedBaseKeeper.GetIBCTransferQueueCalls())
func (mock *BaseKeeperMock) GetIBCTransferQueueCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockGetIBCTransferQueue.RLock()
	calls = mock.calls.GetIBCTransferQueue
	mock.lockGetIBCTransferQueue.RUnlock()
	return calls
}

// GetRouteTimeoutWindow calls GetRouteTimeoutWindowFunc.
func (mock *BaseKeeperMock) GetRouteTimeoutWindow(ctx cosmossdktypes.Context) uint64 {
	if mock.GetRouteTimeoutWindowFunc == nil {
		panic("BaseKeeperMock.GetRouteTimeoutWindowFunc: method is nil but BaseKeeper.GetRouteTimeoutWindow was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetRouteTimeoutWindow.Lock()
	mock.calls.GetRouteTimeoutWindow = append(mock.calls.GetRouteTimeoutWindow, callInfo)
	mock.lockGetRouteTimeoutWindow.Unlock()
	return mock.GetRouteTimeoutWindowFunc(ctx)
}

// GetRouteTimeoutWindowCalls gets all the calls that were made to GetRouteTimeoutWindow.
// Check the length with:
//     len(mockedBaseKeeper.GetRouteTimeoutWindowCalls())
func (mock *BaseKeeperMock) GetRouteTimeoutWindowCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockGetRouteTimeoutWindow.RLock()
	calls = mock.calls.GetRouteTimeoutWindow
	mock.lockGetRouteTimeoutWindow.RUnlock()
	return calls
}

// GetTransferLimit calls GetTransferLimitFunc.
func (mock *BaseKeeperMock) GetTransferLimit(ctx cosmossdktypes.Context) uint64 {
	if mock.GetTransferLimitFunc == nil {
		panic("BaseKeeperMock.GetTransferLimitFunc: method is nil but BaseKeeper.GetTransferLimit was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetTransferLimit.Lock()
	mock.calls.GetTransferLimit = append(mock.calls.GetTransferLimit, callInfo)
	mock.lockGetTransferLimit.Unlock()
	return mock.GetTransferLimitFunc(ctx)
}

// GetTransferLimitCalls gets all the calls that were made to GetTransferLimit.
// Check the length with:
//     len(mockedBaseKeeper.GetTransferLimitCalls())
func (mock *BaseKeeperMock) GetTransferLimitCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockGetTransferLimit.RLock()
	calls = mock.calls.GetTransferLimit
	mock.lockGetTransferLimit.RUnlock()
	return calls
}

// Logger calls LoggerFunc.
func (mock *BaseKeeperMock) Logger(ctx cosmossdktypes.Context) log.Logger {
	if mock.LoggerFunc == nil {
		panic("BaseKeeperMock.LoggerFunc: method is nil but BaseKeeper.Logger was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockLogger.Lock()
	mock.calls.Logger = append(mock.calls.Logger, callInfo)
	mock.lockLogger.Unlock()
	return mock.LoggerFunc(ctx)
}

// LoggerCalls gets all the calls that were made to Logger.
// Check the length with:
//     len(mockedBaseKeeper.LoggerCalls())
func (mock *BaseKeeperMock) LoggerCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockLogger.RLock()
	calls = mock.calls.Logger
	mock.lockLogger.RUnlock()
	return calls
}

// SetSeqIDMapping calls SetSeqIDMappingFunc.
func (mock *BaseKeeperMock) SetSeqIDMapping(ctx cosmossdktypes.Context, t axelarnettypes.IBCTransfer) error {
	if mock.SetSeqIDMappingFunc == nil {
		panic("BaseKeeperMock.SetSeqIDMappingFunc: method is nil but BaseKeeper.SetSeqIDMapping was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
		T   axelarnettypes.IBCTransfer
	}{
		Ctx: ctx,
		T:   t,
	}
	mock.lockSetSeqIDMapping.Lock()
	mock.calls.SetSeqIDMapping = append(mock.calls.SetSeqIDMapping, callInfo)
	mock.lockSetSeqIDMapping.Unlock()
	return mock.SetSeqIDMappingFunc(ctx, t)
}

// SetSeqIDMappingCalls gets all the calls that were made to SetSeqIDMapping.
// Check the length with:
//     len(mockedBaseKeeper.SetSeqIDMappingCalls())
func (mock *BaseKeeperMock) SetSeqIDMappingCalls() []struct {
	Ctx cosmossdktypes.Context
	T   axelarnettypes.IBCTransfer
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
		T   axelarnettypes.IBCTransfer
	}
	mock.lockSetSeqIDMapping.RLock()
	calls = mock.calls.SetSeqIDMapping
	mock.lockSetSeqIDMapping.RUnlock()
	return calls
}

// SetTransferFailed calls SetTransferFailedFunc.
func (mock *BaseKeeperMock) SetTransferFailed(ctx cosmossdktypes.Context, transferID github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferID) error {
	if mock.SetTransferFailedFunc == nil {
		panic("BaseKeeperMock.SetTransferFailedFunc: method is nil but BaseKeeper.SetTransferFailed was just called")
	}
	callInfo := struct {
		Ctx        cosmossdktypes.Context
		TransferID github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferID
	}{
		Ctx:        ctx,
		TransferID: transferID,
	}
	mock.lockSetTransferFailed.Lock()
	mock.calls.SetTransferFailed = append(mock.calls.SetTransferFailed, callInfo)
	mock.lockSetTransferFailed.Unlock()
	return mock.SetTransferFailedFunc(ctx, transferID)
}

// SetTransferFailedCalls gets all the calls that were made to SetTransferFailed.
// Check the length with:
//     len(mockedBaseKeeper.SetTransferFailedCalls())
func (mock *BaseKeeperMock) SetTransferFailedCalls() []struct {
	Ctx        cosmossdktypes.Context
	TransferID github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferID
} {
	var calls []struct {
		Ctx        cosmossdktypes.Context
		TransferID github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferID
	}
	mock.lockSetTransferFailed.RLock()
	calls = mock.calls.SetTransferFailed
	mock.lockSetTransferFailed.RUnlock()
	return calls
}

// Ensure, that NexusMock does implement axelarnettypes.Nexus.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.Nexus = &NexusMock{}

// NexusMock is a mock implementation of axelarnettypes.Nexus.
//
// 	func TestSomethingThatUsesNexus(t *testing.T) {
//
// 		// make and configure a mocked axelarnettypes.Nexus
// 		mockedNexus := &NexusMock{
// 			ActivateChainFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain)  {
// 				panic("mock out the ActivateChain method")
// 			},
// 			ArchivePendingTransferFunc: func(ctx cosmossdktypes.Context, transfer github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainTransfer)  {
// 				panic("mock out the ArchivePendingTransfer method")
// 			},
// 			EnqueueForTransferFunc: func(ctx cosmossdktypes.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, amount cosmossdktypes.Coin) (github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferID, error) {
// 				panic("mock out the EnqueueForTransfer method")
// 			},
// 			GetChainFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, bool) {
// 				panic("mock out the GetChain method")
// 			},
// 			GetChainByNativeAssetFunc: func(ctx cosmossdktypes.Context, asset string) (github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, bool) {
// 				panic("mock out the GetChainByNativeAsset method")
// 			},
// 			GetRecipientFunc: func(ctx cosmossdktypes.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress) (github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, bool) {
// 				panic("mock out the GetRecipient method")
// 			},
// 			GetTransferFeesFunc: func(ctx cosmossdktypes.Context) cosmossdktypes.Coins {
// 				panic("mock out the GetTransferFees method")
// 			},
// 			GetTransfersForChainPaginatedFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, state github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferState, pageRequest *query.PageRequest) ([]github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainTransfer, *query.PageResponse, error) {
// 				panic("mock out the GetTransfersForChainPaginated method")
// 			},
// 			IsAssetRegisteredFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, denom string) bool {
// 				panic("mock out the IsAssetRegistered method")
// 			},
// 			IsChainActivatedFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) bool {
// 				panic("mock out the IsChainActivated method")
// 			},
// 			LinkAddressesFunc: func(ctx cosmossdktypes.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress) error {
// 				panic("mock out the LinkAddresses method")
// 			},
// 			RegisterAssetFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, asset github_com_axelarnetwork_axelar_core_x_nexus_exported.Asset) error {
// 				panic("mock out the RegisterAsset method")
// 			},
// 			SetChainFunc: func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain)  {
// 				panic("mock out the SetChain method")
// 			},
// 			SubTransferFeeFunc: func(ctx cosmossdktypes.Context, coin cosmossdktypes.Coin)  {
// 				panic("mock out the SubTransferFee method")
// 			},
// 		}
//
// 		// use mockedNexus in code that requires axelarnettypes.Nexus
// 		// and then make assertions.
//
// 	}
type NexusMock struct {
	// ActivateChainFunc mocks the ActivateChain method.
	ActivateChainFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain)

	// ArchivePendingTransferFunc mocks the ArchivePendingTransfer method.
	ArchivePendingTransferFunc func(ctx cosmossdktypes.Context, transfer github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainTransfer)

	// EnqueueForTransferFunc mocks the EnqueueForTransfer method.
	EnqueueForTransferFunc func(ctx cosmossdktypes.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, amount cosmossdktypes.Coin) (github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferID, error)

	// GetChainFunc mocks the GetChain method.
	GetChainFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, bool)

	// GetChainByNativeAssetFunc mocks the GetChainByNativeAsset method.
	GetChainByNativeAssetFunc func(ctx cosmossdktypes.Context, asset string) (github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, bool)

	// GetRecipientFunc mocks the GetRecipient method.
	GetRecipientFunc func(ctx cosmossdktypes.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress) (github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, bool)

	// GetTransferFeesFunc mocks the GetTransferFees method.
	GetTransferFeesFunc func(ctx cosmossdktypes.Context) cosmossdktypes.Coins

	// GetTransfersForChainPaginatedFunc mocks the GetTransfersForChainPaginated method.
	GetTransfersForChainPaginatedFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, state github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferState, pageRequest *query.PageRequest) ([]github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainTransfer, *query.PageResponse, error)

	// IsAssetRegisteredFunc mocks the IsAssetRegistered method.
	IsAssetRegisteredFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, denom string) bool

	// IsChainActivatedFunc mocks the IsChainActivated method.
	IsChainActivatedFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) bool

	// LinkAddressesFunc mocks the LinkAddresses method.
	LinkAddressesFunc func(ctx cosmossdktypes.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress) error

	// RegisterAssetFunc mocks the RegisterAsset method.
	RegisterAssetFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, asset github_com_axelarnetwork_axelar_core_x_nexus_exported.Asset) error

	// SetChainFunc mocks the SetChain method.
	SetChainFunc func(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain)

	// SubTransferFeeFunc mocks the SubTransferFee method.
	SubTransferFeeFunc func(ctx cosmossdktypes.Context, coin cosmossdktypes.Coin)

	// calls tracks calls to the methods.
	calls struct {
		// ActivateChain holds details about calls to the ActivateChain method.
		ActivateChain []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		}
		// ArchivePendingTransfer holds details about calls to the ArchivePendingTransfer method.
		ArchivePendingTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Transfer is the transfer argument value.
			Transfer github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainTransfer
		}
		// EnqueueForTransfer holds details about calls to the EnqueueForTransfer method.
		EnqueueForTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Sender is the sender argument value.
			Sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
			// Amount is the amount argument value.
			Amount cosmossdktypes.Coin
		}
		// GetChain holds details about calls to the GetChain method.
		GetChain []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
		}
		// GetChainByNativeAsset holds details about calls to the GetChainByNativeAsset method.
		GetChainByNativeAsset []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Asset is the asset argument value.
			Asset string
		}
		// GetRecipient holds details about calls to the GetRecipient method.
		GetRecipient []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Sender is the sender argument value.
			Sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
		}
		// GetTransferFees holds details about calls to the GetTransferFees method.
		GetTransferFees []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// GetTransfersForChainPaginated holds details about calls to the GetTransfersForChainPaginated method.
		GetTransfersForChainPaginated []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
			// State is the state argument value.
			State github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferState
			// PageRequest is the pageRequest argument value.
			PageRequest *query.PageRequest
		}
		// IsAssetRegistered holds details about calls to the IsAssetRegistered method.
		IsAssetRegistered []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
			// Denom is the denom argument value.
			Denom string
		}
		// IsChainActivated holds details about calls to the IsChainActivated method.
		IsChainActivated []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		}
		// LinkAddresses holds details about calls to the LinkAddresses method.
		LinkAddresses []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Sender is the sender argument value.
			Sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
			// Recipient is the recipient argument value.
			Recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
		}
		// RegisterAsset holds details about calls to the RegisterAsset method.
		RegisterAsset []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
			// Asset is the asset argument value.
			Asset github_com_axelarnetwork_axelar_core_x_nexus_exported.Asset
		}
		// SetChain holds details about calls to the SetChain method.
		SetChain []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		}
		// SubTransferFee holds details about calls to the SubTransferFee method.
		SubTransferFee []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Coin is the coin argument value.
			Coin cosmossdktypes.Coin
		}
	}
	lockActivateChain                 sync.RWMutex
	lockArchivePendingTransfer        sync.RWMutex
	lockEnqueueForTransfer            sync.RWMutex
	lockGetChain                      sync.RWMutex
	lockGetChainByNativeAsset         sync.RWMutex
	lockGetRecipient                  sync.RWMutex
	lockGetTransferFees               sync.RWMutex
	lockGetTransfersForChainPaginated sync.RWMutex
	lockIsAssetRegistered             sync.RWMutex
	lockIsChainActivated              sync.RWMutex
	lockLinkAddresses                 sync.RWMutex
	lockRegisterAsset                 sync.RWMutex
	lockSetChain                      sync.RWMutex
	lockSubTransferFee                sync.RWMutex
}

// ActivateChain calls ActivateChainFunc.
func (mock *NexusMock) ActivateChain(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) {
	if mock.ActivateChainFunc == nil {
		panic("NexusMock.ActivateChainFunc: method is nil but Nexus.ActivateChain was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockActivateChain.Lock()
	mock.calls.ActivateChain = append(mock.calls.ActivateChain, callInfo)
	mock.lockActivateChain.Unlock()
	mock.ActivateChainFunc(ctx, chain)
}

// ActivateChainCalls gets all the calls that were made to ActivateChain.
// Check the length with:
//     len(mockedNexus.ActivateChainCalls())
func (mock *NexusMock) ActivateChainCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}
	mock.lockActivateChain.RLock()
	calls = mock.calls.ActivateChain
	mock.lockActivateChain.RUnlock()
	return calls
}

// ArchivePendingTransfer calls ArchivePendingTransferFunc.
func (mock *NexusMock) ArchivePendingTransfer(ctx cosmossdktypes.Context, transfer github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainTransfer) {
	if mock.ArchivePendingTransferFunc == nil {
		panic("NexusMock.ArchivePendingTransferFunc: method is nil but Nexus.ArchivePendingTransfer was just called")
	}
	callInfo := struct {
		Ctx      cosmossdktypes.Context
		Transfer github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainTransfer
	}{
		Ctx:      ctx,
		Transfer: transfer,
	}
	mock.lockArchivePendingTransfer.Lock()
	mock.calls.ArchivePendingTransfer = append(mock.calls.ArchivePendingTransfer, callInfo)
	mock.lockArchivePendingTransfer.Unlock()
	mock.ArchivePendingTransferFunc(ctx, transfer)
}

// ArchivePendingTransferCalls gets all the calls that were made to ArchivePendingTransfer.
// Check the length with:
//     len(mockedNexus.ArchivePendingTransferCalls())
func (mock *NexusMock) ArchivePendingTransferCalls() []struct {
	Ctx      cosmossdktypes.Context
	Transfer github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainTransfer
} {
	var calls []struct {
		Ctx      cosmossdktypes.Context
		Transfer github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainTransfer
	}
	mock.lockArchivePendingTransfer.RLock()
	calls = mock.calls.ArchivePendingTransfer
	mock.lockArchivePendingTransfer.RUnlock()
	return calls
}

// EnqueueForTransfer calls EnqueueForTransferFunc.
func (mock *NexusMock) EnqueueForTransfer(ctx cosmossdktypes.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, amount cosmossdktypes.Coin) (github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferID, error) {
	if mock.EnqueueForTransferFunc == nil {
		panic("NexusMock.EnqueueForTransferFunc: method is nil but Nexus.EnqueueForTransfer was just called")
	}
	callInfo := struct {
		Ctx    cosmossdktypes.Context
		Sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
		Amount cosmossdktypes.Coin
	}{
		Ctx:    ctx,
		Sender: sender,
		Amount: amount,
	}
	mock.lockEnqueueForTransfer.Lock()
	mock.calls.EnqueueForTransfer = append(mock.calls.EnqueueForTransfer, callInfo)
	mock.lockEnqueueForTransfer.Unlock()
	return mock.EnqueueForTransferFunc(ctx, sender, amount)
}

// EnqueueForTransferCalls gets all the calls that were made to EnqueueForTransfer.
// Check the length with:
//     len(mockedNexus.EnqueueForTransferCalls())
func (mock *NexusMock) EnqueueForTransferCalls() []struct {
	Ctx    cosmossdktypes.Context
	Sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
	Amount cosmossdktypes.Coin
} {
	var calls []struct {
		Ctx    cosmossdktypes.Context
		Sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
		Amount cosmossdktypes.Coin
	}
	mock.lockEnqueueForTransfer.RLock()
	calls = mock.calls.EnqueueForTransfer
	mock.lockEnqueueForTransfer.RUnlock()
	return calls
}

// GetChain calls GetChainFunc.
func (mock *NexusMock) GetChain(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, bool) {
	if mock.GetChainFunc == nil {
		panic("NexusMock.GetChainFunc: method is nil but Nexus.GetChain was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockGetChain.Lock()
	mock.calls.GetChain = append(mock.calls.GetChain, callInfo)
	mock.lockGetChain.Unlock()
	return mock.GetChainFunc(ctx, chain)
}

// GetChainCalls gets all the calls that were made to GetChain.
// Check the length with:
//     len(mockedNexus.GetChainCalls())
func (mock *NexusMock) GetChainCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}
	mock.lockGetChain.RLock()
	calls = mock.calls.GetChain
	mock.lockGetChain.RUnlock()
	return calls
}

// GetChainByNativeAsset calls GetChainByNativeAssetFunc.
func (mock *NexusMock) GetChainByNativeAsset(ctx cosmossdktypes.Context, asset string) (github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, bool) {
	if mock.GetChainByNativeAssetFunc == nil {
		panic("NexusMock.GetChainByNativeAssetFunc: method is nil but Nexus.GetChainByNativeAsset was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Asset string
	}{
		Ctx:   ctx,
		Asset: asset,
	}
	mock.lockGetChainByNativeAsset.Lock()
	mock.calls.GetChainByNativeAsset = append(mock.calls.GetChainByNativeAsset, callInfo)
	mock.lockGetChainByNativeAsset.Unlock()
	return mock.GetChainByNativeAssetFunc(ctx, asset)
}

// GetChainByNativeAssetCalls gets all the calls that were made to GetChainByNativeAsset.
// Check the length with:
//     len(mockedNexus.GetChainByNativeAssetCalls())
func (mock *NexusMock) GetChainByNativeAssetCalls() []struct {
	Ctx   cosmossdktypes.Context
	Asset string
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Asset string
	}
	mock.lockGetChainByNativeAsset.RLock()
	calls = mock.calls.GetChainByNativeAsset
	mock.lockGetChainByNativeAsset.RUnlock()
	return calls
}

// GetRecipient calls GetRecipientFunc.
func (mock *NexusMock) GetRecipient(ctx cosmossdktypes.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress) (github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, bool) {
	if mock.GetRecipientFunc == nil {
		panic("NexusMock.GetRecipientFunc: method is nil but Nexus.GetRecipient was just called")
	}
	callInfo := struct {
		Ctx    cosmossdktypes.Context
		Sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
	}{
		Ctx:    ctx,
		Sender: sender,
	}
	mock.lockGetRecipient.Lock()
	mock.calls.GetRecipient = append(mock.calls.GetRecipient, callInfo)
	mock.lockGetRecipient.Unlock()
	return mock.GetRecipientFunc(ctx, sender)
}

// GetRecipientCalls gets all the calls that were made to GetRecipient.
// Check the length with:
//     len(mockedNexus.GetRecipientCalls())
func (mock *NexusMock) GetRecipientCalls() []struct {
	Ctx    cosmossdktypes.Context
	Sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
} {
	var calls []struct {
		Ctx    cosmossdktypes.Context
		Sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
	}
	mock.lockGetRecipient.RLock()
	calls = mock.calls.GetRecipient
	mock.lockGetRecipient.RUnlock()
	return calls
}

// GetTransferFees calls GetTransferFeesFunc.
func (mock *NexusMock) GetTransferFees(ctx cosmossdktypes.Context) cosmossdktypes.Coins {
	if mock.GetTransferFeesFunc == nil {
		panic("NexusMock.GetTransferFeesFunc: method is nil but Nexus.GetTransferFees was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetTransferFees.Lock()
	mock.calls.GetTransferFees = append(mock.calls.GetTransferFees, callInfo)
	mock.lockGetTransferFees.Unlock()
	return mock.GetTransferFeesFunc(ctx)
}

// GetTransferFeesCalls gets all the calls that were made to GetTransferFees.
// Check the length with:
//     len(mockedNexus.GetTransferFeesCalls())
func (mock *NexusMock) GetTransferFeesCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockGetTransferFees.RLock()
	calls = mock.calls.GetTransferFees
	mock.lockGetTransferFees.RUnlock()
	return calls
}

// GetTransfersForChainPaginated calls GetTransfersForChainPaginatedFunc.
func (mock *NexusMock) GetTransfersForChainPaginated(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, state github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferState, pageRequest *query.PageRequest) ([]github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainTransfer, *query.PageResponse, error) {
	if mock.GetTransfersForChainPaginatedFunc == nil {
		panic("NexusMock.GetTransfersForChainPaginatedFunc: method is nil but Nexus.GetTransfersForChainPaginated was just called")
	}
	callInfo := struct {
		Ctx         cosmossdktypes.Context
		Chain       github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		State       github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferState
		PageRequest *query.PageRequest
	}{
		Ctx:         ctx,
		Chain:       chain,
		State:       state,
		PageRequest: pageRequest,
	}
	mock.lockGetTransfersForChainPaginated.Lock()
	mock.calls.GetTransfersForChainPaginated = append(mock.calls.GetTransfersForChainPaginated, callInfo)
	mock.lockGetTransfersForChainPaginated.Unlock()
	return mock.GetTransfersForChainPaginatedFunc(ctx, chain, state, pageRequest)
}

// GetTransfersForChainPaginatedCalls gets all the calls that were made to GetTransfersForChainPaginated.
// Check the length with:
//     len(mockedNexus.GetTransfersForChainPaginatedCalls())
func (mock *NexusMock) GetTransfersForChainPaginatedCalls() []struct {
	Ctx         cosmossdktypes.Context
	Chain       github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	State       github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferState
	PageRequest *query.PageRequest
} {
	var calls []struct {
		Ctx         cosmossdktypes.Context
		Chain       github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		State       github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferState
		PageRequest *query.PageRequest
	}
	mock.lockGetTransfersForChainPaginated.RLock()
	calls = mock.calls.GetTransfersForChainPaginated
	mock.lockGetTransfersForChainPaginated.RUnlock()
	return calls
}

// IsAssetRegistered calls IsAssetRegisteredFunc.
func (mock *NexusMock) IsAssetRegistered(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, denom string) bool {
	if mock.IsAssetRegisteredFunc == nil {
		panic("NexusMock.IsAssetRegisteredFunc: method is nil but Nexus.IsAssetRegistered was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Denom string
	}{
		Ctx:   ctx,
		Chain: chain,
		Denom: denom,
	}
	mock.lockIsAssetRegistered.Lock()
	mock.calls.IsAssetRegistered = append(mock.calls.IsAssetRegistered, callInfo)
	mock.lockIsAssetRegistered.Unlock()
	return mock.IsAssetRegisteredFunc(ctx, chain, denom)
}

// IsAssetRegisteredCalls gets all the calls that were made to IsAssetRegistered.
// Check the length with:
//     len(mockedNexus.IsAssetRegisteredCalls())
func (mock *NexusMock) IsAssetRegisteredCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	Denom string
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Denom string
	}
	mock.lockIsAssetRegistered.RLock()
	calls = mock.calls.IsAssetRegistered
	mock.lockIsAssetRegistered.RUnlock()
	return calls
}

// IsChainActivated calls IsChainActivatedFunc.
func (mock *NexusMock) IsChainActivated(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) bool {
	if mock.IsChainActivatedFunc == nil {
		panic("NexusMock.IsChainActivatedFunc: method is nil but Nexus.IsChainActivated was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockIsChainActivated.Lock()
	mock.calls.IsChainActivated = append(mock.calls.IsChainActivated, callInfo)
	mock.lockIsChainActivated.Unlock()
	return mock.IsChainActivatedFunc(ctx, chain)
}

// IsChainActivatedCalls gets all the calls that were made to IsChainActivated.
// Check the length with:
//     len(mockedNexus.IsChainActivatedCalls())
func (mock *NexusMock) IsChainActivatedCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}
	mock.lockIsChainActivated.RLock()
	calls = mock.calls.IsChainActivated
	mock.lockIsChainActivated.RUnlock()
	return calls
}

// LinkAddresses calls LinkAddressesFunc.
func (mock *NexusMock) LinkAddresses(ctx cosmossdktypes.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress) error {
	if mock.LinkAddressesFunc == nil {
		panic("NexusMock.LinkAddressesFunc: method is nil but Nexus.LinkAddresses was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		Sender    github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
		Recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
	}{
		Ctx:       ctx,
		Sender:    sender,
		Recipient: recipient,
	}
	mock.lockLinkAddresses.Lock()
	mock.calls.LinkAddresses = append(mock.calls.LinkAddresses, callInfo)
	mock.lockLinkAddresses.Unlock()
	return mock.LinkAddressesFunc(ctx, sender, recipient)
}

// LinkAddressesCalls gets all the calls that were made to LinkAddresses.
// Check the length with:
//     len(mockedNexus.LinkAddressesCalls())
func (mock *NexusMock) LinkAddressesCalls() []struct {
	Ctx       cosmossdktypes.Context
	Sender    github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
	Recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		Sender    github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
		Recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
	}
	mock.lockLinkAddresses.RLock()
	calls = mock.calls.LinkAddresses
	mock.lockLinkAddresses.RUnlock()
	return calls
}

// RegisterAsset calls RegisterAssetFunc.
func (mock *NexusMock) RegisterAsset(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, asset github_com_axelarnetwork_axelar_core_x_nexus_exported.Asset) error {
	if mock.RegisterAssetFunc == nil {
		panic("NexusMock.RegisterAssetFunc: method is nil but Nexus.RegisterAsset was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Asset github_com_axelarnetwork_axelar_core_x_nexus_exported.Asset
	}{
		Ctx:   ctx,
		Chain: chain,
		Asset: asset,
	}
	mock.lockRegisterAsset.Lock()
	mock.calls.RegisterAsset = append(mock.calls.RegisterAsset, callInfo)
	mock.lockRegisterAsset.Unlock()
	return mock.RegisterAssetFunc(ctx, chain, asset)
}

// RegisterAssetCalls gets all the calls that were made to RegisterAsset.
// Check the length with:
//     len(mockedNexus.RegisterAssetCalls())
func (mock *NexusMock) RegisterAssetCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	Asset github_com_axelarnetwork_axelar_core_x_nexus_exported.Asset
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Asset github_com_axelarnetwork_axelar_core_x_nexus_exported.Asset
	}
	mock.lockRegisterAsset.RLock()
	calls = mock.calls.RegisterAsset
	mock.lockRegisterAsset.RUnlock()
	return calls
}

// SetChain calls SetChainFunc.
func (mock *NexusMock) SetChain(ctx cosmossdktypes.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) {
	if mock.SetChainFunc == nil {
		panic("NexusMock.SetChainFunc: method is nil but Nexus.SetChain was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockSetChain.Lock()
	mock.calls.SetChain = append(mock.calls.SetChain, callInfo)
	mock.lockSetChain.Unlock()
	mock.SetChainFunc(ctx, chain)
}

// SetChainCalls gets all the calls that were made to SetChain.
// Check the length with:
//     len(mockedNexus.SetChainCalls())
func (mock *NexusMock) SetChainCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}
	mock.lockSetChain.RLock()
	calls = mock.calls.SetChain
	mock.lockSetChain.RUnlock()
	return calls
}

// SubTransferFee calls SubTransferFeeFunc.
func (mock *NexusMock) SubTransferFee(ctx cosmossdktypes.Context, coin cosmossdktypes.Coin) {
	if mock.SubTransferFeeFunc == nil {
		panic("NexusMock.SubTransferFeeFunc: method is nil but Nexus.SubTransferFee was just called")
	}
	callInfo := struct {
		Ctx  cosmossdktypes.Context
		Coin cosmossdktypes.Coin
	}{
		Ctx:  ctx,
		Coin: coin,
	}
	mock.lockSubTransferFee.Lock()
	mock.calls.SubTransferFee = append(mock.calls.SubTransferFee, callInfo)
	mock.lockSubTransferFee.Unlock()
	mock.SubTransferFeeFunc(ctx, coin)
}

// SubTransferFeeCalls gets all the calls that were made to SubTransferFee.
// Check the length with:
//     len(mockedNexus.SubTransferFeeCalls())
func (mock *NexusMock) SubTransferFeeCalls() []struct {
	Ctx  cosmossdktypes.Context
	Coin cosmossdktypes.Coin
} {
	var calls []struct {
		Ctx  cosmossdktypes.Context
		Coin cosmossdktypes.Coin
	}
	mock.lockSubTransferFee.RLock()
	calls = mock.calls.SubTransferFee
	mock.lockSubTransferFee.RUnlock()
	return calls
}

// Ensure, that BankKeeperMock does implement axelarnettypes.BankKeeper.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.BankKeeper = &BankKeeperMock{}

// BankKeeperMock is a mock implementation of axelarnettypes.BankKeeper.
//
// 	func TestSomethingThatUsesBankKeeper(t *testing.T) {
//
// 		// make and configure a mocked axelarnettypes.BankKeeper
// 		mockedBankKeeper := &BankKeeperMock{
// 			BlockedAddrFunc: func(addr cosmossdktypes.AccAddress) bool {
// 				panic("mock out the BlockedAddr method")
// 			},
// 			BurnCoinsFunc: func(ctx cosmossdktypes.Context, moduleName string, amt cosmossdktypes.Coins) error {
// 				panic("mock out the BurnCoins method")
// 			},
// 			GetBalanceFunc: func(ctx cosmossdktypes.Context, addr cosmossdktypes.AccAddress, denom string) cosmossdktypes.Coin {
// 				panic("mock out the GetBalance method")
// 			},
// 			MintCoinsFunc: func(ctx cosmossdktypes.Context, moduleName string, amt cosmossdktypes.Coins) error {
// 				panic("mock out the MintCoins method")
// 			},
// 			SendCoinsFunc: func(ctx cosmossdktypes.Context, fromAddr cosmossdktypes.AccAddress, toAddr cosmossdktypes.AccAddress, amt cosmossdktypes.Coins) error {
// 				panic("mock out the SendCoins method")
// 			},
// 			SendCoinsFromAccountToModuleFunc: func(ctx cosmossdktypes.Context, senderAddr cosmossdktypes.AccAddress, recipientModule string, amt cosmossdktypes.Coins) error {
// 				panic("mock out the SendCoinsFromAccountToModule method")
// 			},
// 			SendCoinsFromModuleToAccountFunc: func(ctx cosmossdktypes.Context, senderModule string, recipientAddr cosmossdktypes.AccAddress, amt cosmossdktypes.Coins) error {
// 				panic("mock out the SendCoinsFromModuleToAccount method")
// 			},
// 		}
//
// 		// use mockedBankKeeper in code that requires axelarnettypes.BankKeeper
// 		// and then make assertions.
//
// 	}
type BankKeeperMock struct {
	// BlockedAddrFunc mocks the BlockedAddr method.
	BlockedAddrFunc func(addr cosmossdktypes.AccAddress) bool

	// BurnCoinsFunc mocks the BurnCoins method.
	BurnCoinsFunc func(ctx cosmossdktypes.Context, moduleName string, amt cosmossdktypes.Coins) error

	// GetBalanceFunc mocks the GetBalance method.
	GetBalanceFunc func(ctx cosmossdktypes.Context, addr cosmossdktypes.AccAddress, denom string) cosmossdktypes.Coin

	// MintCoinsFunc mocks the MintCoins method.
	MintCoinsFunc func(ctx cosmossdktypes.Context, moduleName string, amt cosmossdktypes.Coins) error

	// SendCoinsFunc mocks the SendCoins method.
	SendCoinsFunc func(ctx cosmossdktypes.Context, fromAddr cosmossdktypes.AccAddress, toAddr cosmossdktypes.AccAddress, amt cosmossdktypes.Coins) error

	// SendCoinsFromAccountToModuleFunc mocks the SendCoinsFromAccountToModule method.
	SendCoinsFromAccountToModuleFunc func(ctx cosmossdktypes.Context, senderAddr cosmossdktypes.AccAddress, recipientModule string, amt cosmossdktypes.Coins) error

	// SendCoinsFromModuleToAccountFunc mocks the SendCoinsFromModuleToAccount method.
	SendCoinsFromModuleToAccountFunc func(ctx cosmossdktypes.Context, senderModule string, recipientAddr cosmossdktypes.AccAddress, amt cosmossdktypes.Coins) error

	// calls tracks calls to the methods.
	calls struct {
		// BlockedAddr holds details about calls to the BlockedAddr method.
		BlockedAddr []struct {
			// Addr is the addr argument value.
			Addr cosmossdktypes.AccAddress
		}
		// BurnCoins holds details about calls to the BurnCoins method.
		BurnCoins []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ModuleName is the moduleName argument value.
			ModuleName string
			// Amt is the amt argument value.
			Amt cosmossdktypes.Coins
		}
		// GetBalance holds details about calls to the GetBalance method.
		GetBalance []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Addr is the addr argument value.
			Addr cosmossdktypes.AccAddress
			// Denom is the denom argument value.
			Denom string
		}
		// MintCoins holds details about calls to the MintCoins method.
		MintCoins []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ModuleName is the moduleName argument value.
			ModuleName string
			// Amt is the amt argument value.
			Amt cosmossdktypes.Coins
		}
		// SendCoins holds details about calls to the SendCoins method.
		SendCoins []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// FromAddr is the fromAddr argument value.
			FromAddr cosmossdktypes.AccAddress
			// ToAddr is the toAddr argument value.
			ToAddr cosmossdktypes.AccAddress
			// Amt is the amt argument value.
			Amt cosmossdktypes.Coins
		}
		// SendCoinsFromAccountToModule holds details about calls to the SendCoinsFromAccountToModule method.
		SendCoinsFromAccountToModule []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// SenderAddr is the senderAddr argument value.
			SenderAddr cosmossdktypes.AccAddress
			// RecipientModule is the recipientModule argument value.
			RecipientModule string
			// Amt is the amt argument value.
			Amt cosmossdktypes.Coins
		}
		// SendCoinsFromModuleToAccount holds details about calls to the SendCoinsFromModuleToAccount method.
		SendCoinsFromModuleToAccount []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// SenderModule is the senderModule argument value.
			SenderModule string
			// RecipientAddr is the recipientAddr argument value.
			RecipientAddr cosmossdktypes.AccAddress
			// Amt is the amt argument value.
			Amt cosmossdktypes.Coins
		}
	}
	lockBlockedAddr                  sync.RWMutex
	lockBurnCoins                    sync.RWMutex
	lockGetBalance                   sync.RWMutex
	lockMintCoins                    sync.RWMutex
	lockSendCoins                    sync.RWMutex
	lockSendCoinsFromAccountToModule sync.RWMutex
	lockSendCoinsFromModuleToAccount sync.RWMutex
}

// BlockedAddr calls BlockedAddrFunc.
func (mock *BankKeeperMock) BlockedAddr(addr cosmossdktypes.AccAddress) bool {
	if mock.BlockedAddrFunc == nil {
		panic("BankKeeperMock.BlockedAddrFunc: method is nil but BankKeeper.BlockedAddr was just called")
	}
	callInfo := struct {
		Addr cosmossdktypes.AccAddress
	}{
		Addr: addr,
	}
	mock.lockBlockedAddr.Lock()
	mock.calls.BlockedAddr = append(mock.calls.BlockedAddr, callInfo)
	mock.lockBlockedAddr.Unlock()
	return mock.BlockedAddrFunc(addr)
}

// BlockedAddrCalls gets all the calls that were made to BlockedAddr.
// Check the length with:
//     len(mockedBankKeeper.BlockedAddrCalls())
func (mock *BankKeeperMock) BlockedAddrCalls() []struct {
	Addr cosmossdktypes.AccAddress
} {
	var calls []struct {
		Addr cosmossdktypes.AccAddress
	}
	mock.lockBlockedAddr.RLock()
	calls = mock.calls.BlockedAddr
	mock.lockBlockedAddr.RUnlock()
	return calls
}

// BurnCoins calls BurnCoinsFunc.
func (mock *BankKeeperMock) BurnCoins(ctx cosmossdktypes.Context, moduleName string, amt cosmossdktypes.Coins) error {
	if mock.BurnCoinsFunc == nil {
		panic("BankKeeperMock.BurnCoinsFunc: method is nil but BankKeeper.BurnCoins was just called")
	}
	callInfo := struct {
		Ctx        cosmossdktypes.Context
		ModuleName string
		Amt        cosmossdktypes.Coins
	}{
		Ctx:        ctx,
		ModuleName: moduleName,
		Amt:        amt,
	}
	mock.lockBurnCoins.Lock()
	mock.calls.BurnCoins = append(mock.calls.BurnCoins, callInfo)
	mock.lockBurnCoins.Unlock()
	return mock.BurnCoinsFunc(ctx, moduleName, amt)
}

// BurnCoinsCalls gets all the calls that were made to BurnCoins.
// Check the length with:
//     len(mockedBankKeeper.BurnCoinsCalls())
func (mock *BankKeeperMock) BurnCoinsCalls() []struct {
	Ctx        cosmossdktypes.Context
	ModuleName string
	Amt        cosmossdktypes.Coins
} {
	var calls []struct {
		Ctx        cosmossdktypes.Context
		ModuleName string
		Amt        cosmossdktypes.Coins
	}
	mock.lockBurnCoins.RLock()
	calls = mock.calls.BurnCoins
	mock.lockBurnCoins.RUnlock()
	return calls
}

// GetBalance calls GetBalanceFunc.
func (mock *BankKeeperMock) GetBalance(ctx cosmossdktypes.Context, addr cosmossdktypes.AccAddress, denom string) cosmossdktypes.Coin {
	if mock.GetBalanceFunc == nil {
		panic("BankKeeperMock.GetBalanceFunc: method is nil but BankKeeper.GetBalance was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Addr  cosmossdktypes.AccAddress
		Denom string
	}{
		Ctx:   ctx,
		Addr:  addr,
		Denom: denom,
	}
	mock.lockGetBalance.Lock()
	mock.calls.GetBalance = append(mock.calls.GetBalance, callInfo)
	mock.lockGetBalance.Unlock()
	return mock.GetBalanceFunc(ctx, addr, denom)
}

// GetBalanceCalls gets all the calls that were made to GetBalance.
// Check the length with:
//     len(mockedBankKeeper.GetBalanceCalls())
func (mock *BankKeeperMock) GetBalanceCalls() []struct {
	Ctx   cosmossdktypes.Context
	Addr  cosmossdktypes.AccAddress
	Denom string
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Addr  cosmossdktypes.AccAddress
		Denom string
	}
	mock.lockGetBalance.RLock()
	calls = mock.calls.GetBalance
	mock.lockGetBalance.RUnlock()
	return calls
}

// MintCoins calls MintCoinsFunc.
func (mock *BankKeeperMock) MintCoins(ctx cosmossdktypes.Context, moduleName string, amt cosmossdktypes.Coins) error {
	if mock.MintCoinsFunc == nil {
		panic("BankKeeperMock.MintCoinsFunc: method is nil but BankKeeper.MintCoins was just called")
	}
	callInfo := struct {
		Ctx        cosmossdktypes.Context
		ModuleName string
		Amt        cosmossdktypes.Coins
	}{
		Ctx:        ctx,
		ModuleName: moduleName,
		Amt:        amt,
	}
	mock.lockMintCoins.Lock()
	mock.calls.MintCoins = append(mock.calls.MintCoins, callInfo)
	mock.lockMintCoins.Unlock()
	return mock.MintCoinsFunc(ctx, moduleName, amt)
}

// MintCoinsCalls gets all the calls that were made to MintCoins.
// Check the length with:
//     len(mockedBankKeeper.MintCoinsCalls())
func (mock *BankKeeperMock) MintCoinsCalls() []struct {
	Ctx        cosmossdktypes.Context
	ModuleName string
	Amt        cosmossdktypes.Coins
} {
	var calls []struct {
		Ctx        cosmossdktypes.Context
		ModuleName string
		Amt        cosmossdktypes.Coins
	}
	mock.lockMintCoins.RLock()
	calls = mock.calls.MintCoins
	mock.lockMintCoins.RUnlock()
	return calls
}

// SendCoins calls SendCoinsFunc.
func (mock *BankKeeperMock) SendCoins(ctx cosmossdktypes.Context, fromAddr cosmossdktypes.AccAddress, toAddr cosmossdktypes.AccAddress, amt cosmossdktypes.Coins) error {
	if mock.SendCoinsFunc == nil {
		panic("BankKeeperMock.SendCoinsFunc: method is nil but BankKeeper.SendCoins was just called")
	}
	callInfo := struct {
		Ctx      cosmossdktypes.Context
		FromAddr cosmossdktypes.AccAddress
		ToAddr   cosmossdktypes.AccAddress
		Amt      cosmossdktypes.Coins
	}{
		Ctx:      ctx,
		FromAddr: fromAddr,
		ToAddr:   toAddr,
		Amt:      amt,
	}
	mock.lockSendCoins.Lock()
	mock.calls.SendCoins = append(mock.calls.SendCoins, callInfo)
	mock.lockSendCoins.Unlock()
	return mock.SendCoinsFunc(ctx, fromAddr, toAddr, amt)
}

// SendCoinsCalls gets all the calls that were made to SendCoins.
// Check the length with:
//     len(mockedBankKeeper.SendCoinsCalls())
func (mock *BankKeeperMock) SendCoinsCalls() []struct {
	Ctx      cosmossdktypes.Context
	FromAddr cosmossdktypes.AccAddress
	ToAddr   cosmossdktypes.AccAddress
	Amt      cosmossdktypes.Coins
} {
	var calls []struct {
		Ctx      cosmossdktypes.Context
		FromAddr cosmossdktypes.AccAddress
		ToAddr   cosmossdktypes.AccAddress
		Amt      cosmossdktypes.Coins
	}
	mock.lockSendCoins.RLock()
	calls = mock.calls.SendCoins
	mock.lockSendCoins.RUnlock()
	return calls
}

// SendCoinsFromAccountToModule calls SendCoinsFromAccountToModuleFunc.
func (mock *BankKeeperMock) SendCoinsFromAccountToModule(ctx cosmossdktypes.Context, senderAddr cosmossdktypes.AccAddress, recipientModule string, amt cosmossdktypes.Coins) error {
	if mock.SendCoinsFromAccountToModuleFunc == nil {
		panic("BankKeeperMock.SendCoinsFromAccountToModuleFunc: method is nil but BankKeeper.SendCoinsFromAccountToModule was just called")
	}
	callInfo := struct {
		Ctx             cosmossdktypes.Context
		SenderAddr      cosmossdktypes.AccAddress
		RecipientModule string
		Amt             cosmossdktypes.Coins
	}{
		Ctx:             ctx,
		SenderAddr:      senderAddr,
		RecipientModule: recipientModule,
		Amt:             amt,
	}
	mock.lockSendCoinsFromAccountToModule.Lock()
	mock.calls.SendCoinsFromAccountToModule = append(mock.calls.SendCoinsFromAccountToModule, callInfo)
	mock.lockSendCoinsFromAccountToModule.Unlock()
	return mock.SendCoinsFromAccountToModuleFunc(ctx, senderAddr, recipientModule, amt)
}

// SendCoinsFromAccountToModuleCalls gets all the calls that were made to SendCoinsFromAccountToModule.
// Check the length with:
//     len(mockedBankKeeper.SendCoinsFromAccountToModuleCalls())
func (mock *BankKeeperMock) SendCoinsFromAccountToModuleCalls() []struct {
	Ctx             cosmossdktypes.Context
	SenderAddr      cosmossdktypes.AccAddress
	RecipientModule string
	Amt             cosmossdktypes.Coins
} {
	var calls []struct {
		Ctx             cosmossdktypes.Context
		SenderAddr      cosmossdktypes.AccAddress
		RecipientModule string
		Amt             cosmossdktypes.Coins
	}
	mock.lockSendCoinsFromAccountToModule.RLock()
	calls = mock.calls.SendCoinsFromAccountToModule
	mock.lockSendCoinsFromAccountToModule.RUnlock()
	return calls
}

// SendCoinsFromModuleToAccount calls SendCoinsFromModuleToAccountFunc.
func (mock *BankKeeperMock) SendCoinsFromModuleToAccount(ctx cosmossdktypes.Context, senderModule string, recipientAddr cosmossdktypes.AccAddress, amt cosmossdktypes.Coins) error {
	if mock.SendCoinsFromModuleToAccountFunc == nil {
		panic("BankKeeperMock.SendCoinsFromModuleToAccountFunc: method is nil but BankKeeper.SendCoinsFromModuleToAccount was just called")
	}
	callInfo := struct {
		Ctx           cosmossdktypes.Context
		SenderModule  string
		RecipientAddr cosmossdktypes.AccAddress
		Amt           cosmossdktypes.Coins
	}{
		Ctx:           ctx,
		SenderModule:  senderModule,
		RecipientAddr: recipientAddr,
		Amt:           amt,
	}
	mock.lockSendCoinsFromModuleToAccount.Lock()
	mock.calls.SendCoinsFromModuleToAccount = append(mock.calls.SendCoinsFromModuleToAccount, callInfo)
	mock.lockSendCoinsFromModuleToAccount.Unlock()
	return mock.SendCoinsFromModuleToAccountFunc(ctx, senderModule, recipientAddr, amt)
}

// SendCoinsFromModuleToAccountCalls gets all the calls that were made to SendCoinsFromModuleToAccount.
// Check the length with:
//     len(mockedBankKeeper.SendCoinsFromModuleToAccountCalls())
func (mock *BankKeeperMock) SendCoinsFromModuleToAccountCalls() []struct {
	Ctx           cosmossdktypes.Context
	SenderModule  string
	RecipientAddr cosmossdktypes.AccAddress
	Amt           cosmossdktypes.Coins
} {
	var calls []struct {
		Ctx           cosmossdktypes.Context
		SenderModule  string
		RecipientAddr cosmossdktypes.AccAddress
		Amt           cosmossdktypes.Coins
	}
	mock.lockSendCoinsFromModuleToAccount.RLock()
	calls = mock.calls.SendCoinsFromModuleToAccount
	mock.lockSendCoinsFromModuleToAccount.RUnlock()
	return calls
}

// Ensure, that IBCTransferKeeperMock does implement axelarnettypes.IBCTransferKeeper.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.IBCTransferKeeper = &IBCTransferKeeperMock{}

// IBCTransferKeeperMock is a mock implementation of axelarnettypes.IBCTransferKeeper.
//
// 	func TestSomethingThatUsesIBCTransferKeeper(t *testing.T) {
//
// 		// make and configure a mocked axelarnettypes.IBCTransferKeeper
// 		mockedIBCTransferKeeper := &IBCTransferKeeperMock{
// 			GetDenomTraceFunc: func(ctx cosmossdktypes.Context, denomTraceHash tmbytes.HexBytes) (ibctypes.DenomTrace, bool) {
// 				panic("mock out the GetDenomTrace method")
// 			},
// 			SendTransferFunc: func(ctx cosmossdktypes.Context, sourcePort string, sourceChannel string, token cosmossdktypes.Coin, sender cosmossdktypes.AccAddress, receiver string, timeoutHeight clienttypes.Height, timeoutTimestamp uint64) error {
// 				panic("mock out the SendTransfer method")
// 			},
// 		}
//
// 		// use mockedIBCTransferKeeper in code that requires axelarnettypes.IBCTransferKeeper
// 		// and then make assertions.
//
// 	}
type IBCTransferKeeperMock struct {
	// GetDenomTraceFunc mocks the GetDenomTrace method.
	GetDenomTraceFunc func(ctx cosmossdktypes.Context, denomTraceHash tmbytes.HexBytes) (ibctypes.DenomTrace, bool)

	// SendTransferFunc mocks the SendTransfer method.
	SendTransferFunc func(ctx cosmossdktypes.Context, sourcePort string, sourceChannel string, token cosmossdktypes.Coin, sender cosmossdktypes.AccAddress, receiver string, timeoutHeight clienttypes.Height, timeoutTimestamp uint64) error

	// calls tracks calls to the methods.
	calls struct {
		// GetDenomTrace holds details about calls to the GetDenomTrace method.
		GetDenomTrace []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// DenomTraceHash is the denomTraceHash argument value.
			DenomTraceHash tmbytes.HexBytes
		}
		// SendTransfer holds details about calls to the SendTransfer method.
		SendTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// SourcePort is the sourcePort argument value.
			SourcePort string
			// SourceChannel is the sourceChannel argument value.
			SourceChannel string
			// Token is the token argument value.
			Token cosmossdktypes.Coin
			// Sender is the sender argument value.
			Sender cosmossdktypes.AccAddress
			// Receiver is the receiver argument value.
			Receiver string
			// TimeoutHeight is the timeoutHeight argument value.
			TimeoutHeight clienttypes.Height
			// TimeoutTimestamp is the timeoutTimestamp argument value.
			TimeoutTimestamp uint64
		}
	}
	lockGetDenomTrace sync.RWMutex
	lockSendTransfer  sync.RWMutex
}

// GetDenomTrace calls GetDenomTraceFunc.
func (mock *IBCTransferKeeperMock) GetDenomTrace(ctx cosmossdktypes.Context, denomTraceHash tmbytes.HexBytes) (ibctypes.DenomTrace, bool) {
	if mock.GetDenomTraceFunc == nil {
		panic("IBCTransferKeeperMock.GetDenomTraceFunc: method is nil but IBCTransferKeeper.GetDenomTrace was just called")
	}
	callInfo := struct {
		Ctx            cosmossdktypes.Context
		DenomTraceHash tmbytes.HexBytes
	}{
		Ctx:            ctx,
		DenomTraceHash: denomTraceHash,
	}
	mock.lockGetDenomTrace.Lock()
	mock.calls.GetDenomTrace = append(mock.calls.GetDenomTrace, callInfo)
	mock.lockGetDenomTrace.Unlock()
	return mock.GetDenomTraceFunc(ctx, denomTraceHash)
}

// GetDenomTraceCalls gets all the calls that were made to GetDenomTrace.
// Check the length with:
//     len(mockedIBCTransferKeeper.GetDenomTraceCalls())
func (mock *IBCTransferKeeperMock) GetDenomTraceCalls() []struct {
	Ctx            cosmossdktypes.Context
	DenomTraceHash tmbytes.HexBytes
} {
	var calls []struct {
		Ctx            cosmossdktypes.Context
		DenomTraceHash tmbytes.HexBytes
	}
	mock.lockGetDenomTrace.RLock()
	calls = mock.calls.GetDenomTrace
	mock.lockGetDenomTrace.RUnlock()
	return calls
}

// SendTransfer calls SendTransferFunc.
func (mock *IBCTransferKeeperMock) SendTransfer(ctx cosmossdktypes.Context, sourcePort string, sourceChannel string, token cosmossdktypes.Coin, sender cosmossdktypes.AccAddress, receiver string, timeoutHeight clienttypes.Height, timeoutTimestamp uint64) error {
	if mock.SendTransferFunc == nil {
		panic("IBCTransferKeeperMock.SendTransferFunc: method is nil but IBCTransferKeeper.SendTransfer was just called")
	}
	callInfo := struct {
		Ctx              cosmossdktypes.Context
		SourcePort       string
		SourceChannel    string
		Token            cosmossdktypes.Coin
		Sender           cosmossdktypes.AccAddress
		Receiver         string
		TimeoutHeight    clienttypes.Height
		TimeoutTimestamp uint64
	}{
		Ctx:              ctx,
		SourcePort:       sourcePort,
		SourceChannel:    sourceChannel,
		Token:            token,
		Sender:           sender,
		Receiver:         receiver,
		TimeoutHeight:    timeoutHeight,
		TimeoutTimestamp: timeoutTimestamp,
	}
	mock.lockSendTransfer.Lock()
	mock.calls.SendTransfer = append(mock.calls.SendTransfer, callInfo)
	mock.lockSendTransfer.Unlock()
	return mock.SendTransferFunc(ctx, sourcePort, sourceChannel, token, sender, receiver, timeoutHeight, timeoutTimestamp)
}

// SendTransferCalls gets all the calls that were made to SendTransfer.
// Check the length with:
//     len(mockedIBCTransferKeeper.SendTransferCalls())
func (mock *IBCTransferKeeperMock) SendTransferCalls() []struct {
	Ctx              cosmossdktypes.Context
	SourcePort       string
	SourceChannel    string
	Token            cosmossdktypes.Coin
	Sender           cosmossdktypes.AccAddress
	Receiver         string
	TimeoutHeight    clienttypes.Height
	TimeoutTimestamp uint64
} {
	var calls []struct {
		Ctx              cosmossdktypes.Context
		SourcePort       string
		SourceChannel    string
		Token            cosmossdktypes.Coin
		Sender           cosmossdktypes.AccAddress
		Receiver         string
		TimeoutHeight    clienttypes.Height
		TimeoutTimestamp uint64
	}
	mock.lockSendTransfer.RLock()
	calls = mock.calls.SendTransfer
	mock.lockSendTransfer.RUnlock()
	return calls
}

// Ensure, that ChannelKeeperMock does implement axelarnettypes.ChannelKeeper.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.ChannelKeeper = &ChannelKeeperMock{}

// ChannelKeeperMock is a mock implementation of axelarnettypes.ChannelKeeper.
//
// 	func TestSomethingThatUsesChannelKeeper(t *testing.T) {
//
// 		// make and configure a mocked axelarnettypes.ChannelKeeper
// 		mockedChannelKeeper := &ChannelKeeperMock{
// 			GetChannelFunc: func(ctx cosmossdktypes.Context, srcPort string, srcChan string) (channeltypes.Channel, bool) {
// 				panic("mock out the GetChannel method")
// 			},
// 			GetChannelClientStateFunc: func(ctx cosmossdktypes.Context, portID string, channelID string) (string, ibcexported.ClientState, error) {
// 				panic("mock out the GetChannelClientState method")
// 			},
// 			GetNextSequenceSendFunc: func(ctx cosmossdktypes.Context, portID string, channelID string) (uint64, bool) {
// 				panic("mock out the GetNextSequenceSend method")
// 			},
// 			SendPacketFunc: func(ctx cosmossdktypes.Context, channelCap *capabilitytypes.Capability, packet ibcexported.PacketI) error {
// 				panic("mock out the SendPacket method")
// 			},
// 		}
//
// 		// use mockedChannelKeeper in code that requires axelarnettypes.ChannelKeeper
// 		// and then make assertions.
//
// 	}
type ChannelKeeperMock struct {
	// GetChannelFunc mocks the GetChannel method.
	GetChannelFunc func(ctx cosmossdktypes.Context, srcPort string, srcChan string) (channeltypes.Channel, bool)

	// GetChannelClientStateFunc mocks the GetChannelClientState method.
	GetChannelClientStateFunc func(ctx cosmossdktypes.Context, portID string, channelID string) (string, ibcexported.ClientState, error)

	// GetNextSequenceSendFunc mocks the GetNextSequenceSend method.
	GetNextSequenceSendFunc func(ctx cosmossdktypes.Context, portID string, channelID string) (uint64, bool)

	// SendPacketFunc mocks the SendPacket method.
	SendPacketFunc func(ctx cosmossdktypes.Context, channelCap *capabilitytypes.Capability, packet ibcexported.PacketI) error

	// calls tracks calls to the methods.
	calls struct {
		// GetChannel holds details about calls to the GetChannel method.
		GetChannel []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// SrcPort is the srcPort argument value.
			SrcPort string
			// SrcChan is the srcChan argument value.
			SrcChan string
		}
		// GetChannelClientState holds details about calls to the GetChannelClientState method.
		GetChannelClientState []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// PortID is the portID argument value.
			PortID string
			// ChannelID is the channelID argument value.
			ChannelID string
		}
		// GetNextSequenceSend holds details about calls to the GetNextSequenceSend method.
		GetNextSequenceSend []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// PortID is the portID argument value.
			PortID string
			// ChannelID is the channelID argument value.
			ChannelID string
		}
		// SendPacket holds details about calls to the SendPacket method.
		SendPacket []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ChannelCap is the channelCap argument value.
			ChannelCap *capabilitytypes.Capability
			// Packet is the packet argument value.
			Packet ibcexported.PacketI
		}
	}
	lockGetChannel            sync.RWMutex
	lockGetChannelClientState sync.RWMutex
	lockGetNextSequenceSend   sync.RWMutex
	lockSendPacket            sync.RWMutex
}

// GetChannel calls GetChannelFunc.
func (mock *ChannelKeeperMock) GetChannel(ctx cosmossdktypes.Context, srcPort string, srcChan string) (channeltypes.Channel, bool) {
	if mock.GetChannelFunc == nil {
		panic("ChannelKeeperMock.GetChannelFunc: method is nil but ChannelKeeper.GetChannel was just called")
	}
	callInfo := struct {
		Ctx     cosmossdktypes.Context
		SrcPort string
		SrcChan string
	}{
		Ctx:     ctx,
		SrcPort: srcPort,
		SrcChan: srcChan,
	}
	mock.lockGetChannel.Lock()
	mock.calls.GetChannel = append(mock.calls.GetChannel, callInfo)
	mock.lockGetChannel.Unlock()
	return mock.GetChannelFunc(ctx, srcPort, srcChan)
}

// GetChannelCalls gets all the calls that were made to GetChannel.
// Check the length with:
//     len(mockedChannelKeeper.GetChannelCalls())
func (mock *ChannelKeeperMock) GetChannelCalls() []struct {
	Ctx     cosmossdktypes.Context
	SrcPort string
	SrcChan string
} {
	var calls []struct {
		Ctx     cosmossdktypes.Context
		SrcPort string
		SrcChan string
	}
	mock.lockGetChannel.RLock()
	calls = mock.calls.GetChannel
	mock.lockGetChannel.RUnlock()
	return calls
}

// GetChannelClientState calls GetChannelClientStateFunc.
func (mock *ChannelKeeperMock) GetChannelClientState(ctx cosmossdktypes.Context, portID string, channelID string) (string, ibcexported.ClientState, error) {
	if mock.GetChannelClientStateFunc == nil {
		panic("ChannelKeeperMock.GetChannelClientStateFunc: method is nil but ChannelKeeper.GetChannelClientState was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		PortID    string
		ChannelID string
	}{
		Ctx:       ctx,
		PortID:    portID,
		ChannelID: channelID,
	}
	mock.lockGetChannelClientState.Lock()
	mock.calls.GetChannelClientState = append(mock.calls.GetChannelClientState, callInfo)
	mock.lockGetChannelClientState.Unlock()
	return mock.GetChannelClientStateFunc(ctx, portID, channelID)
}

// GetChannelClientStateCalls gets all the calls that were made to GetChannelClientState.
// Check the length with:
//     len(mockedChannelKeeper.GetChannelClientStateCalls())
func (mock *ChannelKeeperMock) GetChannelClientStateCalls() []struct {
	Ctx       cosmossdktypes.Context
	PortID    string
	ChannelID string
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		PortID    string
		ChannelID string
	}
	mock.lockGetChannelClientState.RLock()
	calls = mock.calls.GetChannelClientState
	mock.lockGetChannelClientState.RUnlock()
	return calls
}

// GetNextSequenceSend calls GetNextSequenceSendFunc.
func (mock *ChannelKeeperMock) GetNextSequenceSend(ctx cosmossdktypes.Context, portID string, channelID string) (uint64, bool) {
	if mock.GetNextSequenceSendFunc == nil {
		panic("ChannelKeeperMock.GetNextSequenceSendFunc: method is nil but ChannelKeeper.GetNextSequenceSend was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		PortID    string
		ChannelID string
	}{
		Ctx:       ctx,
		PortID:    portID,
		ChannelID: channelID,
	}
	mock.lockGetNextSequenceSend.Lock()
	mock.calls.GetNextSequenceSend = append(mock.calls.GetNextSequenceSend, callInfo)
	mock.lockGetNextSequenceSend.Unlock()
	return mock.GetNextSequenceSendFunc(ctx, portID, channelID)
}

// GetNextSequenceSendCalls gets all the calls that were made to GetNextSequenceSend.
// Check the length with:
//     len(mockedChannelKeeper.GetNextSequenceSendCalls())
func (mock *ChannelKeeperMock) GetNextSequenceSendCalls() []struct {
	Ctx       cosmossdktypes.Context
	PortID    string
	ChannelID string
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		PortID    string
		ChannelID string
	}
	mock.lockGetNextSequenceSend.RLock()
	calls = mock.calls.GetNextSequenceSend
	mock.lockGetNextSequenceSend.RUnlock()
	return calls
}

// SendPacket calls SendPacketFunc.
func (mock *ChannelKeeperMock) SendPacket(ctx cosmossdktypes.Context, channelCap *capabilitytypes.Capability, packet ibcexported.PacketI) error {
	if mock.SendPacketFunc == nil {
		panic("ChannelKeeperMock.SendPacketFunc: method is nil but ChannelKeeper.SendPacket was just called")
	}
	callInfo := struct {
		Ctx        cosmossdktypes.Context
		ChannelCap *capabilitytypes.Capability
		Packet     ibcexported.PacketI
	}{
		Ctx:        ctx,
		ChannelCap: channelCap,
		Packet:     packet,
	}
	mock.lockSendPacket.Lock()
	mock.calls.SendPacket = append(mock.calls.SendPacket, callInfo)
	mock.lockSendPacket.Unlock()
	return mock.SendPacketFunc(ctx, channelCap, packet)
}

// SendPacketCalls gets all the calls that were made to SendPacket.
// Check the length with:
//     len(mockedChannelKeeper.SendPacketCalls())
func (mock *ChannelKeeperMock) SendPacketCalls() []struct {
	Ctx        cosmossdktypes.Context
	ChannelCap *capabilitytypes.Capability
	Packet     ibcexported.PacketI
} {
	var calls []struct {
		Ctx        cosmossdktypes.Context
		ChannelCap *capabilitytypes.Capability
		Packet     ibcexported.PacketI
	}
	mock.lockSendPacket.RLock()
	calls = mock.calls.SendPacket
	mock.lockSendPacket.RUnlock()
	return calls
}

// Ensure, that AccountKeeperMock does implement axelarnettypes.AccountKeeper.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.AccountKeeper = &AccountKeeperMock{}

// AccountKeeperMock is a mock implementation of axelarnettypes.AccountKeeper.
//
// 	func TestSomethingThatUsesAccountKeeper(t *testing.T) {
//
// 		// make and configure a mocked axelarnettypes.AccountKeeper
// 		mockedAccountKeeper := &AccountKeeperMock{
// 			GetModuleAccountFunc: func(ctx cosmossdktypes.Context, moduleName string) types.ModuleAccountI {
// 				panic("mock out the GetModuleAccount method")
// 			},
// 			GetModuleAddressFunc: func(moduleName string) cosmossdktypes.AccAddress {
// 				panic("mock out the GetModuleAddress method")
// 			},
// 		}
//
// 		// use mockedAccountKeeper in code that requires axelarnettypes.AccountKeeper
// 		// and then make assertions.
//
// 	}
type AccountKeeperMock struct {
	// GetModuleAccountFunc mocks the GetModuleAccount method.
	GetModuleAccountFunc func(ctx cosmossdktypes.Context, moduleName string) types.ModuleAccountI

	// GetModuleAddressFunc mocks the GetModuleAddress method.
	GetModuleAddressFunc func(moduleName string) cosmossdktypes.AccAddress

	// calls tracks calls to the methods.
	calls struct {
		// GetModuleAccount holds details about calls to the GetModuleAccount method.
		GetModuleAccount []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ModuleName is the moduleName argument value.
			ModuleName string
		}
		// GetModuleAddress holds details about calls to the GetModuleAddress method.
		GetModuleAddress []struct {
			// ModuleName is the moduleName argument value.
			ModuleName string
		}
	}
	lockGetModuleAccount sync.RWMutex
	lockGetModuleAddress sync.RWMutex
}

// GetModuleAccount calls GetModuleAccountFunc.
func (mock *AccountKeeperMock) GetModuleAccount(ctx cosmossdktypes.Context, moduleName string) types.ModuleAccountI {
	if mock.GetModuleAccountFunc == nil {
		panic("AccountKeeperMock.GetModuleAccountFunc: method is nil but AccountKeeper.GetModuleAccount was just called")
	}
	callInfo := struct {
		Ctx        cosmossdktypes.Context
		ModuleName string
	}{
		Ctx:        ctx,
		ModuleName: moduleName,
	}
	mock.lockGetModuleAccount.Lock()
	mock.calls.GetModuleAccount = append(mock.calls.GetModuleAccount, callInfo)
	mock.lockGetModuleAccount.Unlock()
	return mock.GetModuleAccountFunc(ctx, moduleName)
}

// GetModuleAccountCalls gets all the calls that were made to GetModuleAccount.
// Check the length with:
//     len(mockedAccountKeeper.GetModuleAccountCalls())
func (mock *AccountKeeperMock) GetModuleAccountCalls() []struct {
	Ctx        cosmossdktypes.Context
	ModuleName string
} {
	var calls []struct {
		Ctx        cosmossdktypes.Context
		ModuleName string
	}
	mock.lockGetModuleAccount.RLock()
	calls = mock.calls.GetModuleAccount
	mock.lockGetModuleAccount.RUnlock()
	return calls
}

// GetModuleAddress calls GetModuleAddressFunc.
func (mock *AccountKeeperMock) GetModuleAddress(moduleName string) cosmossdktypes.AccAddress {
	if mock.GetModuleAddressFunc == nil {
		panic("AccountKeeperMock.GetModuleAddressFunc: method is nil but AccountKeeper.GetModuleAddress was just called")
	}
	callInfo := struct {
		ModuleName string
	}{
		ModuleName: moduleName,
	}
	mock.lockGetModuleAddress.Lock()
	mock.calls.GetModuleAddress = append(mock.calls.GetModuleAddress, callInfo)
	mock.lockGetModuleAddress.Unlock()
	return mock.GetModuleAddressFunc(moduleName)
}

// GetModuleAddressCalls gets all the calls that were made to GetModuleAddress.
// Check the length with:
//     len(mockedAccountKeeper.GetModuleAddressCalls())
func (mock *AccountKeeperMock) GetModuleAddressCalls() []struct {
	ModuleName string
} {
	var calls []struct {
		ModuleName string
	}
	mock.lockGetModuleAddress.RLock()
	calls = mock.calls.GetModuleAddress
	mock.lockGetModuleAddress.RUnlock()
	return calls
}

// Ensure, that PortKeeperMock does implement axelarnettypes.PortKeeper.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.PortKeeper = &PortKeeperMock{}

// PortKeeperMock is a mock implementation of axelarnettypes.PortKeeper.
//
// 	func TestSomethingThatUsesPortKeeper(t *testing.T) {
//
// 		// make and configure a mocked axelarnettypes.PortKeeper
// 		mockedPortKeeper := &PortKeeperMock{
// 			BindPortFunc: func(ctx cosmossdktypes.Context, portID string) *capabilitytypes.Capability {
// 				panic("mock out the BindPort method")
// 			},
// 		}
//
// 		// use mockedPortKeeper in code that requires axelarnettypes.PortKeeper
// 		// and then make assertions.
//
// 	}
type PortKeeperMock struct {
	// BindPortFunc mocks the BindPort method.
	BindPortFunc func(ctx cosmossdktypes.Context, portID string) *capabilitytypes.Capability

	// calls tracks calls to the methods.
	calls struct {
		// BindPort holds details about calls to the BindPort method.
		BindPort []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// PortID is the portID argument value.
			PortID string
		}
	}
	lockBindPort sync.RWMutex
}

// BindPort calls BindPortFunc.
func (mock *PortKeeperMock) BindPort(ctx cosmossdktypes.Context, portID string) *capabilitytypes.Capability {
	if mock.BindPortFunc == nil {
		panic("PortKeeperMock.BindPortFunc: method is nil but PortKeeper.BindPort was just called")
	}
	callInfo := struct {
		Ctx    cosmossdktypes.Context
		PortID string
	}{
		Ctx:    ctx,
		PortID: portID,
	}
	mock.lockBindPort.Lock()
	mock.calls.BindPort = append(mock.calls.BindPort, callInfo)
	mock.lockBindPort.Unlock()
	return mock.BindPortFunc(ctx, portID)
}

// BindPortCalls gets all the calls that were made to BindPort.
// Check the length with:
//     len(mockedPortKeeper.BindPortCalls())
func (mock *PortKeeperMock) BindPortCalls() []struct {
	Ctx    cosmossdktypes.Context
	PortID string
} {
	var calls []struct {
		Ctx    cosmossdktypes.Context
		PortID string
	}
	mock.lockBindPort.RLock()
	calls = mock.calls.BindPort
	mock.lockBindPort.RUnlock()
	return calls
}
