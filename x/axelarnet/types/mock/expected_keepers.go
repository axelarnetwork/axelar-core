// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	axelarnettypes "github.com/axelarnetwork/axelar-core/x/axelarnet/types"
	exported "github.com/axelarnetwork/axelar-core/x/nexus/exported"
	cosmossdktypes "github.com/cosmos/cosmos-sdk/types"
	ibctypes "github.com/cosmos/ibc-go/modules/apps/transfer/types"
	clienttypes "github.com/cosmos/ibc-go/modules/core/02-client/types"
	ibcclient "github.com/cosmos/ibc-go/modules/core/exported"
	tmbytes "github.com/tendermint/tendermint/libs/bytes"
	"github.com/tendermint/tendermint/libs/log"
	"sync"
)

// Ensure, that BaseKeeperMock does implement axelarnettypes.BaseKeeper.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.BaseKeeper = &BaseKeeperMock{}

// BaseKeeperMock is a mock implementation of axelarnettypes.BaseKeeper.
//
// 	func TestSomethingThatUsesBaseKeeper(t *testing.T) {
//
// 		// make and configure a mocked axelarnettypes.BaseKeeper
// 		mockedBaseKeeper := &BaseKeeperMock{
// 			DeletePendingIBCTransferFunc: func(ctx cosmossdktypes.Context, portID string, channelID string, sequence uint64)  {
// 				panic("mock out the DeletePendingIBCTransfer method")
// 			},
// 			GetCosmosChainByNameFunc: func(ctx cosmossdktypes.Context, chain string) (axelarnettypes.CosmosChain, bool) {
// 				panic("mock out the GetCosmosChainByName method")
// 			},
// 			GetCosmosChainsFunc: func(ctx cosmossdktypes.Context) []string {
// 				panic("mock out the GetCosmosChains method")
// 			},
// 			GetFeeCollectorFunc: func(ctx cosmossdktypes.Context) (cosmossdktypes.AccAddress, bool) {
// 				panic("mock out the GetFeeCollector method")
// 			},
// 			GetIBCPathFunc: func(ctx cosmossdktypes.Context, chain string) (string, bool) {
// 				panic("mock out the GetIBCPath method")
// 			},
// 			GetPendingIBCTransferFunc: func(ctx cosmossdktypes.Context, portID string, channelID string, sequence uint64) (axelarnettypes.IBCTransfer, bool) {
// 				panic("mock out the GetPendingIBCTransfer method")
// 			},
// 			GetRouteTimeoutWindowFunc: func(ctx cosmossdktypes.Context) uint64 {
// 				panic("mock out the GetRouteTimeoutWindow method")
// 			},
// 			GetTransactionFeeRateFunc: func(ctx cosmossdktypes.Context) cosmossdktypes.Dec {
// 				panic("mock out the GetTransactionFeeRate method")
// 			},
// 			LoggerFunc: func(ctx cosmossdktypes.Context) log.Logger {
// 				panic("mock out the Logger method")
// 			},
// 			RegisterIBCPathFunc: func(ctx cosmossdktypes.Context, asset string, path string) error {
// 				panic("mock out the RegisterIBCPath method")
// 			},
// 			SetCosmosChainFunc: func(ctx cosmossdktypes.Context, chain axelarnettypes.CosmosChain)  {
// 				panic("mock out the SetCosmosChain method")
// 			},
// 			SetFeeCollectorFunc: func(ctx cosmossdktypes.Context, address cosmossdktypes.AccAddress) error {
// 				panic("mock out the SetFeeCollector method")
// 			},
// 			SetPendingIBCTransferFunc: func(ctx cosmossdktypes.Context, transfer axelarnettypes.IBCTransfer)  {
// 				panic("mock out the SetPendingIBCTransfer method")
// 			},
// 		}
//
// 		// use mockedBaseKeeper in code that requires axelarnettypes.BaseKeeper
// 		// and then make assertions.
//
// 	}
type BaseKeeperMock struct {
	// DeletePendingIBCTransferFunc mocks the DeletePendingIBCTransfer method.
	DeletePendingIBCTransferFunc func(ctx cosmossdktypes.Context, portID string, channelID string, sequence uint64)

	// GetCosmosChainByNameFunc mocks the GetCosmosChainByName method.
	GetCosmosChainByNameFunc func(ctx cosmossdktypes.Context, chain string) (axelarnettypes.CosmosChain, bool)

	// GetCosmosChainsFunc mocks the GetCosmosChains method.
	GetCosmosChainsFunc func(ctx cosmossdktypes.Context) []string

	// GetFeeCollectorFunc mocks the GetFeeCollector method.
	GetFeeCollectorFunc func(ctx cosmossdktypes.Context) (cosmossdktypes.AccAddress, bool)

	// GetIBCPathFunc mocks the GetIBCPath method.
	GetIBCPathFunc func(ctx cosmossdktypes.Context, chain string) (string, bool)

	// GetPendingIBCTransferFunc mocks the GetPendingIBCTransfer method.
	GetPendingIBCTransferFunc func(ctx cosmossdktypes.Context, portID string, channelID string, sequence uint64) (axelarnettypes.IBCTransfer, bool)

	// GetRouteTimeoutWindowFunc mocks the GetRouteTimeoutWindow method.
	GetRouteTimeoutWindowFunc func(ctx cosmossdktypes.Context) uint64

	// GetTransactionFeeRateFunc mocks the GetTransactionFeeRate method.
	GetTransactionFeeRateFunc func(ctx cosmossdktypes.Context) cosmossdktypes.Dec

	// LoggerFunc mocks the Logger method.
	LoggerFunc func(ctx cosmossdktypes.Context) log.Logger

	// RegisterIBCPathFunc mocks the RegisterIBCPath method.
	RegisterIBCPathFunc func(ctx cosmossdktypes.Context, asset string, path string) error

	// SetCosmosChainFunc mocks the SetCosmosChain method.
	SetCosmosChainFunc func(ctx cosmossdktypes.Context, chain axelarnettypes.CosmosChain)

	// SetFeeCollectorFunc mocks the SetFeeCollector method.
	SetFeeCollectorFunc func(ctx cosmossdktypes.Context, address cosmossdktypes.AccAddress) error

	// SetPendingIBCTransferFunc mocks the SetPendingIBCTransfer method.
	SetPendingIBCTransferFunc func(ctx cosmossdktypes.Context, transfer axelarnettypes.IBCTransfer)

	// calls tracks calls to the methods.
	calls struct {
		// DeletePendingIBCTransfer holds details about calls to the DeletePendingIBCTransfer method.
		DeletePendingIBCTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// PortID is the portID argument value.
			PortID string
			// ChannelID is the channelID argument value.
			ChannelID string
			// Sequence is the sequence argument value.
			Sequence uint64
		}
		// GetCosmosChainByName holds details about calls to the GetCosmosChainByName method.
		GetCosmosChainByName []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain string
		}
		// GetCosmosChains holds details about calls to the GetCosmosChains method.
		GetCosmosChains []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// GetFeeCollector holds details about calls to the GetFeeCollector method.
		GetFeeCollector []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// GetIBCPath holds details about calls to the GetIBCPath method.
		GetIBCPath []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain string
		}
		// GetPendingIBCTransfer holds details about calls to the GetPendingIBCTransfer method.
		GetPendingIBCTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// PortID is the portID argument value.
			PortID string
			// ChannelID is the channelID argument value.
			ChannelID string
			// Sequence is the sequence argument value.
			Sequence uint64
		}
		// GetRouteTimeoutWindow holds details about calls to the GetRouteTimeoutWindow method.
		GetRouteTimeoutWindow []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// GetTransactionFeeRate holds details about calls to the GetTransactionFeeRate method.
		GetTransactionFeeRate []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// Logger holds details about calls to the Logger method.
		Logger []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// RegisterIBCPath holds details about calls to the RegisterIBCPath method.
		RegisterIBCPath []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Asset is the asset argument value.
			Asset string
			// Path is the path argument value.
			Path string
		}
		// SetCosmosChain holds details about calls to the SetCosmosChain method.
		SetCosmosChain []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain axelarnettypes.CosmosChain
		}
		// SetFeeCollector holds details about calls to the SetFeeCollector method.
		SetFeeCollector []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Address is the address argument value.
			Address cosmossdktypes.AccAddress
		}
		// SetPendingIBCTransfer holds details about calls to the SetPendingIBCTransfer method.
		SetPendingIBCTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Transfer is the transfer argument value.
			Transfer axelarnettypes.IBCTransfer
		}
	}
	lockDeletePendingIBCTransfer sync.RWMutex
	lockGetCosmosChainByName     sync.RWMutex
	lockGetCosmosChains          sync.RWMutex
	lockGetFeeCollector          sync.RWMutex
	lockGetIBCPath               sync.RWMutex
	lockGetPendingIBCTransfer    sync.RWMutex
	lockGetRouteTimeoutWindow    sync.RWMutex
	lockGetTransactionFeeRate    sync.RWMutex
	lockLogger                   sync.RWMutex
	lockRegisterIBCPath          sync.RWMutex
	lockSetCosmosChain           sync.RWMutex
	lockSetFeeCollector          sync.RWMutex
	lockSetPendingIBCTransfer    sync.RWMutex
}

// DeletePendingIBCTransfer calls DeletePendingIBCTransferFunc.
func (mock *BaseKeeperMock) DeletePendingIBCTransfer(ctx cosmossdktypes.Context, portID string, channelID string, sequence uint64) {
	if mock.DeletePendingIBCTransferFunc == nil {
		panic("BaseKeeperMock.DeletePendingIBCTransferFunc: method is nil but BaseKeeper.DeletePendingIBCTransfer was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		PortID    string
		ChannelID string
		Sequence  uint64
	}{
		Ctx:       ctx,
		PortID:    portID,
		ChannelID: channelID,
		Sequence:  sequence,
	}
	mock.lockDeletePendingIBCTransfer.Lock()
	mock.calls.DeletePendingIBCTransfer = append(mock.calls.DeletePendingIBCTransfer, callInfo)
	mock.lockDeletePendingIBCTransfer.Unlock()
	mock.DeletePendingIBCTransferFunc(ctx, portID, channelID, sequence)
}

// DeletePendingIBCTransferCalls gets all the calls that were made to DeletePendingIBCTransfer.
// Check the length with:
//     len(mockedBaseKeeper.DeletePendingIBCTransferCalls())
func (mock *BaseKeeperMock) DeletePendingIBCTransferCalls() []struct {
	Ctx       cosmossdktypes.Context
	PortID    string
	ChannelID string
	Sequence  uint64
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		PortID    string
		ChannelID string
		Sequence  uint64
	}
	mock.lockDeletePendingIBCTransfer.RLock()
	calls = mock.calls.DeletePendingIBCTransfer
	mock.lockDeletePendingIBCTransfer.RUnlock()
	return calls
}

// GetCosmosChainByName calls GetCosmosChainByNameFunc.
func (mock *BaseKeeperMock) GetCosmosChainByName(ctx cosmossdktypes.Context, chain string) (axelarnettypes.CosmosChain, bool) {
	if mock.GetCosmosChainByNameFunc == nil {
		panic("BaseKeeperMock.GetCosmosChainByNameFunc: method is nil but BaseKeeper.GetCosmosChainByName was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain string
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockGetCosmosChainByName.Lock()
	mock.calls.GetCosmosChainByName = append(mock.calls.GetCosmosChainByName, callInfo)
	mock.lockGetCosmosChainByName.Unlock()
	return mock.GetCosmosChainByNameFunc(ctx, chain)
}

// GetCosmosChainByNameCalls gets all the calls that were made to GetCosmosChainByName.
// Check the length with:
//     len(mockedBaseKeeper.GetCosmosChainByNameCalls())
func (mock *BaseKeeperMock) GetCosmosChainByNameCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain string
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain string
	}
	mock.lockGetCosmosChainByName.RLock()
	calls = mock.calls.GetCosmosChainByName
	mock.lockGetCosmosChainByName.RUnlock()
	return calls
}

// GetCosmosChains calls GetCosmosChainsFunc.
func (mock *BaseKeeperMock) GetCosmosChains(ctx cosmossdktypes.Context) []string {
	if mock.GetCosmosChainsFunc == nil {
		panic("BaseKeeperMock.GetCosmosChainsFunc: method is nil but BaseKeeper.GetCosmosChains was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetCosmosChains.Lock()
	mock.calls.GetCosmosChains = append(mock.calls.GetCosmosChains, callInfo)
	mock.lockGetCosmosChains.Unlock()
	return mock.GetCosmosChainsFunc(ctx)
}

// GetCosmosChainsCalls gets all the calls that were made to GetCosmosChains.
// Check the length with:
//     len(mockedBaseKeeper.GetCosmosChainsCalls())
func (mock *BaseKeeperMock) GetCosmosChainsCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockGetCosmosChains.RLock()
	calls = mock.calls.GetCosmosChains
	mock.lockGetCosmosChains.RUnlock()
	return calls
}

// GetFeeCollector calls GetFeeCollectorFunc.
func (mock *BaseKeeperMock) GetFeeCollector(ctx cosmossdktypes.Context) (cosmossdktypes.AccAddress, bool) {
	if mock.GetFeeCollectorFunc == nil {
		panic("BaseKeeperMock.GetFeeCollectorFunc: method is nil but BaseKeeper.GetFeeCollector was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetFeeCollector.Lock()
	mock.calls.GetFeeCollector = append(mock.calls.GetFeeCollector, callInfo)
	mock.lockGetFeeCollector.Unlock()
	return mock.GetFeeCollectorFunc(ctx)
}

// GetFeeCollectorCalls gets all the calls that were made to GetFeeCollector.
// Check the length with:
//     len(mockedBaseKeeper.GetFeeCollectorCalls())
func (mock *BaseKeeperMock) GetFeeCollectorCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockGetFeeCollector.RLock()
	calls = mock.calls.GetFeeCollector
	mock.lockGetFeeCollector.RUnlock()
	return calls
}

// GetIBCPath calls GetIBCPathFunc.
func (mock *BaseKeeperMock) GetIBCPath(ctx cosmossdktypes.Context, chain string) (string, bool) {
	if mock.GetIBCPathFunc == nil {
		panic("BaseKeeperMock.GetIBCPathFunc: method is nil but BaseKeeper.GetIBCPath was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain string
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockGetIBCPath.Lock()
	mock.calls.GetIBCPath = append(mock.calls.GetIBCPath, callInfo)
	mock.lockGetIBCPath.Unlock()
	return mock.GetIBCPathFunc(ctx, chain)
}

// GetIBCPathCalls gets all the calls that were made to GetIBCPath.
// Check the length with:
//     len(mockedBaseKeeper.GetIBCPathCalls())
func (mock *BaseKeeperMock) GetIBCPathCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain string
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain string
	}
	mock.lockGetIBCPath.RLock()
	calls = mock.calls.GetIBCPath
	mock.lockGetIBCPath.RUnlock()
	return calls
}

// GetPendingIBCTransfer calls GetPendingIBCTransferFunc.
func (mock *BaseKeeperMock) GetPendingIBCTransfer(ctx cosmossdktypes.Context, portID string, channelID string, sequence uint64) (axelarnettypes.IBCTransfer, bool) {
	if mock.GetPendingIBCTransferFunc == nil {
		panic("BaseKeeperMock.GetPendingIBCTransferFunc: method is nil but BaseKeeper.GetPendingIBCTransfer was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		PortID    string
		ChannelID string
		Sequence  uint64
	}{
		Ctx:       ctx,
		PortID:    portID,
		ChannelID: channelID,
		Sequence:  sequence,
	}
	mock.lockGetPendingIBCTransfer.Lock()
	mock.calls.GetPendingIBCTransfer = append(mock.calls.GetPendingIBCTransfer, callInfo)
	mock.lockGetPendingIBCTransfer.Unlock()
	return mock.GetPendingIBCTransferFunc(ctx, portID, channelID, sequence)
}

// GetPendingIBCTransferCalls gets all the calls that were made to GetPendingIBCTransfer.
// Check the length with:
//     len(mockedBaseKeeper.GetPendingIBCTransferCalls())
func (mock *BaseKeeperMock) GetPendingIBCTransferCalls() []struct {
	Ctx       cosmossdktypes.Context
	PortID    string
	ChannelID string
	Sequence  uint64
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		PortID    string
		ChannelID string
		Sequence  uint64
	}
	mock.lockGetPendingIBCTransfer.RLock()
	calls = mock.calls.GetPendingIBCTransfer
	mock.lockGetPendingIBCTransfer.RUnlock()
	return calls
}

// GetRouteTimeoutWindow calls GetRouteTimeoutWindowFunc.
func (mock *BaseKeeperMock) GetRouteTimeoutWindow(ctx cosmossdktypes.Context) uint64 {
	if mock.GetRouteTimeoutWindowFunc == nil {
		panic("BaseKeeperMock.GetRouteTimeoutWindowFunc: method is nil but BaseKeeper.GetRouteTimeoutWindow was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetRouteTimeoutWindow.Lock()
	mock.calls.GetRouteTimeoutWindow = append(mock.calls.GetRouteTimeoutWindow, callInfo)
	mock.lockGetRouteTimeoutWindow.Unlock()
	return mock.GetRouteTimeoutWindowFunc(ctx)
}

// GetRouteTimeoutWindowCalls gets all the calls that were made to GetRouteTimeoutWindow.
// Check the length with:
//     len(mockedBaseKeeper.GetRouteTimeoutWindowCalls())
func (mock *BaseKeeperMock) GetRouteTimeoutWindowCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockGetRouteTimeoutWindow.RLock()
	calls = mock.calls.GetRouteTimeoutWindow
	mock.lockGetRouteTimeoutWindow.RUnlock()
	return calls
}

// GetTransactionFeeRate calls GetTransactionFeeRateFunc.
func (mock *BaseKeeperMock) GetTransactionFeeRate(ctx cosmossdktypes.Context) cosmossdktypes.Dec {
	if mock.GetTransactionFeeRateFunc == nil {
		panic("BaseKeeperMock.GetTransactionFeeRateFunc: method is nil but BaseKeeper.GetTransactionFeeRate was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetTransactionFeeRate.Lock()
	mock.calls.GetTransactionFeeRate = append(mock.calls.GetTransactionFeeRate, callInfo)
	mock.lockGetTransactionFeeRate.Unlock()
	return mock.GetTransactionFeeRateFunc(ctx)
}

// GetTransactionFeeRateCalls gets all the calls that were made to GetTransactionFeeRate.
// Check the length with:
//     len(mockedBaseKeeper.GetTransactionFeeRateCalls())
func (mock *BaseKeeperMock) GetTransactionFeeRateCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockGetTransactionFeeRate.RLock()
	calls = mock.calls.GetTransactionFeeRate
	mock.lockGetTransactionFeeRate.RUnlock()
	return calls
}

// Logger calls LoggerFunc.
func (mock *BaseKeeperMock) Logger(ctx cosmossdktypes.Context) log.Logger {
	if mock.LoggerFunc == nil {
		panic("BaseKeeperMock.LoggerFunc: method is nil but BaseKeeper.Logger was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockLogger.Lock()
	mock.calls.Logger = append(mock.calls.Logger, callInfo)
	mock.lockLogger.Unlock()
	return mock.LoggerFunc(ctx)
}

// LoggerCalls gets all the calls that were made to Logger.
// Check the length with:
//     len(mockedBaseKeeper.LoggerCalls())
func (mock *BaseKeeperMock) LoggerCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockLogger.RLock()
	calls = mock.calls.Logger
	mock.lockLogger.RUnlock()
	return calls
}

// RegisterIBCPath calls RegisterIBCPathFunc.
func (mock *BaseKeeperMock) RegisterIBCPath(ctx cosmossdktypes.Context, asset string, path string) error {
	if mock.RegisterIBCPathFunc == nil {
		panic("BaseKeeperMock.RegisterIBCPathFunc: method is nil but BaseKeeper.RegisterIBCPath was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Asset string
		Path  string
	}{
		Ctx:   ctx,
		Asset: asset,
		Path:  path,
	}
	mock.lockRegisterIBCPath.Lock()
	mock.calls.RegisterIBCPath = append(mock.calls.RegisterIBCPath, callInfo)
	mock.lockRegisterIBCPath.Unlock()
	return mock.RegisterIBCPathFunc(ctx, asset, path)
}

// RegisterIBCPathCalls gets all the calls that were made to RegisterIBCPath.
// Check the length with:
//     len(mockedBaseKeeper.RegisterIBCPathCalls())
func (mock *BaseKeeperMock) RegisterIBCPathCalls() []struct {
	Ctx   cosmossdktypes.Context
	Asset string
	Path  string
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Asset string
		Path  string
	}
	mock.lockRegisterIBCPath.RLock()
	calls = mock.calls.RegisterIBCPath
	mock.lockRegisterIBCPath.RUnlock()
	return calls
}

// SetCosmosChain calls SetCosmosChainFunc.
func (mock *BaseKeeperMock) SetCosmosChain(ctx cosmossdktypes.Context, chain axelarnettypes.CosmosChain) {
	if mock.SetCosmosChainFunc == nil {
		panic("BaseKeeperMock.SetCosmosChainFunc: method is nil but BaseKeeper.SetCosmosChain was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain axelarnettypes.CosmosChain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockSetCosmosChain.Lock()
	mock.calls.SetCosmosChain = append(mock.calls.SetCosmosChain, callInfo)
	mock.lockSetCosmosChain.Unlock()
	mock.SetCosmosChainFunc(ctx, chain)
}

// SetCosmosChainCalls gets all the calls that were made to SetCosmosChain.
// Check the length with:
//     len(mockedBaseKeeper.SetCosmosChainCalls())
func (mock *BaseKeeperMock) SetCosmosChainCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain axelarnettypes.CosmosChain
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain axelarnettypes.CosmosChain
	}
	mock.lockSetCosmosChain.RLock()
	calls = mock.calls.SetCosmosChain
	mock.lockSetCosmosChain.RUnlock()
	return calls
}

// SetFeeCollector calls SetFeeCollectorFunc.
func (mock *BaseKeeperMock) SetFeeCollector(ctx cosmossdktypes.Context, address cosmossdktypes.AccAddress) error {
	if mock.SetFeeCollectorFunc == nil {
		panic("BaseKeeperMock.SetFeeCollectorFunc: method is nil but BaseKeeper.SetFeeCollector was just called")
	}
	callInfo := struct {
		Ctx     cosmossdktypes.Context
		Address cosmossdktypes.AccAddress
	}{
		Ctx:     ctx,
		Address: address,
	}
	mock.lockSetFeeCollector.Lock()
	mock.calls.SetFeeCollector = append(mock.calls.SetFeeCollector, callInfo)
	mock.lockSetFeeCollector.Unlock()
	return mock.SetFeeCollectorFunc(ctx, address)
}

// SetFeeCollectorCalls gets all the calls that were made to SetFeeCollector.
// Check the length with:
//     len(mockedBaseKeeper.SetFeeCollectorCalls())
func (mock *BaseKeeperMock) SetFeeCollectorCalls() []struct {
	Ctx     cosmossdktypes.Context
	Address cosmossdktypes.AccAddress
} {
	var calls []struct {
		Ctx     cosmossdktypes.Context
		Address cosmossdktypes.AccAddress
	}
	mock.lockSetFeeCollector.RLock()
	calls = mock.calls.SetFeeCollector
	mock.lockSetFeeCollector.RUnlock()
	return calls
}

// SetPendingIBCTransfer calls SetPendingIBCTransferFunc.
func (mock *BaseKeeperMock) SetPendingIBCTransfer(ctx cosmossdktypes.Context, transfer axelarnettypes.IBCTransfer) {
	if mock.SetPendingIBCTransferFunc == nil {
		panic("BaseKeeperMock.SetPendingIBCTransferFunc: method is nil but BaseKeeper.SetPendingIBCTransfer was just called")
	}
	callInfo := struct {
		Ctx      cosmossdktypes.Context
		Transfer axelarnettypes.IBCTransfer
	}{
		Ctx:      ctx,
		Transfer: transfer,
	}
	mock.lockSetPendingIBCTransfer.Lock()
	mock.calls.SetPendingIBCTransfer = append(mock.calls.SetPendingIBCTransfer, callInfo)
	mock.lockSetPendingIBCTransfer.Unlock()
	mock.SetPendingIBCTransferFunc(ctx, transfer)
}

// SetPendingIBCTransferCalls gets all the calls that were made to SetPendingIBCTransfer.
// Check the length with:
//     len(mockedBaseKeeper.SetPendingIBCTransferCalls())
func (mock *BaseKeeperMock) SetPendingIBCTransferCalls() []struct {
	Ctx      cosmossdktypes.Context
	Transfer axelarnettypes.IBCTransfer
} {
	var calls []struct {
		Ctx      cosmossdktypes.Context
		Transfer axelarnettypes.IBCTransfer
	}
	mock.lockSetPendingIBCTransfer.RLock()
	calls = mock.calls.SetPendingIBCTransfer
	mock.lockSetPendingIBCTransfer.RUnlock()
	return calls
}

// Ensure, that NexusMock does implement axelarnettypes.Nexus.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.Nexus = &NexusMock{}

// NexusMock is a mock implementation of axelarnettypes.Nexus.
//
// 	func TestSomethingThatUsesNexus(t *testing.T) {
//
// 		// make and configure a mocked axelarnettypes.Nexus
// 		mockedNexus := &NexusMock{
// 			ActivateChainFunc: func(ctx cosmossdktypes.Context, chain exported.Chain)  {
// 				panic("mock out the ActivateChain method")
// 			},
// 			ArchivePendingTransferFunc: func(ctx cosmossdktypes.Context, transfer exported.CrossChainTransfer)  {
// 				panic("mock out the ArchivePendingTransfer method")
// 			},
// 			EnqueueForTransferFunc: func(ctx cosmossdktypes.Context, sender exported.CrossChainAddress, amount cosmossdktypes.Coin, feeRate cosmossdktypes.Dec) (exported.TransferID, error) {
// 				panic("mock out the EnqueueForTransfer method")
// 			},
// 			GetChainFunc: func(ctx cosmossdktypes.Context, chain string) (exported.Chain, bool) {
// 				panic("mock out the GetChain method")
// 			},
// 			GetChainByNativeAssetFunc: func(ctx cosmossdktypes.Context, asset string) (exported.Chain, bool) {
// 				panic("mock out the GetChainByNativeAsset method")
// 			},
// 			GetRecipientFunc: func(ctx cosmossdktypes.Context, sender exported.CrossChainAddress) (exported.CrossChainAddress, bool) {
// 				panic("mock out the GetRecipient method")
// 			},
// 			GetTransferFeesFunc: func(ctx cosmossdktypes.Context) cosmossdktypes.Coins {
// 				panic("mock out the GetTransferFees method")
// 			},
// 			GetTransfersForChainFunc: func(ctx cosmossdktypes.Context, chain exported.Chain, state exported.TransferState) []exported.CrossChainTransfer {
// 				panic("mock out the GetTransfersForChain method")
// 			},
// 			IsAssetRegisteredFunc: func(ctx cosmossdktypes.Context, chain exported.Chain, denom string) bool {
// 				panic("mock out the IsAssetRegistered method")
// 			},
// 			LinkAddressesFunc: func(ctx cosmossdktypes.Context, sender exported.CrossChainAddress, recipient exported.CrossChainAddress) error {
// 				panic("mock out the LinkAddresses method")
// 			},
// 			RegisterAssetFunc: func(ctx cosmossdktypes.Context, chain exported.Chain, asset exported.Asset) error {
// 				panic("mock out the RegisterAsset method")
// 			},
// 			RegisterNativeAssetFunc: func(ctx cosmossdktypes.Context, chain exported.Chain, nativeAsset string) error {
// 				panic("mock out the RegisterNativeAsset method")
// 			},
// 			SetChainFunc: func(ctx cosmossdktypes.Context, chain exported.Chain)  {
// 				panic("mock out the SetChain method")
// 			},
// 			SubTransferFeeFunc: func(ctx cosmossdktypes.Context, coin cosmossdktypes.Coin)  {
// 				panic("mock out the SubTransferFee method")
// 			},
// 		}
//
// 		// use mockedNexus in code that requires axelarnettypes.Nexus
// 		// and then make assertions.
//
// 	}
type NexusMock struct {
	// ActivateChainFunc mocks the ActivateChain method.
	ActivateChainFunc func(ctx cosmossdktypes.Context, chain exported.Chain)

	// ArchivePendingTransferFunc mocks the ArchivePendingTransfer method.
	ArchivePendingTransferFunc func(ctx cosmossdktypes.Context, transfer exported.CrossChainTransfer)

	// EnqueueForTransferFunc mocks the EnqueueForTransfer method.
	EnqueueForTransferFunc func(ctx cosmossdktypes.Context, sender exported.CrossChainAddress, amount cosmossdktypes.Coin, feeRate cosmossdktypes.Dec) (exported.TransferID, error)

	// GetChainFunc mocks the GetChain method.
	GetChainFunc func(ctx cosmossdktypes.Context, chain string) (exported.Chain, bool)

	// GetChainByNativeAssetFunc mocks the GetChainByNativeAsset method.
	GetChainByNativeAssetFunc func(ctx cosmossdktypes.Context, asset string) (exported.Chain, bool)

	// GetRecipientFunc mocks the GetRecipient method.
	GetRecipientFunc func(ctx cosmossdktypes.Context, sender exported.CrossChainAddress) (exported.CrossChainAddress, bool)

	// GetTransferFeesFunc mocks the GetTransferFees method.
	GetTransferFeesFunc func(ctx cosmossdktypes.Context) cosmossdktypes.Coins

	// GetTransfersForChainFunc mocks the GetTransfersForChain method.
	GetTransfersForChainFunc func(ctx cosmossdktypes.Context, chain exported.Chain, state exported.TransferState) []exported.CrossChainTransfer

	// IsAssetRegisteredFunc mocks the IsAssetRegistered method.
	IsAssetRegisteredFunc func(ctx cosmossdktypes.Context, chain exported.Chain, denom string) bool

	// LinkAddressesFunc mocks the LinkAddresses method.
	LinkAddressesFunc func(ctx cosmossdktypes.Context, sender exported.CrossChainAddress, recipient exported.CrossChainAddress) error

	// RegisterAssetFunc mocks the RegisterAsset method.
	RegisterAssetFunc func(ctx cosmossdktypes.Context, chain exported.Chain, asset exported.Asset) error

	// RegisterNativeAssetFunc mocks the RegisterNativeAsset method.
	RegisterNativeAssetFunc func(ctx cosmossdktypes.Context, chain exported.Chain, nativeAsset string) error

	// SetChainFunc mocks the SetChain method.
	SetChainFunc func(ctx cosmossdktypes.Context, chain exported.Chain)

	// SubTransferFeeFunc mocks the SubTransferFee method.
	SubTransferFeeFunc func(ctx cosmossdktypes.Context, coin cosmossdktypes.Coin)

	// calls tracks calls to the methods.
	calls struct {
		// ActivateChain holds details about calls to the ActivateChain method.
		ActivateChain []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain exported.Chain
		}
		// ArchivePendingTransfer holds details about calls to the ArchivePendingTransfer method.
		ArchivePendingTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Transfer is the transfer argument value.
			Transfer exported.CrossChainTransfer
		}
		// EnqueueForTransfer holds details about calls to the EnqueueForTransfer method.
		EnqueueForTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Sender is the sender argument value.
			Sender exported.CrossChainAddress
			// Amount is the amount argument value.
			Amount cosmossdktypes.Coin
			// FeeRate is the feeRate argument value.
			FeeRate cosmossdktypes.Dec
		}
		// GetChain holds details about calls to the GetChain method.
		GetChain []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain string
		}
		// GetChainByNativeAsset holds details about calls to the GetChainByNativeAsset method.
		GetChainByNativeAsset []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Asset is the asset argument value.
			Asset string
		}
		// GetRecipient holds details about calls to the GetRecipient method.
		GetRecipient []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Sender is the sender argument value.
			Sender exported.CrossChainAddress
		}
		// GetTransferFees holds details about calls to the GetTransferFees method.
		GetTransferFees []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
		}
		// GetTransfersForChain holds details about calls to the GetTransfersForChain method.
		GetTransfersForChain []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain exported.Chain
			// State is the state argument value.
			State exported.TransferState
		}
		// IsAssetRegistered holds details about calls to the IsAssetRegistered method.
		IsAssetRegistered []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain exported.Chain
			// Denom is the denom argument value.
			Denom string
		}
		// LinkAddresses holds details about calls to the LinkAddresses method.
		LinkAddresses []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Sender is the sender argument value.
			Sender exported.CrossChainAddress
			// Recipient is the recipient argument value.
			Recipient exported.CrossChainAddress
		}
		// RegisterAsset holds details about calls to the RegisterAsset method.
		RegisterAsset []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain exported.Chain
			// Asset is the asset argument value.
			Asset exported.Asset
		}
		// RegisterNativeAsset holds details about calls to the RegisterNativeAsset method.
		RegisterNativeAsset []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain exported.Chain
			// NativeAsset is the nativeAsset argument value.
			NativeAsset string
		}
		// SetChain holds details about calls to the SetChain method.
		SetChain []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Chain is the chain argument value.
			Chain exported.Chain
		}
		// SubTransferFee holds details about calls to the SubTransferFee method.
		SubTransferFee []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Coin is the coin argument value.
			Coin cosmossdktypes.Coin
		}
	}
	lockActivateChain          sync.RWMutex
	lockArchivePendingTransfer sync.RWMutex
	lockEnqueueForTransfer     sync.RWMutex
	lockGetChain               sync.RWMutex
	lockGetChainByNativeAsset  sync.RWMutex
	lockGetRecipient           sync.RWMutex
	lockGetTransferFees        sync.RWMutex
	lockGetTransfersForChain   sync.RWMutex
	lockIsAssetRegistered      sync.RWMutex
	lockLinkAddresses          sync.RWMutex
	lockRegisterAsset          sync.RWMutex
	lockRegisterNativeAsset    sync.RWMutex
	lockSetChain               sync.RWMutex
	lockSubTransferFee         sync.RWMutex
}

// ActivateChain calls ActivateChainFunc.
func (mock *NexusMock) ActivateChain(ctx cosmossdktypes.Context, chain exported.Chain) {
	if mock.ActivateChainFunc == nil {
		panic("NexusMock.ActivateChainFunc: method is nil but Nexus.ActivateChain was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain exported.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockActivateChain.Lock()
	mock.calls.ActivateChain = append(mock.calls.ActivateChain, callInfo)
	mock.lockActivateChain.Unlock()
	mock.ActivateChainFunc(ctx, chain)
}

// ActivateChainCalls gets all the calls that were made to ActivateChain.
// Check the length with:
//     len(mockedNexus.ActivateChainCalls())
func (mock *NexusMock) ActivateChainCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain exported.Chain
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain exported.Chain
	}
	mock.lockActivateChain.RLock()
	calls = mock.calls.ActivateChain
	mock.lockActivateChain.RUnlock()
	return calls
}

// ArchivePendingTransfer calls ArchivePendingTransferFunc.
func (mock *NexusMock) ArchivePendingTransfer(ctx cosmossdktypes.Context, transfer exported.CrossChainTransfer) {
	if mock.ArchivePendingTransferFunc == nil {
		panic("NexusMock.ArchivePendingTransferFunc: method is nil but Nexus.ArchivePendingTransfer was just called")
	}
	callInfo := struct {
		Ctx      cosmossdktypes.Context
		Transfer exported.CrossChainTransfer
	}{
		Ctx:      ctx,
		Transfer: transfer,
	}
	mock.lockArchivePendingTransfer.Lock()
	mock.calls.ArchivePendingTransfer = append(mock.calls.ArchivePendingTransfer, callInfo)
	mock.lockArchivePendingTransfer.Unlock()
	mock.ArchivePendingTransferFunc(ctx, transfer)
}

// ArchivePendingTransferCalls gets all the calls that were made to ArchivePendingTransfer.
// Check the length with:
//     len(mockedNexus.ArchivePendingTransferCalls())
func (mock *NexusMock) ArchivePendingTransferCalls() []struct {
	Ctx      cosmossdktypes.Context
	Transfer exported.CrossChainTransfer
} {
	var calls []struct {
		Ctx      cosmossdktypes.Context
		Transfer exported.CrossChainTransfer
	}
	mock.lockArchivePendingTransfer.RLock()
	calls = mock.calls.ArchivePendingTransfer
	mock.lockArchivePendingTransfer.RUnlock()
	return calls
}

// EnqueueForTransfer calls EnqueueForTransferFunc.
func (mock *NexusMock) EnqueueForTransfer(ctx cosmossdktypes.Context, sender exported.CrossChainAddress, amount cosmossdktypes.Coin, feeRate cosmossdktypes.Dec) (exported.TransferID, error) {
	if mock.EnqueueForTransferFunc == nil {
		panic("NexusMock.EnqueueForTransferFunc: method is nil but Nexus.EnqueueForTransfer was just called")
	}
	callInfo := struct {
		Ctx     cosmossdktypes.Context
		Sender  exported.CrossChainAddress
		Amount  cosmossdktypes.Coin
		FeeRate cosmossdktypes.Dec
	}{
		Ctx:     ctx,
		Sender:  sender,
		Amount:  amount,
		FeeRate: feeRate,
	}
	mock.lockEnqueueForTransfer.Lock()
	mock.calls.EnqueueForTransfer = append(mock.calls.EnqueueForTransfer, callInfo)
	mock.lockEnqueueForTransfer.Unlock()
	return mock.EnqueueForTransferFunc(ctx, sender, amount, feeRate)
}

// EnqueueForTransferCalls gets all the calls that were made to EnqueueForTransfer.
// Check the length with:
//     len(mockedNexus.EnqueueForTransferCalls())
func (mock *NexusMock) EnqueueForTransferCalls() []struct {
	Ctx     cosmossdktypes.Context
	Sender  exported.CrossChainAddress
	Amount  cosmossdktypes.Coin
	FeeRate cosmossdktypes.Dec
} {
	var calls []struct {
		Ctx     cosmossdktypes.Context
		Sender  exported.CrossChainAddress
		Amount  cosmossdktypes.Coin
		FeeRate cosmossdktypes.Dec
	}
	mock.lockEnqueueForTransfer.RLock()
	calls = mock.calls.EnqueueForTransfer
	mock.lockEnqueueForTransfer.RUnlock()
	return calls
}

// GetChain calls GetChainFunc.
func (mock *NexusMock) GetChain(ctx cosmossdktypes.Context, chain string) (exported.Chain, bool) {
	if mock.GetChainFunc == nil {
		panic("NexusMock.GetChainFunc: method is nil but Nexus.GetChain was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain string
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockGetChain.Lock()
	mock.calls.GetChain = append(mock.calls.GetChain, callInfo)
	mock.lockGetChain.Unlock()
	return mock.GetChainFunc(ctx, chain)
}

// GetChainCalls gets all the calls that were made to GetChain.
// Check the length with:
//     len(mockedNexus.GetChainCalls())
func (mock *NexusMock) GetChainCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain string
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain string
	}
	mock.lockGetChain.RLock()
	calls = mock.calls.GetChain
	mock.lockGetChain.RUnlock()
	return calls
}

// GetChainByNativeAsset calls GetChainByNativeAssetFunc.
func (mock *NexusMock) GetChainByNativeAsset(ctx cosmossdktypes.Context, asset string) (exported.Chain, bool) {
	if mock.GetChainByNativeAssetFunc == nil {
		panic("NexusMock.GetChainByNativeAssetFunc: method is nil but Nexus.GetChainByNativeAsset was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Asset string
	}{
		Ctx:   ctx,
		Asset: asset,
	}
	mock.lockGetChainByNativeAsset.Lock()
	mock.calls.GetChainByNativeAsset = append(mock.calls.GetChainByNativeAsset, callInfo)
	mock.lockGetChainByNativeAsset.Unlock()
	return mock.GetChainByNativeAssetFunc(ctx, asset)
}

// GetChainByNativeAssetCalls gets all the calls that were made to GetChainByNativeAsset.
// Check the length with:
//     len(mockedNexus.GetChainByNativeAssetCalls())
func (mock *NexusMock) GetChainByNativeAssetCalls() []struct {
	Ctx   cosmossdktypes.Context
	Asset string
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Asset string
	}
	mock.lockGetChainByNativeAsset.RLock()
	calls = mock.calls.GetChainByNativeAsset
	mock.lockGetChainByNativeAsset.RUnlock()
	return calls
}

// GetRecipient calls GetRecipientFunc.
func (mock *NexusMock) GetRecipient(ctx cosmossdktypes.Context, sender exported.CrossChainAddress) (exported.CrossChainAddress, bool) {
	if mock.GetRecipientFunc == nil {
		panic("NexusMock.GetRecipientFunc: method is nil but Nexus.GetRecipient was just called")
	}
	callInfo := struct {
		Ctx    cosmossdktypes.Context
		Sender exported.CrossChainAddress
	}{
		Ctx:    ctx,
		Sender: sender,
	}
	mock.lockGetRecipient.Lock()
	mock.calls.GetRecipient = append(mock.calls.GetRecipient, callInfo)
	mock.lockGetRecipient.Unlock()
	return mock.GetRecipientFunc(ctx, sender)
}

// GetRecipientCalls gets all the calls that were made to GetRecipient.
// Check the length with:
//     len(mockedNexus.GetRecipientCalls())
func (mock *NexusMock) GetRecipientCalls() []struct {
	Ctx    cosmossdktypes.Context
	Sender exported.CrossChainAddress
} {
	var calls []struct {
		Ctx    cosmossdktypes.Context
		Sender exported.CrossChainAddress
	}
	mock.lockGetRecipient.RLock()
	calls = mock.calls.GetRecipient
	mock.lockGetRecipient.RUnlock()
	return calls
}

// GetTransferFees calls GetTransferFeesFunc.
func (mock *NexusMock) GetTransferFees(ctx cosmossdktypes.Context) cosmossdktypes.Coins {
	if mock.GetTransferFeesFunc == nil {
		panic("NexusMock.GetTransferFeesFunc: method is nil but Nexus.GetTransferFees was just called")
	}
	callInfo := struct {
		Ctx cosmossdktypes.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetTransferFees.Lock()
	mock.calls.GetTransferFees = append(mock.calls.GetTransferFees, callInfo)
	mock.lockGetTransferFees.Unlock()
	return mock.GetTransferFeesFunc(ctx)
}

// GetTransferFeesCalls gets all the calls that were made to GetTransferFees.
// Check the length with:
//     len(mockedNexus.GetTransferFeesCalls())
func (mock *NexusMock) GetTransferFeesCalls() []struct {
	Ctx cosmossdktypes.Context
} {
	var calls []struct {
		Ctx cosmossdktypes.Context
	}
	mock.lockGetTransferFees.RLock()
	calls = mock.calls.GetTransferFees
	mock.lockGetTransferFees.RUnlock()
	return calls
}

// GetTransfersForChain calls GetTransfersForChainFunc.
func (mock *NexusMock) GetTransfersForChain(ctx cosmossdktypes.Context, chain exported.Chain, state exported.TransferState) []exported.CrossChainTransfer {
	if mock.GetTransfersForChainFunc == nil {
		panic("NexusMock.GetTransfersForChainFunc: method is nil but Nexus.GetTransfersForChain was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain exported.Chain
		State exported.TransferState
	}{
		Ctx:   ctx,
		Chain: chain,
		State: state,
	}
	mock.lockGetTransfersForChain.Lock()
	mock.calls.GetTransfersForChain = append(mock.calls.GetTransfersForChain, callInfo)
	mock.lockGetTransfersForChain.Unlock()
	return mock.GetTransfersForChainFunc(ctx, chain, state)
}

// GetTransfersForChainCalls gets all the calls that were made to GetTransfersForChain.
// Check the length with:
//     len(mockedNexus.GetTransfersForChainCalls())
func (mock *NexusMock) GetTransfersForChainCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain exported.Chain
	State exported.TransferState
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain exported.Chain
		State exported.TransferState
	}
	mock.lockGetTransfersForChain.RLock()
	calls = mock.calls.GetTransfersForChain
	mock.lockGetTransfersForChain.RUnlock()
	return calls
}

// IsAssetRegistered calls IsAssetRegisteredFunc.
func (mock *NexusMock) IsAssetRegistered(ctx cosmossdktypes.Context, chain exported.Chain, denom string) bool {
	if mock.IsAssetRegisteredFunc == nil {
		panic("NexusMock.IsAssetRegisteredFunc: method is nil but Nexus.IsAssetRegistered was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain exported.Chain
		Denom string
	}{
		Ctx:   ctx,
		Chain: chain,
		Denom: denom,
	}
	mock.lockIsAssetRegistered.Lock()
	mock.calls.IsAssetRegistered = append(mock.calls.IsAssetRegistered, callInfo)
	mock.lockIsAssetRegistered.Unlock()
	return mock.IsAssetRegisteredFunc(ctx, chain, denom)
}

// IsAssetRegisteredCalls gets all the calls that were made to IsAssetRegistered.
// Check the length with:
//     len(mockedNexus.IsAssetRegisteredCalls())
func (mock *NexusMock) IsAssetRegisteredCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain exported.Chain
	Denom string
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain exported.Chain
		Denom string
	}
	mock.lockIsAssetRegistered.RLock()
	calls = mock.calls.IsAssetRegistered
	mock.lockIsAssetRegistered.RUnlock()
	return calls
}

// LinkAddresses calls LinkAddressesFunc.
func (mock *NexusMock) LinkAddresses(ctx cosmossdktypes.Context, sender exported.CrossChainAddress, recipient exported.CrossChainAddress) error {
	if mock.LinkAddressesFunc == nil {
		panic("NexusMock.LinkAddressesFunc: method is nil but Nexus.LinkAddresses was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		Sender    exported.CrossChainAddress
		Recipient exported.CrossChainAddress
	}{
		Ctx:       ctx,
		Sender:    sender,
		Recipient: recipient,
	}
	mock.lockLinkAddresses.Lock()
	mock.calls.LinkAddresses = append(mock.calls.LinkAddresses, callInfo)
	mock.lockLinkAddresses.Unlock()
	return mock.LinkAddressesFunc(ctx, sender, recipient)
}

// LinkAddressesCalls gets all the calls that were made to LinkAddresses.
// Check the length with:
//     len(mockedNexus.LinkAddressesCalls())
func (mock *NexusMock) LinkAddressesCalls() []struct {
	Ctx       cosmossdktypes.Context
	Sender    exported.CrossChainAddress
	Recipient exported.CrossChainAddress
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		Sender    exported.CrossChainAddress
		Recipient exported.CrossChainAddress
	}
	mock.lockLinkAddresses.RLock()
	calls = mock.calls.LinkAddresses
	mock.lockLinkAddresses.RUnlock()
	return calls
}

// RegisterAsset calls RegisterAssetFunc.
func (mock *NexusMock) RegisterAsset(ctx cosmossdktypes.Context, chain exported.Chain, asset exported.Asset) error {
	if mock.RegisterAssetFunc == nil {
		panic("NexusMock.RegisterAssetFunc: method is nil but Nexus.RegisterAsset was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain exported.Chain
		Asset exported.Asset
	}{
		Ctx:   ctx,
		Chain: chain,
		Asset: asset,
	}
	mock.lockRegisterAsset.Lock()
	mock.calls.RegisterAsset = append(mock.calls.RegisterAsset, callInfo)
	mock.lockRegisterAsset.Unlock()
	return mock.RegisterAssetFunc(ctx, chain, asset)
}

// RegisterAssetCalls gets all the calls that were made to RegisterAsset.
// Check the length with:
//     len(mockedNexus.RegisterAssetCalls())
func (mock *NexusMock) RegisterAssetCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain exported.Chain
	Asset exported.Asset
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain exported.Chain
		Asset exported.Asset
	}
	mock.lockRegisterAsset.RLock()
	calls = mock.calls.RegisterAsset
	mock.lockRegisterAsset.RUnlock()
	return calls
}

// RegisterNativeAsset calls RegisterNativeAssetFunc.
func (mock *NexusMock) RegisterNativeAsset(ctx cosmossdktypes.Context, chain exported.Chain, nativeAsset string) error {
	if mock.RegisterNativeAssetFunc == nil {
		panic("NexusMock.RegisterNativeAssetFunc: method is nil but Nexus.RegisterNativeAsset was just called")
	}
	callInfo := struct {
		Ctx         cosmossdktypes.Context
		Chain       exported.Chain
		NativeAsset string
	}{
		Ctx:         ctx,
		Chain:       chain,
		NativeAsset: nativeAsset,
	}
	mock.lockRegisterNativeAsset.Lock()
	mock.calls.RegisterNativeAsset = append(mock.calls.RegisterNativeAsset, callInfo)
	mock.lockRegisterNativeAsset.Unlock()
	return mock.RegisterNativeAssetFunc(ctx, chain, nativeAsset)
}

// RegisterNativeAssetCalls gets all the calls that were made to RegisterNativeAsset.
// Check the length with:
//     len(mockedNexus.RegisterNativeAssetCalls())
func (mock *NexusMock) RegisterNativeAssetCalls() []struct {
	Ctx         cosmossdktypes.Context
	Chain       exported.Chain
	NativeAsset string
} {
	var calls []struct {
		Ctx         cosmossdktypes.Context
		Chain       exported.Chain
		NativeAsset string
	}
	mock.lockRegisterNativeAsset.RLock()
	calls = mock.calls.RegisterNativeAsset
	mock.lockRegisterNativeAsset.RUnlock()
	return calls
}

// SetChain calls SetChainFunc.
func (mock *NexusMock) SetChain(ctx cosmossdktypes.Context, chain exported.Chain) {
	if mock.SetChainFunc == nil {
		panic("NexusMock.SetChainFunc: method is nil but Nexus.SetChain was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Chain exported.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockSetChain.Lock()
	mock.calls.SetChain = append(mock.calls.SetChain, callInfo)
	mock.lockSetChain.Unlock()
	mock.SetChainFunc(ctx, chain)
}

// SetChainCalls gets all the calls that were made to SetChain.
// Check the length with:
//     len(mockedNexus.SetChainCalls())
func (mock *NexusMock) SetChainCalls() []struct {
	Ctx   cosmossdktypes.Context
	Chain exported.Chain
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Chain exported.Chain
	}
	mock.lockSetChain.RLock()
	calls = mock.calls.SetChain
	mock.lockSetChain.RUnlock()
	return calls
}

// SubTransferFee calls SubTransferFeeFunc.
func (mock *NexusMock) SubTransferFee(ctx cosmossdktypes.Context, coin cosmossdktypes.Coin) {
	if mock.SubTransferFeeFunc == nil {
		panic("NexusMock.SubTransferFeeFunc: method is nil but Nexus.SubTransferFee was just called")
	}
	callInfo := struct {
		Ctx  cosmossdktypes.Context
		Coin cosmossdktypes.Coin
	}{
		Ctx:  ctx,
		Coin: coin,
	}
	mock.lockSubTransferFee.Lock()
	mock.calls.SubTransferFee = append(mock.calls.SubTransferFee, callInfo)
	mock.lockSubTransferFee.Unlock()
	mock.SubTransferFeeFunc(ctx, coin)
}

// SubTransferFeeCalls gets all the calls that were made to SubTransferFee.
// Check the length with:
//     len(mockedNexus.SubTransferFeeCalls())
func (mock *NexusMock) SubTransferFeeCalls() []struct {
	Ctx  cosmossdktypes.Context
	Coin cosmossdktypes.Coin
} {
	var calls []struct {
		Ctx  cosmossdktypes.Context
		Coin cosmossdktypes.Coin
	}
	mock.lockSubTransferFee.RLock()
	calls = mock.calls.SubTransferFee
	mock.lockSubTransferFee.RUnlock()
	return calls
}

// Ensure, that BankKeeperMock does implement axelarnettypes.BankKeeper.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.BankKeeper = &BankKeeperMock{}

// BankKeeperMock is a mock implementation of axelarnettypes.BankKeeper.
//
// 	func TestSomethingThatUsesBankKeeper(t *testing.T) {
//
// 		// make and configure a mocked axelarnettypes.BankKeeper
// 		mockedBankKeeper := &BankKeeperMock{
// 			BurnCoinsFunc: func(ctx cosmossdktypes.Context, moduleName string, amt cosmossdktypes.Coins) error {
// 				panic("mock out the BurnCoins method")
// 			},
// 			GetBalanceFunc: func(ctx cosmossdktypes.Context, addr cosmossdktypes.AccAddress, denom string) cosmossdktypes.Coin {
// 				panic("mock out the GetBalance method")
// 			},
// 			MintCoinsFunc: func(ctx cosmossdktypes.Context, moduleName string, amt cosmossdktypes.Coins) error {
// 				panic("mock out the MintCoins method")
// 			},
// 			SendCoinsFunc: func(ctx cosmossdktypes.Context, fromAddr cosmossdktypes.AccAddress, toAddr cosmossdktypes.AccAddress, amt cosmossdktypes.Coins) error {
// 				panic("mock out the SendCoins method")
// 			},
// 			SendCoinsFromAccountToModuleFunc: func(ctx cosmossdktypes.Context, senderAddr cosmossdktypes.AccAddress, recipientModule string, amt cosmossdktypes.Coins) error {
// 				panic("mock out the SendCoinsFromAccountToModule method")
// 			},
// 			SendCoinsFromModuleToAccountFunc: func(ctx cosmossdktypes.Context, senderModule string, recipientAddr cosmossdktypes.AccAddress, amt cosmossdktypes.Coins) error {
// 				panic("mock out the SendCoinsFromModuleToAccount method")
// 			},
// 		}
//
// 		// use mockedBankKeeper in code that requires axelarnettypes.BankKeeper
// 		// and then make assertions.
//
// 	}
type BankKeeperMock struct {
	// BurnCoinsFunc mocks the BurnCoins method.
	BurnCoinsFunc func(ctx cosmossdktypes.Context, moduleName string, amt cosmossdktypes.Coins) error

	// GetBalanceFunc mocks the GetBalance method.
	GetBalanceFunc func(ctx cosmossdktypes.Context, addr cosmossdktypes.AccAddress, denom string) cosmossdktypes.Coin

	// MintCoinsFunc mocks the MintCoins method.
	MintCoinsFunc func(ctx cosmossdktypes.Context, moduleName string, amt cosmossdktypes.Coins) error

	// SendCoinsFunc mocks the SendCoins method.
	SendCoinsFunc func(ctx cosmossdktypes.Context, fromAddr cosmossdktypes.AccAddress, toAddr cosmossdktypes.AccAddress, amt cosmossdktypes.Coins) error

	// SendCoinsFromAccountToModuleFunc mocks the SendCoinsFromAccountToModule method.
	SendCoinsFromAccountToModuleFunc func(ctx cosmossdktypes.Context, senderAddr cosmossdktypes.AccAddress, recipientModule string, amt cosmossdktypes.Coins) error

	// SendCoinsFromModuleToAccountFunc mocks the SendCoinsFromModuleToAccount method.
	SendCoinsFromModuleToAccountFunc func(ctx cosmossdktypes.Context, senderModule string, recipientAddr cosmossdktypes.AccAddress, amt cosmossdktypes.Coins) error

	// calls tracks calls to the methods.
	calls struct {
		// BurnCoins holds details about calls to the BurnCoins method.
		BurnCoins []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ModuleName is the moduleName argument value.
			ModuleName string
			// Amt is the amt argument value.
			Amt cosmossdktypes.Coins
		}
		// GetBalance holds details about calls to the GetBalance method.
		GetBalance []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// Addr is the addr argument value.
			Addr cosmossdktypes.AccAddress
			// Denom is the denom argument value.
			Denom string
		}
		// MintCoins holds details about calls to the MintCoins method.
		MintCoins []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// ModuleName is the moduleName argument value.
			ModuleName string
			// Amt is the amt argument value.
			Amt cosmossdktypes.Coins
		}
		// SendCoins holds details about calls to the SendCoins method.
		SendCoins []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// FromAddr is the fromAddr argument value.
			FromAddr cosmossdktypes.AccAddress
			// ToAddr is the toAddr argument value.
			ToAddr cosmossdktypes.AccAddress
			// Amt is the amt argument value.
			Amt cosmossdktypes.Coins
		}
		// SendCoinsFromAccountToModule holds details about calls to the SendCoinsFromAccountToModule method.
		SendCoinsFromAccountToModule []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// SenderAddr is the senderAddr argument value.
			SenderAddr cosmossdktypes.AccAddress
			// RecipientModule is the recipientModule argument value.
			RecipientModule string
			// Amt is the amt argument value.
			Amt cosmossdktypes.Coins
		}
		// SendCoinsFromModuleToAccount holds details about calls to the SendCoinsFromModuleToAccount method.
		SendCoinsFromModuleToAccount []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// SenderModule is the senderModule argument value.
			SenderModule string
			// RecipientAddr is the recipientAddr argument value.
			RecipientAddr cosmossdktypes.AccAddress
			// Amt is the amt argument value.
			Amt cosmossdktypes.Coins
		}
	}
	lockBurnCoins                    sync.RWMutex
	lockGetBalance                   sync.RWMutex
	lockMintCoins                    sync.RWMutex
	lockSendCoins                    sync.RWMutex
	lockSendCoinsFromAccountToModule sync.RWMutex
	lockSendCoinsFromModuleToAccount sync.RWMutex
}

// BurnCoins calls BurnCoinsFunc.
func (mock *BankKeeperMock) BurnCoins(ctx cosmossdktypes.Context, moduleName string, amt cosmossdktypes.Coins) error {
	if mock.BurnCoinsFunc == nil {
		panic("BankKeeperMock.BurnCoinsFunc: method is nil but BankKeeper.BurnCoins was just called")
	}
	callInfo := struct {
		Ctx        cosmossdktypes.Context
		ModuleName string
		Amt        cosmossdktypes.Coins
	}{
		Ctx:        ctx,
		ModuleName: moduleName,
		Amt:        amt,
	}
	mock.lockBurnCoins.Lock()
	mock.calls.BurnCoins = append(mock.calls.BurnCoins, callInfo)
	mock.lockBurnCoins.Unlock()
	return mock.BurnCoinsFunc(ctx, moduleName, amt)
}

// BurnCoinsCalls gets all the calls that were made to BurnCoins.
// Check the length with:
//     len(mockedBankKeeper.BurnCoinsCalls())
func (mock *BankKeeperMock) BurnCoinsCalls() []struct {
	Ctx        cosmossdktypes.Context
	ModuleName string
	Amt        cosmossdktypes.Coins
} {
	var calls []struct {
		Ctx        cosmossdktypes.Context
		ModuleName string
		Amt        cosmossdktypes.Coins
	}
	mock.lockBurnCoins.RLock()
	calls = mock.calls.BurnCoins
	mock.lockBurnCoins.RUnlock()
	return calls
}

// GetBalance calls GetBalanceFunc.
func (mock *BankKeeperMock) GetBalance(ctx cosmossdktypes.Context, addr cosmossdktypes.AccAddress, denom string) cosmossdktypes.Coin {
	if mock.GetBalanceFunc == nil {
		panic("BankKeeperMock.GetBalanceFunc: method is nil but BankKeeper.GetBalance was just called")
	}
	callInfo := struct {
		Ctx   cosmossdktypes.Context
		Addr  cosmossdktypes.AccAddress
		Denom string
	}{
		Ctx:   ctx,
		Addr:  addr,
		Denom: denom,
	}
	mock.lockGetBalance.Lock()
	mock.calls.GetBalance = append(mock.calls.GetBalance, callInfo)
	mock.lockGetBalance.Unlock()
	return mock.GetBalanceFunc(ctx, addr, denom)
}

// GetBalanceCalls gets all the calls that were made to GetBalance.
// Check the length with:
//     len(mockedBankKeeper.GetBalanceCalls())
func (mock *BankKeeperMock) GetBalanceCalls() []struct {
	Ctx   cosmossdktypes.Context
	Addr  cosmossdktypes.AccAddress
	Denom string
} {
	var calls []struct {
		Ctx   cosmossdktypes.Context
		Addr  cosmossdktypes.AccAddress
		Denom string
	}
	mock.lockGetBalance.RLock()
	calls = mock.calls.GetBalance
	mock.lockGetBalance.RUnlock()
	return calls
}

// MintCoins calls MintCoinsFunc.
func (mock *BankKeeperMock) MintCoins(ctx cosmossdktypes.Context, moduleName string, amt cosmossdktypes.Coins) error {
	if mock.MintCoinsFunc == nil {
		panic("BankKeeperMock.MintCoinsFunc: method is nil but BankKeeper.MintCoins was just called")
	}
	callInfo := struct {
		Ctx        cosmossdktypes.Context
		ModuleName string
		Amt        cosmossdktypes.Coins
	}{
		Ctx:        ctx,
		ModuleName: moduleName,
		Amt:        amt,
	}
	mock.lockMintCoins.Lock()
	mock.calls.MintCoins = append(mock.calls.MintCoins, callInfo)
	mock.lockMintCoins.Unlock()
	return mock.MintCoinsFunc(ctx, moduleName, amt)
}

// MintCoinsCalls gets all the calls that were made to MintCoins.
// Check the length with:
//     len(mockedBankKeeper.MintCoinsCalls())
func (mock *BankKeeperMock) MintCoinsCalls() []struct {
	Ctx        cosmossdktypes.Context
	ModuleName string
	Amt        cosmossdktypes.Coins
} {
	var calls []struct {
		Ctx        cosmossdktypes.Context
		ModuleName string
		Amt        cosmossdktypes.Coins
	}
	mock.lockMintCoins.RLock()
	calls = mock.calls.MintCoins
	mock.lockMintCoins.RUnlock()
	return calls
}

// SendCoins calls SendCoinsFunc.
func (mock *BankKeeperMock) SendCoins(ctx cosmossdktypes.Context, fromAddr cosmossdktypes.AccAddress, toAddr cosmossdktypes.AccAddress, amt cosmossdktypes.Coins) error {
	if mock.SendCoinsFunc == nil {
		panic("BankKeeperMock.SendCoinsFunc: method is nil but BankKeeper.SendCoins was just called")
	}
	callInfo := struct {
		Ctx      cosmossdktypes.Context
		FromAddr cosmossdktypes.AccAddress
		ToAddr   cosmossdktypes.AccAddress
		Amt      cosmossdktypes.Coins
	}{
		Ctx:      ctx,
		FromAddr: fromAddr,
		ToAddr:   toAddr,
		Amt:      amt,
	}
	mock.lockSendCoins.Lock()
	mock.calls.SendCoins = append(mock.calls.SendCoins, callInfo)
	mock.lockSendCoins.Unlock()
	return mock.SendCoinsFunc(ctx, fromAddr, toAddr, amt)
}

// SendCoinsCalls gets all the calls that were made to SendCoins.
// Check the length with:
//     len(mockedBankKeeper.SendCoinsCalls())
func (mock *BankKeeperMock) SendCoinsCalls() []struct {
	Ctx      cosmossdktypes.Context
	FromAddr cosmossdktypes.AccAddress
	ToAddr   cosmossdktypes.AccAddress
	Amt      cosmossdktypes.Coins
} {
	var calls []struct {
		Ctx      cosmossdktypes.Context
		FromAddr cosmossdktypes.AccAddress
		ToAddr   cosmossdktypes.AccAddress
		Amt      cosmossdktypes.Coins
	}
	mock.lockSendCoins.RLock()
	calls = mock.calls.SendCoins
	mock.lockSendCoins.RUnlock()
	return calls
}

// SendCoinsFromAccountToModule calls SendCoinsFromAccountToModuleFunc.
func (mock *BankKeeperMock) SendCoinsFromAccountToModule(ctx cosmossdktypes.Context, senderAddr cosmossdktypes.AccAddress, recipientModule string, amt cosmossdktypes.Coins) error {
	if mock.SendCoinsFromAccountToModuleFunc == nil {
		panic("BankKeeperMock.SendCoinsFromAccountToModuleFunc: method is nil but BankKeeper.SendCoinsFromAccountToModule was just called")
	}
	callInfo := struct {
		Ctx             cosmossdktypes.Context
		SenderAddr      cosmossdktypes.AccAddress
		RecipientModule string
		Amt             cosmossdktypes.Coins
	}{
		Ctx:             ctx,
		SenderAddr:      senderAddr,
		RecipientModule: recipientModule,
		Amt:             amt,
	}
	mock.lockSendCoinsFromAccountToModule.Lock()
	mock.calls.SendCoinsFromAccountToModule = append(mock.calls.SendCoinsFromAccountToModule, callInfo)
	mock.lockSendCoinsFromAccountToModule.Unlock()
	return mock.SendCoinsFromAccountToModuleFunc(ctx, senderAddr, recipientModule, amt)
}

// SendCoinsFromAccountToModuleCalls gets all the calls that were made to SendCoinsFromAccountToModule.
// Check the length with:
//     len(mockedBankKeeper.SendCoinsFromAccountToModuleCalls())
func (mock *BankKeeperMock) SendCoinsFromAccountToModuleCalls() []struct {
	Ctx             cosmossdktypes.Context
	SenderAddr      cosmossdktypes.AccAddress
	RecipientModule string
	Amt             cosmossdktypes.Coins
} {
	var calls []struct {
		Ctx             cosmossdktypes.Context
		SenderAddr      cosmossdktypes.AccAddress
		RecipientModule string
		Amt             cosmossdktypes.Coins
	}
	mock.lockSendCoinsFromAccountToModule.RLock()
	calls = mock.calls.SendCoinsFromAccountToModule
	mock.lockSendCoinsFromAccountToModule.RUnlock()
	return calls
}

// SendCoinsFromModuleToAccount calls SendCoinsFromModuleToAccountFunc.
func (mock *BankKeeperMock) SendCoinsFromModuleToAccount(ctx cosmossdktypes.Context, senderModule string, recipientAddr cosmossdktypes.AccAddress, amt cosmossdktypes.Coins) error {
	if mock.SendCoinsFromModuleToAccountFunc == nil {
		panic("BankKeeperMock.SendCoinsFromModuleToAccountFunc: method is nil but BankKeeper.SendCoinsFromModuleToAccount was just called")
	}
	callInfo := struct {
		Ctx           cosmossdktypes.Context
		SenderModule  string
		RecipientAddr cosmossdktypes.AccAddress
		Amt           cosmossdktypes.Coins
	}{
		Ctx:           ctx,
		SenderModule:  senderModule,
		RecipientAddr: recipientAddr,
		Amt:           amt,
	}
	mock.lockSendCoinsFromModuleToAccount.Lock()
	mock.calls.SendCoinsFromModuleToAccount = append(mock.calls.SendCoinsFromModuleToAccount, callInfo)
	mock.lockSendCoinsFromModuleToAccount.Unlock()
	return mock.SendCoinsFromModuleToAccountFunc(ctx, senderModule, recipientAddr, amt)
}

// SendCoinsFromModuleToAccountCalls gets all the calls that were made to SendCoinsFromModuleToAccount.
// Check the length with:
//     len(mockedBankKeeper.SendCoinsFromModuleToAccountCalls())
func (mock *BankKeeperMock) SendCoinsFromModuleToAccountCalls() []struct {
	Ctx           cosmossdktypes.Context
	SenderModule  string
	RecipientAddr cosmossdktypes.AccAddress
	Amt           cosmossdktypes.Coins
} {
	var calls []struct {
		Ctx           cosmossdktypes.Context
		SenderModule  string
		RecipientAddr cosmossdktypes.AccAddress
		Amt           cosmossdktypes.Coins
	}
	mock.lockSendCoinsFromModuleToAccount.RLock()
	calls = mock.calls.SendCoinsFromModuleToAccount
	mock.lockSendCoinsFromModuleToAccount.RUnlock()
	return calls
}

// Ensure, that IBCTransferKeeperMock does implement axelarnettypes.IBCTransferKeeper.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.IBCTransferKeeper = &IBCTransferKeeperMock{}

// IBCTransferKeeperMock is a mock implementation of axelarnettypes.IBCTransferKeeper.
//
// 	func TestSomethingThatUsesIBCTransferKeeper(t *testing.T) {
//
// 		// make and configure a mocked axelarnettypes.IBCTransferKeeper
// 		mockedIBCTransferKeeper := &IBCTransferKeeperMock{
// 			GetDenomTraceFunc: func(ctx cosmossdktypes.Context, denomTraceHash tmbytes.HexBytes) (ibctypes.DenomTrace, bool) {
// 				panic("mock out the GetDenomTrace method")
// 			},
// 			SendTransferFunc: func(ctx cosmossdktypes.Context, sourcePort string, sourceChannel string, token cosmossdktypes.Coin, sender cosmossdktypes.AccAddress, receiver string, timeoutHeight clienttypes.Height, timeoutTimestamp uint64) error {
// 				panic("mock out the SendTransfer method")
// 			},
// 		}
//
// 		// use mockedIBCTransferKeeper in code that requires axelarnettypes.IBCTransferKeeper
// 		// and then make assertions.
//
// 	}
type IBCTransferKeeperMock struct {
	// GetDenomTraceFunc mocks the GetDenomTrace method.
	GetDenomTraceFunc func(ctx cosmossdktypes.Context, denomTraceHash tmbytes.HexBytes) (ibctypes.DenomTrace, bool)

	// SendTransferFunc mocks the SendTransfer method.
	SendTransferFunc func(ctx cosmossdktypes.Context, sourcePort string, sourceChannel string, token cosmossdktypes.Coin, sender cosmossdktypes.AccAddress, receiver string, timeoutHeight clienttypes.Height, timeoutTimestamp uint64) error

	// calls tracks calls to the methods.
	calls struct {
		// GetDenomTrace holds details about calls to the GetDenomTrace method.
		GetDenomTrace []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// DenomTraceHash is the denomTraceHash argument value.
			DenomTraceHash tmbytes.HexBytes
		}
		// SendTransfer holds details about calls to the SendTransfer method.
		SendTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// SourcePort is the sourcePort argument value.
			SourcePort string
			// SourceChannel is the sourceChannel argument value.
			SourceChannel string
			// Token is the token argument value.
			Token cosmossdktypes.Coin
			// Sender is the sender argument value.
			Sender cosmossdktypes.AccAddress
			// Receiver is the receiver argument value.
			Receiver string
			// TimeoutHeight is the timeoutHeight argument value.
			TimeoutHeight clienttypes.Height
			// TimeoutTimestamp is the timeoutTimestamp argument value.
			TimeoutTimestamp uint64
		}
	}
	lockGetDenomTrace sync.RWMutex
	lockSendTransfer  sync.RWMutex
}

// GetDenomTrace calls GetDenomTraceFunc.
func (mock *IBCTransferKeeperMock) GetDenomTrace(ctx cosmossdktypes.Context, denomTraceHash tmbytes.HexBytes) (ibctypes.DenomTrace, bool) {
	if mock.GetDenomTraceFunc == nil {
		panic("IBCTransferKeeperMock.GetDenomTraceFunc: method is nil but IBCTransferKeeper.GetDenomTrace was just called")
	}
	callInfo := struct {
		Ctx            cosmossdktypes.Context
		DenomTraceHash tmbytes.HexBytes
	}{
		Ctx:            ctx,
		DenomTraceHash: denomTraceHash,
	}
	mock.lockGetDenomTrace.Lock()
	mock.calls.GetDenomTrace = append(mock.calls.GetDenomTrace, callInfo)
	mock.lockGetDenomTrace.Unlock()
	return mock.GetDenomTraceFunc(ctx, denomTraceHash)
}

// GetDenomTraceCalls gets all the calls that were made to GetDenomTrace.
// Check the length with:
//     len(mockedIBCTransferKeeper.GetDenomTraceCalls())
func (mock *IBCTransferKeeperMock) GetDenomTraceCalls() []struct {
	Ctx            cosmossdktypes.Context
	DenomTraceHash tmbytes.HexBytes
} {
	var calls []struct {
		Ctx            cosmossdktypes.Context
		DenomTraceHash tmbytes.HexBytes
	}
	mock.lockGetDenomTrace.RLock()
	calls = mock.calls.GetDenomTrace
	mock.lockGetDenomTrace.RUnlock()
	return calls
}

// SendTransfer calls SendTransferFunc.
func (mock *IBCTransferKeeperMock) SendTransfer(ctx cosmossdktypes.Context, sourcePort string, sourceChannel string, token cosmossdktypes.Coin, sender cosmossdktypes.AccAddress, receiver string, timeoutHeight clienttypes.Height, timeoutTimestamp uint64) error {
	if mock.SendTransferFunc == nil {
		panic("IBCTransferKeeperMock.SendTransferFunc: method is nil but IBCTransferKeeper.SendTransfer was just called")
	}
	callInfo := struct {
		Ctx              cosmossdktypes.Context
		SourcePort       string
		SourceChannel    string
		Token            cosmossdktypes.Coin
		Sender           cosmossdktypes.AccAddress
		Receiver         string
		TimeoutHeight    clienttypes.Height
		TimeoutTimestamp uint64
	}{
		Ctx:              ctx,
		SourcePort:       sourcePort,
		SourceChannel:    sourceChannel,
		Token:            token,
		Sender:           sender,
		Receiver:         receiver,
		TimeoutHeight:    timeoutHeight,
		TimeoutTimestamp: timeoutTimestamp,
	}
	mock.lockSendTransfer.Lock()
	mock.calls.SendTransfer = append(mock.calls.SendTransfer, callInfo)
	mock.lockSendTransfer.Unlock()
	return mock.SendTransferFunc(ctx, sourcePort, sourceChannel, token, sender, receiver, timeoutHeight, timeoutTimestamp)
}

// SendTransferCalls gets all the calls that were made to SendTransfer.
// Check the length with:
//     len(mockedIBCTransferKeeper.SendTransferCalls())
func (mock *IBCTransferKeeperMock) SendTransferCalls() []struct {
	Ctx              cosmossdktypes.Context
	SourcePort       string
	SourceChannel    string
	Token            cosmossdktypes.Coin
	Sender           cosmossdktypes.AccAddress
	Receiver         string
	TimeoutHeight    clienttypes.Height
	TimeoutTimestamp uint64
} {
	var calls []struct {
		Ctx              cosmossdktypes.Context
		SourcePort       string
		SourceChannel    string
		Token            cosmossdktypes.Coin
		Sender           cosmossdktypes.AccAddress
		Receiver         string
		TimeoutHeight    clienttypes.Height
		TimeoutTimestamp uint64
	}
	mock.lockSendTransfer.RLock()
	calls = mock.calls.SendTransfer
	mock.lockSendTransfer.RUnlock()
	return calls
}

// Ensure, that ChannelKeeperMock does implement axelarnettypes.ChannelKeeper.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.ChannelKeeper = &ChannelKeeperMock{}

// ChannelKeeperMock is a mock implementation of axelarnettypes.ChannelKeeper.
//
// 	func TestSomethingThatUsesChannelKeeper(t *testing.T) {
//
// 		// make and configure a mocked axelarnettypes.ChannelKeeper
// 		mockedChannelKeeper := &ChannelKeeperMock{
// 			GetChannelClientStateFunc: func(ctx cosmossdktypes.Context, portID string, channelID string) (string, ibcclient.ClientState, error) {
// 				panic("mock out the GetChannelClientState method")
// 			},
// 			GetNextSequenceSendFunc: func(ctx cosmossdktypes.Context, portID string, channelID string) (uint64, bool) {
// 				panic("mock out the GetNextSequenceSend method")
// 			},
// 		}
//
// 		// use mockedChannelKeeper in code that requires axelarnettypes.ChannelKeeper
// 		// and then make assertions.
//
// 	}
type ChannelKeeperMock struct {
	// GetChannelClientStateFunc mocks the GetChannelClientState method.
	GetChannelClientStateFunc func(ctx cosmossdktypes.Context, portID string, channelID string) (string, ibcclient.ClientState, error)

	// GetNextSequenceSendFunc mocks the GetNextSequenceSend method.
	GetNextSequenceSendFunc func(ctx cosmossdktypes.Context, portID string, channelID string) (uint64, bool)

	// calls tracks calls to the methods.
	calls struct {
		// GetChannelClientState holds details about calls to the GetChannelClientState method.
		GetChannelClientState []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// PortID is the portID argument value.
			PortID string
			// ChannelID is the channelID argument value.
			ChannelID string
		}
		// GetNextSequenceSend holds details about calls to the GetNextSequenceSend method.
		GetNextSequenceSend []struct {
			// Ctx is the ctx argument value.
			Ctx cosmossdktypes.Context
			// PortID is the portID argument value.
			PortID string
			// ChannelID is the channelID argument value.
			ChannelID string
		}
	}
	lockGetChannelClientState sync.RWMutex
	lockGetNextSequenceSend   sync.RWMutex
}

// GetChannelClientState calls GetChannelClientStateFunc.
func (mock *ChannelKeeperMock) GetChannelClientState(ctx cosmossdktypes.Context, portID string, channelID string) (string, ibcclient.ClientState, error) {
	if mock.GetChannelClientStateFunc == nil {
		panic("ChannelKeeperMock.GetChannelClientStateFunc: method is nil but ChannelKeeper.GetChannelClientState was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		PortID    string
		ChannelID string
	}{
		Ctx:       ctx,
		PortID:    portID,
		ChannelID: channelID,
	}
	mock.lockGetChannelClientState.Lock()
	mock.calls.GetChannelClientState = append(mock.calls.GetChannelClientState, callInfo)
	mock.lockGetChannelClientState.Unlock()
	return mock.GetChannelClientStateFunc(ctx, portID, channelID)
}

// GetChannelClientStateCalls gets all the calls that were made to GetChannelClientState.
// Check the length with:
//     len(mockedChannelKeeper.GetChannelClientStateCalls())
func (mock *ChannelKeeperMock) GetChannelClientStateCalls() []struct {
	Ctx       cosmossdktypes.Context
	PortID    string
	ChannelID string
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		PortID    string
		ChannelID string
	}
	mock.lockGetChannelClientState.RLock()
	calls = mock.calls.GetChannelClientState
	mock.lockGetChannelClientState.RUnlock()
	return calls
}

// GetNextSequenceSend calls GetNextSequenceSendFunc.
func (mock *ChannelKeeperMock) GetNextSequenceSend(ctx cosmossdktypes.Context, portID string, channelID string) (uint64, bool) {
	if mock.GetNextSequenceSendFunc == nil {
		panic("ChannelKeeperMock.GetNextSequenceSendFunc: method is nil but ChannelKeeper.GetNextSequenceSend was just called")
	}
	callInfo := struct {
		Ctx       cosmossdktypes.Context
		PortID    string
		ChannelID string
	}{
		Ctx:       ctx,
		PortID:    portID,
		ChannelID: channelID,
	}
	mock.lockGetNextSequenceSend.Lock()
	mock.calls.GetNextSequenceSend = append(mock.calls.GetNextSequenceSend, callInfo)
	mock.lockGetNextSequenceSend.Unlock()
	return mock.GetNextSequenceSendFunc(ctx, portID, channelID)
}

// GetNextSequenceSendCalls gets all the calls that were made to GetNextSequenceSend.
// Check the length with:
//     len(mockedChannelKeeper.GetNextSequenceSendCalls())
func (mock *ChannelKeeperMock) GetNextSequenceSendCalls() []struct {
	Ctx       cosmossdktypes.Context
	PortID    string
	ChannelID string
} {
	var calls []struct {
		Ctx       cosmossdktypes.Context
		PortID    string
		ChannelID string
	}
	mock.lockGetNextSequenceSend.RLock()
	calls = mock.calls.GetNextSequenceSend
	mock.lockGetNextSequenceSend.RUnlock()
	return calls
}

// Ensure, that AccountKeeperMock does implement axelarnettypes.AccountKeeper.
// If this is not the case, regenerate this file with moq.
var _ axelarnettypes.AccountKeeper = &AccountKeeperMock{}

// AccountKeeperMock is a mock implementation of axelarnettypes.AccountKeeper.
//
// 	func TestSomethingThatUsesAccountKeeper(t *testing.T) {
//
// 		// make and configure a mocked axelarnettypes.AccountKeeper
// 		mockedAccountKeeper := &AccountKeeperMock{
// 			GetModuleAddressFunc: func(moduleName string) cosmossdktypes.AccAddress {
// 				panic("mock out the GetModuleAddress method")
// 			},
// 		}
//
// 		// use mockedAccountKeeper in code that requires axelarnettypes.AccountKeeper
// 		// and then make assertions.
//
// 	}
type AccountKeeperMock struct {
	// GetModuleAddressFunc mocks the GetModuleAddress method.
	GetModuleAddressFunc func(moduleName string) cosmossdktypes.AccAddress

	// calls tracks calls to the methods.
	calls struct {
		// GetModuleAddress holds details about calls to the GetModuleAddress method.
		GetModuleAddress []struct {
			// ModuleName is the moduleName argument value.
			ModuleName string
		}
	}
	lockGetModuleAddress sync.RWMutex
}

// GetModuleAddress calls GetModuleAddressFunc.
func (mock *AccountKeeperMock) GetModuleAddress(moduleName string) cosmossdktypes.AccAddress {
	if mock.GetModuleAddressFunc == nil {
		panic("AccountKeeperMock.GetModuleAddressFunc: method is nil but AccountKeeper.GetModuleAddress was just called")
	}
	callInfo := struct {
		ModuleName string
	}{
		ModuleName: moduleName,
	}
	mock.lockGetModuleAddress.Lock()
	mock.calls.GetModuleAddress = append(mock.calls.GetModuleAddress, callInfo)
	mock.lockGetModuleAddress.Unlock()
	return mock.GetModuleAddressFunc(moduleName)
}

// GetModuleAddressCalls gets all the calls that were made to GetModuleAddress.
// Check the length with:
//     len(mockedAccountKeeper.GetModuleAddressCalls())
func (mock *AccountKeeperMock) GetModuleAddressCalls() []struct {
	ModuleName string
} {
	var calls []struct {
		ModuleName string
	}
	mock.lockGetModuleAddress.RLock()
	calls = mock.calls.GetModuleAddress
	mock.lockGetModuleAddress.RUnlock()
	return calls
}
