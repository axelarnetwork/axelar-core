// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	sdk "github.com/cosmos/cosmos-sdk/types"
	"sync"
)

// Ensure, that TxMock does implement Tx.
// If this is not the case, regenerate this file with moq.
var _ Tx = &TxMock{}

// TxMock is a mock implementation of Tx.
//
//	func TestSomethingThatUsesTx(t *testing.T) {
//
//		// make and configure a mocked Tx
//		mockedTx := &TxMock{
//			GetMsgsFunc: func() []sdk.Msg {
//				panic("mock out the GetMsgs method")
//			},
//			ValidateBasicFunc: func() error {
//				panic("mock out the ValidateBasic method")
//			},
//		}
//
//		// use mockedTx in code that requires Tx
//		// and then make assertions.
//
//	}
type TxMock struct {
	// GetMsgsFunc mocks the GetMsgs method.
	GetMsgsFunc func() []sdk.Msg

	// ValidateBasicFunc mocks the ValidateBasic method.
	ValidateBasicFunc func() error

	// calls tracks calls to the methods.
	calls struct {
		// GetMsgs holds details about calls to the GetMsgs method.
		GetMsgs []struct {
		}
		// ValidateBasic holds details about calls to the ValidateBasic method.
		ValidateBasic []struct {
		}
	}
	lockGetMsgs       sync.RWMutex
	lockValidateBasic sync.RWMutex
}

// GetMsgs calls GetMsgsFunc.
func (mock *TxMock) GetMsgs() []sdk.Msg {
	if mock.GetMsgsFunc == nil {
		panic("TxMock.GetMsgsFunc: method is nil but Tx.GetMsgs was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetMsgs.Lock()
	mock.calls.GetMsgs = append(mock.calls.GetMsgs, callInfo)
	mock.lockGetMsgs.Unlock()
	return mock.GetMsgsFunc()
}

// GetMsgsCalls gets all the calls that were made to GetMsgs.
// Check the length with:
//
//	len(mockedTx.GetMsgsCalls())
func (mock *TxMock) GetMsgsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetMsgs.RLock()
	calls = mock.calls.GetMsgs
	mock.lockGetMsgs.RUnlock()
	return calls
}

// ValidateBasic calls ValidateBasicFunc.
func (mock *TxMock) ValidateBasic() error {
	if mock.ValidateBasicFunc == nil {
		panic("TxMock.ValidateBasicFunc: method is nil but Tx.ValidateBasic was just called")
	}
	callInfo := struct {
	}{}
	mock.lockValidateBasic.Lock()
	mock.calls.ValidateBasic = append(mock.calls.ValidateBasic, callInfo)
	mock.lockValidateBasic.Unlock()
	return mock.ValidateBasicFunc()
}

// ValidateBasicCalls gets all the calls that were made to ValidateBasic.
// Check the length with:
//
//	len(mockedTx.ValidateBasicCalls())
func (mock *TxMock) ValidateBasicCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockValidateBasic.RLock()
	calls = mock.calls.ValidateBasic
	mock.lockValidateBasic.RUnlock()
	return calls
}

// Ensure, that MsgMock does implement Msg.
// If this is not the case, regenerate this file with moq.
var _ Msg = &MsgMock{}

// MsgMock is a mock implementation of Msg.
//
//	func TestSomethingThatUsesMsg(t *testing.T) {
//
//		// make and configure a mocked Msg
//		mockedMsg := &MsgMock{
//			DescriptorFunc: func() ([]byte, []int) {
//				panic("mock out the Descriptor method")
//			},
//			GetSignersFunc: func() []sdk.AccAddress {
//				panic("mock out the GetSigners method")
//			},
//			ProtoMessageFunc: func()  {
//				panic("mock out the ProtoMessage method")
//			},
//			ResetFunc: func()  {
//				panic("mock out the Reset method")
//			},
//			StringFunc: func() string {
//				panic("mock out the String method")
//			},
//			ValidateBasicFunc: func() error {
//				panic("mock out the ValidateBasic method")
//			},
//		}
//
//		// use mockedMsg in code that requires Msg
//		// and then make assertions.
//
//	}
type MsgMock struct {
	// DescriptorFunc mocks the Descriptor method.
	DescriptorFunc func() ([]byte, []int)

	// GetSignersFunc mocks the GetSigners method.
	GetSignersFunc func() []sdk.AccAddress

	// ProtoMessageFunc mocks the ProtoMessage method.
	ProtoMessageFunc func()

	// ResetFunc mocks the Reset method.
	ResetFunc func()

	// StringFunc mocks the String method.
	StringFunc func() string

	// ValidateBasicFunc mocks the ValidateBasic method.
	ValidateBasicFunc func() error

	// calls tracks calls to the methods.
	calls struct {
		// Descriptor holds details about calls to the Descriptor method.
		Descriptor []struct {
		}
		// GetSigners holds details about calls to the GetSigners method.
		GetSigners []struct {
		}
		// ProtoMessage holds details about calls to the ProtoMessage method.
		ProtoMessage []struct {
		}
		// Reset holds details about calls to the Reset method.
		Reset []struct {
		}
		// String holds details about calls to the String method.
		String []struct {
		}
		// ValidateBasic holds details about calls to the ValidateBasic method.
		ValidateBasic []struct {
		}
	}
	lockDescriptor    sync.RWMutex
	lockGetSigners    sync.RWMutex
	lockProtoMessage  sync.RWMutex
	lockReset         sync.RWMutex
	lockString        sync.RWMutex
	lockValidateBasic sync.RWMutex
}

// Descriptor calls DescriptorFunc.
func (mock *MsgMock) Descriptor() ([]byte, []int) {
	if mock.DescriptorFunc == nil {
		panic("MsgMock.DescriptorFunc: method is nil but Msg.Descriptor was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDescriptor.Lock()
	mock.calls.Descriptor = append(mock.calls.Descriptor, callInfo)
	mock.lockDescriptor.Unlock()
	return mock.DescriptorFunc()
}

// DescriptorCalls gets all the calls that were made to Descriptor.
// Check the length with:
//
//	len(mockedMsg.DescriptorCalls())
func (mock *MsgMock) DescriptorCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDescriptor.RLock()
	calls = mock.calls.Descriptor
	mock.lockDescriptor.RUnlock()
	return calls
}

// GetSigners calls GetSignersFunc.
func (mock *MsgMock) GetSigners() []sdk.AccAddress {
	if mock.GetSignersFunc == nil {
		panic("MsgMock.GetSignersFunc: method is nil but Msg.GetSigners was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetSigners.Lock()
	mock.calls.GetSigners = append(mock.calls.GetSigners, callInfo)
	mock.lockGetSigners.Unlock()
	return mock.GetSignersFunc()
}

// GetSignersCalls gets all the calls that were made to GetSigners.
// Check the length with:
//
//	len(mockedMsg.GetSignersCalls())
func (mock *MsgMock) GetSignersCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetSigners.RLock()
	calls = mock.calls.GetSigners
	mock.lockGetSigners.RUnlock()
	return calls
}

// ProtoMessage calls ProtoMessageFunc.
func (mock *MsgMock) ProtoMessage() {
	if mock.ProtoMessageFunc == nil {
		panic("MsgMock.ProtoMessageFunc: method is nil but Msg.ProtoMessage was just called")
	}
	callInfo := struct {
	}{}
	mock.lockProtoMessage.Lock()
	mock.calls.ProtoMessage = append(mock.calls.ProtoMessage, callInfo)
	mock.lockProtoMessage.Unlock()
	mock.ProtoMessageFunc()
}

// ProtoMessageCalls gets all the calls that were made to ProtoMessage.
// Check the length with:
//
//	len(mockedMsg.ProtoMessageCalls())
func (mock *MsgMock) ProtoMessageCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockProtoMessage.RLock()
	calls = mock.calls.ProtoMessage
	mock.lockProtoMessage.RUnlock()
	return calls
}

// Reset calls ResetFunc.
func (mock *MsgMock) Reset() {
	if mock.ResetFunc == nil {
		panic("MsgMock.ResetFunc: method is nil but Msg.Reset was just called")
	}
	callInfo := struct {
	}{}
	mock.lockReset.Lock()
	mock.calls.Reset = append(mock.calls.Reset, callInfo)
	mock.lockReset.Unlock()
	mock.ResetFunc()
}

// ResetCalls gets all the calls that were made to Reset.
// Check the length with:
//
//	len(mockedMsg.ResetCalls())
func (mock *MsgMock) ResetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockReset.RLock()
	calls = mock.calls.Reset
	mock.lockReset.RUnlock()
	return calls
}

// String calls StringFunc.
func (mock *MsgMock) String() string {
	if mock.StringFunc == nil {
		panic("MsgMock.StringFunc: method is nil but Msg.String was just called")
	}
	callInfo := struct {
	}{}
	mock.lockString.Lock()
	mock.calls.String = append(mock.calls.String, callInfo)
	mock.lockString.Unlock()
	return mock.StringFunc()
}

// StringCalls gets all the calls that were made to String.
// Check the length with:
//
//	len(mockedMsg.StringCalls())
func (mock *MsgMock) StringCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockString.RLock()
	calls = mock.calls.String
	mock.lockString.RUnlock()
	return calls
}

// ValidateBasic calls ValidateBasicFunc.
func (mock *MsgMock) ValidateBasic() error {
	if mock.ValidateBasicFunc == nil {
		panic("MsgMock.ValidateBasicFunc: method is nil but Msg.ValidateBasic was just called")
	}
	callInfo := struct {
	}{}
	mock.lockValidateBasic.Lock()
	mock.calls.ValidateBasic = append(mock.calls.ValidateBasic, callInfo)
	mock.lockValidateBasic.Unlock()
	return mock.ValidateBasicFunc()
}

// ValidateBasicCalls gets all the calls that were made to ValidateBasic.
// Check the length with:
//
//	len(mockedMsg.ValidateBasicCalls())
func (mock *MsgMock) ValidateBasicCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockValidateBasic.RLock()
	calls = mock.calls.ValidateBasic
	mock.lockValidateBasic.RUnlock()
	return calls
}
