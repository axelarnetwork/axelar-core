// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	sdk "github.com/cosmos/cosmos-sdk/types"
	"sync"
)

// Ensure, that TxMock does implement Tx.
// If this is not the case, regenerate this file with moq.
var _ Tx = &TxMock{}

// TxMock is a mock implementation of Tx.
//
//	func TestSomethingThatUsesTx(t *testing.T) {
//
//		// make and configure a mocked Tx
//		mockedTx := &TxMock{
//			GetMsgsFunc: func() []sdk.Msg {
//				panic("mock out the GetMsgs method")
//			},
//			ValidateBasicFunc: func() error {
//				panic("mock out the ValidateBasic method")
//			},
//		}
//
//		// use mockedTx in code that requires Tx
//		// and then make assertions.
//
//	}
type TxMock struct {
	// GetMsgsFunc mocks the GetMsgs method.
	GetMsgsFunc func() []sdk.Msg

	// ValidateBasicFunc mocks the ValidateBasic method.
	ValidateBasicFunc func() error

	// calls tracks calls to the methods.
	calls struct {
		// GetMsgs holds details about calls to the GetMsgs method.
		GetMsgs []struct {
		}
		// ValidateBasic holds details about calls to the ValidateBasic method.
		ValidateBasic []struct {
		}
	}
	lockGetMsgs       sync.RWMutex
	lockValidateBasic sync.RWMutex
}

// GetMsgs calls GetMsgsFunc.
func (mock *TxMock) GetMsgs() []sdk.Msg {
	if mock.GetMsgsFunc == nil {
		panic("TxMock.GetMsgsFunc: method is nil but Tx.GetMsgs was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetMsgs.Lock()
	mock.calls.GetMsgs = append(mock.calls.GetMsgs, callInfo)
	mock.lockGetMsgs.Unlock()
	return mock.GetMsgsFunc()
}

// GetMsgsCalls gets all the calls that were made to GetMsgs.
// Check the length with:
//
//	len(mockedTx.GetMsgsCalls())
func (mock *TxMock) GetMsgsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetMsgs.RLock()
	calls = mock.calls.GetMsgs
	mock.lockGetMsgs.RUnlock()
	return calls
}

// ValidateBasic calls ValidateBasicFunc.
func (mock *TxMock) ValidateBasic() error {
	if mock.ValidateBasicFunc == nil {
		panic("TxMock.ValidateBasicFunc: method is nil but Tx.ValidateBasic was just called")
	}
	callInfo := struct {
	}{}
	mock.lockValidateBasic.Lock()
	mock.calls.ValidateBasic = append(mock.calls.ValidateBasic, callInfo)
	mock.lockValidateBasic.Unlock()
	return mock.ValidateBasicFunc()
}

// ValidateBasicCalls gets all the calls that were made to ValidateBasic.
// Check the length with:
//
//	len(mockedTx.ValidateBasicCalls())
func (mock *TxMock) ValidateBasicCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockValidateBasic.RLock()
	calls = mock.calls.ValidateBasic
	mock.lockValidateBasic.RUnlock()
	return calls
}

// Ensure, that FeeTxMock does implement FeeTx.
// If this is not the case, regenerate this file with moq.
var _ FeeTx = &FeeTxMock{}

// FeeTxMock is a mock implementation of FeeTx.
//
//	func TestSomethingThatUsesFeeTx(t *testing.T) {
//
//		// make and configure a mocked FeeTx
//		mockedFeeTx := &FeeTxMock{
//			FeeGranterFunc: func() sdk.AccAddress {
//				panic("mock out the FeeGranter method")
//			},
//			FeePayerFunc: func() sdk.AccAddress {
//				panic("mock out the FeePayer method")
//			},
//			GetFeeFunc: func() sdk.Coins {
//				panic("mock out the GetFee method")
//			},
//			GetGasFunc: func() uint64 {
//				panic("mock out the GetGas method")
//			},
//			GetMsgsFunc: func() []sdk.Msg {
//				panic("mock out the GetMsgs method")
//			},
//			ValidateBasicFunc: func() error {
//				panic("mock out the ValidateBasic method")
//			},
//		}
//
//		// use mockedFeeTx in code that requires FeeTx
//		// and then make assertions.
//
//	}
type FeeTxMock struct {
	// FeeGranterFunc mocks the FeeGranter method.
	FeeGranterFunc func() sdk.AccAddress

	// FeePayerFunc mocks the FeePayer method.
	FeePayerFunc func() sdk.AccAddress

	// GetFeeFunc mocks the GetFee method.
	GetFeeFunc func() sdk.Coins

	// GetGasFunc mocks the GetGas method.
	GetGasFunc func() uint64

	// GetMsgsFunc mocks the GetMsgs method.
	GetMsgsFunc func() []sdk.Msg

	// ValidateBasicFunc mocks the ValidateBasic method.
	ValidateBasicFunc func() error

	// calls tracks calls to the methods.
	calls struct {
		// FeeGranter holds details about calls to the FeeGranter method.
		FeeGranter []struct {
		}
		// FeePayer holds details about calls to the FeePayer method.
		FeePayer []struct {
		}
		// GetFee holds details about calls to the GetFee method.
		GetFee []struct {
		}
		// GetGas holds details about calls to the GetGas method.
		GetGas []struct {
		}
		// GetMsgs holds details about calls to the GetMsgs method.
		GetMsgs []struct {
		}
		// ValidateBasic holds details about calls to the ValidateBasic method.
		ValidateBasic []struct {
		}
	}
	lockFeeGranter    sync.RWMutex
	lockFeePayer      sync.RWMutex
	lockGetFee        sync.RWMutex
	lockGetGas        sync.RWMutex
	lockGetMsgs       sync.RWMutex
	lockValidateBasic sync.RWMutex
}

// FeeGranter calls FeeGranterFunc.
func (mock *FeeTxMock) FeeGranter() sdk.AccAddress {
	if mock.FeeGranterFunc == nil {
		panic("FeeTxMock.FeeGranterFunc: method is nil but FeeTx.FeeGranter was just called")
	}
	callInfo := struct {
	}{}
	mock.lockFeeGranter.Lock()
	mock.calls.FeeGranter = append(mock.calls.FeeGranter, callInfo)
	mock.lockFeeGranter.Unlock()
	return mock.FeeGranterFunc()
}

// FeeGranterCalls gets all the calls that were made to FeeGranter.
// Check the length with:
//
//	len(mockedFeeTx.FeeGranterCalls())
func (mock *FeeTxMock) FeeGranterCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockFeeGranter.RLock()
	calls = mock.calls.FeeGranter
	mock.lockFeeGranter.RUnlock()
	return calls
}

// FeePayer calls FeePayerFunc.
func (mock *FeeTxMock) FeePayer() sdk.AccAddress {
	if mock.FeePayerFunc == nil {
		panic("FeeTxMock.FeePayerFunc: method is nil but FeeTx.FeePayer was just called")
	}
	callInfo := struct {
	}{}
	mock.lockFeePayer.Lock()
	mock.calls.FeePayer = append(mock.calls.FeePayer, callInfo)
	mock.lockFeePayer.Unlock()
	return mock.FeePayerFunc()
}

// FeePayerCalls gets all the calls that were made to FeePayer.
// Check the length with:
//
//	len(mockedFeeTx.FeePayerCalls())
func (mock *FeeTxMock) FeePayerCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockFeePayer.RLock()
	calls = mock.calls.FeePayer
	mock.lockFeePayer.RUnlock()
	return calls
}

// GetFee calls GetFeeFunc.
func (mock *FeeTxMock) GetFee() sdk.Coins {
	if mock.GetFeeFunc == nil {
		panic("FeeTxMock.GetFeeFunc: method is nil but FeeTx.GetFee was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetFee.Lock()
	mock.calls.GetFee = append(mock.calls.GetFee, callInfo)
	mock.lockGetFee.Unlock()
	return mock.GetFeeFunc()
}

// GetFeeCalls gets all the calls that were made to GetFee.
// Check the length with:
//
//	len(mockedFeeTx.GetFeeCalls())
func (mock *FeeTxMock) GetFeeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetFee.RLock()
	calls = mock.calls.GetFee
	mock.lockGetFee.RUnlock()
	return calls
}

// GetGas calls GetGasFunc.
func (mock *FeeTxMock) GetGas() uint64 {
	if mock.GetGasFunc == nil {
		panic("FeeTxMock.GetGasFunc: method is nil but FeeTx.GetGas was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetGas.Lock()
	mock.calls.GetGas = append(mock.calls.GetGas, callInfo)
	mock.lockGetGas.Unlock()
	return mock.GetGasFunc()
}

// GetGasCalls gets all the calls that were made to GetGas.
// Check the length with:
//
//	len(mockedFeeTx.GetGasCalls())
func (mock *FeeTxMock) GetGasCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetGas.RLock()
	calls = mock.calls.GetGas
	mock.lockGetGas.RUnlock()
	return calls
}

// GetMsgs calls GetMsgsFunc.
func (mock *FeeTxMock) GetMsgs() []sdk.Msg {
	if mock.GetMsgsFunc == nil {
		panic("FeeTxMock.GetMsgsFunc: method is nil but FeeTx.GetMsgs was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetMsgs.Lock()
	mock.calls.GetMsgs = append(mock.calls.GetMsgs, callInfo)
	mock.lockGetMsgs.Unlock()
	return mock.GetMsgsFunc()
}

// GetMsgsCalls gets all the calls that were made to GetMsgs.
// Check the length with:
//
//	len(mockedFeeTx.GetMsgsCalls())
func (mock *FeeTxMock) GetMsgsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetMsgs.RLock()
	calls = mock.calls.GetMsgs
	mock.lockGetMsgs.RUnlock()
	return calls
}

// ValidateBasic calls ValidateBasicFunc.
func (mock *FeeTxMock) ValidateBasic() error {
	if mock.ValidateBasicFunc == nil {
		panic("FeeTxMock.ValidateBasicFunc: method is nil but FeeTx.ValidateBasic was just called")
	}
	callInfo := struct {
	}{}
	mock.lockValidateBasic.Lock()
	mock.calls.ValidateBasic = append(mock.calls.ValidateBasic, callInfo)
	mock.lockValidateBasic.Unlock()
	return mock.ValidateBasicFunc()
}

// ValidateBasicCalls gets all the calls that were made to ValidateBasic.
// Check the length with:
//
//	len(mockedFeeTx.ValidateBasicCalls())
func (mock *FeeTxMock) ValidateBasicCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockValidateBasic.RLock()
	calls = mock.calls.ValidateBasic
	mock.lockValidateBasic.RUnlock()
	return calls
}

// Ensure, that MsgMock does implement Msg.
// If this is not the case, regenerate this file with moq.
var _ Msg = &MsgMock{}

// MsgMock is a mock implementation of Msg.
//
//	func TestSomethingThatUsesMsg(t *testing.T) {
//
//		// make and configure a mocked Msg
//		mockedMsg := &MsgMock{
//			DescriptorFunc: func() ([]byte, []int) {
//				panic("mock out the Descriptor method")
//			},
//			GetSignersFunc: func() []sdk.AccAddress {
//				panic("mock out the GetSigners method")
//			},
//			ProtoMessageFunc: func()  {
//				panic("mock out the ProtoMessage method")
//			},
//			ResetFunc: func()  {
//				panic("mock out the Reset method")
//			},
//			StringFunc: func() string {
//				panic("mock out the String method")
//			},
//			ValidateBasicFunc: func() error {
//				panic("mock out the ValidateBasic method")
//			},
//		}
//
//		// use mockedMsg in code that requires Msg
//		// and then make assertions.
//
//	}
type MsgMock struct {
	// DescriptorFunc mocks the Descriptor method.
	DescriptorFunc func() ([]byte, []int)

	// GetSignersFunc mocks the GetSigners method.
	GetSignersFunc func() []sdk.AccAddress

	// ProtoMessageFunc mocks the ProtoMessage method.
	ProtoMessageFunc func()

	// ResetFunc mocks the Reset method.
	ResetFunc func()

	// StringFunc mocks the String method.
	StringFunc func() string

	// ValidateBasicFunc mocks the ValidateBasic method.
	ValidateBasicFunc func() error

	// calls tracks calls to the methods.
	calls struct {
		// Descriptor holds details about calls to the Descriptor method.
		Descriptor []struct {
		}
		// GetSigners holds details about calls to the GetSigners method.
		GetSigners []struct {
		}
		// ProtoMessage holds details about calls to the ProtoMessage method.
		ProtoMessage []struct {
		}
		// Reset holds details about calls to the Reset method.
		Reset []struct {
		}
		// String holds details about calls to the String method.
		String []struct {
		}
		// ValidateBasic holds details about calls to the ValidateBasic method.
		ValidateBasic []struct {
		}
	}
	lockDescriptor    sync.RWMutex
	lockGetSigners    sync.RWMutex
	lockProtoMessage  sync.RWMutex
	lockReset         sync.RWMutex
	lockString        sync.RWMutex
	lockValidateBasic sync.RWMutex
}

// Descriptor calls DescriptorFunc.
func (mock *MsgMock) Descriptor() ([]byte, []int) {
	if mock.DescriptorFunc == nil {
		panic("MsgMock.DescriptorFunc: method is nil but Msg.Descriptor was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDescriptor.Lock()
	mock.calls.Descriptor = append(mock.calls.Descriptor, callInfo)
	mock.lockDescriptor.Unlock()
	return mock.DescriptorFunc()
}

// DescriptorCalls gets all the calls that were made to Descriptor.
// Check the length with:
//
//	len(mockedMsg.DescriptorCalls())
func (mock *MsgMock) DescriptorCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDescriptor.RLock()
	calls = mock.calls.Descriptor
	mock.lockDescriptor.RUnlock()
	return calls
}

// GetSigners calls GetSignersFunc.
func (mock *MsgMock) GetSigners() []sdk.AccAddress {
	if mock.GetSignersFunc == nil {
		panic("MsgMock.GetSignersFunc: method is nil but Msg.GetSigners was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetSigners.Lock()
	mock.calls.GetSigners = append(mock.calls.GetSigners, callInfo)
	mock.lockGetSigners.Unlock()
	return mock.GetSignersFunc()
}

// GetSignersCalls gets all the calls that were made to GetSigners.
// Check the length with:
//
//	len(mockedMsg.GetSignersCalls())
func (mock *MsgMock) GetSignersCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetSigners.RLock()
	calls = mock.calls.GetSigners
	mock.lockGetSigners.RUnlock()
	return calls
}

// ProtoMessage calls ProtoMessageFunc.
func (mock *MsgMock) ProtoMessage() {
	if mock.ProtoMessageFunc == nil {
		panic("MsgMock.ProtoMessageFunc: method is nil but Msg.ProtoMessage was just called")
	}
	callInfo := struct {
	}{}
	mock.lockProtoMessage.Lock()
	mock.calls.ProtoMessage = append(mock.calls.ProtoMessage, callInfo)
	mock.lockProtoMessage.Unlock()
	mock.ProtoMessageFunc()
}

// ProtoMessageCalls gets all the calls that were made to ProtoMessage.
// Check the length with:
//
//	len(mockedMsg.ProtoMessageCalls())
func (mock *MsgMock) ProtoMessageCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockProtoMessage.RLock()
	calls = mock.calls.ProtoMessage
	mock.lockProtoMessage.RUnlock()
	return calls
}

// Reset calls ResetFunc.
func (mock *MsgMock) Reset() {
	if mock.ResetFunc == nil {
		panic("MsgMock.ResetFunc: method is nil but Msg.Reset was just called")
	}
	callInfo := struct {
	}{}
	mock.lockReset.Lock()
	mock.calls.Reset = append(mock.calls.Reset, callInfo)
	mock.lockReset.Unlock()
	mock.ResetFunc()
}

// ResetCalls gets all the calls that were made to Reset.
// Check the length with:
//
//	len(mockedMsg.ResetCalls())
func (mock *MsgMock) ResetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockReset.RLock()
	calls = mock.calls.Reset
	mock.lockReset.RUnlock()
	return calls
}

// String calls StringFunc.
func (mock *MsgMock) String() string {
	if mock.StringFunc == nil {
		panic("MsgMock.StringFunc: method is nil but Msg.String was just called")
	}
	callInfo := struct {
	}{}
	mock.lockString.Lock()
	mock.calls.String = append(mock.calls.String, callInfo)
	mock.lockString.Unlock()
	return mock.StringFunc()
}

// StringCalls gets all the calls that were made to String.
// Check the length with:
//
//	len(mockedMsg.StringCalls())
func (mock *MsgMock) StringCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockString.RLock()
	calls = mock.calls.String
	mock.lockString.RUnlock()
	return calls
}

// ValidateBasic calls ValidateBasicFunc.
func (mock *MsgMock) ValidateBasic() error {
	if mock.ValidateBasicFunc == nil {
		panic("MsgMock.ValidateBasicFunc: method is nil but Msg.ValidateBasic was just called")
	}
	callInfo := struct {
	}{}
	mock.lockValidateBasic.Lock()
	mock.calls.ValidateBasic = append(mock.calls.ValidateBasic, callInfo)
	mock.lockValidateBasic.Unlock()
	return mock.ValidateBasicFunc()
}

// ValidateBasicCalls gets all the calls that were made to ValidateBasic.
// Check the length with:
//
//	len(mockedMsg.ValidateBasicCalls())
func (mock *MsgMock) ValidateBasicCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockValidateBasic.RLock()
	calls = mock.calls.ValidateBasic
	mock.lockValidateBasic.RUnlock()
	return calls
}
