// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"github.com/axelarnetwork/axelar-core/x/distribution/types"
	sdk "github.com/cosmos/cosmos-sdk/types"
	authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"
	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
	"sync"
)

// Ensure, that BankKeeperMock does implement types.BankKeeper.
// If this is not the case, regenerate this file with moq.
var _ types.BankKeeper = &BankKeeperMock{}

// BankKeeperMock is a mock implementation of types.BankKeeper.
//
//	func TestSomethingThatUsesBankKeeper(t *testing.T) {
//
//		// make and configure a mocked types.BankKeeper
//		mockedBankKeeper := &BankKeeperMock{
//			BurnCoinsFunc: func(ctx sdk.Context, moduleName string, amt sdk.Coins) error {
//				panic("mock out the BurnCoins method")
//			},
//			GetAllBalancesFunc: func(ctx sdk.Context, addr sdk.AccAddress) sdk.Coins {
//				panic("mock out the GetAllBalances method")
//			},
//			GetBalanceFunc: func(ctx sdk.Context, addr sdk.AccAddress, denom string) sdk.Coin {
//				panic("mock out the GetBalance method")
//			},
//			LockedCoinsFunc: func(ctx sdk.Context, addr sdk.AccAddress) sdk.Coins {
//				panic("mock out the LockedCoins method")
//			},
//			MintCoinsFunc: func(ctx sdk.Context, moduleName string, amt sdk.Coins) error {
//				panic("mock out the MintCoins method")
//			},
//			SendCoinsFromAccountToModuleFunc: func(ctx sdk.Context, senderAddr sdk.AccAddress, recipientModule string, amt sdk.Coins) error {
//				panic("mock out the SendCoinsFromAccountToModule method")
//			},
//			SendCoinsFromModuleToAccountFunc: func(ctx sdk.Context, senderModule string, recipientAddr sdk.AccAddress, amt sdk.Coins) error {
//				panic("mock out the SendCoinsFromModuleToAccount method")
//			},
//			SendCoinsFromModuleToModuleFunc: func(ctx sdk.Context, senderModule string, recipientModule string, amt sdk.Coins) error {
//				panic("mock out the SendCoinsFromModuleToModule method")
//			},
//			SpendableCoinsFunc: func(ctx sdk.Context, addr sdk.AccAddress) sdk.Coins {
//				panic("mock out the SpendableCoins method")
//			},
//		}
//
//		// use mockedBankKeeper in code that requires types.BankKeeper
//		// and then make assertions.
//
//	}
type BankKeeperMock struct {
	// BurnCoinsFunc mocks the BurnCoins method.
	BurnCoinsFunc func(ctx sdk.Context, moduleName string, amt sdk.Coins) error

	// GetAllBalancesFunc mocks the GetAllBalances method.
	GetAllBalancesFunc func(ctx sdk.Context, addr sdk.AccAddress) sdk.Coins

	// GetBalanceFunc mocks the GetBalance method.
	GetBalanceFunc func(ctx sdk.Context, addr sdk.AccAddress, denom string) sdk.Coin

	// LockedCoinsFunc mocks the LockedCoins method.
	LockedCoinsFunc func(ctx sdk.Context, addr sdk.AccAddress) sdk.Coins

	// MintCoinsFunc mocks the MintCoins method.
	MintCoinsFunc func(ctx sdk.Context, moduleName string, amt sdk.Coins) error

	// SendCoinsFromAccountToModuleFunc mocks the SendCoinsFromAccountToModule method.
	SendCoinsFromAccountToModuleFunc func(ctx sdk.Context, senderAddr sdk.AccAddress, recipientModule string, amt sdk.Coins) error

	// SendCoinsFromModuleToAccountFunc mocks the SendCoinsFromModuleToAccount method.
	SendCoinsFromModuleToAccountFunc func(ctx sdk.Context, senderModule string, recipientAddr sdk.AccAddress, amt sdk.Coins) error

	// SendCoinsFromModuleToModuleFunc mocks the SendCoinsFromModuleToModule method.
	SendCoinsFromModuleToModuleFunc func(ctx sdk.Context, senderModule string, recipientModule string, amt sdk.Coins) error

	// SpendableCoinsFunc mocks the SpendableCoins method.
	SpendableCoinsFunc func(ctx sdk.Context, addr sdk.AccAddress) sdk.Coins

	// calls tracks calls to the methods.
	calls struct {
		// BurnCoins holds details about calls to the BurnCoins method.
		BurnCoins []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// ModuleName is the moduleName argument value.
			ModuleName string
			// Amt is the amt argument value.
			Amt sdk.Coins
		}
		// GetAllBalances holds details about calls to the GetAllBalances method.
		GetAllBalances []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Addr is the addr argument value.
			Addr sdk.AccAddress
		}
		// GetBalance holds details about calls to the GetBalance method.
		GetBalance []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Addr is the addr argument value.
			Addr sdk.AccAddress
			// Denom is the denom argument value.
			Denom string
		}
		// LockedCoins holds details about calls to the LockedCoins method.
		LockedCoins []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Addr is the addr argument value.
			Addr sdk.AccAddress
		}
		// MintCoins holds details about calls to the MintCoins method.
		MintCoins []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// ModuleName is the moduleName argument value.
			ModuleName string
			// Amt is the amt argument value.
			Amt sdk.Coins
		}
		// SendCoinsFromAccountToModule holds details about calls to the SendCoinsFromAccountToModule method.
		SendCoinsFromAccountToModule []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// SenderAddr is the senderAddr argument value.
			SenderAddr sdk.AccAddress
			// RecipientModule is the recipientModule argument value.
			RecipientModule string
			// Amt is the amt argument value.
			Amt sdk.Coins
		}
		// SendCoinsFromModuleToAccount holds details about calls to the SendCoinsFromModuleToAccount method.
		SendCoinsFromModuleToAccount []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// SenderModule is the senderModule argument value.
			SenderModule string
			// RecipientAddr is the recipientAddr argument value.
			RecipientAddr sdk.AccAddress
			// Amt is the amt argument value.
			Amt sdk.Coins
		}
		// SendCoinsFromModuleToModule holds details about calls to the SendCoinsFromModuleToModule method.
		SendCoinsFromModuleToModule []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// SenderModule is the senderModule argument value.
			SenderModule string
			// RecipientModule is the recipientModule argument value.
			RecipientModule string
			// Amt is the amt argument value.
			Amt sdk.Coins
		}
		// SpendableCoins holds details about calls to the SpendableCoins method.
		SpendableCoins []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Addr is the addr argument value.
			Addr sdk.AccAddress
		}
	}
	lockBurnCoins                    sync.RWMutex
	lockGetAllBalances               sync.RWMutex
	lockGetBalance                   sync.RWMutex
	lockLockedCoins                  sync.RWMutex
	lockMintCoins                    sync.RWMutex
	lockSendCoinsFromAccountToModule sync.RWMutex
	lockSendCoinsFromModuleToAccount sync.RWMutex
	lockSendCoinsFromModuleToModule  sync.RWMutex
	lockSpendableCoins               sync.RWMutex
}

// BurnCoins calls BurnCoinsFunc.
func (mock *BankKeeperMock) BurnCoins(ctx sdk.Context, moduleName string, amt sdk.Coins) error {
	if mock.BurnCoinsFunc == nil {
		panic("BankKeeperMock.BurnCoinsFunc: method is nil but BankKeeper.BurnCoins was just called")
	}
	callInfo := struct {
		Ctx        sdk.Context
		ModuleName string
		Amt        sdk.Coins
	}{
		Ctx:        ctx,
		ModuleName: moduleName,
		Amt:        amt,
	}
	mock.lockBurnCoins.Lock()
	mock.calls.BurnCoins = append(mock.calls.BurnCoins, callInfo)
	mock.lockBurnCoins.Unlock()
	return mock.BurnCoinsFunc(ctx, moduleName, amt)
}

// BurnCoinsCalls gets all the calls that were made to BurnCoins.
// Check the length with:
//
//	len(mockedBankKeeper.BurnCoinsCalls())
func (mock *BankKeeperMock) BurnCoinsCalls() []struct {
	Ctx        sdk.Context
	ModuleName string
	Amt        sdk.Coins
} {
	var calls []struct {
		Ctx        sdk.Context
		ModuleName string
		Amt        sdk.Coins
	}
	mock.lockBurnCoins.RLock()
	calls = mock.calls.BurnCoins
	mock.lockBurnCoins.RUnlock()
	return calls
}

// GetAllBalances calls GetAllBalancesFunc.
func (mock *BankKeeperMock) GetAllBalances(ctx sdk.Context, addr sdk.AccAddress) sdk.Coins {
	if mock.GetAllBalancesFunc == nil {
		panic("BankKeeperMock.GetAllBalancesFunc: method is nil but BankKeeper.GetAllBalances was just called")
	}
	callInfo := struct {
		Ctx  sdk.Context
		Addr sdk.AccAddress
	}{
		Ctx:  ctx,
		Addr: addr,
	}
	mock.lockGetAllBalances.Lock()
	mock.calls.GetAllBalances = append(mock.calls.GetAllBalances, callInfo)
	mock.lockGetAllBalances.Unlock()
	return mock.GetAllBalancesFunc(ctx, addr)
}

// GetAllBalancesCalls gets all the calls that were made to GetAllBalances.
// Check the length with:
//
//	len(mockedBankKeeper.GetAllBalancesCalls())
func (mock *BankKeeperMock) GetAllBalancesCalls() []struct {
	Ctx  sdk.Context
	Addr sdk.AccAddress
} {
	var calls []struct {
		Ctx  sdk.Context
		Addr sdk.AccAddress
	}
	mock.lockGetAllBalances.RLock()
	calls = mock.calls.GetAllBalances
	mock.lockGetAllBalances.RUnlock()
	return calls
}

// GetBalance calls GetBalanceFunc.
func (mock *BankKeeperMock) GetBalance(ctx sdk.Context, addr sdk.AccAddress, denom string) sdk.Coin {
	if mock.GetBalanceFunc == nil {
		panic("BankKeeperMock.GetBalanceFunc: method is nil but BankKeeper.GetBalance was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		Addr  sdk.AccAddress
		Denom string
	}{
		Ctx:   ctx,
		Addr:  addr,
		Denom: denom,
	}
	mock.lockGetBalance.Lock()
	mock.calls.GetBalance = append(mock.calls.GetBalance, callInfo)
	mock.lockGetBalance.Unlock()
	return mock.GetBalanceFunc(ctx, addr, denom)
}

// GetBalanceCalls gets all the calls that were made to GetBalance.
// Check the length with:
//
//	len(mockedBankKeeper.GetBalanceCalls())
func (mock *BankKeeperMock) GetBalanceCalls() []struct {
	Ctx   sdk.Context
	Addr  sdk.AccAddress
	Denom string
} {
	var calls []struct {
		Ctx   sdk.Context
		Addr  sdk.AccAddress
		Denom string
	}
	mock.lockGetBalance.RLock()
	calls = mock.calls.GetBalance
	mock.lockGetBalance.RUnlock()
	return calls
}

// LockedCoins calls LockedCoinsFunc.
func (mock *BankKeeperMock) LockedCoins(ctx sdk.Context, addr sdk.AccAddress) sdk.Coins {
	if mock.LockedCoinsFunc == nil {
		panic("BankKeeperMock.LockedCoinsFunc: method is nil but BankKeeper.LockedCoins was just called")
	}
	callInfo := struct {
		Ctx  sdk.Context
		Addr sdk.AccAddress
	}{
		Ctx:  ctx,
		Addr: addr,
	}
	mock.lockLockedCoins.Lock()
	mock.calls.LockedCoins = append(mock.calls.LockedCoins, callInfo)
	mock.lockLockedCoins.Unlock()
	return mock.LockedCoinsFunc(ctx, addr)
}

// LockedCoinsCalls gets all the calls that were made to LockedCoins.
// Check the length with:
//
//	len(mockedBankKeeper.LockedCoinsCalls())
func (mock *BankKeeperMock) LockedCoinsCalls() []struct {
	Ctx  sdk.Context
	Addr sdk.AccAddress
} {
	var calls []struct {
		Ctx  sdk.Context
		Addr sdk.AccAddress
	}
	mock.lockLockedCoins.RLock()
	calls = mock.calls.LockedCoins
	mock.lockLockedCoins.RUnlock()
	return calls
}

// MintCoins calls MintCoinsFunc.
func (mock *BankKeeperMock) MintCoins(ctx sdk.Context, moduleName string, amt sdk.Coins) error {
	if mock.MintCoinsFunc == nil {
		panic("BankKeeperMock.MintCoinsFunc: method is nil but BankKeeper.MintCoins was just called")
	}
	callInfo := struct {
		Ctx        sdk.Context
		ModuleName string
		Amt        sdk.Coins
	}{
		Ctx:        ctx,
		ModuleName: moduleName,
		Amt:        amt,
	}
	mock.lockMintCoins.Lock()
	mock.calls.MintCoins = append(mock.calls.MintCoins, callInfo)
	mock.lockMintCoins.Unlock()
	return mock.MintCoinsFunc(ctx, moduleName, amt)
}

// MintCoinsCalls gets all the calls that were made to MintCoins.
// Check the length with:
//
//	len(mockedBankKeeper.MintCoinsCalls())
func (mock *BankKeeperMock) MintCoinsCalls() []struct {
	Ctx        sdk.Context
	ModuleName string
	Amt        sdk.Coins
} {
	var calls []struct {
		Ctx        sdk.Context
		ModuleName string
		Amt        sdk.Coins
	}
	mock.lockMintCoins.RLock()
	calls = mock.calls.MintCoins
	mock.lockMintCoins.RUnlock()
	return calls
}

// SendCoinsFromAccountToModule calls SendCoinsFromAccountToModuleFunc.
func (mock *BankKeeperMock) SendCoinsFromAccountToModule(ctx sdk.Context, senderAddr sdk.AccAddress, recipientModule string, amt sdk.Coins) error {
	if mock.SendCoinsFromAccountToModuleFunc == nil {
		panic("BankKeeperMock.SendCoinsFromAccountToModuleFunc: method is nil but BankKeeper.SendCoinsFromAccountToModule was just called")
	}
	callInfo := struct {
		Ctx             sdk.Context
		SenderAddr      sdk.AccAddress
		RecipientModule string
		Amt             sdk.Coins
	}{
		Ctx:             ctx,
		SenderAddr:      senderAddr,
		RecipientModule: recipientModule,
		Amt:             amt,
	}
	mock.lockSendCoinsFromAccountToModule.Lock()
	mock.calls.SendCoinsFromAccountToModule = append(mock.calls.SendCoinsFromAccountToModule, callInfo)
	mock.lockSendCoinsFromAccountToModule.Unlock()
	return mock.SendCoinsFromAccountToModuleFunc(ctx, senderAddr, recipientModule, amt)
}

// SendCoinsFromAccountToModuleCalls gets all the calls that were made to SendCoinsFromAccountToModule.
// Check the length with:
//
//	len(mockedBankKeeper.SendCoinsFromAccountToModuleCalls())
func (mock *BankKeeperMock) SendCoinsFromAccountToModuleCalls() []struct {
	Ctx             sdk.Context
	SenderAddr      sdk.AccAddress
	RecipientModule string
	Amt             sdk.Coins
} {
	var calls []struct {
		Ctx             sdk.Context
		SenderAddr      sdk.AccAddress
		RecipientModule string
		Amt             sdk.Coins
	}
	mock.lockSendCoinsFromAccountToModule.RLock()
	calls = mock.calls.SendCoinsFromAccountToModule
	mock.lockSendCoinsFromAccountToModule.RUnlock()
	return calls
}

// SendCoinsFromModuleToAccount calls SendCoinsFromModuleToAccountFunc.
func (mock *BankKeeperMock) SendCoinsFromModuleToAccount(ctx sdk.Context, senderModule string, recipientAddr sdk.AccAddress, amt sdk.Coins) error {
	if mock.SendCoinsFromModuleToAccountFunc == nil {
		panic("BankKeeperMock.SendCoinsFromModuleToAccountFunc: method is nil but BankKeeper.SendCoinsFromModuleToAccount was just called")
	}
	callInfo := struct {
		Ctx           sdk.Context
		SenderModule  string
		RecipientAddr sdk.AccAddress
		Amt           sdk.Coins
	}{
		Ctx:           ctx,
		SenderModule:  senderModule,
		RecipientAddr: recipientAddr,
		Amt:           amt,
	}
	mock.lockSendCoinsFromModuleToAccount.Lock()
	mock.calls.SendCoinsFromModuleToAccount = append(mock.calls.SendCoinsFromModuleToAccount, callInfo)
	mock.lockSendCoinsFromModuleToAccount.Unlock()
	return mock.SendCoinsFromModuleToAccountFunc(ctx, senderModule, recipientAddr, amt)
}

// SendCoinsFromModuleToAccountCalls gets all the calls that were made to SendCoinsFromModuleToAccount.
// Check the length with:
//
//	len(mockedBankKeeper.SendCoinsFromModuleToAccountCalls())
func (mock *BankKeeperMock) SendCoinsFromModuleToAccountCalls() []struct {
	Ctx           sdk.Context
	SenderModule  string
	RecipientAddr sdk.AccAddress
	Amt           sdk.Coins
} {
	var calls []struct {
		Ctx           sdk.Context
		SenderModule  string
		RecipientAddr sdk.AccAddress
		Amt           sdk.Coins
	}
	mock.lockSendCoinsFromModuleToAccount.RLock()
	calls = mock.calls.SendCoinsFromModuleToAccount
	mock.lockSendCoinsFromModuleToAccount.RUnlock()
	return calls
}

// SendCoinsFromModuleToModule calls SendCoinsFromModuleToModuleFunc.
func (mock *BankKeeperMock) SendCoinsFromModuleToModule(ctx sdk.Context, senderModule string, recipientModule string, amt sdk.Coins) error {
	if mock.SendCoinsFromModuleToModuleFunc == nil {
		panic("BankKeeperMock.SendCoinsFromModuleToModuleFunc: method is nil but BankKeeper.SendCoinsFromModuleToModule was just called")
	}
	callInfo := struct {
		Ctx             sdk.Context
		SenderModule    string
		RecipientModule string
		Amt             sdk.Coins
	}{
		Ctx:             ctx,
		SenderModule:    senderModule,
		RecipientModule: recipientModule,
		Amt:             amt,
	}
	mock.lockSendCoinsFromModuleToModule.Lock()
	mock.calls.SendCoinsFromModuleToModule = append(mock.calls.SendCoinsFromModuleToModule, callInfo)
	mock.lockSendCoinsFromModuleToModule.Unlock()
	return mock.SendCoinsFromModuleToModuleFunc(ctx, senderModule, recipientModule, amt)
}

// SendCoinsFromModuleToModuleCalls gets all the calls that were made to SendCoinsFromModuleToModule.
// Check the length with:
//
//	len(mockedBankKeeper.SendCoinsFromModuleToModuleCalls())
func (mock *BankKeeperMock) SendCoinsFromModuleToModuleCalls() []struct {
	Ctx             sdk.Context
	SenderModule    string
	RecipientModule string
	Amt             sdk.Coins
} {
	var calls []struct {
		Ctx             sdk.Context
		SenderModule    string
		RecipientModule string
		Amt             sdk.Coins
	}
	mock.lockSendCoinsFromModuleToModule.RLock()
	calls = mock.calls.SendCoinsFromModuleToModule
	mock.lockSendCoinsFromModuleToModule.RUnlock()
	return calls
}

// SpendableCoins calls SpendableCoinsFunc.
func (mock *BankKeeperMock) SpendableCoins(ctx sdk.Context, addr sdk.AccAddress) sdk.Coins {
	if mock.SpendableCoinsFunc == nil {
		panic("BankKeeperMock.SpendableCoinsFunc: method is nil but BankKeeper.SpendableCoins was just called")
	}
	callInfo := struct {
		Ctx  sdk.Context
		Addr sdk.AccAddress
	}{
		Ctx:  ctx,
		Addr: addr,
	}
	mock.lockSpendableCoins.Lock()
	mock.calls.SpendableCoins = append(mock.calls.SpendableCoins, callInfo)
	mock.lockSpendableCoins.Unlock()
	return mock.SpendableCoinsFunc(ctx, addr)
}

// SpendableCoinsCalls gets all the calls that were made to SpendableCoins.
// Check the length with:
//
//	len(mockedBankKeeper.SpendableCoinsCalls())
func (mock *BankKeeperMock) SpendableCoinsCalls() []struct {
	Ctx  sdk.Context
	Addr sdk.AccAddress
} {
	var calls []struct {
		Ctx  sdk.Context
		Addr sdk.AccAddress
	}
	mock.lockSpendableCoins.RLock()
	calls = mock.calls.SpendableCoins
	mock.lockSpendableCoins.RUnlock()
	return calls
}

// Ensure, that AccountKeeperMock does implement types.AccountKeeper.
// If this is not the case, regenerate this file with moq.
var _ types.AccountKeeper = &AccountKeeperMock{}

// AccountKeeperMock is a mock implementation of types.AccountKeeper.
//
//	func TestSomethingThatUsesAccountKeeper(t *testing.T) {
//
//		// make and configure a mocked types.AccountKeeper
//		mockedAccountKeeper := &AccountKeeperMock{
//			GetAccountFunc: func(ctx sdk.Context, addr sdk.AccAddress) authtypes.AccountI {
//				panic("mock out the GetAccount method")
//			},
//			GetModuleAccountFunc: func(ctx sdk.Context, name string) authtypes.ModuleAccountI {
//				panic("mock out the GetModuleAccount method")
//			},
//			GetModuleAddressFunc: func(name string) sdk.AccAddress {
//				panic("mock out the GetModuleAddress method")
//			},
//			SetModuleAccountFunc: func(context sdk.Context, moduleAccountI authtypes.ModuleAccountI)  {
//				panic("mock out the SetModuleAccount method")
//			},
//		}
//
//		// use mockedAccountKeeper in code that requires types.AccountKeeper
//		// and then make assertions.
//
//	}
type AccountKeeperMock struct {
	// GetAccountFunc mocks the GetAccount method.
	GetAccountFunc func(ctx sdk.Context, addr sdk.AccAddress) authtypes.AccountI

	// GetModuleAccountFunc mocks the GetModuleAccount method.
	GetModuleAccountFunc func(ctx sdk.Context, name string) authtypes.ModuleAccountI

	// GetModuleAddressFunc mocks the GetModuleAddress method.
	GetModuleAddressFunc func(name string) sdk.AccAddress

	// SetModuleAccountFunc mocks the SetModuleAccount method.
	SetModuleAccountFunc func(context sdk.Context, moduleAccountI authtypes.ModuleAccountI)

	// calls tracks calls to the methods.
	calls struct {
		// GetAccount holds details about calls to the GetAccount method.
		GetAccount []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Addr is the addr argument value.
			Addr sdk.AccAddress
		}
		// GetModuleAccount holds details about calls to the GetModuleAccount method.
		GetModuleAccount []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Name is the name argument value.
			Name string
		}
		// GetModuleAddress holds details about calls to the GetModuleAddress method.
		GetModuleAddress []struct {
			// Name is the name argument value.
			Name string
		}
		// SetModuleAccount holds details about calls to the SetModuleAccount method.
		SetModuleAccount []struct {
			// Context is the context argument value.
			Context sdk.Context
			// ModuleAccountI is the moduleAccountI argument value.
			ModuleAccountI authtypes.ModuleAccountI
		}
	}
	lockGetAccount       sync.RWMutex
	lockGetModuleAccount sync.RWMutex
	lockGetModuleAddress sync.RWMutex
	lockSetModuleAccount sync.RWMutex
}

// GetAccount calls GetAccountFunc.
func (mock *AccountKeeperMock) GetAccount(ctx sdk.Context, addr sdk.AccAddress) authtypes.AccountI {
	if mock.GetAccountFunc == nil {
		panic("AccountKeeperMock.GetAccountFunc: method is nil but AccountKeeper.GetAccount was just called")
	}
	callInfo := struct {
		Ctx  sdk.Context
		Addr sdk.AccAddress
	}{
		Ctx:  ctx,
		Addr: addr,
	}
	mock.lockGetAccount.Lock()
	mock.calls.GetAccount = append(mock.calls.GetAccount, callInfo)
	mock.lockGetAccount.Unlock()
	return mock.GetAccountFunc(ctx, addr)
}

// GetAccountCalls gets all the calls that were made to GetAccount.
// Check the length with:
//
//	len(mockedAccountKeeper.GetAccountCalls())
func (mock *AccountKeeperMock) GetAccountCalls() []struct {
	Ctx  sdk.Context
	Addr sdk.AccAddress
} {
	var calls []struct {
		Ctx  sdk.Context
		Addr sdk.AccAddress
	}
	mock.lockGetAccount.RLock()
	calls = mock.calls.GetAccount
	mock.lockGetAccount.RUnlock()
	return calls
}

// GetModuleAccount calls GetModuleAccountFunc.
func (mock *AccountKeeperMock) GetModuleAccount(ctx sdk.Context, name string) authtypes.ModuleAccountI {
	if mock.GetModuleAccountFunc == nil {
		panic("AccountKeeperMock.GetModuleAccountFunc: method is nil but AccountKeeper.GetModuleAccount was just called")
	}
	callInfo := struct {
		Ctx  sdk.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockGetModuleAccount.Lock()
	mock.calls.GetModuleAccount = append(mock.calls.GetModuleAccount, callInfo)
	mock.lockGetModuleAccount.Unlock()
	return mock.GetModuleAccountFunc(ctx, name)
}

// GetModuleAccountCalls gets all the calls that were made to GetModuleAccount.
// Check the length with:
//
//	len(mockedAccountKeeper.GetModuleAccountCalls())
func (mock *AccountKeeperMock) GetModuleAccountCalls() []struct {
	Ctx  sdk.Context
	Name string
} {
	var calls []struct {
		Ctx  sdk.Context
		Name string
	}
	mock.lockGetModuleAccount.RLock()
	calls = mock.calls.GetModuleAccount
	mock.lockGetModuleAccount.RUnlock()
	return calls
}

// GetModuleAddress calls GetModuleAddressFunc.
func (mock *AccountKeeperMock) GetModuleAddress(name string) sdk.AccAddress {
	if mock.GetModuleAddressFunc == nil {
		panic("AccountKeeperMock.GetModuleAddressFunc: method is nil but AccountKeeper.GetModuleAddress was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockGetModuleAddress.Lock()
	mock.calls.GetModuleAddress = append(mock.calls.GetModuleAddress, callInfo)
	mock.lockGetModuleAddress.Unlock()
	return mock.GetModuleAddressFunc(name)
}

// GetModuleAddressCalls gets all the calls that were made to GetModuleAddress.
// Check the length with:
//
//	len(mockedAccountKeeper.GetModuleAddressCalls())
func (mock *AccountKeeperMock) GetModuleAddressCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockGetModuleAddress.RLock()
	calls = mock.calls.GetModuleAddress
	mock.lockGetModuleAddress.RUnlock()
	return calls
}

// SetModuleAccount calls SetModuleAccountFunc.
func (mock *AccountKeeperMock) SetModuleAccount(context sdk.Context, moduleAccountI authtypes.ModuleAccountI) {
	if mock.SetModuleAccountFunc == nil {
		panic("AccountKeeperMock.SetModuleAccountFunc: method is nil but AccountKeeper.SetModuleAccount was just called")
	}
	callInfo := struct {
		Context        sdk.Context
		ModuleAccountI authtypes.ModuleAccountI
	}{
		Context:        context,
		ModuleAccountI: moduleAccountI,
	}
	mock.lockSetModuleAccount.Lock()
	mock.calls.SetModuleAccount = append(mock.calls.SetModuleAccount, callInfo)
	mock.lockSetModuleAccount.Unlock()
	mock.SetModuleAccountFunc(context, moduleAccountI)
}

// SetModuleAccountCalls gets all the calls that were made to SetModuleAccount.
// Check the length with:
//
//	len(mockedAccountKeeper.SetModuleAccountCalls())
func (mock *AccountKeeperMock) SetModuleAccountCalls() []struct {
	Context        sdk.Context
	ModuleAccountI authtypes.ModuleAccountI
} {
	var calls []struct {
		Context        sdk.Context
		ModuleAccountI authtypes.ModuleAccountI
	}
	mock.lockSetModuleAccount.RLock()
	calls = mock.calls.SetModuleAccount
	mock.lockSetModuleAccount.RUnlock()
	return calls
}

// Ensure, that StakingKeeperMock does implement types.StakingKeeper.
// If this is not the case, regenerate this file with moq.
var _ types.StakingKeeper = &StakingKeeperMock{}

// StakingKeeperMock is a mock implementation of types.StakingKeeper.
//
//	func TestSomethingThatUsesStakingKeeper(t *testing.T) {
//
//		// make and configure a mocked types.StakingKeeper
//		mockedStakingKeeper := &StakingKeeperMock{
//			DelegationFunc: func(context sdk.Context, accAddress sdk.AccAddress, valAddress sdk.ValAddress) stakingtypes.DelegationI {
//				panic("mock out the Delegation method")
//			},
//			GetAllSDKDelegationsFunc: func(ctx sdk.Context) []stakingtypes.Delegation {
//				panic("mock out the GetAllSDKDelegations method")
//			},
//			GetLastTotalPowerFunc: func(ctx sdk.Context) sdk.Int {
//				panic("mock out the GetLastTotalPower method")
//			},
//			GetLastValidatorPowerFunc: func(ctx sdk.Context, valAddr sdk.ValAddress) int64 {
//				panic("mock out the GetLastValidatorPower method")
//			},
//			IterateBondedValidatorsByPowerFunc: func(context sdk.Context, fn func(index int64, validator stakingtypes.ValidatorI) (stop bool))  {
//				panic("mock out the IterateBondedValidatorsByPower method")
//			},
//			IterateDelegationsFunc: func(ctx sdk.Context, delegator sdk.AccAddress, fn func(index int64, delegation stakingtypes.DelegationI) (stop bool))  {
//				panic("mock out the IterateDelegations method")
//			},
//			IterateLastValidatorsFunc: func(context sdk.Context, fn func(index int64, validator stakingtypes.ValidatorI) (stop bool))  {
//				panic("mock out the IterateLastValidators method")
//			},
//			IterateValidatorsFunc: func(context sdk.Context, fn func(index int64, validator stakingtypes.ValidatorI) (stop bool))  {
//				panic("mock out the IterateValidators method")
//			},
//			JailFunc: func(context sdk.Context, consAddress sdk.ConsAddress)  {
//				panic("mock out the Jail method")
//			},
//			MaxValidatorsFunc: func(context sdk.Context) uint32 {
//				panic("mock out the MaxValidators method")
//			},
//			SlashFunc: func(context sdk.Context, consAddress sdk.ConsAddress, n1 int64, n2 int64, dec sdk.Dec)  {
//				panic("mock out the Slash method")
//			},
//			UnjailFunc: func(context sdk.Context, consAddress sdk.ConsAddress)  {
//				panic("mock out the Unjail method")
//			},
//			ValidatorFunc: func(context sdk.Context, valAddress sdk.ValAddress) stakingtypes.ValidatorI {
//				panic("mock out the Validator method")
//			},
//			ValidatorByConsAddrFunc: func(context sdk.Context, consAddress sdk.ConsAddress) stakingtypes.ValidatorI {
//				panic("mock out the ValidatorByConsAddr method")
//			},
//		}
//
//		// use mockedStakingKeeper in code that requires types.StakingKeeper
//		// and then make assertions.
//
//	}
type StakingKeeperMock struct {
	// DelegationFunc mocks the Delegation method.
	DelegationFunc func(context sdk.Context, accAddress sdk.AccAddress, valAddress sdk.ValAddress) stakingtypes.DelegationI

	// GetAllSDKDelegationsFunc mocks the GetAllSDKDelegations method.
	GetAllSDKDelegationsFunc func(ctx sdk.Context) []stakingtypes.Delegation

	// GetLastTotalPowerFunc mocks the GetLastTotalPower method.
	GetLastTotalPowerFunc func(ctx sdk.Context) sdk.Int

	// GetLastValidatorPowerFunc mocks the GetLastValidatorPower method.
	GetLastValidatorPowerFunc func(ctx sdk.Context, valAddr sdk.ValAddress) int64

	// IterateBondedValidatorsByPowerFunc mocks the IterateBondedValidatorsByPower method.
	IterateBondedValidatorsByPowerFunc func(context sdk.Context, fn func(index int64, validator stakingtypes.ValidatorI) (stop bool))

	// IterateDelegationsFunc mocks the IterateDelegations method.
	IterateDelegationsFunc func(ctx sdk.Context, delegator sdk.AccAddress, fn func(index int64, delegation stakingtypes.DelegationI) (stop bool))

	// IterateLastValidatorsFunc mocks the IterateLastValidators method.
	IterateLastValidatorsFunc func(context sdk.Context, fn func(index int64, validator stakingtypes.ValidatorI) (stop bool))

	// IterateValidatorsFunc mocks the IterateValidators method.
	IterateValidatorsFunc func(context sdk.Context, fn func(index int64, validator stakingtypes.ValidatorI) (stop bool))

	// JailFunc mocks the Jail method.
	JailFunc func(context sdk.Context, consAddress sdk.ConsAddress)

	// MaxValidatorsFunc mocks the MaxValidators method.
	MaxValidatorsFunc func(context sdk.Context) uint32

	// SlashFunc mocks the Slash method.
	SlashFunc func(context sdk.Context, consAddress sdk.ConsAddress, n1 int64, n2 int64, dec sdk.Dec)

	// UnjailFunc mocks the Unjail method.
	UnjailFunc func(context sdk.Context, consAddress sdk.ConsAddress)

	// ValidatorFunc mocks the Validator method.
	ValidatorFunc func(context sdk.Context, valAddress sdk.ValAddress) stakingtypes.ValidatorI

	// ValidatorByConsAddrFunc mocks the ValidatorByConsAddr method.
	ValidatorByConsAddrFunc func(context sdk.Context, consAddress sdk.ConsAddress) stakingtypes.ValidatorI

	// calls tracks calls to the methods.
	calls struct {
		// Delegation holds details about calls to the Delegation method.
		Delegation []struct {
			// Context is the context argument value.
			Context sdk.Context
			// AccAddress is the accAddress argument value.
			AccAddress sdk.AccAddress
			// ValAddress is the valAddress argument value.
			ValAddress sdk.ValAddress
		}
		// GetAllSDKDelegations holds details about calls to the GetAllSDKDelegations method.
		GetAllSDKDelegations []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetLastTotalPower holds details about calls to the GetLastTotalPower method.
		GetLastTotalPower []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetLastValidatorPower holds details about calls to the GetLastValidatorPower method.
		GetLastValidatorPower []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// ValAddr is the valAddr argument value.
			ValAddr sdk.ValAddress
		}
		// IterateBondedValidatorsByPower holds details about calls to the IterateBondedValidatorsByPower method.
		IterateBondedValidatorsByPower []struct {
			// Context is the context argument value.
			Context sdk.Context
			// Fn is the fn argument value.
			Fn func(index int64, validator stakingtypes.ValidatorI) (stop bool)
		}
		// IterateDelegations holds details about calls to the IterateDelegations method.
		IterateDelegations []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Delegator is the delegator argument value.
			Delegator sdk.AccAddress
			// Fn is the fn argument value.
			Fn func(index int64, delegation stakingtypes.DelegationI) (stop bool)
		}
		// IterateLastValidators holds details about calls to the IterateLastValidators method.
		IterateLastValidators []struct {
			// Context is the context argument value.
			Context sdk.Context
			// Fn is the fn argument value.
			Fn func(index int64, validator stakingtypes.ValidatorI) (stop bool)
		}
		// IterateValidators holds details about calls to the IterateValidators method.
		IterateValidators []struct {
			// Context is the context argument value.
			Context sdk.Context
			// Fn is the fn argument value.
			Fn func(index int64, validator stakingtypes.ValidatorI) (stop bool)
		}
		// Jail holds details about calls to the Jail method.
		Jail []struct {
			// Context is the context argument value.
			Context sdk.Context
			// ConsAddress is the consAddress argument value.
			ConsAddress sdk.ConsAddress
		}
		// MaxValidators holds details about calls to the MaxValidators method.
		MaxValidators []struct {
			// Context is the context argument value.
			Context sdk.Context
		}
		// Slash holds details about calls to the Slash method.
		Slash []struct {
			// Context is the context argument value.
			Context sdk.Context
			// ConsAddress is the consAddress argument value.
			ConsAddress sdk.ConsAddress
			// N1 is the n1 argument value.
			N1 int64
			// N2 is the n2 argument value.
			N2 int64
			// Dec is the dec argument value.
			Dec sdk.Dec
		}
		// Unjail holds details about calls to the Unjail method.
		Unjail []struct {
			// Context is the context argument value.
			Context sdk.Context
			// ConsAddress is the consAddress argument value.
			ConsAddress sdk.ConsAddress
		}
		// Validator holds details about calls to the Validator method.
		Validator []struct {
			// Context is the context argument value.
			Context sdk.Context
			// ValAddress is the valAddress argument value.
			ValAddress sdk.ValAddress
		}
		// ValidatorByConsAddr holds details about calls to the ValidatorByConsAddr method.
		ValidatorByConsAddr []struct {
			// Context is the context argument value.
			Context sdk.Context
			// ConsAddress is the consAddress argument value.
			ConsAddress sdk.ConsAddress
		}
	}
	lockDelegation                     sync.RWMutex
	lockGetAllSDKDelegations           sync.RWMutex
	lockGetLastTotalPower              sync.RWMutex
	lockGetLastValidatorPower          sync.RWMutex
	lockIterateBondedValidatorsByPower sync.RWMutex
	lockIterateDelegations             sync.RWMutex
	lockIterateLastValidators          sync.RWMutex
	lockIterateValidators              sync.RWMutex
	lockJail                           sync.RWMutex
	lockMaxValidators                  sync.RWMutex
	lockSlash                          sync.RWMutex
	lockUnjail                         sync.RWMutex
	lockValidator                      sync.RWMutex
	lockValidatorByConsAddr            sync.RWMutex
}

// Delegation calls DelegationFunc.
func (mock *StakingKeeperMock) Delegation(context sdk.Context, accAddress sdk.AccAddress, valAddress sdk.ValAddress) stakingtypes.DelegationI {
	if mock.DelegationFunc == nil {
		panic("StakingKeeperMock.DelegationFunc: method is nil but StakingKeeper.Delegation was just called")
	}
	callInfo := struct {
		Context    sdk.Context
		AccAddress sdk.AccAddress
		ValAddress sdk.ValAddress
	}{
		Context:    context,
		AccAddress: accAddress,
		ValAddress: valAddress,
	}
	mock.lockDelegation.Lock()
	mock.calls.Delegation = append(mock.calls.Delegation, callInfo)
	mock.lockDelegation.Unlock()
	return mock.DelegationFunc(context, accAddress, valAddress)
}

// DelegationCalls gets all the calls that were made to Delegation.
// Check the length with:
//
//	len(mockedStakingKeeper.DelegationCalls())
func (mock *StakingKeeperMock) DelegationCalls() []struct {
	Context    sdk.Context
	AccAddress sdk.AccAddress
	ValAddress sdk.ValAddress
} {
	var calls []struct {
		Context    sdk.Context
		AccAddress sdk.AccAddress
		ValAddress sdk.ValAddress
	}
	mock.lockDelegation.RLock()
	calls = mock.calls.Delegation
	mock.lockDelegation.RUnlock()
	return calls
}

// GetAllSDKDelegations calls GetAllSDKDelegationsFunc.
func (mock *StakingKeeperMock) GetAllSDKDelegations(ctx sdk.Context) []stakingtypes.Delegation {
	if mock.GetAllSDKDelegationsFunc == nil {
		panic("StakingKeeperMock.GetAllSDKDelegationsFunc: method is nil but StakingKeeper.GetAllSDKDelegations was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAllSDKDelegations.Lock()
	mock.calls.GetAllSDKDelegations = append(mock.calls.GetAllSDKDelegations, callInfo)
	mock.lockGetAllSDKDelegations.Unlock()
	return mock.GetAllSDKDelegationsFunc(ctx)
}

// GetAllSDKDelegationsCalls gets all the calls that were made to GetAllSDKDelegations.
// Check the length with:
//
//	len(mockedStakingKeeper.GetAllSDKDelegationsCalls())
func (mock *StakingKeeperMock) GetAllSDKDelegationsCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetAllSDKDelegations.RLock()
	calls = mock.calls.GetAllSDKDelegations
	mock.lockGetAllSDKDelegations.RUnlock()
	return calls
}

// GetLastTotalPower calls GetLastTotalPowerFunc.
func (mock *StakingKeeperMock) GetLastTotalPower(ctx sdk.Context) sdk.Int {
	if mock.GetLastTotalPowerFunc == nil {
		panic("StakingKeeperMock.GetLastTotalPowerFunc: method is nil but StakingKeeper.GetLastTotalPower was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetLastTotalPower.Lock()
	mock.calls.GetLastTotalPower = append(mock.calls.GetLastTotalPower, callInfo)
	mock.lockGetLastTotalPower.Unlock()
	return mock.GetLastTotalPowerFunc(ctx)
}

// GetLastTotalPowerCalls gets all the calls that were made to GetLastTotalPower.
// Check the length with:
//
//	len(mockedStakingKeeper.GetLastTotalPowerCalls())
func (mock *StakingKeeperMock) GetLastTotalPowerCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetLastTotalPower.RLock()
	calls = mock.calls.GetLastTotalPower
	mock.lockGetLastTotalPower.RUnlock()
	return calls
}

// GetLastValidatorPower calls GetLastValidatorPowerFunc.
func (mock *StakingKeeperMock) GetLastValidatorPower(ctx sdk.Context, valAddr sdk.ValAddress) int64 {
	if mock.GetLastValidatorPowerFunc == nil {
		panic("StakingKeeperMock.GetLastValidatorPowerFunc: method is nil but StakingKeeper.GetLastValidatorPower was just called")
	}
	callInfo := struct {
		Ctx     sdk.Context
		ValAddr sdk.ValAddress
	}{
		Ctx:     ctx,
		ValAddr: valAddr,
	}
	mock.lockGetLastValidatorPower.Lock()
	mock.calls.GetLastValidatorPower = append(mock.calls.GetLastValidatorPower, callInfo)
	mock.lockGetLastValidatorPower.Unlock()
	return mock.GetLastValidatorPowerFunc(ctx, valAddr)
}

// GetLastValidatorPowerCalls gets all the calls that were made to GetLastValidatorPower.
// Check the length with:
//
//	len(mockedStakingKeeper.GetLastValidatorPowerCalls())
func (mock *StakingKeeperMock) GetLastValidatorPowerCalls() []struct {
	Ctx     sdk.Context
	ValAddr sdk.ValAddress
} {
	var calls []struct {
		Ctx     sdk.Context
		ValAddr sdk.ValAddress
	}
	mock.lockGetLastValidatorPower.RLock()
	calls = mock.calls.GetLastValidatorPower
	mock.lockGetLastValidatorPower.RUnlock()
	return calls
}

// IterateBondedValidatorsByPower calls IterateBondedValidatorsByPowerFunc.
func (mock *StakingKeeperMock) IterateBondedValidatorsByPower(context sdk.Context, fn func(index int64, validator stakingtypes.ValidatorI) (stop bool)) {
	if mock.IterateBondedValidatorsByPowerFunc == nil {
		panic("StakingKeeperMock.IterateBondedValidatorsByPowerFunc: method is nil but StakingKeeper.IterateBondedValidatorsByPower was just called")
	}
	callInfo := struct {
		Context sdk.Context
		Fn      func(index int64, validator stakingtypes.ValidatorI) (stop bool)
	}{
		Context: context,
		Fn:      fn,
	}
	mock.lockIterateBondedValidatorsByPower.Lock()
	mock.calls.IterateBondedValidatorsByPower = append(mock.calls.IterateBondedValidatorsByPower, callInfo)
	mock.lockIterateBondedValidatorsByPower.Unlock()
	mock.IterateBondedValidatorsByPowerFunc(context, fn)
}

// IterateBondedValidatorsByPowerCalls gets all the calls that were made to IterateBondedValidatorsByPower.
// Check the length with:
//
//	len(mockedStakingKeeper.IterateBondedValidatorsByPowerCalls())
func (mock *StakingKeeperMock) IterateBondedValidatorsByPowerCalls() []struct {
	Context sdk.Context
	Fn      func(index int64, validator stakingtypes.ValidatorI) (stop bool)
} {
	var calls []struct {
		Context sdk.Context
		Fn      func(index int64, validator stakingtypes.ValidatorI) (stop bool)
	}
	mock.lockIterateBondedValidatorsByPower.RLock()
	calls = mock.calls.IterateBondedValidatorsByPower
	mock.lockIterateBondedValidatorsByPower.RUnlock()
	return calls
}

// IterateDelegations calls IterateDelegationsFunc.
func (mock *StakingKeeperMock) IterateDelegations(ctx sdk.Context, delegator sdk.AccAddress, fn func(index int64, delegation stakingtypes.DelegationI) (stop bool)) {
	if mock.IterateDelegationsFunc == nil {
		panic("StakingKeeperMock.IterateDelegationsFunc: method is nil but StakingKeeper.IterateDelegations was just called")
	}
	callInfo := struct {
		Ctx       sdk.Context
		Delegator sdk.AccAddress
		Fn        func(index int64, delegation stakingtypes.DelegationI) (stop bool)
	}{
		Ctx:       ctx,
		Delegator: delegator,
		Fn:        fn,
	}
	mock.lockIterateDelegations.Lock()
	mock.calls.IterateDelegations = append(mock.calls.IterateDelegations, callInfo)
	mock.lockIterateDelegations.Unlock()
	mock.IterateDelegationsFunc(ctx, delegator, fn)
}

// IterateDelegationsCalls gets all the calls that were made to IterateDelegations.
// Check the length with:
//
//	len(mockedStakingKeeper.IterateDelegationsCalls())
func (mock *StakingKeeperMock) IterateDelegationsCalls() []struct {
	Ctx       sdk.Context
	Delegator sdk.AccAddress
	Fn        func(index int64, delegation stakingtypes.DelegationI) (stop bool)
} {
	var calls []struct {
		Ctx       sdk.Context
		Delegator sdk.AccAddress
		Fn        func(index int64, delegation stakingtypes.DelegationI) (stop bool)
	}
	mock.lockIterateDelegations.RLock()
	calls = mock.calls.IterateDelegations
	mock.lockIterateDelegations.RUnlock()
	return calls
}

// IterateLastValidators calls IterateLastValidatorsFunc.
func (mock *StakingKeeperMock) IterateLastValidators(context sdk.Context, fn func(index int64, validator stakingtypes.ValidatorI) (stop bool)) {
	if mock.IterateLastValidatorsFunc == nil {
		panic("StakingKeeperMock.IterateLastValidatorsFunc: method is nil but StakingKeeper.IterateLastValidators was just called")
	}
	callInfo := struct {
		Context sdk.Context
		Fn      func(index int64, validator stakingtypes.ValidatorI) (stop bool)
	}{
		Context: context,
		Fn:      fn,
	}
	mock.lockIterateLastValidators.Lock()
	mock.calls.IterateLastValidators = append(mock.calls.IterateLastValidators, callInfo)
	mock.lockIterateLastValidators.Unlock()
	mock.IterateLastValidatorsFunc(context, fn)
}

// IterateLastValidatorsCalls gets all the calls that were made to IterateLastValidators.
// Check the length with:
//
//	len(mockedStakingKeeper.IterateLastValidatorsCalls())
func (mock *StakingKeeperMock) IterateLastValidatorsCalls() []struct {
	Context sdk.Context
	Fn      func(index int64, validator stakingtypes.ValidatorI) (stop bool)
} {
	var calls []struct {
		Context sdk.Context
		Fn      func(index int64, validator stakingtypes.ValidatorI) (stop bool)
	}
	mock.lockIterateLastValidators.RLock()
	calls = mock.calls.IterateLastValidators
	mock.lockIterateLastValidators.RUnlock()
	return calls
}

// IterateValidators calls IterateValidatorsFunc.
func (mock *StakingKeeperMock) IterateValidators(context sdk.Context, fn func(index int64, validator stakingtypes.ValidatorI) (stop bool)) {
	if mock.IterateValidatorsFunc == nil {
		panic("StakingKeeperMock.IterateValidatorsFunc: method is nil but StakingKeeper.IterateValidators was just called")
	}
	callInfo := struct {
		Context sdk.Context
		Fn      func(index int64, validator stakingtypes.ValidatorI) (stop bool)
	}{
		Context: context,
		Fn:      fn,
	}
	mock.lockIterateValidators.Lock()
	mock.calls.IterateValidators = append(mock.calls.IterateValidators, callInfo)
	mock.lockIterateValidators.Unlock()
	mock.IterateValidatorsFunc(context, fn)
}

// IterateValidatorsCalls gets all the calls that were made to IterateValidators.
// Check the length with:
//
//	len(mockedStakingKeeper.IterateValidatorsCalls())
func (mock *StakingKeeperMock) IterateValidatorsCalls() []struct {
	Context sdk.Context
	Fn      func(index int64, validator stakingtypes.ValidatorI) (stop bool)
} {
	var calls []struct {
		Context sdk.Context
		Fn      func(index int64, validator stakingtypes.ValidatorI) (stop bool)
	}
	mock.lockIterateValidators.RLock()
	calls = mock.calls.IterateValidators
	mock.lockIterateValidators.RUnlock()
	return calls
}

// Jail calls JailFunc.
func (mock *StakingKeeperMock) Jail(context sdk.Context, consAddress sdk.ConsAddress) {
	if mock.JailFunc == nil {
		panic("StakingKeeperMock.JailFunc: method is nil but StakingKeeper.Jail was just called")
	}
	callInfo := struct {
		Context     sdk.Context
		ConsAddress sdk.ConsAddress
	}{
		Context:     context,
		ConsAddress: consAddress,
	}
	mock.lockJail.Lock()
	mock.calls.Jail = append(mock.calls.Jail, callInfo)
	mock.lockJail.Unlock()
	mock.JailFunc(context, consAddress)
}

// JailCalls gets all the calls that were made to Jail.
// Check the length with:
//
//	len(mockedStakingKeeper.JailCalls())
func (mock *StakingKeeperMock) JailCalls() []struct {
	Context     sdk.Context
	ConsAddress sdk.ConsAddress
} {
	var calls []struct {
		Context     sdk.Context
		ConsAddress sdk.ConsAddress
	}
	mock.lockJail.RLock()
	calls = mock.calls.Jail
	mock.lockJail.RUnlock()
	return calls
}

// MaxValidators calls MaxValidatorsFunc.
func (mock *StakingKeeperMock) MaxValidators(context sdk.Context) uint32 {
	if mock.MaxValidatorsFunc == nil {
		panic("StakingKeeperMock.MaxValidatorsFunc: method is nil but StakingKeeper.MaxValidators was just called")
	}
	callInfo := struct {
		Context sdk.Context
	}{
		Context: context,
	}
	mock.lockMaxValidators.Lock()
	mock.calls.MaxValidators = append(mock.calls.MaxValidators, callInfo)
	mock.lockMaxValidators.Unlock()
	return mock.MaxValidatorsFunc(context)
}

// MaxValidatorsCalls gets all the calls that were made to MaxValidators.
// Check the length with:
//
//	len(mockedStakingKeeper.MaxValidatorsCalls())
func (mock *StakingKeeperMock) MaxValidatorsCalls() []struct {
	Context sdk.Context
} {
	var calls []struct {
		Context sdk.Context
	}
	mock.lockMaxValidators.RLock()
	calls = mock.calls.MaxValidators
	mock.lockMaxValidators.RUnlock()
	return calls
}

// Slash calls SlashFunc.
func (mock *StakingKeeperMock) Slash(context sdk.Context, consAddress sdk.ConsAddress, n1 int64, n2 int64, dec sdk.Dec) {
	if mock.SlashFunc == nil {
		panic("StakingKeeperMock.SlashFunc: method is nil but StakingKeeper.Slash was just called")
	}
	callInfo := struct {
		Context     sdk.Context
		ConsAddress sdk.ConsAddress
		N1          int64
		N2          int64
		Dec         sdk.Dec
	}{
		Context:     context,
		ConsAddress: consAddress,
		N1:          n1,
		N2:          n2,
		Dec:         dec,
	}
	mock.lockSlash.Lock()
	mock.calls.Slash = append(mock.calls.Slash, callInfo)
	mock.lockSlash.Unlock()
	mock.SlashFunc(context, consAddress, n1, n2, dec)
}

// SlashCalls gets all the calls that were made to Slash.
// Check the length with:
//
//	len(mockedStakingKeeper.SlashCalls())
func (mock *StakingKeeperMock) SlashCalls() []struct {
	Context     sdk.Context
	ConsAddress sdk.ConsAddress
	N1          int64
	N2          int64
	Dec         sdk.Dec
} {
	var calls []struct {
		Context     sdk.Context
		ConsAddress sdk.ConsAddress
		N1          int64
		N2          int64
		Dec         sdk.Dec
	}
	mock.lockSlash.RLock()
	calls = mock.calls.Slash
	mock.lockSlash.RUnlock()
	return calls
}

// Unjail calls UnjailFunc.
func (mock *StakingKeeperMock) Unjail(context sdk.Context, consAddress sdk.ConsAddress) {
	if mock.UnjailFunc == nil {
		panic("StakingKeeperMock.UnjailFunc: method is nil but StakingKeeper.Unjail was just called")
	}
	callInfo := struct {
		Context     sdk.Context
		ConsAddress sdk.ConsAddress
	}{
		Context:     context,
		ConsAddress: consAddress,
	}
	mock.lockUnjail.Lock()
	mock.calls.Unjail = append(mock.calls.Unjail, callInfo)
	mock.lockUnjail.Unlock()
	mock.UnjailFunc(context, consAddress)
}

// UnjailCalls gets all the calls that were made to Unjail.
// Check the length with:
//
//	len(mockedStakingKeeper.UnjailCalls())
func (mock *StakingKeeperMock) UnjailCalls() []struct {
	Context     sdk.Context
	ConsAddress sdk.ConsAddress
} {
	var calls []struct {
		Context     sdk.Context
		ConsAddress sdk.ConsAddress
	}
	mock.lockUnjail.RLock()
	calls = mock.calls.Unjail
	mock.lockUnjail.RUnlock()
	return calls
}

// Validator calls ValidatorFunc.
func (mock *StakingKeeperMock) Validator(context sdk.Context, valAddress sdk.ValAddress) stakingtypes.ValidatorI {
	if mock.ValidatorFunc == nil {
		panic("StakingKeeperMock.ValidatorFunc: method is nil but StakingKeeper.Validator was just called")
	}
	callInfo := struct {
		Context    sdk.Context
		ValAddress sdk.ValAddress
	}{
		Context:    context,
		ValAddress: valAddress,
	}
	mock.lockValidator.Lock()
	mock.calls.Validator = append(mock.calls.Validator, callInfo)
	mock.lockValidator.Unlock()
	return mock.ValidatorFunc(context, valAddress)
}

// ValidatorCalls gets all the calls that were made to Validator.
// Check the length with:
//
//	len(mockedStakingKeeper.ValidatorCalls())
func (mock *StakingKeeperMock) ValidatorCalls() []struct {
	Context    sdk.Context
	ValAddress sdk.ValAddress
} {
	var calls []struct {
		Context    sdk.Context
		ValAddress sdk.ValAddress
	}
	mock.lockValidator.RLock()
	calls = mock.calls.Validator
	mock.lockValidator.RUnlock()
	return calls
}

// ValidatorByConsAddr calls ValidatorByConsAddrFunc.
func (mock *StakingKeeperMock) ValidatorByConsAddr(context sdk.Context, consAddress sdk.ConsAddress) stakingtypes.ValidatorI {
	if mock.ValidatorByConsAddrFunc == nil {
		panic("StakingKeeperMock.ValidatorByConsAddrFunc: method is nil but StakingKeeper.ValidatorByConsAddr was just called")
	}
	callInfo := struct {
		Context     sdk.Context
		ConsAddress sdk.ConsAddress
	}{
		Context:     context,
		ConsAddress: consAddress,
	}
	mock.lockValidatorByConsAddr.Lock()
	mock.calls.ValidatorByConsAddr = append(mock.calls.ValidatorByConsAddr, callInfo)
	mock.lockValidatorByConsAddr.Unlock()
	return mock.ValidatorByConsAddrFunc(context, consAddress)
}

// ValidatorByConsAddrCalls gets all the calls that were made to ValidatorByConsAddr.
// Check the length with:
//
//	len(mockedStakingKeeper.ValidatorByConsAddrCalls())
func (mock *StakingKeeperMock) ValidatorByConsAddrCalls() []struct {
	Context     sdk.Context
	ConsAddress sdk.ConsAddress
} {
	var calls []struct {
		Context     sdk.Context
		ConsAddress sdk.ConsAddress
	}
	mock.lockValidatorByConsAddr.RLock()
	calls = mock.calls.ValidatorByConsAddr
	mock.lockValidatorByConsAddr.RUnlock()
	return calls
}
