// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"cosmossdk.io/core/address"
	"github.com/axelarnetwork/axelar-core/x/distribution/types"
	sdk "github.com/cosmos/cosmos-sdk/types"
	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
	"sync"
)

// Ensure, that BankKeeperMock does implement types.BankKeeper.
// If this is not the case, regenerate this file with moq.
var _ types.BankKeeper = &BankKeeperMock{}

// BankKeeperMock is a mock implementation of types.BankKeeper.
//
//	func TestSomethingThatUsesBankKeeper(t *testing.T) {
//
//		// make and configure a mocked types.BankKeeper
//		mockedBankKeeper := &BankKeeperMock{
//			BlockedAddrFunc: func(addr sdk.AccAddress) bool {
//				panic("mock out the BlockedAddr method")
//			},
//			BurnCoinsFunc: func(ctx context.Context, moduleName string, amt sdk.Coins) error {
//				panic("mock out the BurnCoins method")
//			},
//			GetAllBalancesFunc: func(ctx context.Context, addr sdk.AccAddress) sdk.Coins {
//				panic("mock out the GetAllBalances method")
//			},
//			MintCoinsFunc: func(ctx context.Context, moduleName string, amt sdk.Coins) error {
//				panic("mock out the MintCoins method")
//			},
//			SendCoinsFromAccountToModuleFunc: func(ctx context.Context, senderAddr sdk.AccAddress, recipientModule string, amt sdk.Coins) error {
//				panic("mock out the SendCoinsFromAccountToModule method")
//			},
//			SendCoinsFromModuleToAccountFunc: func(ctx context.Context, senderModule string, recipientAddr sdk.AccAddress, amt sdk.Coins) error {
//				panic("mock out the SendCoinsFromModuleToAccount method")
//			},
//			SendCoinsFromModuleToModuleFunc: func(ctx context.Context, senderModule string, recipientModule string, amt sdk.Coins) error {
//				panic("mock out the SendCoinsFromModuleToModule method")
//			},
//			SpendableCoinsFunc: func(ctx context.Context, addr sdk.AccAddress) sdk.Coins {
//				panic("mock out the SpendableCoins method")
//			},
//		}
//
//		// use mockedBankKeeper in code that requires types.BankKeeper
//		// and then make assertions.
//
//	}
type BankKeeperMock struct {
	// BlockedAddrFunc mocks the BlockedAddr method.
	BlockedAddrFunc func(addr sdk.AccAddress) bool

	// BurnCoinsFunc mocks the BurnCoins method.
	BurnCoinsFunc func(ctx context.Context, moduleName string, amt sdk.Coins) error

	// GetAllBalancesFunc mocks the GetAllBalances method.
	GetAllBalancesFunc func(ctx context.Context, addr sdk.AccAddress) sdk.Coins

	// MintCoinsFunc mocks the MintCoins method.
	MintCoinsFunc func(ctx context.Context, moduleName string, amt sdk.Coins) error

	// SendCoinsFromAccountToModuleFunc mocks the SendCoinsFromAccountToModule method.
	SendCoinsFromAccountToModuleFunc func(ctx context.Context, senderAddr sdk.AccAddress, recipientModule string, amt sdk.Coins) error

	// SendCoinsFromModuleToAccountFunc mocks the SendCoinsFromModuleToAccount method.
	SendCoinsFromModuleToAccountFunc func(ctx context.Context, senderModule string, recipientAddr sdk.AccAddress, amt sdk.Coins) error

	// SendCoinsFromModuleToModuleFunc mocks the SendCoinsFromModuleToModule method.
	SendCoinsFromModuleToModuleFunc func(ctx context.Context, senderModule string, recipientModule string, amt sdk.Coins) error

	// SpendableCoinsFunc mocks the SpendableCoins method.
	SpendableCoinsFunc func(ctx context.Context, addr sdk.AccAddress) sdk.Coins

	// calls tracks calls to the methods.
	calls struct {
		// BlockedAddr holds details about calls to the BlockedAddr method.
		BlockedAddr []struct {
			// Addr is the addr argument value.
			Addr sdk.AccAddress
		}
		// BurnCoins holds details about calls to the BurnCoins method.
		BurnCoins []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ModuleName is the moduleName argument value.
			ModuleName string
			// Amt is the amt argument value.
			Amt sdk.Coins
		}
		// GetAllBalances holds details about calls to the GetAllBalances method.
		GetAllBalances []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Addr is the addr argument value.
			Addr sdk.AccAddress
		}
		// MintCoins holds details about calls to the MintCoins method.
		MintCoins []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ModuleName is the moduleName argument value.
			ModuleName string
			// Amt is the amt argument value.
			Amt sdk.Coins
		}
		// SendCoinsFromAccountToModule holds details about calls to the SendCoinsFromAccountToModule method.
		SendCoinsFromAccountToModule []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SenderAddr is the senderAddr argument value.
			SenderAddr sdk.AccAddress
			// RecipientModule is the recipientModule argument value.
			RecipientModule string
			// Amt is the amt argument value.
			Amt sdk.Coins
		}
		// SendCoinsFromModuleToAccount holds details about calls to the SendCoinsFromModuleToAccount method.
		SendCoinsFromModuleToAccount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SenderModule is the senderModule argument value.
			SenderModule string
			// RecipientAddr is the recipientAddr argument value.
			RecipientAddr sdk.AccAddress
			// Amt is the amt argument value.
			Amt sdk.Coins
		}
		// SendCoinsFromModuleToModule holds details about calls to the SendCoinsFromModuleToModule method.
		SendCoinsFromModuleToModule []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SenderModule is the senderModule argument value.
			SenderModule string
			// RecipientModule is the recipientModule argument value.
			RecipientModule string
			// Amt is the amt argument value.
			Amt sdk.Coins
		}
		// SpendableCoins holds details about calls to the SpendableCoins method.
		SpendableCoins []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Addr is the addr argument value.
			Addr sdk.AccAddress
		}
	}
	lockBlockedAddr                  sync.RWMutex
	lockBurnCoins                    sync.RWMutex
	lockGetAllBalances               sync.RWMutex
	lockMintCoins                    sync.RWMutex
	lockSendCoinsFromAccountToModule sync.RWMutex
	lockSendCoinsFromModuleToAccount sync.RWMutex
	lockSendCoinsFromModuleToModule  sync.RWMutex
	lockSpendableCoins               sync.RWMutex
}

// BlockedAddr calls BlockedAddrFunc.
func (mock *BankKeeperMock) BlockedAddr(addr sdk.AccAddress) bool {
	if mock.BlockedAddrFunc == nil {
		panic("BankKeeperMock.BlockedAddrFunc: method is nil but BankKeeper.BlockedAddr was just called")
	}
	callInfo := struct {
		Addr sdk.AccAddress
	}{
		Addr: addr,
	}
	mock.lockBlockedAddr.Lock()
	mock.calls.BlockedAddr = append(mock.calls.BlockedAddr, callInfo)
	mock.lockBlockedAddr.Unlock()
	return mock.BlockedAddrFunc(addr)
}

// BlockedAddrCalls gets all the calls that were made to BlockedAddr.
// Check the length with:
//
//	len(mockedBankKeeper.BlockedAddrCalls())
func (mock *BankKeeperMock) BlockedAddrCalls() []struct {
	Addr sdk.AccAddress
} {
	var calls []struct {
		Addr sdk.AccAddress
	}
	mock.lockBlockedAddr.RLock()
	calls = mock.calls.BlockedAddr
	mock.lockBlockedAddr.RUnlock()
	return calls
}

// BurnCoins calls BurnCoinsFunc.
func (mock *BankKeeperMock) BurnCoins(ctx context.Context, moduleName string, amt sdk.Coins) error {
	if mock.BurnCoinsFunc == nil {
		panic("BankKeeperMock.BurnCoinsFunc: method is nil but BankKeeper.BurnCoins was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		ModuleName string
		Amt        sdk.Coins
	}{
		Ctx:        ctx,
		ModuleName: moduleName,
		Amt:        amt,
	}
	mock.lockBurnCoins.Lock()
	mock.calls.BurnCoins = append(mock.calls.BurnCoins, callInfo)
	mock.lockBurnCoins.Unlock()
	return mock.BurnCoinsFunc(ctx, moduleName, amt)
}

// BurnCoinsCalls gets all the calls that were made to BurnCoins.
// Check the length with:
//
//	len(mockedBankKeeper.BurnCoinsCalls())
func (mock *BankKeeperMock) BurnCoinsCalls() []struct {
	Ctx        context.Context
	ModuleName string
	Amt        sdk.Coins
} {
	var calls []struct {
		Ctx        context.Context
		ModuleName string
		Amt        sdk.Coins
	}
	mock.lockBurnCoins.RLock()
	calls = mock.calls.BurnCoins
	mock.lockBurnCoins.RUnlock()
	return calls
}

// GetAllBalances calls GetAllBalancesFunc.
func (mock *BankKeeperMock) GetAllBalances(ctx context.Context, addr sdk.AccAddress) sdk.Coins {
	if mock.GetAllBalancesFunc == nil {
		panic("BankKeeperMock.GetAllBalancesFunc: method is nil but BankKeeper.GetAllBalances was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Addr sdk.AccAddress
	}{
		Ctx:  ctx,
		Addr: addr,
	}
	mock.lockGetAllBalances.Lock()
	mock.calls.GetAllBalances = append(mock.calls.GetAllBalances, callInfo)
	mock.lockGetAllBalances.Unlock()
	return mock.GetAllBalancesFunc(ctx, addr)
}

// GetAllBalancesCalls gets all the calls that were made to GetAllBalances.
// Check the length with:
//
//	len(mockedBankKeeper.GetAllBalancesCalls())
func (mock *BankKeeperMock) GetAllBalancesCalls() []struct {
	Ctx  context.Context
	Addr sdk.AccAddress
} {
	var calls []struct {
		Ctx  context.Context
		Addr sdk.AccAddress
	}
	mock.lockGetAllBalances.RLock()
	calls = mock.calls.GetAllBalances
	mock.lockGetAllBalances.RUnlock()
	return calls
}

// MintCoins calls MintCoinsFunc.
func (mock *BankKeeperMock) MintCoins(ctx context.Context, moduleName string, amt sdk.Coins) error {
	if mock.MintCoinsFunc == nil {
		panic("BankKeeperMock.MintCoinsFunc: method is nil but BankKeeper.MintCoins was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		ModuleName string
		Amt        sdk.Coins
	}{
		Ctx:        ctx,
		ModuleName: moduleName,
		Amt:        amt,
	}
	mock.lockMintCoins.Lock()
	mock.calls.MintCoins = append(mock.calls.MintCoins, callInfo)
	mock.lockMintCoins.Unlock()
	return mock.MintCoinsFunc(ctx, moduleName, amt)
}

// MintCoinsCalls gets all the calls that were made to MintCoins.
// Check the length with:
//
//	len(mockedBankKeeper.MintCoinsCalls())
func (mock *BankKeeperMock) MintCoinsCalls() []struct {
	Ctx        context.Context
	ModuleName string
	Amt        sdk.Coins
} {
	var calls []struct {
		Ctx        context.Context
		ModuleName string
		Amt        sdk.Coins
	}
	mock.lockMintCoins.RLock()
	calls = mock.calls.MintCoins
	mock.lockMintCoins.RUnlock()
	return calls
}

// SendCoinsFromAccountToModule calls SendCoinsFromAccountToModuleFunc.
func (mock *BankKeeperMock) SendCoinsFromAccountToModule(ctx context.Context, senderAddr sdk.AccAddress, recipientModule string, amt sdk.Coins) error {
	if mock.SendCoinsFromAccountToModuleFunc == nil {
		panic("BankKeeperMock.SendCoinsFromAccountToModuleFunc: method is nil but BankKeeper.SendCoinsFromAccountToModule was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		SenderAddr      sdk.AccAddress
		RecipientModule string
		Amt             sdk.Coins
	}{
		Ctx:             ctx,
		SenderAddr:      senderAddr,
		RecipientModule: recipientModule,
		Amt:             amt,
	}
	mock.lockSendCoinsFromAccountToModule.Lock()
	mock.calls.SendCoinsFromAccountToModule = append(mock.calls.SendCoinsFromAccountToModule, callInfo)
	mock.lockSendCoinsFromAccountToModule.Unlock()
	return mock.SendCoinsFromAccountToModuleFunc(ctx, senderAddr, recipientModule, amt)
}

// SendCoinsFromAccountToModuleCalls gets all the calls that were made to SendCoinsFromAccountToModule.
// Check the length with:
//
//	len(mockedBankKeeper.SendCoinsFromAccountToModuleCalls())
func (mock *BankKeeperMock) SendCoinsFromAccountToModuleCalls() []struct {
	Ctx             context.Context
	SenderAddr      sdk.AccAddress
	RecipientModule string
	Amt             sdk.Coins
} {
	var calls []struct {
		Ctx             context.Context
		SenderAddr      sdk.AccAddress
		RecipientModule string
		Amt             sdk.Coins
	}
	mock.lockSendCoinsFromAccountToModule.RLock()
	calls = mock.calls.SendCoinsFromAccountToModule
	mock.lockSendCoinsFromAccountToModule.RUnlock()
	return calls
}

// SendCoinsFromModuleToAccount calls SendCoinsFromModuleToAccountFunc.
func (mock *BankKeeperMock) SendCoinsFromModuleToAccount(ctx context.Context, senderModule string, recipientAddr sdk.AccAddress, amt sdk.Coins) error {
	if mock.SendCoinsFromModuleToAccountFunc == nil {
		panic("BankKeeperMock.SendCoinsFromModuleToAccountFunc: method is nil but BankKeeper.SendCoinsFromModuleToAccount was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		SenderModule  string
		RecipientAddr sdk.AccAddress
		Amt           sdk.Coins
	}{
		Ctx:           ctx,
		SenderModule:  senderModule,
		RecipientAddr: recipientAddr,
		Amt:           amt,
	}
	mock.lockSendCoinsFromModuleToAccount.Lock()
	mock.calls.SendCoinsFromModuleToAccount = append(mock.calls.SendCoinsFromModuleToAccount, callInfo)
	mock.lockSendCoinsFromModuleToAccount.Unlock()
	return mock.SendCoinsFromModuleToAccountFunc(ctx, senderModule, recipientAddr, amt)
}

// SendCoinsFromModuleToAccountCalls gets all the calls that were made to SendCoinsFromModuleToAccount.
// Check the length with:
//
//	len(mockedBankKeeper.SendCoinsFromModuleToAccountCalls())
func (mock *BankKeeperMock) SendCoinsFromModuleToAccountCalls() []struct {
	Ctx           context.Context
	SenderModule  string
	RecipientAddr sdk.AccAddress
	Amt           sdk.Coins
} {
	var calls []struct {
		Ctx           context.Context
		SenderModule  string
		RecipientAddr sdk.AccAddress
		Amt           sdk.Coins
	}
	mock.lockSendCoinsFromModuleToAccount.RLock()
	calls = mock.calls.SendCoinsFromModuleToAccount
	mock.lockSendCoinsFromModuleToAccount.RUnlock()
	return calls
}

// SendCoinsFromModuleToModule calls SendCoinsFromModuleToModuleFunc.
func (mock *BankKeeperMock) SendCoinsFromModuleToModule(ctx context.Context, senderModule string, recipientModule string, amt sdk.Coins) error {
	if mock.SendCoinsFromModuleToModuleFunc == nil {
		panic("BankKeeperMock.SendCoinsFromModuleToModuleFunc: method is nil but BankKeeper.SendCoinsFromModuleToModule was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		SenderModule    string
		RecipientModule string
		Amt             sdk.Coins
	}{
		Ctx:             ctx,
		SenderModule:    senderModule,
		RecipientModule: recipientModule,
		Amt:             amt,
	}
	mock.lockSendCoinsFromModuleToModule.Lock()
	mock.calls.SendCoinsFromModuleToModule = append(mock.calls.SendCoinsFromModuleToModule, callInfo)
	mock.lockSendCoinsFromModuleToModule.Unlock()
	return mock.SendCoinsFromModuleToModuleFunc(ctx, senderModule, recipientModule, amt)
}

// SendCoinsFromModuleToModuleCalls gets all the calls that were made to SendCoinsFromModuleToModule.
// Check the length with:
//
//	len(mockedBankKeeper.SendCoinsFromModuleToModuleCalls())
func (mock *BankKeeperMock) SendCoinsFromModuleToModuleCalls() []struct {
	Ctx             context.Context
	SenderModule    string
	RecipientModule string
	Amt             sdk.Coins
} {
	var calls []struct {
		Ctx             context.Context
		SenderModule    string
		RecipientModule string
		Amt             sdk.Coins
	}
	mock.lockSendCoinsFromModuleToModule.RLock()
	calls = mock.calls.SendCoinsFromModuleToModule
	mock.lockSendCoinsFromModuleToModule.RUnlock()
	return calls
}

// SpendableCoins calls SpendableCoinsFunc.
func (mock *BankKeeperMock) SpendableCoins(ctx context.Context, addr sdk.AccAddress) sdk.Coins {
	if mock.SpendableCoinsFunc == nil {
		panic("BankKeeperMock.SpendableCoinsFunc: method is nil but BankKeeper.SpendableCoins was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Addr sdk.AccAddress
	}{
		Ctx:  ctx,
		Addr: addr,
	}
	mock.lockSpendableCoins.Lock()
	mock.calls.SpendableCoins = append(mock.calls.SpendableCoins, callInfo)
	mock.lockSpendableCoins.Unlock()
	return mock.SpendableCoinsFunc(ctx, addr)
}

// SpendableCoinsCalls gets all the calls that were made to SpendableCoins.
// Check the length with:
//
//	len(mockedBankKeeper.SpendableCoinsCalls())
func (mock *BankKeeperMock) SpendableCoinsCalls() []struct {
	Ctx  context.Context
	Addr sdk.AccAddress
} {
	var calls []struct {
		Ctx  context.Context
		Addr sdk.AccAddress
	}
	mock.lockSpendableCoins.RLock()
	calls = mock.calls.SpendableCoins
	mock.lockSpendableCoins.RUnlock()
	return calls
}

// Ensure, that AccountKeeperMock does implement types.AccountKeeper.
// If this is not the case, regenerate this file with moq.
var _ types.AccountKeeper = &AccountKeeperMock{}

// AccountKeeperMock is a mock implementation of types.AccountKeeper.
//
//	func TestSomethingThatUsesAccountKeeper(t *testing.T) {
//
//		// make and configure a mocked types.AccountKeeper
//		mockedAccountKeeper := &AccountKeeperMock{
//			AddressCodecFunc: func() address.Codec {
//				panic("mock out the AddressCodec method")
//			},
//			GetAccountFunc: func(ctx context.Context, addr sdk.AccAddress) sdk.AccountI {
//				panic("mock out the GetAccount method")
//			},
//			GetModuleAccountFunc: func(ctx context.Context, name string) sdk.ModuleAccountI {
//				panic("mock out the GetModuleAccount method")
//			},
//			GetModuleAddressFunc: func(name string) sdk.AccAddress {
//				panic("mock out the GetModuleAddress method")
//			},
//			SetModuleAccountFunc: func(contextMoqParam context.Context, moduleAccountI sdk.ModuleAccountI)  {
//				panic("mock out the SetModuleAccount method")
//			},
//		}
//
//		// use mockedAccountKeeper in code that requires types.AccountKeeper
//		// and then make assertions.
//
//	}
type AccountKeeperMock struct {
	// AddressCodecFunc mocks the AddressCodec method.
	AddressCodecFunc func() address.Codec

	// GetAccountFunc mocks the GetAccount method.
	GetAccountFunc func(ctx context.Context, addr sdk.AccAddress) sdk.AccountI

	// GetModuleAccountFunc mocks the GetModuleAccount method.
	GetModuleAccountFunc func(ctx context.Context, name string) sdk.ModuleAccountI

	// GetModuleAddressFunc mocks the GetModuleAddress method.
	GetModuleAddressFunc func(name string) sdk.AccAddress

	// SetModuleAccountFunc mocks the SetModuleAccount method.
	SetModuleAccountFunc func(contextMoqParam context.Context, moduleAccountI sdk.ModuleAccountI)

	// calls tracks calls to the methods.
	calls struct {
		// AddressCodec holds details about calls to the AddressCodec method.
		AddressCodec []struct {
		}
		// GetAccount holds details about calls to the GetAccount method.
		GetAccount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Addr is the addr argument value.
			Addr sdk.AccAddress
		}
		// GetModuleAccount holds details about calls to the GetModuleAccount method.
		GetModuleAccount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
		}
		// GetModuleAddress holds details about calls to the GetModuleAddress method.
		GetModuleAddress []struct {
			// Name is the name argument value.
			Name string
		}
		// SetModuleAccount holds details about calls to the SetModuleAccount method.
		SetModuleAccount []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// ModuleAccountI is the moduleAccountI argument value.
			ModuleAccountI sdk.ModuleAccountI
		}
	}
	lockAddressCodec     sync.RWMutex
	lockGetAccount       sync.RWMutex
	lockGetModuleAccount sync.RWMutex
	lockGetModuleAddress sync.RWMutex
	lockSetModuleAccount sync.RWMutex
}

// AddressCodec calls AddressCodecFunc.
func (mock *AccountKeeperMock) AddressCodec() address.Codec {
	if mock.AddressCodecFunc == nil {
		panic("AccountKeeperMock.AddressCodecFunc: method is nil but AccountKeeper.AddressCodec was just called")
	}
	callInfo := struct {
	}{}
	mock.lockAddressCodec.Lock()
	mock.calls.AddressCodec = append(mock.calls.AddressCodec, callInfo)
	mock.lockAddressCodec.Unlock()
	return mock.AddressCodecFunc()
}

// AddressCodecCalls gets all the calls that were made to AddressCodec.
// Check the length with:
//
//	len(mockedAccountKeeper.AddressCodecCalls())
func (mock *AccountKeeperMock) AddressCodecCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockAddressCodec.RLock()
	calls = mock.calls.AddressCodec
	mock.lockAddressCodec.RUnlock()
	return calls
}

// GetAccount calls GetAccountFunc.
func (mock *AccountKeeperMock) GetAccount(ctx context.Context, addr sdk.AccAddress) sdk.AccountI {
	if mock.GetAccountFunc == nil {
		panic("AccountKeeperMock.GetAccountFunc: method is nil but AccountKeeper.GetAccount was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Addr sdk.AccAddress
	}{
		Ctx:  ctx,
		Addr: addr,
	}
	mock.lockGetAccount.Lock()
	mock.calls.GetAccount = append(mock.calls.GetAccount, callInfo)
	mock.lockGetAccount.Unlock()
	return mock.GetAccountFunc(ctx, addr)
}

// GetAccountCalls gets all the calls that were made to GetAccount.
// Check the length with:
//
//	len(mockedAccountKeeper.GetAccountCalls())
func (mock *AccountKeeperMock) GetAccountCalls() []struct {
	Ctx  context.Context
	Addr sdk.AccAddress
} {
	var calls []struct {
		Ctx  context.Context
		Addr sdk.AccAddress
	}
	mock.lockGetAccount.RLock()
	calls = mock.calls.GetAccount
	mock.lockGetAccount.RUnlock()
	return calls
}

// GetModuleAccount calls GetModuleAccountFunc.
func (mock *AccountKeeperMock) GetModuleAccount(ctx context.Context, name string) sdk.ModuleAccountI {
	if mock.GetModuleAccountFunc == nil {
		panic("AccountKeeperMock.GetModuleAccountFunc: method is nil but AccountKeeper.GetModuleAccount was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockGetModuleAccount.Lock()
	mock.calls.GetModuleAccount = append(mock.calls.GetModuleAccount, callInfo)
	mock.lockGetModuleAccount.Unlock()
	return mock.GetModuleAccountFunc(ctx, name)
}

// GetModuleAccountCalls gets all the calls that were made to GetModuleAccount.
// Check the length with:
//
//	len(mockedAccountKeeper.GetModuleAccountCalls())
func (mock *AccountKeeperMock) GetModuleAccountCalls() []struct {
	Ctx  context.Context
	Name string
} {
	var calls []struct {
		Ctx  context.Context
		Name string
	}
	mock.lockGetModuleAccount.RLock()
	calls = mock.calls.GetModuleAccount
	mock.lockGetModuleAccount.RUnlock()
	return calls
}

// GetModuleAddress calls GetModuleAddressFunc.
func (mock *AccountKeeperMock) GetModuleAddress(name string) sdk.AccAddress {
	if mock.GetModuleAddressFunc == nil {
		panic("AccountKeeperMock.GetModuleAddressFunc: method is nil but AccountKeeper.GetModuleAddress was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockGetModuleAddress.Lock()
	mock.calls.GetModuleAddress = append(mock.calls.GetModuleAddress, callInfo)
	mock.lockGetModuleAddress.Unlock()
	return mock.GetModuleAddressFunc(name)
}

// GetModuleAddressCalls gets all the calls that were made to GetModuleAddress.
// Check the length with:
//
//	len(mockedAccountKeeper.GetModuleAddressCalls())
func (mock *AccountKeeperMock) GetModuleAddressCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockGetModuleAddress.RLock()
	calls = mock.calls.GetModuleAddress
	mock.lockGetModuleAddress.RUnlock()
	return calls
}

// SetModuleAccount calls SetModuleAccountFunc.
func (mock *AccountKeeperMock) SetModuleAccount(contextMoqParam context.Context, moduleAccountI sdk.ModuleAccountI) {
	if mock.SetModuleAccountFunc == nil {
		panic("AccountKeeperMock.SetModuleAccountFunc: method is nil but AccountKeeper.SetModuleAccount was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		ModuleAccountI  sdk.ModuleAccountI
	}{
		ContextMoqParam: contextMoqParam,
		ModuleAccountI:  moduleAccountI,
	}
	mock.lockSetModuleAccount.Lock()
	mock.calls.SetModuleAccount = append(mock.calls.SetModuleAccount, callInfo)
	mock.lockSetModuleAccount.Unlock()
	mock.SetModuleAccountFunc(contextMoqParam, moduleAccountI)
}

// SetModuleAccountCalls gets all the calls that were made to SetModuleAccount.
// Check the length with:
//
//	len(mockedAccountKeeper.SetModuleAccountCalls())
func (mock *AccountKeeperMock) SetModuleAccountCalls() []struct {
	ContextMoqParam context.Context
	ModuleAccountI  sdk.ModuleAccountI
} {
	var calls []struct {
		ContextMoqParam context.Context
		ModuleAccountI  sdk.ModuleAccountI
	}
	mock.lockSetModuleAccount.RLock()
	calls = mock.calls.SetModuleAccount
	mock.lockSetModuleAccount.RUnlock()
	return calls
}

// Ensure, that StakingKeeperMock does implement types.StakingKeeper.
// If this is not the case, regenerate this file with moq.
var _ types.StakingKeeper = &StakingKeeperMock{}

// StakingKeeperMock is a mock implementation of types.StakingKeeper.
//
//	func TestSomethingThatUsesStakingKeeper(t *testing.T) {
//
//		// make and configure a mocked types.StakingKeeper
//		mockedStakingKeeper := &StakingKeeperMock{
//			ConsensusAddressCodecFunc: func() address.Codec {
//				panic("mock out the ConsensusAddressCodec method")
//			},
//			DelegationFunc: func(contextMoqParam context.Context, accAddress sdk.AccAddress, valAddress sdk.ValAddress) (stakingtypes.DelegationI, error) {
//				panic("mock out the Delegation method")
//			},
//			GetAllDelegatorDelegationsFunc: func(ctx context.Context, delegator sdk.AccAddress) ([]stakingtypes.Delegation, error) {
//				panic("mock out the GetAllDelegatorDelegations method")
//			},
//			GetAllSDKDelegationsFunc: func(ctx context.Context) ([]stakingtypes.Delegation, error) {
//				panic("mock out the GetAllSDKDelegations method")
//			},
//			GetAllValidatorsFunc: func(ctx context.Context) ([]stakingtypes.Validator, error) {
//				panic("mock out the GetAllValidators method")
//			},
//			IterateDelegationsFunc: func(ctx context.Context, delegator sdk.AccAddress, fn func(index int64, delegation stakingtypes.DelegationI) (stop bool)) error {
//				panic("mock out the IterateDelegations method")
//			},
//			IterateValidatorsFunc: func(contextMoqParam context.Context, fn func(index int64, validator stakingtypes.ValidatorI) (stop bool)) error {
//				panic("mock out the IterateValidators method")
//			},
//			ValidatorFunc: func(contextMoqParam context.Context, valAddress sdk.ValAddress) (stakingtypes.ValidatorI, error) {
//				panic("mock out the Validator method")
//			},
//			ValidatorAddressCodecFunc: func() address.Codec {
//				panic("mock out the ValidatorAddressCodec method")
//			},
//			ValidatorByConsAddrFunc: func(contextMoqParam context.Context, consAddress sdk.ConsAddress) (stakingtypes.ValidatorI, error) {
//				panic("mock out the ValidatorByConsAddr method")
//			},
//		}
//
//		// use mockedStakingKeeper in code that requires types.StakingKeeper
//		// and then make assertions.
//
//	}
type StakingKeeperMock struct {
	// ConsensusAddressCodecFunc mocks the ConsensusAddressCodec method.
	ConsensusAddressCodecFunc func() address.Codec

	// DelegationFunc mocks the Delegation method.
	DelegationFunc func(contextMoqParam context.Context, accAddress sdk.AccAddress, valAddress sdk.ValAddress) (stakingtypes.DelegationI, error)

	// GetAllDelegatorDelegationsFunc mocks the GetAllDelegatorDelegations method.
	GetAllDelegatorDelegationsFunc func(ctx context.Context, delegator sdk.AccAddress) ([]stakingtypes.Delegation, error)

	// GetAllSDKDelegationsFunc mocks the GetAllSDKDelegations method.
	GetAllSDKDelegationsFunc func(ctx context.Context) ([]stakingtypes.Delegation, error)

	// GetAllValidatorsFunc mocks the GetAllValidators method.
	GetAllValidatorsFunc func(ctx context.Context) ([]stakingtypes.Validator, error)

	// IterateDelegationsFunc mocks the IterateDelegations method.
	IterateDelegationsFunc func(ctx context.Context, delegator sdk.AccAddress, fn func(index int64, delegation stakingtypes.DelegationI) (stop bool)) error

	// IterateValidatorsFunc mocks the IterateValidators method.
	IterateValidatorsFunc func(contextMoqParam context.Context, fn func(index int64, validator stakingtypes.ValidatorI) (stop bool)) error

	// ValidatorFunc mocks the Validator method.
	ValidatorFunc func(contextMoqParam context.Context, valAddress sdk.ValAddress) (stakingtypes.ValidatorI, error)

	// ValidatorAddressCodecFunc mocks the ValidatorAddressCodec method.
	ValidatorAddressCodecFunc func() address.Codec

	// ValidatorByConsAddrFunc mocks the ValidatorByConsAddr method.
	ValidatorByConsAddrFunc func(contextMoqParam context.Context, consAddress sdk.ConsAddress) (stakingtypes.ValidatorI, error)

	// calls tracks calls to the methods.
	calls struct {
		// ConsensusAddressCodec holds details about calls to the ConsensusAddressCodec method.
		ConsensusAddressCodec []struct {
		}
		// Delegation holds details about calls to the Delegation method.
		Delegation []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// AccAddress is the accAddress argument value.
			AccAddress sdk.AccAddress
			// ValAddress is the valAddress argument value.
			ValAddress sdk.ValAddress
		}
		// GetAllDelegatorDelegations holds details about calls to the GetAllDelegatorDelegations method.
		GetAllDelegatorDelegations []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Delegator is the delegator argument value.
			Delegator sdk.AccAddress
		}
		// GetAllSDKDelegations holds details about calls to the GetAllSDKDelegations method.
		GetAllSDKDelegations []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetAllValidators holds details about calls to the GetAllValidators method.
		GetAllValidators []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// IterateDelegations holds details about calls to the IterateDelegations method.
		IterateDelegations []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Delegator is the delegator argument value.
			Delegator sdk.AccAddress
			// Fn is the fn argument value.
			Fn func(index int64, delegation stakingtypes.DelegationI) (stop bool)
		}
		// IterateValidators holds details about calls to the IterateValidators method.
		IterateValidators []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// Fn is the fn argument value.
			Fn func(index int64, validator stakingtypes.ValidatorI) (stop bool)
		}
		// Validator holds details about calls to the Validator method.
		Validator []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// ValAddress is the valAddress argument value.
			ValAddress sdk.ValAddress
		}
		// ValidatorAddressCodec holds details about calls to the ValidatorAddressCodec method.
		ValidatorAddressCodec []struct {
		}
		// ValidatorByConsAddr holds details about calls to the ValidatorByConsAddr method.
		ValidatorByConsAddr []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// ConsAddress is the consAddress argument value.
			ConsAddress sdk.ConsAddress
		}
	}
	lockConsensusAddressCodec      sync.RWMutex
	lockDelegation                 sync.RWMutex
	lockGetAllDelegatorDelegations sync.RWMutex
	lockGetAllSDKDelegations       sync.RWMutex
	lockGetAllValidators           sync.RWMutex
	lockIterateDelegations         sync.RWMutex
	lockIterateValidators          sync.RWMutex
	lockValidator                  sync.RWMutex
	lockValidatorAddressCodec      sync.RWMutex
	lockValidatorByConsAddr        sync.RWMutex
}

// ConsensusAddressCodec calls ConsensusAddressCodecFunc.
func (mock *StakingKeeperMock) ConsensusAddressCodec() address.Codec {
	if mock.ConsensusAddressCodecFunc == nil {
		panic("StakingKeeperMock.ConsensusAddressCodecFunc: method is nil but StakingKeeper.ConsensusAddressCodec was just called")
	}
	callInfo := struct {
	}{}
	mock.lockConsensusAddressCodec.Lock()
	mock.calls.ConsensusAddressCodec = append(mock.calls.ConsensusAddressCodec, callInfo)
	mock.lockConsensusAddressCodec.Unlock()
	return mock.ConsensusAddressCodecFunc()
}

// ConsensusAddressCodecCalls gets all the calls that were made to ConsensusAddressCodec.
// Check the length with:
//
//	len(mockedStakingKeeper.ConsensusAddressCodecCalls())
func (mock *StakingKeeperMock) ConsensusAddressCodecCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockConsensusAddressCodec.RLock()
	calls = mock.calls.ConsensusAddressCodec
	mock.lockConsensusAddressCodec.RUnlock()
	return calls
}

// Delegation calls DelegationFunc.
func (mock *StakingKeeperMock) Delegation(contextMoqParam context.Context, accAddress sdk.AccAddress, valAddress sdk.ValAddress) (stakingtypes.DelegationI, error) {
	if mock.DelegationFunc == nil {
		panic("StakingKeeperMock.DelegationFunc: method is nil but StakingKeeper.Delegation was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		AccAddress      sdk.AccAddress
		ValAddress      sdk.ValAddress
	}{
		ContextMoqParam: contextMoqParam,
		AccAddress:      accAddress,
		ValAddress:      valAddress,
	}
	mock.lockDelegation.Lock()
	mock.calls.Delegation = append(mock.calls.Delegation, callInfo)
	mock.lockDelegation.Unlock()
	return mock.DelegationFunc(contextMoqParam, accAddress, valAddress)
}

// DelegationCalls gets all the calls that were made to Delegation.
// Check the length with:
//
//	len(mockedStakingKeeper.DelegationCalls())
func (mock *StakingKeeperMock) DelegationCalls() []struct {
	ContextMoqParam context.Context
	AccAddress      sdk.AccAddress
	ValAddress      sdk.ValAddress
} {
	var calls []struct {
		ContextMoqParam context.Context
		AccAddress      sdk.AccAddress
		ValAddress      sdk.ValAddress
	}
	mock.lockDelegation.RLock()
	calls = mock.calls.Delegation
	mock.lockDelegation.RUnlock()
	return calls
}

// GetAllDelegatorDelegations calls GetAllDelegatorDelegationsFunc.
func (mock *StakingKeeperMock) GetAllDelegatorDelegations(ctx context.Context, delegator sdk.AccAddress) ([]stakingtypes.Delegation, error) {
	if mock.GetAllDelegatorDelegationsFunc == nil {
		panic("StakingKeeperMock.GetAllDelegatorDelegationsFunc: method is nil but StakingKeeper.GetAllDelegatorDelegations was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Delegator sdk.AccAddress
	}{
		Ctx:       ctx,
		Delegator: delegator,
	}
	mock.lockGetAllDelegatorDelegations.Lock()
	mock.calls.GetAllDelegatorDelegations = append(mock.calls.GetAllDelegatorDelegations, callInfo)
	mock.lockGetAllDelegatorDelegations.Unlock()
	return mock.GetAllDelegatorDelegationsFunc(ctx, delegator)
}

// GetAllDelegatorDelegationsCalls gets all the calls that were made to GetAllDelegatorDelegations.
// Check the length with:
//
//	len(mockedStakingKeeper.GetAllDelegatorDelegationsCalls())
func (mock *StakingKeeperMock) GetAllDelegatorDelegationsCalls() []struct {
	Ctx       context.Context
	Delegator sdk.AccAddress
} {
	var calls []struct {
		Ctx       context.Context
		Delegator sdk.AccAddress
	}
	mock.lockGetAllDelegatorDelegations.RLock()
	calls = mock.calls.GetAllDelegatorDelegations
	mock.lockGetAllDelegatorDelegations.RUnlock()
	return calls
}

// GetAllSDKDelegations calls GetAllSDKDelegationsFunc.
func (mock *StakingKeeperMock) GetAllSDKDelegations(ctx context.Context) ([]stakingtypes.Delegation, error) {
	if mock.GetAllSDKDelegationsFunc == nil {
		panic("StakingKeeperMock.GetAllSDKDelegationsFunc: method is nil but StakingKeeper.GetAllSDKDelegations was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAllSDKDelegations.Lock()
	mock.calls.GetAllSDKDelegations = append(mock.calls.GetAllSDKDelegations, callInfo)
	mock.lockGetAllSDKDelegations.Unlock()
	return mock.GetAllSDKDelegationsFunc(ctx)
}

// GetAllSDKDelegationsCalls gets all the calls that were made to GetAllSDKDelegations.
// Check the length with:
//
//	len(mockedStakingKeeper.GetAllSDKDelegationsCalls())
func (mock *StakingKeeperMock) GetAllSDKDelegationsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetAllSDKDelegations.RLock()
	calls = mock.calls.GetAllSDKDelegations
	mock.lockGetAllSDKDelegations.RUnlock()
	return calls
}

// GetAllValidators calls GetAllValidatorsFunc.
func (mock *StakingKeeperMock) GetAllValidators(ctx context.Context) ([]stakingtypes.Validator, error) {
	if mock.GetAllValidatorsFunc == nil {
		panic("StakingKeeperMock.GetAllValidatorsFunc: method is nil but StakingKeeper.GetAllValidators was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAllValidators.Lock()
	mock.calls.GetAllValidators = append(mock.calls.GetAllValidators, callInfo)
	mock.lockGetAllValidators.Unlock()
	return mock.GetAllValidatorsFunc(ctx)
}

// GetAllValidatorsCalls gets all the calls that were made to GetAllValidators.
// Check the length with:
//
//	len(mockedStakingKeeper.GetAllValidatorsCalls())
func (mock *StakingKeeperMock) GetAllValidatorsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetAllValidators.RLock()
	calls = mock.calls.GetAllValidators
	mock.lockGetAllValidators.RUnlock()
	return calls
}

// IterateDelegations calls IterateDelegationsFunc.
func (mock *StakingKeeperMock) IterateDelegations(ctx context.Context, delegator sdk.AccAddress, fn func(index int64, delegation stakingtypes.DelegationI) (stop bool)) error {
	if mock.IterateDelegationsFunc == nil {
		panic("StakingKeeperMock.IterateDelegationsFunc: method is nil but StakingKeeper.IterateDelegations was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Delegator sdk.AccAddress
		Fn        func(index int64, delegation stakingtypes.DelegationI) (stop bool)
	}{
		Ctx:       ctx,
		Delegator: delegator,
		Fn:        fn,
	}
	mock.lockIterateDelegations.Lock()
	mock.calls.IterateDelegations = append(mock.calls.IterateDelegations, callInfo)
	mock.lockIterateDelegations.Unlock()
	return mock.IterateDelegationsFunc(ctx, delegator, fn)
}

// IterateDelegationsCalls gets all the calls that were made to IterateDelegations.
// Check the length with:
//
//	len(mockedStakingKeeper.IterateDelegationsCalls())
func (mock *StakingKeeperMock) IterateDelegationsCalls() []struct {
	Ctx       context.Context
	Delegator sdk.AccAddress
	Fn        func(index int64, delegation stakingtypes.DelegationI) (stop bool)
} {
	var calls []struct {
		Ctx       context.Context
		Delegator sdk.AccAddress
		Fn        func(index int64, delegation stakingtypes.DelegationI) (stop bool)
	}
	mock.lockIterateDelegations.RLock()
	calls = mock.calls.IterateDelegations
	mock.lockIterateDelegations.RUnlock()
	return calls
}

// IterateValidators calls IterateValidatorsFunc.
func (mock *StakingKeeperMock) IterateValidators(contextMoqParam context.Context, fn func(index int64, validator stakingtypes.ValidatorI) (stop bool)) error {
	if mock.IterateValidatorsFunc == nil {
		panic("StakingKeeperMock.IterateValidatorsFunc: method is nil but StakingKeeper.IterateValidators was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		Fn              func(index int64, validator stakingtypes.ValidatorI) (stop bool)
	}{
		ContextMoqParam: contextMoqParam,
		Fn:              fn,
	}
	mock.lockIterateValidators.Lock()
	mock.calls.IterateValidators = append(mock.calls.IterateValidators, callInfo)
	mock.lockIterateValidators.Unlock()
	return mock.IterateValidatorsFunc(contextMoqParam, fn)
}

// IterateValidatorsCalls gets all the calls that were made to IterateValidators.
// Check the length with:
//
//	len(mockedStakingKeeper.IterateValidatorsCalls())
func (mock *StakingKeeperMock) IterateValidatorsCalls() []struct {
	ContextMoqParam context.Context
	Fn              func(index int64, validator stakingtypes.ValidatorI) (stop bool)
} {
	var calls []struct {
		ContextMoqParam context.Context
		Fn              func(index int64, validator stakingtypes.ValidatorI) (stop bool)
	}
	mock.lockIterateValidators.RLock()
	calls = mock.calls.IterateValidators
	mock.lockIterateValidators.RUnlock()
	return calls
}

// Validator calls ValidatorFunc.
func (mock *StakingKeeperMock) Validator(contextMoqParam context.Context, valAddress sdk.ValAddress) (stakingtypes.ValidatorI, error) {
	if mock.ValidatorFunc == nil {
		panic("StakingKeeperMock.ValidatorFunc: method is nil but StakingKeeper.Validator was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		ValAddress      sdk.ValAddress
	}{
		ContextMoqParam: contextMoqParam,
		ValAddress:      valAddress,
	}
	mock.lockValidator.Lock()
	mock.calls.Validator = append(mock.calls.Validator, callInfo)
	mock.lockValidator.Unlock()
	return mock.ValidatorFunc(contextMoqParam, valAddress)
}

// ValidatorCalls gets all the calls that were made to Validator.
// Check the length with:
//
//	len(mockedStakingKeeper.ValidatorCalls())
func (mock *StakingKeeperMock) ValidatorCalls() []struct {
	ContextMoqParam context.Context
	ValAddress      sdk.ValAddress
} {
	var calls []struct {
		ContextMoqParam context.Context
		ValAddress      sdk.ValAddress
	}
	mock.lockValidator.RLock()
	calls = mock.calls.Validator
	mock.lockValidator.RUnlock()
	return calls
}

// ValidatorAddressCodec calls ValidatorAddressCodecFunc.
func (mock *StakingKeeperMock) ValidatorAddressCodec() address.Codec {
	if mock.ValidatorAddressCodecFunc == nil {
		panic("StakingKeeperMock.ValidatorAddressCodecFunc: method is nil but StakingKeeper.ValidatorAddressCodec was just called")
	}
	callInfo := struct {
	}{}
	mock.lockValidatorAddressCodec.Lock()
	mock.calls.ValidatorAddressCodec = append(mock.calls.ValidatorAddressCodec, callInfo)
	mock.lockValidatorAddressCodec.Unlock()
	return mock.ValidatorAddressCodecFunc()
}

// ValidatorAddressCodecCalls gets all the calls that were made to ValidatorAddressCodec.
// Check the length with:
//
//	len(mockedStakingKeeper.ValidatorAddressCodecCalls())
func (mock *StakingKeeperMock) ValidatorAddressCodecCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockValidatorAddressCodec.RLock()
	calls = mock.calls.ValidatorAddressCodec
	mock.lockValidatorAddressCodec.RUnlock()
	return calls
}

// ValidatorByConsAddr calls ValidatorByConsAddrFunc.
func (mock *StakingKeeperMock) ValidatorByConsAddr(contextMoqParam context.Context, consAddress sdk.ConsAddress) (stakingtypes.ValidatorI, error) {
	if mock.ValidatorByConsAddrFunc == nil {
		panic("StakingKeeperMock.ValidatorByConsAddrFunc: method is nil but StakingKeeper.ValidatorByConsAddr was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		ConsAddress     sdk.ConsAddress
	}{
		ContextMoqParam: contextMoqParam,
		ConsAddress:     consAddress,
	}
	mock.lockValidatorByConsAddr.Lock()
	mock.calls.ValidatorByConsAddr = append(mock.calls.ValidatorByConsAddr, callInfo)
	mock.lockValidatorByConsAddr.Unlock()
	return mock.ValidatorByConsAddrFunc(contextMoqParam, consAddress)
}

// ValidatorByConsAddrCalls gets all the calls that were made to ValidatorByConsAddr.
// Check the length with:
//
//	len(mockedStakingKeeper.ValidatorByConsAddrCalls())
func (mock *StakingKeeperMock) ValidatorByConsAddrCalls() []struct {
	ContextMoqParam context.Context
	ConsAddress     sdk.ConsAddress
} {
	var calls []struct {
		ContextMoqParam context.Context
		ConsAddress     sdk.ConsAddress
	}
	mock.lockValidatorByConsAddr.RLock()
	calls = mock.calls.ValidatorByConsAddr
	mock.lockValidatorByConsAddr.RUnlock()
	return calls
}
