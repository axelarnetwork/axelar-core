// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"github.com/axelarnetwork/axelar-core/x/distribution/types"
	sdk "github.com/cosmos/cosmos-sdk/types"
	authtypes "github.com/cosmos/cosmos-sdk/x/auth/types"
	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
	"sync"
)

// Ensure, that BankKeeperMock does implement types.BankKeeper.
// If this is not the case, regenerate this file with moq.
var _ types.BankKeeper = &BankKeeperMock{}

// BankKeeperMock is a mock implementation of types.BankKeeper.
//
//	func TestSomethingThatUsesBankKeeper(t *testing.T) {
//
//		// make and configure a mocked types.BankKeeper
//		mockedBankKeeper := &BankKeeperMock{
//			BlockedAddrFunc: func(addr sdk.AccAddress) bool {
//				panic("mock out the BlockedAddr method")
//			},
//			BurnCoinsFunc: func(ctx sdk.Context, moduleName string, amt sdk.Coins) error {
//				panic("mock out the BurnCoins method")
//			},
//			GetAllBalancesFunc: func(ctx sdk.Context, addr sdk.AccAddress) sdk.Coins {
//				panic("mock out the GetAllBalances method")
//			},
//			MintCoinsFunc: func(ctx sdk.Context, moduleName string, amt sdk.Coins) error {
//				panic("mock out the MintCoins method")
//			},
//			SendCoinsFromAccountToModuleFunc: func(ctx sdk.Context, senderAddr sdk.AccAddress, recipientModule string, amt sdk.Coins) error {
//				panic("mock out the SendCoinsFromAccountToModule method")
//			},
//			SendCoinsFromModuleToAccountFunc: func(ctx sdk.Context, senderModule string, recipientAddr sdk.AccAddress, amt sdk.Coins) error {
//				panic("mock out the SendCoinsFromModuleToAccount method")
//			},
//			SendCoinsFromModuleToModuleFunc: func(ctx sdk.Context, senderModule string, recipientModule string, amt sdk.Coins) error {
//				panic("mock out the SendCoinsFromModuleToModule method")
//			},
//			SpendableCoinsFunc: func(ctx sdk.Context, addr sdk.AccAddress) sdk.Coins {
//				panic("mock out the SpendableCoins method")
//			},
//		}
//
//		// use mockedBankKeeper in code that requires types.BankKeeper
//		// and then make assertions.
//
//	}
type BankKeeperMock struct {
	// BlockedAddrFunc mocks the BlockedAddr method.
	BlockedAddrFunc func(addr sdk.AccAddress) bool

	// BurnCoinsFunc mocks the BurnCoins method.
	BurnCoinsFunc func(ctx sdk.Context, moduleName string, amt sdk.Coins) error

	// GetAllBalancesFunc mocks the GetAllBalances method.
	GetAllBalancesFunc func(ctx sdk.Context, addr sdk.AccAddress) sdk.Coins

	// MintCoinsFunc mocks the MintCoins method.
	MintCoinsFunc func(ctx sdk.Context, moduleName string, amt sdk.Coins) error

	// SendCoinsFromAccountToModuleFunc mocks the SendCoinsFromAccountToModule method.
	SendCoinsFromAccountToModuleFunc func(ctx sdk.Context, senderAddr sdk.AccAddress, recipientModule string, amt sdk.Coins) error

	// SendCoinsFromModuleToAccountFunc mocks the SendCoinsFromModuleToAccount method.
	SendCoinsFromModuleToAccountFunc func(ctx sdk.Context, senderModule string, recipientAddr sdk.AccAddress, amt sdk.Coins) error

	// SendCoinsFromModuleToModuleFunc mocks the SendCoinsFromModuleToModule method.
	SendCoinsFromModuleToModuleFunc func(ctx sdk.Context, senderModule string, recipientModule string, amt sdk.Coins) error

	// SpendableCoinsFunc mocks the SpendableCoins method.
	SpendableCoinsFunc func(ctx sdk.Context, addr sdk.AccAddress) sdk.Coins

	// calls tracks calls to the methods.
	calls struct {
		// BlockedAddr holds details about calls to the BlockedAddr method.
		BlockedAddr []struct {
			// Addr is the addr argument value.
			Addr sdk.AccAddress
		}
		// BurnCoins holds details about calls to the BurnCoins method.
		BurnCoins []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// ModuleName is the moduleName argument value.
			ModuleName string
			// Amt is the amt argument value.
			Amt sdk.Coins
		}
		// GetAllBalances holds details about calls to the GetAllBalances method.
		GetAllBalances []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Addr is the addr argument value.
			Addr sdk.AccAddress
		}
		// MintCoins holds details about calls to the MintCoins method.
		MintCoins []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// ModuleName is the moduleName argument value.
			ModuleName string
			// Amt is the amt argument value.
			Amt sdk.Coins
		}
		// SendCoinsFromAccountToModule holds details about calls to the SendCoinsFromAccountToModule method.
		SendCoinsFromAccountToModule []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// SenderAddr is the senderAddr argument value.
			SenderAddr sdk.AccAddress
			// RecipientModule is the recipientModule argument value.
			RecipientModule string
			// Amt is the amt argument value.
			Amt sdk.Coins
		}
		// SendCoinsFromModuleToAccount holds details about calls to the SendCoinsFromModuleToAccount method.
		SendCoinsFromModuleToAccount []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// SenderModule is the senderModule argument value.
			SenderModule string
			// RecipientAddr is the recipientAddr argument value.
			RecipientAddr sdk.AccAddress
			// Amt is the amt argument value.
			Amt sdk.Coins
		}
		// SendCoinsFromModuleToModule holds details about calls to the SendCoinsFromModuleToModule method.
		SendCoinsFromModuleToModule []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// SenderModule is the senderModule argument value.
			SenderModule string
			// RecipientModule is the recipientModule argument value.
			RecipientModule string
			// Amt is the amt argument value.
			Amt sdk.Coins
		}
		// SpendableCoins holds details about calls to the SpendableCoins method.
		SpendableCoins []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Addr is the addr argument value.
			Addr sdk.AccAddress
		}
	}
	lockBlockedAddr                  sync.RWMutex
	lockBurnCoins                    sync.RWMutex
	lockGetAllBalances               sync.RWMutex
	lockMintCoins                    sync.RWMutex
	lockSendCoinsFromAccountToModule sync.RWMutex
	lockSendCoinsFromModuleToAccount sync.RWMutex
	lockSendCoinsFromModuleToModule  sync.RWMutex
	lockSpendableCoins               sync.RWMutex
}

// BlockedAddr calls BlockedAddrFunc.
func (mock *BankKeeperMock) BlockedAddr(addr sdk.AccAddress) bool {
	if mock.BlockedAddrFunc == nil {
		panic("BankKeeperMock.BlockedAddrFunc: method is nil but BankKeeper.BlockedAddr was just called")
	}
	callInfo := struct {
		Addr sdk.AccAddress
	}{
		Addr: addr,
	}
	mock.lockBlockedAddr.Lock()
	mock.calls.BlockedAddr = append(mock.calls.BlockedAddr, callInfo)
	mock.lockBlockedAddr.Unlock()
	return mock.BlockedAddrFunc(addr)
}

// BlockedAddrCalls gets all the calls that were made to BlockedAddr.
// Check the length with:
//
//	len(mockedBankKeeper.BlockedAddrCalls())
func (mock *BankKeeperMock) BlockedAddrCalls() []struct {
	Addr sdk.AccAddress
} {
	var calls []struct {
		Addr sdk.AccAddress
	}
	mock.lockBlockedAddr.RLock()
	calls = mock.calls.BlockedAddr
	mock.lockBlockedAddr.RUnlock()
	return calls
}

// BurnCoins calls BurnCoinsFunc.
func (mock *BankKeeperMock) BurnCoins(ctx sdk.Context, moduleName string, amt sdk.Coins) error {
	if mock.BurnCoinsFunc == nil {
		panic("BankKeeperMock.BurnCoinsFunc: method is nil but BankKeeper.BurnCoins was just called")
	}
	callInfo := struct {
		Ctx        sdk.Context
		ModuleName string
		Amt        sdk.Coins
	}{
		Ctx:        ctx,
		ModuleName: moduleName,
		Amt:        amt,
	}
	mock.lockBurnCoins.Lock()
	mock.calls.BurnCoins = append(mock.calls.BurnCoins, callInfo)
	mock.lockBurnCoins.Unlock()
	return mock.BurnCoinsFunc(ctx, moduleName, amt)
}

// BurnCoinsCalls gets all the calls that were made to BurnCoins.
// Check the length with:
//
//	len(mockedBankKeeper.BurnCoinsCalls())
func (mock *BankKeeperMock) BurnCoinsCalls() []struct {
	Ctx        sdk.Context
	ModuleName string
	Amt        sdk.Coins
} {
	var calls []struct {
		Ctx        sdk.Context
		ModuleName string
		Amt        sdk.Coins
	}
	mock.lockBurnCoins.RLock()
	calls = mock.calls.BurnCoins
	mock.lockBurnCoins.RUnlock()
	return calls
}

// GetAllBalances calls GetAllBalancesFunc.
func (mock *BankKeeperMock) GetAllBalances(ctx sdk.Context, addr sdk.AccAddress) sdk.Coins {
	if mock.GetAllBalancesFunc == nil {
		panic("BankKeeperMock.GetAllBalancesFunc: method is nil but BankKeeper.GetAllBalances was just called")
	}
	callInfo := struct {
		Ctx  sdk.Context
		Addr sdk.AccAddress
	}{
		Ctx:  ctx,
		Addr: addr,
	}
	mock.lockGetAllBalances.Lock()
	mock.calls.GetAllBalances = append(mock.calls.GetAllBalances, callInfo)
	mock.lockGetAllBalances.Unlock()
	return mock.GetAllBalancesFunc(ctx, addr)
}

// GetAllBalancesCalls gets all the calls that were made to GetAllBalances.
// Check the length with:
//
//	len(mockedBankKeeper.GetAllBalancesCalls())
func (mock *BankKeeperMock) GetAllBalancesCalls() []struct {
	Ctx  sdk.Context
	Addr sdk.AccAddress
} {
	var calls []struct {
		Ctx  sdk.Context
		Addr sdk.AccAddress
	}
	mock.lockGetAllBalances.RLock()
	calls = mock.calls.GetAllBalances
	mock.lockGetAllBalances.RUnlock()
	return calls
}

// MintCoins calls MintCoinsFunc.
func (mock *BankKeeperMock) MintCoins(ctx sdk.Context, moduleName string, amt sdk.Coins) error {
	if mock.MintCoinsFunc == nil {
		panic("BankKeeperMock.MintCoinsFunc: method is nil but BankKeeper.MintCoins was just called")
	}
	callInfo := struct {
		Ctx        sdk.Context
		ModuleName string
		Amt        sdk.Coins
	}{
		Ctx:        ctx,
		ModuleName: moduleName,
		Amt:        amt,
	}
	mock.lockMintCoins.Lock()
	mock.calls.MintCoins = append(mock.calls.MintCoins, callInfo)
	mock.lockMintCoins.Unlock()
	return mock.MintCoinsFunc(ctx, moduleName, amt)
}

// MintCoinsCalls gets all the calls that were made to MintCoins.
// Check the length with:
//
//	len(mockedBankKeeper.MintCoinsCalls())
func (mock *BankKeeperMock) MintCoinsCalls() []struct {
	Ctx        sdk.Context
	ModuleName string
	Amt        sdk.Coins
} {
	var calls []struct {
		Ctx        sdk.Context
		ModuleName string
		Amt        sdk.Coins
	}
	mock.lockMintCoins.RLock()
	calls = mock.calls.MintCoins
	mock.lockMintCoins.RUnlock()
	return calls
}

// SendCoinsFromAccountToModule calls SendCoinsFromAccountToModuleFunc.
func (mock *BankKeeperMock) SendCoinsFromAccountToModule(ctx sdk.Context, senderAddr sdk.AccAddress, recipientModule string, amt sdk.Coins) error {
	if mock.SendCoinsFromAccountToModuleFunc == nil {
		panic("BankKeeperMock.SendCoinsFromAccountToModuleFunc: method is nil but BankKeeper.SendCoinsFromAccountToModule was just called")
	}
	callInfo := struct {
		Ctx             sdk.Context
		SenderAddr      sdk.AccAddress
		RecipientModule string
		Amt             sdk.Coins
	}{
		Ctx:             ctx,
		SenderAddr:      senderAddr,
		RecipientModule: recipientModule,
		Amt:             amt,
	}
	mock.lockSendCoinsFromAccountToModule.Lock()
	mock.calls.SendCoinsFromAccountToModule = append(mock.calls.SendCoinsFromAccountToModule, callInfo)
	mock.lockSendCoinsFromAccountToModule.Unlock()
	return mock.SendCoinsFromAccountToModuleFunc(ctx, senderAddr, recipientModule, amt)
}

// SendCoinsFromAccountToModuleCalls gets all the calls that were made to SendCoinsFromAccountToModule.
// Check the length with:
//
//	len(mockedBankKeeper.SendCoinsFromAccountToModuleCalls())
func (mock *BankKeeperMock) SendCoinsFromAccountToModuleCalls() []struct {
	Ctx             sdk.Context
	SenderAddr      sdk.AccAddress
	RecipientModule string
	Amt             sdk.Coins
} {
	var calls []struct {
		Ctx             sdk.Context
		SenderAddr      sdk.AccAddress
		RecipientModule string
		Amt             sdk.Coins
	}
	mock.lockSendCoinsFromAccountToModule.RLock()
	calls = mock.calls.SendCoinsFromAccountToModule
	mock.lockSendCoinsFromAccountToModule.RUnlock()
	return calls
}

// SendCoinsFromModuleToAccount calls SendCoinsFromModuleToAccountFunc.
func (mock *BankKeeperMock) SendCoinsFromModuleToAccount(ctx sdk.Context, senderModule string, recipientAddr sdk.AccAddress, amt sdk.Coins) error {
	if mock.SendCoinsFromModuleToAccountFunc == nil {
		panic("BankKeeperMock.SendCoinsFromModuleToAccountFunc: method is nil but BankKeeper.SendCoinsFromModuleToAccount was just called")
	}
	callInfo := struct {
		Ctx           sdk.Context
		SenderModule  string
		RecipientAddr sdk.AccAddress
		Amt           sdk.Coins
	}{
		Ctx:           ctx,
		SenderModule:  senderModule,
		RecipientAddr: recipientAddr,
		Amt:           amt,
	}
	mock.lockSendCoinsFromModuleToAccount.Lock()
	mock.calls.SendCoinsFromModuleToAccount = append(mock.calls.SendCoinsFromModuleToAccount, callInfo)
	mock.lockSendCoinsFromModuleToAccount.Unlock()
	return mock.SendCoinsFromModuleToAccountFunc(ctx, senderModule, recipientAddr, amt)
}

// SendCoinsFromModuleToAccountCalls gets all the calls that were made to SendCoinsFromModuleToAccount.
// Check the length with:
//
//	len(mockedBankKeeper.SendCoinsFromModuleToAccountCalls())
func (mock *BankKeeperMock) SendCoinsFromModuleToAccountCalls() []struct {
	Ctx           sdk.Context
	SenderModule  string
	RecipientAddr sdk.AccAddress
	Amt           sdk.Coins
} {
	var calls []struct {
		Ctx           sdk.Context
		SenderModule  string
		RecipientAddr sdk.AccAddress
		Amt           sdk.Coins
	}
	mock.lockSendCoinsFromModuleToAccount.RLock()
	calls = mock.calls.SendCoinsFromModuleToAccount
	mock.lockSendCoinsFromModuleToAccount.RUnlock()
	return calls
}

// SendCoinsFromModuleToModule calls SendCoinsFromModuleToModuleFunc.
func (mock *BankKeeperMock) SendCoinsFromModuleToModule(ctx sdk.Context, senderModule string, recipientModule string, amt sdk.Coins) error {
	if mock.SendCoinsFromModuleToModuleFunc == nil {
		panic("BankKeeperMock.SendCoinsFromModuleToModuleFunc: method is nil but BankKeeper.SendCoinsFromModuleToModule was just called")
	}
	callInfo := struct {
		Ctx             sdk.Context
		SenderModule    string
		RecipientModule string
		Amt             sdk.Coins
	}{
		Ctx:             ctx,
		SenderModule:    senderModule,
		RecipientModule: recipientModule,
		Amt:             amt,
	}
	mock.lockSendCoinsFromModuleToModule.Lock()
	mock.calls.SendCoinsFromModuleToModule = append(mock.calls.SendCoinsFromModuleToModule, callInfo)
	mock.lockSendCoinsFromModuleToModule.Unlock()
	return mock.SendCoinsFromModuleToModuleFunc(ctx, senderModule, recipientModule, amt)
}

// SendCoinsFromModuleToModuleCalls gets all the calls that were made to SendCoinsFromModuleToModule.
// Check the length with:
//
//	len(mockedBankKeeper.SendCoinsFromModuleToModuleCalls())
func (mock *BankKeeperMock) SendCoinsFromModuleToModuleCalls() []struct {
	Ctx             sdk.Context
	SenderModule    string
	RecipientModule string
	Amt             sdk.Coins
} {
	var calls []struct {
		Ctx             sdk.Context
		SenderModule    string
		RecipientModule string
		Amt             sdk.Coins
	}
	mock.lockSendCoinsFromModuleToModule.RLock()
	calls = mock.calls.SendCoinsFromModuleToModule
	mock.lockSendCoinsFromModuleToModule.RUnlock()
	return calls
}

// SpendableCoins calls SpendableCoinsFunc.
func (mock *BankKeeperMock) SpendableCoins(ctx sdk.Context, addr sdk.AccAddress) sdk.Coins {
	if mock.SpendableCoinsFunc == nil {
		panic("BankKeeperMock.SpendableCoinsFunc: method is nil but BankKeeper.SpendableCoins was just called")
	}
	callInfo := struct {
		Ctx  sdk.Context
		Addr sdk.AccAddress
	}{
		Ctx:  ctx,
		Addr: addr,
	}
	mock.lockSpendableCoins.Lock()
	mock.calls.SpendableCoins = append(mock.calls.SpendableCoins, callInfo)
	mock.lockSpendableCoins.Unlock()
	return mock.SpendableCoinsFunc(ctx, addr)
}

// SpendableCoinsCalls gets all the calls that were made to SpendableCoins.
// Check the length with:
//
//	len(mockedBankKeeper.SpendableCoinsCalls())
func (mock *BankKeeperMock) SpendableCoinsCalls() []struct {
	Ctx  sdk.Context
	Addr sdk.AccAddress
} {
	var calls []struct {
		Ctx  sdk.Context
		Addr sdk.AccAddress
	}
	mock.lockSpendableCoins.RLock()
	calls = mock.calls.SpendableCoins
	mock.lockSpendableCoins.RUnlock()
	return calls
}

// Ensure, that AccountKeeperMock does implement types.AccountKeeper.
// If this is not the case, regenerate this file with moq.
var _ types.AccountKeeper = &AccountKeeperMock{}

// AccountKeeperMock is a mock implementation of types.AccountKeeper.
//
//	func TestSomethingThatUsesAccountKeeper(t *testing.T) {
//
//		// make and configure a mocked types.AccountKeeper
//		mockedAccountKeeper := &AccountKeeperMock{
//			GetAccountFunc: func(ctx sdk.Context, addr sdk.AccAddress) authtypes.AccountI {
//				panic("mock out the GetAccount method")
//			},
//			GetModuleAccountFunc: func(ctx sdk.Context, name string) authtypes.ModuleAccountI {
//				panic("mock out the GetModuleAccount method")
//			},
//			GetModuleAddressFunc: func(name string) sdk.AccAddress {
//				panic("mock out the GetModuleAddress method")
//			},
//			SetModuleAccountFunc: func(context sdk.Context, moduleAccountI authtypes.ModuleAccountI)  {
//				panic("mock out the SetModuleAccount method")
//			},
//		}
//
//		// use mockedAccountKeeper in code that requires types.AccountKeeper
//		// and then make assertions.
//
//	}
type AccountKeeperMock struct {
	// GetAccountFunc mocks the GetAccount method.
	GetAccountFunc func(ctx sdk.Context, addr sdk.AccAddress) authtypes.AccountI

	// GetModuleAccountFunc mocks the GetModuleAccount method.
	GetModuleAccountFunc func(ctx sdk.Context, name string) authtypes.ModuleAccountI

	// GetModuleAddressFunc mocks the GetModuleAddress method.
	GetModuleAddressFunc func(name string) sdk.AccAddress

	// SetModuleAccountFunc mocks the SetModuleAccount method.
	SetModuleAccountFunc func(context sdk.Context, moduleAccountI authtypes.ModuleAccountI)

	// calls tracks calls to the methods.
	calls struct {
		// GetAccount holds details about calls to the GetAccount method.
		GetAccount []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Addr is the addr argument value.
			Addr sdk.AccAddress
		}
		// GetModuleAccount holds details about calls to the GetModuleAccount method.
		GetModuleAccount []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Name is the name argument value.
			Name string
		}
		// GetModuleAddress holds details about calls to the GetModuleAddress method.
		GetModuleAddress []struct {
			// Name is the name argument value.
			Name string
		}
		// SetModuleAccount holds details about calls to the SetModuleAccount method.
		SetModuleAccount []struct {
			// Context is the context argument value.
			Context sdk.Context
			// ModuleAccountI is the moduleAccountI argument value.
			ModuleAccountI authtypes.ModuleAccountI
		}
	}
	lockGetAccount       sync.RWMutex
	lockGetModuleAccount sync.RWMutex
	lockGetModuleAddress sync.RWMutex
	lockSetModuleAccount sync.RWMutex
}

// GetAccount calls GetAccountFunc.
func (mock *AccountKeeperMock) GetAccount(ctx sdk.Context, addr sdk.AccAddress) authtypes.AccountI {
	if mock.GetAccountFunc == nil {
		panic("AccountKeeperMock.GetAccountFunc: method is nil but AccountKeeper.GetAccount was just called")
	}
	callInfo := struct {
		Ctx  sdk.Context
		Addr sdk.AccAddress
	}{
		Ctx:  ctx,
		Addr: addr,
	}
	mock.lockGetAccount.Lock()
	mock.calls.GetAccount = append(mock.calls.GetAccount, callInfo)
	mock.lockGetAccount.Unlock()
	return mock.GetAccountFunc(ctx, addr)
}

// GetAccountCalls gets all the calls that were made to GetAccount.
// Check the length with:
//
//	len(mockedAccountKeeper.GetAccountCalls())
func (mock *AccountKeeperMock) GetAccountCalls() []struct {
	Ctx  sdk.Context
	Addr sdk.AccAddress
} {
	var calls []struct {
		Ctx  sdk.Context
		Addr sdk.AccAddress
	}
	mock.lockGetAccount.RLock()
	calls = mock.calls.GetAccount
	mock.lockGetAccount.RUnlock()
	return calls
}

// GetModuleAccount calls GetModuleAccountFunc.
func (mock *AccountKeeperMock) GetModuleAccount(ctx sdk.Context, name string) authtypes.ModuleAccountI {
	if mock.GetModuleAccountFunc == nil {
		panic("AccountKeeperMock.GetModuleAccountFunc: method is nil but AccountKeeper.GetModuleAccount was just called")
	}
	callInfo := struct {
		Ctx  sdk.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockGetModuleAccount.Lock()
	mock.calls.GetModuleAccount = append(mock.calls.GetModuleAccount, callInfo)
	mock.lockGetModuleAccount.Unlock()
	return mock.GetModuleAccountFunc(ctx, name)
}

// GetModuleAccountCalls gets all the calls that were made to GetModuleAccount.
// Check the length with:
//
//	len(mockedAccountKeeper.GetModuleAccountCalls())
func (mock *AccountKeeperMock) GetModuleAccountCalls() []struct {
	Ctx  sdk.Context
	Name string
} {
	var calls []struct {
		Ctx  sdk.Context
		Name string
	}
	mock.lockGetModuleAccount.RLock()
	calls = mock.calls.GetModuleAccount
	mock.lockGetModuleAccount.RUnlock()
	return calls
}

// GetModuleAddress calls GetModuleAddressFunc.
func (mock *AccountKeeperMock) GetModuleAddress(name string) sdk.AccAddress {
	if mock.GetModuleAddressFunc == nil {
		panic("AccountKeeperMock.GetModuleAddressFunc: method is nil but AccountKeeper.GetModuleAddress was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockGetModuleAddress.Lock()
	mock.calls.GetModuleAddress = append(mock.calls.GetModuleAddress, callInfo)
	mock.lockGetModuleAddress.Unlock()
	return mock.GetModuleAddressFunc(name)
}

// GetModuleAddressCalls gets all the calls that were made to GetModuleAddress.
// Check the length with:
//
//	len(mockedAccountKeeper.GetModuleAddressCalls())
func (mock *AccountKeeperMock) GetModuleAddressCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockGetModuleAddress.RLock()
	calls = mock.calls.GetModuleAddress
	mock.lockGetModuleAddress.RUnlock()
	return calls
}

// SetModuleAccount calls SetModuleAccountFunc.
func (mock *AccountKeeperMock) SetModuleAccount(context sdk.Context, moduleAccountI authtypes.ModuleAccountI) {
	if mock.SetModuleAccountFunc == nil {
		panic("AccountKeeperMock.SetModuleAccountFunc: method is nil but AccountKeeper.SetModuleAccount was just called")
	}
	callInfo := struct {
		Context        sdk.Context
		ModuleAccountI authtypes.ModuleAccountI
	}{
		Context:        context,
		ModuleAccountI: moduleAccountI,
	}
	mock.lockSetModuleAccount.Lock()
	mock.calls.SetModuleAccount = append(mock.calls.SetModuleAccount, callInfo)
	mock.lockSetModuleAccount.Unlock()
	mock.SetModuleAccountFunc(context, moduleAccountI)
}

// SetModuleAccountCalls gets all the calls that were made to SetModuleAccount.
// Check the length with:
//
//	len(mockedAccountKeeper.SetModuleAccountCalls())
func (mock *AccountKeeperMock) SetModuleAccountCalls() []struct {
	Context        sdk.Context
	ModuleAccountI authtypes.ModuleAccountI
} {
	var calls []struct {
		Context        sdk.Context
		ModuleAccountI authtypes.ModuleAccountI
	}
	mock.lockSetModuleAccount.RLock()
	calls = mock.calls.SetModuleAccount
	mock.lockSetModuleAccount.RUnlock()
	return calls
}

// Ensure, that StakingKeeperMock does implement types.StakingKeeper.
// If this is not the case, regenerate this file with moq.
var _ types.StakingKeeper = &StakingKeeperMock{}

// StakingKeeperMock is a mock implementation of types.StakingKeeper.
//
//	func TestSomethingThatUsesStakingKeeper(t *testing.T) {
//
//		// make and configure a mocked types.StakingKeeper
//		mockedStakingKeeper := &StakingKeeperMock{
//			DelegationFunc: func(context sdk.Context, accAddress sdk.AccAddress, valAddress sdk.ValAddress) stakingtypes.DelegationI {
//				panic("mock out the Delegation method")
//			},
//			GetAllDelegatorDelegationsFunc: func(ctx sdk.Context, delegator sdk.AccAddress) []stakingtypes.Delegation {
//				panic("mock out the GetAllDelegatorDelegations method")
//			},
//			GetAllSDKDelegationsFunc: func(ctx sdk.Context) []stakingtypes.Delegation {
//				panic("mock out the GetAllSDKDelegations method")
//			},
//			GetAllValidatorsFunc: func(ctx sdk.Context) []stakingtypes.Validator {
//				panic("mock out the GetAllValidators method")
//			},
//			IterateDelegationsFunc: func(ctx sdk.Context, delegator sdk.AccAddress, fn func(index int64, delegation stakingtypes.DelegationI) (stop bool))  {
//				panic("mock out the IterateDelegations method")
//			},
//			IterateValidatorsFunc: func(context sdk.Context, fn func(index int64, validator stakingtypes.ValidatorI) (stop bool))  {
//				panic("mock out the IterateValidators method")
//			},
//			ValidatorFunc: func(context sdk.Context, valAddress sdk.ValAddress) stakingtypes.ValidatorI {
//				panic("mock out the Validator method")
//			},
//			ValidatorByConsAddrFunc: func(context sdk.Context, consAddress sdk.ConsAddress) stakingtypes.ValidatorI {
//				panic("mock out the ValidatorByConsAddr method")
//			},
//		}
//
//		// use mockedStakingKeeper in code that requires types.StakingKeeper
//		// and then make assertions.
//
//	}
type StakingKeeperMock struct {
	// DelegationFunc mocks the Delegation method.
	DelegationFunc func(context sdk.Context, accAddress sdk.AccAddress, valAddress sdk.ValAddress) stakingtypes.DelegationI

	// GetAllDelegatorDelegationsFunc mocks the GetAllDelegatorDelegations method.
	GetAllDelegatorDelegationsFunc func(ctx sdk.Context, delegator sdk.AccAddress) []stakingtypes.Delegation

	// GetAllSDKDelegationsFunc mocks the GetAllSDKDelegations method.
	GetAllSDKDelegationsFunc func(ctx sdk.Context) []stakingtypes.Delegation

	// GetAllValidatorsFunc mocks the GetAllValidators method.
	GetAllValidatorsFunc func(ctx sdk.Context) []stakingtypes.Validator

	// IterateDelegationsFunc mocks the IterateDelegations method.
	IterateDelegationsFunc func(ctx sdk.Context, delegator sdk.AccAddress, fn func(index int64, delegation stakingtypes.DelegationI) (stop bool))

	// IterateValidatorsFunc mocks the IterateValidators method.
	IterateValidatorsFunc func(context sdk.Context, fn func(index int64, validator stakingtypes.ValidatorI) (stop bool))

	// ValidatorFunc mocks the Validator method.
	ValidatorFunc func(context sdk.Context, valAddress sdk.ValAddress) stakingtypes.ValidatorI

	// ValidatorByConsAddrFunc mocks the ValidatorByConsAddr method.
	ValidatorByConsAddrFunc func(context sdk.Context, consAddress sdk.ConsAddress) stakingtypes.ValidatorI

	// calls tracks calls to the methods.
	calls struct {
		// Delegation holds details about calls to the Delegation method.
		Delegation []struct {
			// Context is the context argument value.
			Context sdk.Context
			// AccAddress is the accAddress argument value.
			AccAddress sdk.AccAddress
			// ValAddress is the valAddress argument value.
			ValAddress sdk.ValAddress
		}
		// GetAllDelegatorDelegations holds details about calls to the GetAllDelegatorDelegations method.
		GetAllDelegatorDelegations []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Delegator is the delegator argument value.
			Delegator sdk.AccAddress
		}
		// GetAllSDKDelegations holds details about calls to the GetAllSDKDelegations method.
		GetAllSDKDelegations []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetAllValidators holds details about calls to the GetAllValidators method.
		GetAllValidators []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// IterateDelegations holds details about calls to the IterateDelegations method.
		IterateDelegations []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Delegator is the delegator argument value.
			Delegator sdk.AccAddress
			// Fn is the fn argument value.
			Fn func(index int64, delegation stakingtypes.DelegationI) (stop bool)
		}
		// IterateValidators holds details about calls to the IterateValidators method.
		IterateValidators []struct {
			// Context is the context argument value.
			Context sdk.Context
			// Fn is the fn argument value.
			Fn func(index int64, validator stakingtypes.ValidatorI) (stop bool)
		}
		// Validator holds details about calls to the Validator method.
		Validator []struct {
			// Context is the context argument value.
			Context sdk.Context
			// ValAddress is the valAddress argument value.
			ValAddress sdk.ValAddress
		}
		// ValidatorByConsAddr holds details about calls to the ValidatorByConsAddr method.
		ValidatorByConsAddr []struct {
			// Context is the context argument value.
			Context sdk.Context
			// ConsAddress is the consAddress argument value.
			ConsAddress sdk.ConsAddress
		}
	}
	lockDelegation                 sync.RWMutex
	lockGetAllDelegatorDelegations sync.RWMutex
	lockGetAllSDKDelegations       sync.RWMutex
	lockGetAllValidators           sync.RWMutex
	lockIterateDelegations         sync.RWMutex
	lockIterateValidators          sync.RWMutex
	lockValidator                  sync.RWMutex
	lockValidatorByConsAddr        sync.RWMutex
}

// Delegation calls DelegationFunc.
func (mock *StakingKeeperMock) Delegation(context sdk.Context, accAddress sdk.AccAddress, valAddress sdk.ValAddress) stakingtypes.DelegationI {
	if mock.DelegationFunc == nil {
		panic("StakingKeeperMock.DelegationFunc: method is nil but StakingKeeper.Delegation was just called")
	}
	callInfo := struct {
		Context    sdk.Context
		AccAddress sdk.AccAddress
		ValAddress sdk.ValAddress
	}{
		Context:    context,
		AccAddress: accAddress,
		ValAddress: valAddress,
	}
	mock.lockDelegation.Lock()
	mock.calls.Delegation = append(mock.calls.Delegation, callInfo)
	mock.lockDelegation.Unlock()
	return mock.DelegationFunc(context, accAddress, valAddress)
}

// DelegationCalls gets all the calls that were made to Delegation.
// Check the length with:
//
//	len(mockedStakingKeeper.DelegationCalls())
func (mock *StakingKeeperMock) DelegationCalls() []struct {
	Context    sdk.Context
	AccAddress sdk.AccAddress
	ValAddress sdk.ValAddress
} {
	var calls []struct {
		Context    sdk.Context
		AccAddress sdk.AccAddress
		ValAddress sdk.ValAddress
	}
	mock.lockDelegation.RLock()
	calls = mock.calls.Delegation
	mock.lockDelegation.RUnlock()
	return calls
}

// GetAllDelegatorDelegations calls GetAllDelegatorDelegationsFunc.
func (mock *StakingKeeperMock) GetAllDelegatorDelegations(ctx sdk.Context, delegator sdk.AccAddress) []stakingtypes.Delegation {
	if mock.GetAllDelegatorDelegationsFunc == nil {
		panic("StakingKeeperMock.GetAllDelegatorDelegationsFunc: method is nil but StakingKeeper.GetAllDelegatorDelegations was just called")
	}
	callInfo := struct {
		Ctx       sdk.Context
		Delegator sdk.AccAddress
	}{
		Ctx:       ctx,
		Delegator: delegator,
	}
	mock.lockGetAllDelegatorDelegations.Lock()
	mock.calls.GetAllDelegatorDelegations = append(mock.calls.GetAllDelegatorDelegations, callInfo)
	mock.lockGetAllDelegatorDelegations.Unlock()
	return mock.GetAllDelegatorDelegationsFunc(ctx, delegator)
}

// GetAllDelegatorDelegationsCalls gets all the calls that were made to GetAllDelegatorDelegations.
// Check the length with:
//
//	len(mockedStakingKeeper.GetAllDelegatorDelegationsCalls())
func (mock *StakingKeeperMock) GetAllDelegatorDelegationsCalls() []struct {
	Ctx       sdk.Context
	Delegator sdk.AccAddress
} {
	var calls []struct {
		Ctx       sdk.Context
		Delegator sdk.AccAddress
	}
	mock.lockGetAllDelegatorDelegations.RLock()
	calls = mock.calls.GetAllDelegatorDelegations
	mock.lockGetAllDelegatorDelegations.RUnlock()
	return calls
}

// GetAllSDKDelegations calls GetAllSDKDelegationsFunc.
func (mock *StakingKeeperMock) GetAllSDKDelegations(ctx sdk.Context) []stakingtypes.Delegation {
	if mock.GetAllSDKDelegationsFunc == nil {
		panic("StakingKeeperMock.GetAllSDKDelegationsFunc: method is nil but StakingKeeper.GetAllSDKDelegations was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAllSDKDelegations.Lock()
	mock.calls.GetAllSDKDelegations = append(mock.calls.GetAllSDKDelegations, callInfo)
	mock.lockGetAllSDKDelegations.Unlock()
	return mock.GetAllSDKDelegationsFunc(ctx)
}

// GetAllSDKDelegationsCalls gets all the calls that were made to GetAllSDKDelegations.
// Check the length with:
//
//	len(mockedStakingKeeper.GetAllSDKDelegationsCalls())
func (mock *StakingKeeperMock) GetAllSDKDelegationsCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetAllSDKDelegations.RLock()
	calls = mock.calls.GetAllSDKDelegations
	mock.lockGetAllSDKDelegations.RUnlock()
	return calls
}

// GetAllValidators calls GetAllValidatorsFunc.
func (mock *StakingKeeperMock) GetAllValidators(ctx sdk.Context) []stakingtypes.Validator {
	if mock.GetAllValidatorsFunc == nil {
		panic("StakingKeeperMock.GetAllValidatorsFunc: method is nil but StakingKeeper.GetAllValidators was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAllValidators.Lock()
	mock.calls.GetAllValidators = append(mock.calls.GetAllValidators, callInfo)
	mock.lockGetAllValidators.Unlock()
	return mock.GetAllValidatorsFunc(ctx)
}

// GetAllValidatorsCalls gets all the calls that were made to GetAllValidators.
// Check the length with:
//
//	len(mockedStakingKeeper.GetAllValidatorsCalls())
func (mock *StakingKeeperMock) GetAllValidatorsCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetAllValidators.RLock()
	calls = mock.calls.GetAllValidators
	mock.lockGetAllValidators.RUnlock()
	return calls
}

// IterateDelegations calls IterateDelegationsFunc.
func (mock *StakingKeeperMock) IterateDelegations(ctx sdk.Context, delegator sdk.AccAddress, fn func(index int64, delegation stakingtypes.DelegationI) (stop bool)) {
	if mock.IterateDelegationsFunc == nil {
		panic("StakingKeeperMock.IterateDelegationsFunc: method is nil but StakingKeeper.IterateDelegations was just called")
	}
	callInfo := struct {
		Ctx       sdk.Context
		Delegator sdk.AccAddress
		Fn        func(index int64, delegation stakingtypes.DelegationI) (stop bool)
	}{
		Ctx:       ctx,
		Delegator: delegator,
		Fn:        fn,
	}
	mock.lockIterateDelegations.Lock()
	mock.calls.IterateDelegations = append(mock.calls.IterateDelegations, callInfo)
	mock.lockIterateDelegations.Unlock()
	mock.IterateDelegationsFunc(ctx, delegator, fn)
}

// IterateDelegationsCalls gets all the calls that were made to IterateDelegations.
// Check the length with:
//
//	len(mockedStakingKeeper.IterateDelegationsCalls())
func (mock *StakingKeeperMock) IterateDelegationsCalls() []struct {
	Ctx       sdk.Context
	Delegator sdk.AccAddress
	Fn        func(index int64, delegation stakingtypes.DelegationI) (stop bool)
} {
	var calls []struct {
		Ctx       sdk.Context
		Delegator sdk.AccAddress
		Fn        func(index int64, delegation stakingtypes.DelegationI) (stop bool)
	}
	mock.lockIterateDelegations.RLock()
	calls = mock.calls.IterateDelegations
	mock.lockIterateDelegations.RUnlock()
	return calls
}

// IterateValidators calls IterateValidatorsFunc.
func (mock *StakingKeeperMock) IterateValidators(context sdk.Context, fn func(index int64, validator stakingtypes.ValidatorI) (stop bool)) {
	if mock.IterateValidatorsFunc == nil {
		panic("StakingKeeperMock.IterateValidatorsFunc: method is nil but StakingKeeper.IterateValidators was just called")
	}
	callInfo := struct {
		Context sdk.Context
		Fn      func(index int64, validator stakingtypes.ValidatorI) (stop bool)
	}{
		Context: context,
		Fn:      fn,
	}
	mock.lockIterateValidators.Lock()
	mock.calls.IterateValidators = append(mock.calls.IterateValidators, callInfo)
	mock.lockIterateValidators.Unlock()
	mock.IterateValidatorsFunc(context, fn)
}

// IterateValidatorsCalls gets all the calls that were made to IterateValidators.
// Check the length with:
//
//	len(mockedStakingKeeper.IterateValidatorsCalls())
func (mock *StakingKeeperMock) IterateValidatorsCalls() []struct {
	Context sdk.Context
	Fn      func(index int64, validator stakingtypes.ValidatorI) (stop bool)
} {
	var calls []struct {
		Context sdk.Context
		Fn      func(index int64, validator stakingtypes.ValidatorI) (stop bool)
	}
	mock.lockIterateValidators.RLock()
	calls = mock.calls.IterateValidators
	mock.lockIterateValidators.RUnlock()
	return calls
}

// Validator calls ValidatorFunc.
func (mock *StakingKeeperMock) Validator(context sdk.Context, valAddress sdk.ValAddress) stakingtypes.ValidatorI {
	if mock.ValidatorFunc == nil {
		panic("StakingKeeperMock.ValidatorFunc: method is nil but StakingKeeper.Validator was just called")
	}
	callInfo := struct {
		Context    sdk.Context
		ValAddress sdk.ValAddress
	}{
		Context:    context,
		ValAddress: valAddress,
	}
	mock.lockValidator.Lock()
	mock.calls.Validator = append(mock.calls.Validator, callInfo)
	mock.lockValidator.Unlock()
	return mock.ValidatorFunc(context, valAddress)
}

// ValidatorCalls gets all the calls that were made to Validator.
// Check the length with:
//
//	len(mockedStakingKeeper.ValidatorCalls())
func (mock *StakingKeeperMock) ValidatorCalls() []struct {
	Context    sdk.Context
	ValAddress sdk.ValAddress
} {
	var calls []struct {
		Context    sdk.Context
		ValAddress sdk.ValAddress
	}
	mock.lockValidator.RLock()
	calls = mock.calls.Validator
	mock.lockValidator.RUnlock()
	return calls
}

// ValidatorByConsAddr calls ValidatorByConsAddrFunc.
func (mock *StakingKeeperMock) ValidatorByConsAddr(context sdk.Context, consAddress sdk.ConsAddress) stakingtypes.ValidatorI {
	if mock.ValidatorByConsAddrFunc == nil {
		panic("StakingKeeperMock.ValidatorByConsAddrFunc: method is nil but StakingKeeper.ValidatorByConsAddr was just called")
	}
	callInfo := struct {
		Context     sdk.Context
		ConsAddress sdk.ConsAddress
	}{
		Context:     context,
		ConsAddress: consAddress,
	}
	mock.lockValidatorByConsAddr.Lock()
	mock.calls.ValidatorByConsAddr = append(mock.calls.ValidatorByConsAddr, callInfo)
	mock.lockValidatorByConsAddr.Unlock()
	return mock.ValidatorByConsAddrFunc(context, consAddress)
}

// ValidatorByConsAddrCalls gets all the calls that were made to ValidatorByConsAddr.
// Check the length with:
//
//	len(mockedStakingKeeper.ValidatorByConsAddrCalls())
func (mock *StakingKeeperMock) ValidatorByConsAddrCalls() []struct {
	Context     sdk.Context
	ConsAddress sdk.ConsAddress
} {
	var calls []struct {
		Context     sdk.Context
		ConsAddress sdk.ConsAddress
	}
	mock.lockValidatorByConsAddr.RLock()
	calls = mock.calls.ValidatorByConsAddr
	mock.lockValidatorByConsAddr.RUnlock()
	return calls
}
