// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"github.com/axelarnetwork/axelar-core/x/ethereum/types"
	nexus "github.com/axelarnetwork/axelar-core/x/nexus/exported"
	snapshot "github.com/axelarnetwork/axelar-core/x/snapshot/exported"
	tss "github.com/axelarnetwork/axelar-core/x/tss/exported"
	vote "github.com/axelarnetwork/axelar-core/x/vote/exported"
	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/ethereum/go-ethereum/common"
	"github.com/tendermint/go-amino"
	"sync"
)

// Ensure, that VoterMock does implement types.Voter.
// If this is not the case, regenerate this file with moq.
var _ types.Voter = &VoterMock{}

// VoterMock is a mock implementation of types.Voter.
//
// 	func TestSomethingThatUsesVoter(t *testing.T) {
//
// 		// make and configure a mocked types.Voter
// 		mockedVoter := &VoterMock{
// 			DeletePollFunc: func(ctx sdk.Context, poll vote.PollMeta)  {
// 				panic("mock out the DeletePoll method")
// 			},
// 			InitPollFunc: func(ctx sdk.Context, poll vote.PollMeta, snapshotCounter int64) error {
// 				panic("mock out the InitPoll method")
// 			},
// 			ResultFunc: func(ctx sdk.Context, poll vote.PollMeta) vote.VotingData {
// 				panic("mock out the Result method")
// 			},
// 			TallyVoteFunc: func(ctx sdk.Context, sender sdk.AccAddress, pollMeta vote.PollMeta, data vote.VotingData) error {
// 				panic("mock out the TallyVote method")
// 			},
// 		}
//
// 		// use mockedVoter in code that requires types.Voter
// 		// and then make assertions.
//
// 	}
type VoterMock struct {
	// DeletePollFunc mocks the DeletePoll method.
	DeletePollFunc func(ctx sdk.Context, poll vote.PollMeta)

	// InitPollFunc mocks the InitPoll method.
	InitPollFunc func(ctx sdk.Context, poll vote.PollMeta, snapshotCounter int64) error

	// ResultFunc mocks the Result method.
	ResultFunc func(ctx sdk.Context, poll vote.PollMeta) vote.VotingData

	// TallyVoteFunc mocks the TallyVote method.
	TallyVoteFunc func(ctx sdk.Context, sender sdk.AccAddress, pollMeta vote.PollMeta, data vote.VotingData) error

	// calls tracks calls to the methods.
	calls struct {
		// DeletePoll holds details about calls to the DeletePoll method.
		DeletePoll []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Poll is the poll argument value.
			Poll vote.PollMeta
		}
		// InitPoll holds details about calls to the InitPoll method.
		InitPoll []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Poll is the poll argument value.
			Poll vote.PollMeta
			// SnapshotCounter is the snapshotCounter argument value.
			SnapshotCounter int64
		}
		// Result holds details about calls to the Result method.
		Result []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Poll is the poll argument value.
			Poll vote.PollMeta
		}
		// TallyVote holds details about calls to the TallyVote method.
		TallyVote []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Sender is the sender argument value.
			Sender sdk.AccAddress
			// PollMeta is the pollMeta argument value.
			PollMeta vote.PollMeta
			// Data is the data argument value.
			Data vote.VotingData
		}
	}
	lockDeletePoll sync.RWMutex
	lockInitPoll   sync.RWMutex
	lockResult     sync.RWMutex
	lockTallyVote  sync.RWMutex
}

// DeletePoll calls DeletePollFunc.
func (mock *VoterMock) DeletePoll(ctx sdk.Context, poll vote.PollMeta) {
	if mock.DeletePollFunc == nil {
		panic("VoterMock.DeletePollFunc: method is nil but Voter.DeletePoll was just called")
	}
	callInfo := struct {
		Ctx  sdk.Context
		Poll vote.PollMeta
	}{
		Ctx:  ctx,
		Poll: poll,
	}
	mock.lockDeletePoll.Lock()
	mock.calls.DeletePoll = append(mock.calls.DeletePoll, callInfo)
	mock.lockDeletePoll.Unlock()
	mock.DeletePollFunc(ctx, poll)
}

// DeletePollCalls gets all the calls that were made to DeletePoll.
// Check the length with:
//     len(mockedVoter.DeletePollCalls())
func (mock *VoterMock) DeletePollCalls() []struct {
	Ctx  sdk.Context
	Poll vote.PollMeta
} {
	var calls []struct {
		Ctx  sdk.Context
		Poll vote.PollMeta
	}
	mock.lockDeletePoll.RLock()
	calls = mock.calls.DeletePoll
	mock.lockDeletePoll.RUnlock()
	return calls
}

// InitPoll calls InitPollFunc.
func (mock *VoterMock) InitPoll(ctx sdk.Context, poll vote.PollMeta, snapshotCounter int64) error {
	if mock.InitPollFunc == nil {
		panic("VoterMock.InitPollFunc: method is nil but Voter.InitPoll was just called")
	}
	callInfo := struct {
		Ctx             sdk.Context
		Poll            vote.PollMeta
		SnapshotCounter int64
	}{
		Ctx:             ctx,
		Poll:            poll,
		SnapshotCounter: snapshotCounter,
	}
	mock.lockInitPoll.Lock()
	mock.calls.InitPoll = append(mock.calls.InitPoll, callInfo)
	mock.lockInitPoll.Unlock()
	return mock.InitPollFunc(ctx, poll, snapshotCounter)
}

// InitPollCalls gets all the calls that were made to InitPoll.
// Check the length with:
//     len(mockedVoter.InitPollCalls())
func (mock *VoterMock) InitPollCalls() []struct {
	Ctx             sdk.Context
	Poll            vote.PollMeta
	SnapshotCounter int64
} {
	var calls []struct {
		Ctx             sdk.Context
		Poll            vote.PollMeta
		SnapshotCounter int64
	}
	mock.lockInitPoll.RLock()
	calls = mock.calls.InitPoll
	mock.lockInitPoll.RUnlock()
	return calls
}

// Result calls ResultFunc.
func (mock *VoterMock) Result(ctx sdk.Context, poll vote.PollMeta) vote.VotingData {
	if mock.ResultFunc == nil {
		panic("VoterMock.ResultFunc: method is nil but Voter.Result was just called")
	}
	callInfo := struct {
		Ctx  sdk.Context
		Poll vote.PollMeta
	}{
		Ctx:  ctx,
		Poll: poll,
	}
	mock.lockResult.Lock()
	mock.calls.Result = append(mock.calls.Result, callInfo)
	mock.lockResult.Unlock()
	return mock.ResultFunc(ctx, poll)
}

// ResultCalls gets all the calls that were made to Result.
// Check the length with:
//     len(mockedVoter.ResultCalls())
func (mock *VoterMock) ResultCalls() []struct {
	Ctx  sdk.Context
	Poll vote.PollMeta
} {
	var calls []struct {
		Ctx  sdk.Context
		Poll vote.PollMeta
	}
	mock.lockResult.RLock()
	calls = mock.calls.Result
	mock.lockResult.RUnlock()
	return calls
}

// TallyVote calls TallyVoteFunc.
func (mock *VoterMock) TallyVote(ctx sdk.Context, sender sdk.AccAddress, pollMeta vote.PollMeta, data vote.VotingData) error {
	if mock.TallyVoteFunc == nil {
		panic("VoterMock.TallyVoteFunc: method is nil but Voter.TallyVote was just called")
	}
	callInfo := struct {
		Ctx      sdk.Context
		Sender   sdk.AccAddress
		PollMeta vote.PollMeta
		Data     vote.VotingData
	}{
		Ctx:      ctx,
		Sender:   sender,
		PollMeta: pollMeta,
		Data:     data,
	}
	mock.lockTallyVote.Lock()
	mock.calls.TallyVote = append(mock.calls.TallyVote, callInfo)
	mock.lockTallyVote.Unlock()
	return mock.TallyVoteFunc(ctx, sender, pollMeta, data)
}

// TallyVoteCalls gets all the calls that were made to TallyVote.
// Check the length with:
//     len(mockedVoter.TallyVoteCalls())
func (mock *VoterMock) TallyVoteCalls() []struct {
	Ctx      sdk.Context
	Sender   sdk.AccAddress
	PollMeta vote.PollMeta
	Data     vote.VotingData
} {
	var calls []struct {
		Ctx      sdk.Context
		Sender   sdk.AccAddress
		PollMeta vote.PollMeta
		Data     vote.VotingData
	}
	mock.lockTallyVote.RLock()
	calls = mock.calls.TallyVote
	mock.lockTallyVote.RUnlock()
	return calls
}

// Ensure, that SignerMock does implement types.Signer.
// If this is not the case, regenerate this file with moq.
var _ types.Signer = &SignerMock{}

// SignerMock is a mock implementation of types.Signer.
//
// 	func TestSomethingThatUsesSigner(t *testing.T) {
//
// 		// make and configure a mocked types.Signer
// 		mockedSigner := &SignerMock{
// 			GetCurrentKeyFunc: func(ctx sdk.Context, chain nexus.Chain, keyRole tss.KeyRole) (tss.Key, bool) {
// 				panic("mock out the GetCurrentKey method")
// 			},
// 			GetCurrentKeyIDFunc: func(ctx sdk.Context, chain nexus.Chain, keyRole tss.KeyRole) (string, bool) {
// 				panic("mock out the GetCurrentKeyID method")
// 			},
// 			GetKeyFunc: func(ctx sdk.Context, keyID string) (tss.Key, bool) {
// 				panic("mock out the GetKey method")
// 			},
// 			GetKeyForSigIDFunc: func(ctx sdk.Context, sigID string) (tss.Key, bool) {
// 				panic("mock out the GetKeyForSigID method")
// 			},
// 			GetSigFunc: func(ctx sdk.Context, sigID string) (tss.Signature, bool) {
// 				panic("mock out the GetSig method")
// 			},
// 			GetSnapshotCounterForKeyIDFunc: func(ctx sdk.Context, keyID string) (int64, bool) {
// 				panic("mock out the GetSnapshotCounterForKeyID method")
// 			},
// 			StartSignFunc: func(ctx sdk.Context, initPoll interface{InitPoll(ctx sdk.Context, poll vote.PollMeta, snapshotCounter int64) error}, keyID string, sigID string, msg []byte, snapshotMoqParam snapshot.Snapshot) error {
// 				panic("mock out the StartSign method")
// 			},
// 		}
//
// 		// use mockedSigner in code that requires types.Signer
// 		// and then make assertions.
//
// 	}
type SignerMock struct {
	// GetCurrentKeyFunc mocks the GetCurrentKey method.
	GetCurrentKeyFunc func(ctx sdk.Context, chain nexus.Chain, keyRole tss.KeyRole) (tss.Key, bool)

	// GetCurrentKeyIDFunc mocks the GetCurrentKeyID method.
	GetCurrentKeyIDFunc func(ctx sdk.Context, chain nexus.Chain, keyRole tss.KeyRole) (string, bool)

	// GetKeyFunc mocks the GetKey method.
	GetKeyFunc func(ctx sdk.Context, keyID string) (tss.Key, bool)

	// GetKeyForSigIDFunc mocks the GetKeyForSigID method.
	GetKeyForSigIDFunc func(ctx sdk.Context, sigID string) (tss.Key, bool)

	// GetSigFunc mocks the GetSig method.
	GetSigFunc func(ctx sdk.Context, sigID string) (tss.Signature, bool)

	// GetSnapshotCounterForKeyIDFunc mocks the GetSnapshotCounterForKeyID method.
	GetSnapshotCounterForKeyIDFunc func(ctx sdk.Context, keyID string) (int64, bool)

	// StartSignFunc mocks the StartSign method.
	StartSignFunc func(ctx sdk.Context, initPoll interface {
		InitPoll(ctx sdk.Context, poll vote.PollMeta, snapshotCounter int64) error
	}, keyID string, sigID string, msg []byte, snapshotMoqParam snapshot.Snapshot) error

	// calls tracks calls to the methods.
	calls struct {
		// GetCurrentKey holds details about calls to the GetCurrentKey method.
		GetCurrentKey []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Chain is the chain argument value.
			Chain nexus.Chain
			// KeyRole is the keyRole argument value.
			KeyRole tss.KeyRole
		}
		// GetCurrentKeyID holds details about calls to the GetCurrentKeyID method.
		GetCurrentKeyID []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Chain is the chain argument value.
			Chain nexus.Chain
			// KeyRole is the keyRole argument value.
			KeyRole tss.KeyRole
		}
		// GetKey holds details about calls to the GetKey method.
		GetKey []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// KeyID is the keyID argument value.
			KeyID string
		}
		// GetKeyForSigID holds details about calls to the GetKeyForSigID method.
		GetKeyForSigID []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// SigID is the sigID argument value.
			SigID string
		}
		// GetSig holds details about calls to the GetSig method.
		GetSig []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// SigID is the sigID argument value.
			SigID string
		}
		// GetSnapshotCounterForKeyID holds details about calls to the GetSnapshotCounterForKeyID method.
		GetSnapshotCounterForKeyID []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// KeyID is the keyID argument value.
			KeyID string
		}
		// StartSign holds details about calls to the StartSign method.
		StartSign []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// InitPoll is the initPoll argument value.
			InitPoll interface {
				InitPoll(ctx sdk.Context, poll vote.PollMeta, snapshotCounter int64) error
			}
			// KeyID is the keyID argument value.
			KeyID string
			// SigID is the sigID argument value.
			SigID string
			// Msg is the msg argument value.
			Msg []byte
			// SnapshotMoqParam is the snapshotMoqParam argument value.
			SnapshotMoqParam snapshot.Snapshot
		}
	}
	lockGetCurrentKey              sync.RWMutex
	lockGetCurrentKeyID            sync.RWMutex
	lockGetKey                     sync.RWMutex
	lockGetKeyForSigID             sync.RWMutex
	lockGetSig                     sync.RWMutex
	lockGetSnapshotCounterForKeyID sync.RWMutex
	lockStartSign                  sync.RWMutex
}

// GetCurrentKey calls GetCurrentKeyFunc.
func (mock *SignerMock) GetCurrentKey(ctx sdk.Context, chain nexus.Chain, keyRole tss.KeyRole) (tss.Key, bool) {
	if mock.GetCurrentKeyFunc == nil {
		panic("SignerMock.GetCurrentKeyFunc: method is nil but Signer.GetCurrentKey was just called")
	}
	callInfo := struct {
		Ctx     sdk.Context
		Chain   nexus.Chain
		KeyRole tss.KeyRole
	}{
		Ctx:     ctx,
		Chain:   chain,
		KeyRole: keyRole,
	}
	mock.lockGetCurrentKey.Lock()
	mock.calls.GetCurrentKey = append(mock.calls.GetCurrentKey, callInfo)
	mock.lockGetCurrentKey.Unlock()
	return mock.GetCurrentKeyFunc(ctx, chain, keyRole)
}

// GetCurrentKeyCalls gets all the calls that were made to GetCurrentKey.
// Check the length with:
//     len(mockedSigner.GetCurrentKeyCalls())
func (mock *SignerMock) GetCurrentKeyCalls() []struct {
	Ctx     sdk.Context
	Chain   nexus.Chain
	KeyRole tss.KeyRole
} {
	var calls []struct {
		Ctx     sdk.Context
		Chain   nexus.Chain
		KeyRole tss.KeyRole
	}
	mock.lockGetCurrentKey.RLock()
	calls = mock.calls.GetCurrentKey
	mock.lockGetCurrentKey.RUnlock()
	return calls
}

// GetCurrentKeyID calls GetCurrentKeyIDFunc.
func (mock *SignerMock) GetCurrentKeyID(ctx sdk.Context, chain nexus.Chain, keyRole tss.KeyRole) (string, bool) {
	if mock.GetCurrentKeyIDFunc == nil {
		panic("SignerMock.GetCurrentKeyIDFunc: method is nil but Signer.GetCurrentKeyID was just called")
	}
	callInfo := struct {
		Ctx     sdk.Context
		Chain   nexus.Chain
		KeyRole tss.KeyRole
	}{
		Ctx:     ctx,
		Chain:   chain,
		KeyRole: keyRole,
	}
	mock.lockGetCurrentKeyID.Lock()
	mock.calls.GetCurrentKeyID = append(mock.calls.GetCurrentKeyID, callInfo)
	mock.lockGetCurrentKeyID.Unlock()
	return mock.GetCurrentKeyIDFunc(ctx, chain, keyRole)
}

// GetCurrentKeyIDCalls gets all the calls that were made to GetCurrentKeyID.
// Check the length with:
//     len(mockedSigner.GetCurrentKeyIDCalls())
func (mock *SignerMock) GetCurrentKeyIDCalls() []struct {
	Ctx     sdk.Context
	Chain   nexus.Chain
	KeyRole tss.KeyRole
} {
	var calls []struct {
		Ctx     sdk.Context
		Chain   nexus.Chain
		KeyRole tss.KeyRole
	}
	mock.lockGetCurrentKeyID.RLock()
	calls = mock.calls.GetCurrentKeyID
	mock.lockGetCurrentKeyID.RUnlock()
	return calls
}

// GetKey calls GetKeyFunc.
func (mock *SignerMock) GetKey(ctx sdk.Context, keyID string) (tss.Key, bool) {
	if mock.GetKeyFunc == nil {
		panic("SignerMock.GetKeyFunc: method is nil but Signer.GetKey was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		KeyID string
	}{
		Ctx:   ctx,
		KeyID: keyID,
	}
	mock.lockGetKey.Lock()
	mock.calls.GetKey = append(mock.calls.GetKey, callInfo)
	mock.lockGetKey.Unlock()
	return mock.GetKeyFunc(ctx, keyID)
}

// GetKeyCalls gets all the calls that were made to GetKey.
// Check the length with:
//     len(mockedSigner.GetKeyCalls())
func (mock *SignerMock) GetKeyCalls() []struct {
	Ctx   sdk.Context
	KeyID string
} {
	var calls []struct {
		Ctx   sdk.Context
		KeyID string
	}
	mock.lockGetKey.RLock()
	calls = mock.calls.GetKey
	mock.lockGetKey.RUnlock()
	return calls
}

// GetKeyForSigID calls GetKeyForSigIDFunc.
func (mock *SignerMock) GetKeyForSigID(ctx sdk.Context, sigID string) (tss.Key, bool) {
	if mock.GetKeyForSigIDFunc == nil {
		panic("SignerMock.GetKeyForSigIDFunc: method is nil but Signer.GetKeyForSigID was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		SigID string
	}{
		Ctx:   ctx,
		SigID: sigID,
	}
	mock.lockGetKeyForSigID.Lock()
	mock.calls.GetKeyForSigID = append(mock.calls.GetKeyForSigID, callInfo)
	mock.lockGetKeyForSigID.Unlock()
	return mock.GetKeyForSigIDFunc(ctx, sigID)
}

// GetKeyForSigIDCalls gets all the calls that were made to GetKeyForSigID.
// Check the length with:
//     len(mockedSigner.GetKeyForSigIDCalls())
func (mock *SignerMock) GetKeyForSigIDCalls() []struct {
	Ctx   sdk.Context
	SigID string
} {
	var calls []struct {
		Ctx   sdk.Context
		SigID string
	}
	mock.lockGetKeyForSigID.RLock()
	calls = mock.calls.GetKeyForSigID
	mock.lockGetKeyForSigID.RUnlock()
	return calls
}

// GetSig calls GetSigFunc.
func (mock *SignerMock) GetSig(ctx sdk.Context, sigID string) (tss.Signature, bool) {
	if mock.GetSigFunc == nil {
		panic("SignerMock.GetSigFunc: method is nil but Signer.GetSig was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		SigID string
	}{
		Ctx:   ctx,
		SigID: sigID,
	}
	mock.lockGetSig.Lock()
	mock.calls.GetSig = append(mock.calls.GetSig, callInfo)
	mock.lockGetSig.Unlock()
	return mock.GetSigFunc(ctx, sigID)
}

// GetSigCalls gets all the calls that were made to GetSig.
// Check the length with:
//     len(mockedSigner.GetSigCalls())
func (mock *SignerMock) GetSigCalls() []struct {
	Ctx   sdk.Context
	SigID string
} {
	var calls []struct {
		Ctx   sdk.Context
		SigID string
	}
	mock.lockGetSig.RLock()
	calls = mock.calls.GetSig
	mock.lockGetSig.RUnlock()
	return calls
}

// GetSnapshotCounterForKeyID calls GetSnapshotCounterForKeyIDFunc.
func (mock *SignerMock) GetSnapshotCounterForKeyID(ctx sdk.Context, keyID string) (int64, bool) {
	if mock.GetSnapshotCounterForKeyIDFunc == nil {
		panic("SignerMock.GetSnapshotCounterForKeyIDFunc: method is nil but Signer.GetSnapshotCounterForKeyID was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		KeyID string
	}{
		Ctx:   ctx,
		KeyID: keyID,
	}
	mock.lockGetSnapshotCounterForKeyID.Lock()
	mock.calls.GetSnapshotCounterForKeyID = append(mock.calls.GetSnapshotCounterForKeyID, callInfo)
	mock.lockGetSnapshotCounterForKeyID.Unlock()
	return mock.GetSnapshotCounterForKeyIDFunc(ctx, keyID)
}

// GetSnapshotCounterForKeyIDCalls gets all the calls that were made to GetSnapshotCounterForKeyID.
// Check the length with:
//     len(mockedSigner.GetSnapshotCounterForKeyIDCalls())
func (mock *SignerMock) GetSnapshotCounterForKeyIDCalls() []struct {
	Ctx   sdk.Context
	KeyID string
} {
	var calls []struct {
		Ctx   sdk.Context
		KeyID string
	}
	mock.lockGetSnapshotCounterForKeyID.RLock()
	calls = mock.calls.GetSnapshotCounterForKeyID
	mock.lockGetSnapshotCounterForKeyID.RUnlock()
	return calls
}

// StartSign calls StartSignFunc.
func (mock *SignerMock) StartSign(ctx sdk.Context, initPoll interface {
	InitPoll(ctx sdk.Context, poll vote.PollMeta, snapshotCounter int64) error
}, keyID string, sigID string, msg []byte, snapshotMoqParam snapshot.Snapshot) error {
	if mock.StartSignFunc == nil {
		panic("SignerMock.StartSignFunc: method is nil but Signer.StartSign was just called")
	}
	callInfo := struct {
		Ctx      sdk.Context
		InitPoll interface {
			InitPoll(ctx sdk.Context, poll vote.PollMeta, snapshotCounter int64) error
		}
		KeyID            string
		SigID            string
		Msg              []byte
		SnapshotMoqParam snapshot.Snapshot
	}{
		Ctx:              ctx,
		InitPoll:         initPoll,
		KeyID:            keyID,
		SigID:            sigID,
		Msg:              msg,
		SnapshotMoqParam: snapshotMoqParam,
	}
	mock.lockStartSign.Lock()
	mock.calls.StartSign = append(mock.calls.StartSign, callInfo)
	mock.lockStartSign.Unlock()
	return mock.StartSignFunc(ctx, initPoll, keyID, sigID, msg, snapshotMoqParam)
}

// StartSignCalls gets all the calls that were made to StartSign.
// Check the length with:
//     len(mockedSigner.StartSignCalls())
func (mock *SignerMock) StartSignCalls() []struct {
	Ctx      sdk.Context
	InitPoll interface {
		InitPoll(ctx sdk.Context, poll vote.PollMeta, snapshotCounter int64) error
	}
	KeyID            string
	SigID            string
	Msg              []byte
	SnapshotMoqParam snapshot.Snapshot
} {
	var calls []struct {
		Ctx      sdk.Context
		InitPoll interface {
			InitPoll(ctx sdk.Context, poll vote.PollMeta, snapshotCounter int64) error
		}
		KeyID            string
		SigID            string
		Msg              []byte
		SnapshotMoqParam snapshot.Snapshot
	}
	mock.lockStartSign.RLock()
	calls = mock.calls.StartSign
	mock.lockStartSign.RUnlock()
	return calls
}

// Ensure, that NexusMock does implement types.Nexus.
// If this is not the case, regenerate this file with moq.
var _ types.Nexus = &NexusMock{}

// NexusMock is a mock implementation of types.Nexus.
//
// 	func TestSomethingThatUsesNexus(t *testing.T) {
//
// 		// make and configure a mocked types.Nexus
// 		mockedNexus := &NexusMock{
// 			ArchivePendingTransferFunc: func(ctx sdk.Context, transfer nexus.CrossChainTransfer)  {
// 				panic("mock out the ArchivePendingTransfer method")
// 			},
// 			EnqueueForTransferFunc: func(ctx sdk.Context, sender nexus.CrossChainAddress, amount sdk.Coin) error {
// 				panic("mock out the EnqueueForTransfer method")
// 			},
// 			GetArchivedTransfersForChainFunc: func(ctx sdk.Context, chain nexus.Chain) []nexus.CrossChainTransfer {
// 				panic("mock out the GetArchivedTransfersForChain method")
// 			},
// 			GetChainFunc: func(ctx sdk.Context, chain string) (nexus.Chain, bool) {
// 				panic("mock out the GetChain method")
// 			},
// 			GetPendingTransfersForChainFunc: func(ctx sdk.Context, chain nexus.Chain) []nexus.CrossChainTransfer {
// 				panic("mock out the GetPendingTransfersForChain method")
// 			},
// 			GetRecipientFunc: func(ctx sdk.Context, sender nexus.CrossChainAddress) (nexus.CrossChainAddress, bool) {
// 				panic("mock out the GetRecipient method")
// 			},
// 			IsAssetRegisteredFunc: func(ctx sdk.Context, chainName string, denom string) bool {
// 				panic("mock out the IsAssetRegistered method")
// 			},
// 			LinkAddressesFunc: func(ctx sdk.Context, sender nexus.CrossChainAddress, recipient nexus.CrossChainAddress)  {
// 				panic("mock out the LinkAddresses method")
// 			},
// 			RegisterAssetFunc: func(ctx sdk.Context, chainName string, denom string)  {
// 				panic("mock out the RegisterAsset method")
// 			},
// 		}
//
// 		// use mockedNexus in code that requires types.Nexus
// 		// and then make assertions.
//
// 	}
type NexusMock struct {
	// ArchivePendingTransferFunc mocks the ArchivePendingTransfer method.
	ArchivePendingTransferFunc func(ctx sdk.Context, transfer nexus.CrossChainTransfer)

	// EnqueueForTransferFunc mocks the EnqueueForTransfer method.
	EnqueueForTransferFunc func(ctx sdk.Context, sender nexus.CrossChainAddress, amount sdk.Coin) error

	// GetArchivedTransfersForChainFunc mocks the GetArchivedTransfersForChain method.
	GetArchivedTransfersForChainFunc func(ctx sdk.Context, chain nexus.Chain) []nexus.CrossChainTransfer

	// GetChainFunc mocks the GetChain method.
	GetChainFunc func(ctx sdk.Context, chain string) (nexus.Chain, bool)

	// GetPendingTransfersForChainFunc mocks the GetPendingTransfersForChain method.
	GetPendingTransfersForChainFunc func(ctx sdk.Context, chain nexus.Chain) []nexus.CrossChainTransfer

	// GetRecipientFunc mocks the GetRecipient method.
	GetRecipientFunc func(ctx sdk.Context, sender nexus.CrossChainAddress) (nexus.CrossChainAddress, bool)

	// IsAssetRegisteredFunc mocks the IsAssetRegistered method.
	IsAssetRegisteredFunc func(ctx sdk.Context, chainName string, denom string) bool

	// LinkAddressesFunc mocks the LinkAddresses method.
	LinkAddressesFunc func(ctx sdk.Context, sender nexus.CrossChainAddress, recipient nexus.CrossChainAddress)

	// RegisterAssetFunc mocks the RegisterAsset method.
	RegisterAssetFunc func(ctx sdk.Context, chainName string, denom string)

	// calls tracks calls to the methods.
	calls struct {
		// ArchivePendingTransfer holds details about calls to the ArchivePendingTransfer method.
		ArchivePendingTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Transfer is the transfer argument value.
			Transfer nexus.CrossChainTransfer
		}
		// EnqueueForTransfer holds details about calls to the EnqueueForTransfer method.
		EnqueueForTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Sender is the sender argument value.
			Sender nexus.CrossChainAddress
			// Amount is the amount argument value.
			Amount sdk.Coin
		}
		// GetArchivedTransfersForChain holds details about calls to the GetArchivedTransfersForChain method.
		GetArchivedTransfersForChain []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Chain is the chain argument value.
			Chain nexus.Chain
		}
		// GetChain holds details about calls to the GetChain method.
		GetChain []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Chain is the chain argument value.
			Chain string
		}
		// GetPendingTransfersForChain holds details about calls to the GetPendingTransfersForChain method.
		GetPendingTransfersForChain []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Chain is the chain argument value.
			Chain nexus.Chain
		}
		// GetRecipient holds details about calls to the GetRecipient method.
		GetRecipient []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Sender is the sender argument value.
			Sender nexus.CrossChainAddress
		}
		// IsAssetRegistered holds details about calls to the IsAssetRegistered method.
		IsAssetRegistered []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// ChainName is the chainName argument value.
			ChainName string
			// Denom is the denom argument value.
			Denom string
		}
		// LinkAddresses holds details about calls to the LinkAddresses method.
		LinkAddresses []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Sender is the sender argument value.
			Sender nexus.CrossChainAddress
			// Recipient is the recipient argument value.
			Recipient nexus.CrossChainAddress
		}
		// RegisterAsset holds details about calls to the RegisterAsset method.
		RegisterAsset []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// ChainName is the chainName argument value.
			ChainName string
			// Denom is the denom argument value.
			Denom string
		}
	}
	lockArchivePendingTransfer       sync.RWMutex
	lockEnqueueForTransfer           sync.RWMutex
	lockGetArchivedTransfersForChain sync.RWMutex
	lockGetChain                     sync.RWMutex
	lockGetPendingTransfersForChain  sync.RWMutex
	lockGetRecipient                 sync.RWMutex
	lockIsAssetRegistered            sync.RWMutex
	lockLinkAddresses                sync.RWMutex
	lockRegisterAsset                sync.RWMutex
}

// ArchivePendingTransfer calls ArchivePendingTransferFunc.
func (mock *NexusMock) ArchivePendingTransfer(ctx sdk.Context, transfer nexus.CrossChainTransfer) {
	if mock.ArchivePendingTransferFunc == nil {
		panic("NexusMock.ArchivePendingTransferFunc: method is nil but Nexus.ArchivePendingTransfer was just called")
	}
	callInfo := struct {
		Ctx      sdk.Context
		Transfer nexus.CrossChainTransfer
	}{
		Ctx:      ctx,
		Transfer: transfer,
	}
	mock.lockArchivePendingTransfer.Lock()
	mock.calls.ArchivePendingTransfer = append(mock.calls.ArchivePendingTransfer, callInfo)
	mock.lockArchivePendingTransfer.Unlock()
	mock.ArchivePendingTransferFunc(ctx, transfer)
}

// ArchivePendingTransferCalls gets all the calls that were made to ArchivePendingTransfer.
// Check the length with:
//     len(mockedNexus.ArchivePendingTransferCalls())
func (mock *NexusMock) ArchivePendingTransferCalls() []struct {
	Ctx      sdk.Context
	Transfer nexus.CrossChainTransfer
} {
	var calls []struct {
		Ctx      sdk.Context
		Transfer nexus.CrossChainTransfer
	}
	mock.lockArchivePendingTransfer.RLock()
	calls = mock.calls.ArchivePendingTransfer
	mock.lockArchivePendingTransfer.RUnlock()
	return calls
}

// EnqueueForTransfer calls EnqueueForTransferFunc.
func (mock *NexusMock) EnqueueForTransfer(ctx sdk.Context, sender nexus.CrossChainAddress, amount sdk.Coin) error {
	if mock.EnqueueForTransferFunc == nil {
		panic("NexusMock.EnqueueForTransferFunc: method is nil but Nexus.EnqueueForTransfer was just called")
	}
	callInfo := struct {
		Ctx    sdk.Context
		Sender nexus.CrossChainAddress
		Amount sdk.Coin
	}{
		Ctx:    ctx,
		Sender: sender,
		Amount: amount,
	}
	mock.lockEnqueueForTransfer.Lock()
	mock.calls.EnqueueForTransfer = append(mock.calls.EnqueueForTransfer, callInfo)
	mock.lockEnqueueForTransfer.Unlock()
	return mock.EnqueueForTransferFunc(ctx, sender, amount)
}

// EnqueueForTransferCalls gets all the calls that were made to EnqueueForTransfer.
// Check the length with:
//     len(mockedNexus.EnqueueForTransferCalls())
func (mock *NexusMock) EnqueueForTransferCalls() []struct {
	Ctx    sdk.Context
	Sender nexus.CrossChainAddress
	Amount sdk.Coin
} {
	var calls []struct {
		Ctx    sdk.Context
		Sender nexus.CrossChainAddress
		Amount sdk.Coin
	}
	mock.lockEnqueueForTransfer.RLock()
	calls = mock.calls.EnqueueForTransfer
	mock.lockEnqueueForTransfer.RUnlock()
	return calls
}

// GetArchivedTransfersForChain calls GetArchivedTransfersForChainFunc.
func (mock *NexusMock) GetArchivedTransfersForChain(ctx sdk.Context, chain nexus.Chain) []nexus.CrossChainTransfer {
	if mock.GetArchivedTransfersForChainFunc == nil {
		panic("NexusMock.GetArchivedTransfersForChainFunc: method is nil but Nexus.GetArchivedTransfersForChain was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		Chain nexus.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockGetArchivedTransfersForChain.Lock()
	mock.calls.GetArchivedTransfersForChain = append(mock.calls.GetArchivedTransfersForChain, callInfo)
	mock.lockGetArchivedTransfersForChain.Unlock()
	return mock.GetArchivedTransfersForChainFunc(ctx, chain)
}

// GetArchivedTransfersForChainCalls gets all the calls that were made to GetArchivedTransfersForChain.
// Check the length with:
//     len(mockedNexus.GetArchivedTransfersForChainCalls())
func (mock *NexusMock) GetArchivedTransfersForChainCalls() []struct {
	Ctx   sdk.Context
	Chain nexus.Chain
} {
	var calls []struct {
		Ctx   sdk.Context
		Chain nexus.Chain
	}
	mock.lockGetArchivedTransfersForChain.RLock()
	calls = mock.calls.GetArchivedTransfersForChain
	mock.lockGetArchivedTransfersForChain.RUnlock()
	return calls
}

// GetChain calls GetChainFunc.
func (mock *NexusMock) GetChain(ctx sdk.Context, chain string) (nexus.Chain, bool) {
	if mock.GetChainFunc == nil {
		panic("NexusMock.GetChainFunc: method is nil but Nexus.GetChain was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		Chain string
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockGetChain.Lock()
	mock.calls.GetChain = append(mock.calls.GetChain, callInfo)
	mock.lockGetChain.Unlock()
	return mock.GetChainFunc(ctx, chain)
}

// GetChainCalls gets all the calls that were made to GetChain.
// Check the length with:
//     len(mockedNexus.GetChainCalls())
func (mock *NexusMock) GetChainCalls() []struct {
	Ctx   sdk.Context
	Chain string
} {
	var calls []struct {
		Ctx   sdk.Context
		Chain string
	}
	mock.lockGetChain.RLock()
	calls = mock.calls.GetChain
	mock.lockGetChain.RUnlock()
	return calls
}

// GetPendingTransfersForChain calls GetPendingTransfersForChainFunc.
func (mock *NexusMock) GetPendingTransfersForChain(ctx sdk.Context, chain nexus.Chain) []nexus.CrossChainTransfer {
	if mock.GetPendingTransfersForChainFunc == nil {
		panic("NexusMock.GetPendingTransfersForChainFunc: method is nil but Nexus.GetPendingTransfersForChain was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		Chain nexus.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockGetPendingTransfersForChain.Lock()
	mock.calls.GetPendingTransfersForChain = append(mock.calls.GetPendingTransfersForChain, callInfo)
	mock.lockGetPendingTransfersForChain.Unlock()
	return mock.GetPendingTransfersForChainFunc(ctx, chain)
}

// GetPendingTransfersForChainCalls gets all the calls that were made to GetPendingTransfersForChain.
// Check the length with:
//     len(mockedNexus.GetPendingTransfersForChainCalls())
func (mock *NexusMock) GetPendingTransfersForChainCalls() []struct {
	Ctx   sdk.Context
	Chain nexus.Chain
} {
	var calls []struct {
		Ctx   sdk.Context
		Chain nexus.Chain
	}
	mock.lockGetPendingTransfersForChain.RLock()
	calls = mock.calls.GetPendingTransfersForChain
	mock.lockGetPendingTransfersForChain.RUnlock()
	return calls
}

// GetRecipient calls GetRecipientFunc.
func (mock *NexusMock) GetRecipient(ctx sdk.Context, sender nexus.CrossChainAddress) (nexus.CrossChainAddress, bool) {
	if mock.GetRecipientFunc == nil {
		panic("NexusMock.GetRecipientFunc: method is nil but Nexus.GetRecipient was just called")
	}
	callInfo := struct {
		Ctx    sdk.Context
		Sender nexus.CrossChainAddress
	}{
		Ctx:    ctx,
		Sender: sender,
	}
	mock.lockGetRecipient.Lock()
	mock.calls.GetRecipient = append(mock.calls.GetRecipient, callInfo)
	mock.lockGetRecipient.Unlock()
	return mock.GetRecipientFunc(ctx, sender)
}

// GetRecipientCalls gets all the calls that were made to GetRecipient.
// Check the length with:
//     len(mockedNexus.GetRecipientCalls())
func (mock *NexusMock) GetRecipientCalls() []struct {
	Ctx    sdk.Context
	Sender nexus.CrossChainAddress
} {
	var calls []struct {
		Ctx    sdk.Context
		Sender nexus.CrossChainAddress
	}
	mock.lockGetRecipient.RLock()
	calls = mock.calls.GetRecipient
	mock.lockGetRecipient.RUnlock()
	return calls
}

// IsAssetRegistered calls IsAssetRegisteredFunc.
func (mock *NexusMock) IsAssetRegistered(ctx sdk.Context, chainName string, denom string) bool {
	if mock.IsAssetRegisteredFunc == nil {
		panic("NexusMock.IsAssetRegisteredFunc: method is nil but Nexus.IsAssetRegistered was just called")
	}
	callInfo := struct {
		Ctx       sdk.Context
		ChainName string
		Denom     string
	}{
		Ctx:       ctx,
		ChainName: chainName,
		Denom:     denom,
	}
	mock.lockIsAssetRegistered.Lock()
	mock.calls.IsAssetRegistered = append(mock.calls.IsAssetRegistered, callInfo)
	mock.lockIsAssetRegistered.Unlock()
	return mock.IsAssetRegisteredFunc(ctx, chainName, denom)
}

// IsAssetRegisteredCalls gets all the calls that were made to IsAssetRegistered.
// Check the length with:
//     len(mockedNexus.IsAssetRegisteredCalls())
func (mock *NexusMock) IsAssetRegisteredCalls() []struct {
	Ctx       sdk.Context
	ChainName string
	Denom     string
} {
	var calls []struct {
		Ctx       sdk.Context
		ChainName string
		Denom     string
	}
	mock.lockIsAssetRegistered.RLock()
	calls = mock.calls.IsAssetRegistered
	mock.lockIsAssetRegistered.RUnlock()
	return calls
}

// LinkAddresses calls LinkAddressesFunc.
func (mock *NexusMock) LinkAddresses(ctx sdk.Context, sender nexus.CrossChainAddress, recipient nexus.CrossChainAddress) {
	if mock.LinkAddressesFunc == nil {
		panic("NexusMock.LinkAddressesFunc: method is nil but Nexus.LinkAddresses was just called")
	}
	callInfo := struct {
		Ctx       sdk.Context
		Sender    nexus.CrossChainAddress
		Recipient nexus.CrossChainAddress
	}{
		Ctx:       ctx,
		Sender:    sender,
		Recipient: recipient,
	}
	mock.lockLinkAddresses.Lock()
	mock.calls.LinkAddresses = append(mock.calls.LinkAddresses, callInfo)
	mock.lockLinkAddresses.Unlock()
	mock.LinkAddressesFunc(ctx, sender, recipient)
}

// LinkAddressesCalls gets all the calls that were made to LinkAddresses.
// Check the length with:
//     len(mockedNexus.LinkAddressesCalls())
func (mock *NexusMock) LinkAddressesCalls() []struct {
	Ctx       sdk.Context
	Sender    nexus.CrossChainAddress
	Recipient nexus.CrossChainAddress
} {
	var calls []struct {
		Ctx       sdk.Context
		Sender    nexus.CrossChainAddress
		Recipient nexus.CrossChainAddress
	}
	mock.lockLinkAddresses.RLock()
	calls = mock.calls.LinkAddresses
	mock.lockLinkAddresses.RUnlock()
	return calls
}

// RegisterAsset calls RegisterAssetFunc.
func (mock *NexusMock) RegisterAsset(ctx sdk.Context, chainName string, denom string) {
	if mock.RegisterAssetFunc == nil {
		panic("NexusMock.RegisterAssetFunc: method is nil but Nexus.RegisterAsset was just called")
	}
	callInfo := struct {
		Ctx       sdk.Context
		ChainName string
		Denom     string
	}{
		Ctx:       ctx,
		ChainName: chainName,
		Denom:     denom,
	}
	mock.lockRegisterAsset.Lock()
	mock.calls.RegisterAsset = append(mock.calls.RegisterAsset, callInfo)
	mock.lockRegisterAsset.Unlock()
	mock.RegisterAssetFunc(ctx, chainName, denom)
}

// RegisterAssetCalls gets all the calls that were made to RegisterAsset.
// Check the length with:
//     len(mockedNexus.RegisterAssetCalls())
func (mock *NexusMock) RegisterAssetCalls() []struct {
	Ctx       sdk.Context
	ChainName string
	Denom     string
} {
	var calls []struct {
		Ctx       sdk.Context
		ChainName string
		Denom     string
	}
	mock.lockRegisterAsset.RLock()
	calls = mock.calls.RegisterAsset
	mock.lockRegisterAsset.RUnlock()
	return calls
}

// Ensure, that SnapshotterMock does implement types.Snapshotter.
// If this is not the case, regenerate this file with moq.
var _ types.Snapshotter = &SnapshotterMock{}

// SnapshotterMock is a mock implementation of types.Snapshotter.
//
// 	func TestSomethingThatUsesSnapshotter(t *testing.T) {
//
// 		// make and configure a mocked types.Snapshotter
// 		mockedSnapshotter := &SnapshotterMock{
// 			GetSnapshotFunc: func(ctx sdk.Context, counter int64) (snapshot.Snapshot, bool) {
// 				panic("mock out the GetSnapshot method")
// 			},
// 		}
//
// 		// use mockedSnapshotter in code that requires types.Snapshotter
// 		// and then make assertions.
//
// 	}
type SnapshotterMock struct {
	// GetSnapshotFunc mocks the GetSnapshot method.
	GetSnapshotFunc func(ctx sdk.Context, counter int64) (snapshot.Snapshot, bool)

	// calls tracks calls to the methods.
	calls struct {
		// GetSnapshot holds details about calls to the GetSnapshot method.
		GetSnapshot []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Counter is the counter argument value.
			Counter int64
		}
	}
	lockGetSnapshot sync.RWMutex
}

// GetSnapshot calls GetSnapshotFunc.
func (mock *SnapshotterMock) GetSnapshot(ctx sdk.Context, counter int64) (snapshot.Snapshot, bool) {
	if mock.GetSnapshotFunc == nil {
		panic("SnapshotterMock.GetSnapshotFunc: method is nil but Snapshotter.GetSnapshot was just called")
	}
	callInfo := struct {
		Ctx     sdk.Context
		Counter int64
	}{
		Ctx:     ctx,
		Counter: counter,
	}
	mock.lockGetSnapshot.Lock()
	mock.calls.GetSnapshot = append(mock.calls.GetSnapshot, callInfo)
	mock.lockGetSnapshot.Unlock()
	return mock.GetSnapshotFunc(ctx, counter)
}

// GetSnapshotCalls gets all the calls that were made to GetSnapshot.
// Check the length with:
//     len(mockedSnapshotter.GetSnapshotCalls())
func (mock *SnapshotterMock) GetSnapshotCalls() []struct {
	Ctx     sdk.Context
	Counter int64
} {
	var calls []struct {
		Ctx     sdk.Context
		Counter int64
	}
	mock.lockGetSnapshot.RLock()
	calls = mock.calls.GetSnapshot
	mock.lockGetSnapshot.RUnlock()
	return calls
}

// Ensure, that EthKeeperMock does implement types.EthKeeper.
// If this is not the case, regenerate this file with moq.
var _ types.EthKeeper = &EthKeeperMock{}

// EthKeeperMock is a mock implementation of types.EthKeeper.
//
// 	func TestSomethingThatUsesEthKeeper(t *testing.T) {
//
// 		// make and configure a mocked types.EthKeeper
// 		mockedEthKeeper := &EthKeeperMock{
// 			CodecFunc: func() *amino.Codec {
// 				panic("mock out the Codec method")
// 			},
// 			GetBurnerInfoFunc: func(ctx sdk.Context, address common.Address) *types.BurnerInfo {
// 				panic("mock out the GetBurnerInfo method")
// 			},
// 			GetDepositFunc: func(ctx sdk.Context, txID string, burnerAddr string) (types.ERC20Deposit, types.DepositState, bool) {
// 				panic("mock out the GetDeposit method")
// 			},
// 			GetGatewayAddressFunc: func(ctx sdk.Context) (common.Address, bool) {
// 				panic("mock out the GetGatewayAddress method")
// 			},
// 			GetRequiredConfirmationHeightFunc: func(ctx sdk.Context) uint64 {
// 				panic("mock out the GetRequiredConfirmationHeight method")
// 			},
// 			GetRevoteLockingPeriodFunc: func(ctx sdk.Context) int64 {
// 				panic("mock out the GetRevoteLockingPeriod method")
// 			},
// 			GetTokenAddressFunc: func(ctx sdk.Context, symbol string, gatewayAddr common.Address) (common.Address, error) {
// 				panic("mock out the GetTokenAddress method")
// 			},
// 			GetTokenDeploySignatureFunc: func(ctx sdk.Context) common.Hash {
// 				panic("mock out the GetTokenDeploySignature method")
// 			},
// 			SetPendingDepositFunc: func(ctx sdk.Context, poll vote.PollMeta, deposit *types.ERC20Deposit)  {
// 				panic("mock out the SetPendingDeposit method")
// 			},
// 			SetPendingTokenDeployFunc: func(ctx sdk.Context, poll vote.PollMeta, tokenDeploy types.ERC20TokenDeploy)  {
// 				panic("mock out the SetPendingTokenDeploy method")
// 			},
// 		}
//
// 		// use mockedEthKeeper in code that requires types.EthKeeper
// 		// and then make assertions.
//
// 	}
type EthKeeperMock struct {
	// CodecFunc mocks the Codec method.
	CodecFunc func() *amino.Codec

	// GetBurnerInfoFunc mocks the GetBurnerInfo method.
	GetBurnerInfoFunc func(ctx sdk.Context, address common.Address) *types.BurnerInfo

	// GetDepositFunc mocks the GetDeposit method.
	GetDepositFunc func(ctx sdk.Context, txID string, burnerAddr string) (types.ERC20Deposit, types.DepositState, bool)

	// GetGatewayAddressFunc mocks the GetGatewayAddress method.
	GetGatewayAddressFunc func(ctx sdk.Context) (common.Address, bool)

	// GetRequiredConfirmationHeightFunc mocks the GetRequiredConfirmationHeight method.
	GetRequiredConfirmationHeightFunc func(ctx sdk.Context) uint64

	// GetRevoteLockingPeriodFunc mocks the GetRevoteLockingPeriod method.
	GetRevoteLockingPeriodFunc func(ctx sdk.Context) int64

	// GetTokenAddressFunc mocks the GetTokenAddress method.
	GetTokenAddressFunc func(ctx sdk.Context, symbol string, gatewayAddr common.Address) (common.Address, error)

	// GetTokenDeploySignatureFunc mocks the GetTokenDeploySignature method.
	GetTokenDeploySignatureFunc func(ctx sdk.Context) common.Hash

	// SetPendingDepositFunc mocks the SetPendingDeposit method.
	SetPendingDepositFunc func(ctx sdk.Context, poll vote.PollMeta, deposit *types.ERC20Deposit)

	// SetPendingTokenDeployFunc mocks the SetPendingTokenDeploy method.
	SetPendingTokenDeployFunc func(ctx sdk.Context, poll vote.PollMeta, tokenDeploy types.ERC20TokenDeploy)

	// calls tracks calls to the methods.
	calls struct {
		// Codec holds details about calls to the Codec method.
		Codec []struct {
		}
		// GetBurnerInfo holds details about calls to the GetBurnerInfo method.
		GetBurnerInfo []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Address is the address argument value.
			Address common.Address
		}
		// GetDeposit holds details about calls to the GetDeposit method.
		GetDeposit []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// TxID is the txID argument value.
			TxID string
			// BurnerAddr is the burnerAddr argument value.
			BurnerAddr string
		}
		// GetGatewayAddress holds details about calls to the GetGatewayAddress method.
		GetGatewayAddress []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetRequiredConfirmationHeight holds details about calls to the GetRequiredConfirmationHeight method.
		GetRequiredConfirmationHeight []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetRevoteLockingPeriod holds details about calls to the GetRevoteLockingPeriod method.
		GetRevoteLockingPeriod []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetTokenAddress holds details about calls to the GetTokenAddress method.
		GetTokenAddress []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Symbol is the symbol argument value.
			Symbol string
			// GatewayAddr is the gatewayAddr argument value.
			GatewayAddr common.Address
		}
		// GetTokenDeploySignature holds details about calls to the GetTokenDeploySignature method.
		GetTokenDeploySignature []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// SetPendingDeposit holds details about calls to the SetPendingDeposit method.
		SetPendingDeposit []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Poll is the poll argument value.
			Poll vote.PollMeta
			// Deposit is the deposit argument value.
			Deposit *types.ERC20Deposit
		}
		// SetPendingTokenDeploy holds details about calls to the SetPendingTokenDeploy method.
		SetPendingTokenDeploy []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Poll is the poll argument value.
			Poll vote.PollMeta
			// TokenDeploy is the tokenDeploy argument value.
			TokenDeploy types.ERC20TokenDeploy
		}
	}
	lockCodec                         sync.RWMutex
	lockGetBurnerInfo                 sync.RWMutex
	lockGetDeposit                    sync.RWMutex
	lockGetGatewayAddress             sync.RWMutex
	lockGetRequiredConfirmationHeight sync.RWMutex
	lockGetRevoteLockingPeriod        sync.RWMutex
	lockGetTokenAddress               sync.RWMutex
	lockGetTokenDeploySignature       sync.RWMutex
	lockSetPendingDeposit             sync.RWMutex
	lockSetPendingTokenDeploy         sync.RWMutex
}

// Codec calls CodecFunc.
func (mock *EthKeeperMock) Codec() *amino.Codec {
	if mock.CodecFunc == nil {
		panic("EthKeeperMock.CodecFunc: method is nil but EthKeeper.Codec was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCodec.Lock()
	mock.calls.Codec = append(mock.calls.Codec, callInfo)
	mock.lockCodec.Unlock()
	return mock.CodecFunc()
}

// CodecCalls gets all the calls that were made to Codec.
// Check the length with:
//     len(mockedEthKeeper.CodecCalls())
func (mock *EthKeeperMock) CodecCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCodec.RLock()
	calls = mock.calls.Codec
	mock.lockCodec.RUnlock()
	return calls
}

// GetBurnerInfo calls GetBurnerInfoFunc.
func (mock *EthKeeperMock) GetBurnerInfo(ctx sdk.Context, address common.Address) *types.BurnerInfo {
	if mock.GetBurnerInfoFunc == nil {
		panic("EthKeeperMock.GetBurnerInfoFunc: method is nil but EthKeeper.GetBurnerInfo was just called")
	}
	callInfo := struct {
		Ctx     sdk.Context
		Address common.Address
	}{
		Ctx:     ctx,
		Address: address,
	}
	mock.lockGetBurnerInfo.Lock()
	mock.calls.GetBurnerInfo = append(mock.calls.GetBurnerInfo, callInfo)
	mock.lockGetBurnerInfo.Unlock()
	return mock.GetBurnerInfoFunc(ctx, address)
}

// GetBurnerInfoCalls gets all the calls that were made to GetBurnerInfo.
// Check the length with:
//     len(mockedEthKeeper.GetBurnerInfoCalls())
func (mock *EthKeeperMock) GetBurnerInfoCalls() []struct {
	Ctx     sdk.Context
	Address common.Address
} {
	var calls []struct {
		Ctx     sdk.Context
		Address common.Address
	}
	mock.lockGetBurnerInfo.RLock()
	calls = mock.calls.GetBurnerInfo
	mock.lockGetBurnerInfo.RUnlock()
	return calls
}

// GetDeposit calls GetDepositFunc.
func (mock *EthKeeperMock) GetDeposit(ctx sdk.Context, txID string, burnerAddr string) (types.ERC20Deposit, types.DepositState, bool) {
	if mock.GetDepositFunc == nil {
		panic("EthKeeperMock.GetDepositFunc: method is nil but EthKeeper.GetDeposit was just called")
	}
	callInfo := struct {
		Ctx        sdk.Context
		TxID       string
		BurnerAddr string
	}{
		Ctx:        ctx,
		TxID:       txID,
		BurnerAddr: burnerAddr,
	}
	mock.lockGetDeposit.Lock()
	mock.calls.GetDeposit = append(mock.calls.GetDeposit, callInfo)
	mock.lockGetDeposit.Unlock()
	return mock.GetDepositFunc(ctx, txID, burnerAddr)
}

// GetDepositCalls gets all the calls that were made to GetDeposit.
// Check the length with:
//     len(mockedEthKeeper.GetDepositCalls())
func (mock *EthKeeperMock) GetDepositCalls() []struct {
	Ctx        sdk.Context
	TxID       string
	BurnerAddr string
} {
	var calls []struct {
		Ctx        sdk.Context
		TxID       string
		BurnerAddr string
	}
	mock.lockGetDeposit.RLock()
	calls = mock.calls.GetDeposit
	mock.lockGetDeposit.RUnlock()
	return calls
}

// GetGatewayAddress calls GetGatewayAddressFunc.
func (mock *EthKeeperMock) GetGatewayAddress(ctx sdk.Context) (common.Address, bool) {
	if mock.GetGatewayAddressFunc == nil {
		panic("EthKeeperMock.GetGatewayAddressFunc: method is nil but EthKeeper.GetGatewayAddress was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetGatewayAddress.Lock()
	mock.calls.GetGatewayAddress = append(mock.calls.GetGatewayAddress, callInfo)
	mock.lockGetGatewayAddress.Unlock()
	return mock.GetGatewayAddressFunc(ctx)
}

// GetGatewayAddressCalls gets all the calls that were made to GetGatewayAddress.
// Check the length with:
//     len(mockedEthKeeper.GetGatewayAddressCalls())
func (mock *EthKeeperMock) GetGatewayAddressCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetGatewayAddress.RLock()
	calls = mock.calls.GetGatewayAddress
	mock.lockGetGatewayAddress.RUnlock()
	return calls
}

// GetRequiredConfirmationHeight calls GetRequiredConfirmationHeightFunc.
func (mock *EthKeeperMock) GetRequiredConfirmationHeight(ctx sdk.Context) uint64 {
	if mock.GetRequiredConfirmationHeightFunc == nil {
		panic("EthKeeperMock.GetRequiredConfirmationHeightFunc: method is nil but EthKeeper.GetRequiredConfirmationHeight was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetRequiredConfirmationHeight.Lock()
	mock.calls.GetRequiredConfirmationHeight = append(mock.calls.GetRequiredConfirmationHeight, callInfo)
	mock.lockGetRequiredConfirmationHeight.Unlock()
	return mock.GetRequiredConfirmationHeightFunc(ctx)
}

// GetRequiredConfirmationHeightCalls gets all the calls that were made to GetRequiredConfirmationHeight.
// Check the length with:
//     len(mockedEthKeeper.GetRequiredConfirmationHeightCalls())
func (mock *EthKeeperMock) GetRequiredConfirmationHeightCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetRequiredConfirmationHeight.RLock()
	calls = mock.calls.GetRequiredConfirmationHeight
	mock.lockGetRequiredConfirmationHeight.RUnlock()
	return calls
}

// GetRevoteLockingPeriod calls GetRevoteLockingPeriodFunc.
func (mock *EthKeeperMock) GetRevoteLockingPeriod(ctx sdk.Context) int64 {
	if mock.GetRevoteLockingPeriodFunc == nil {
		panic("EthKeeperMock.GetRevoteLockingPeriodFunc: method is nil but EthKeeper.GetRevoteLockingPeriod was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetRevoteLockingPeriod.Lock()
	mock.calls.GetRevoteLockingPeriod = append(mock.calls.GetRevoteLockingPeriod, callInfo)
	mock.lockGetRevoteLockingPeriod.Unlock()
	return mock.GetRevoteLockingPeriodFunc(ctx)
}

// GetRevoteLockingPeriodCalls gets all the calls that were made to GetRevoteLockingPeriod.
// Check the length with:
//     len(mockedEthKeeper.GetRevoteLockingPeriodCalls())
func (mock *EthKeeperMock) GetRevoteLockingPeriodCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetRevoteLockingPeriod.RLock()
	calls = mock.calls.GetRevoteLockingPeriod
	mock.lockGetRevoteLockingPeriod.RUnlock()
	return calls
}

// GetTokenAddress calls GetTokenAddressFunc.
func (mock *EthKeeperMock) GetTokenAddress(ctx sdk.Context, symbol string, gatewayAddr common.Address) (common.Address, error) {
	if mock.GetTokenAddressFunc == nil {
		panic("EthKeeperMock.GetTokenAddressFunc: method is nil but EthKeeper.GetTokenAddress was just called")
	}
	callInfo := struct {
		Ctx         sdk.Context
		Symbol      string
		GatewayAddr common.Address
	}{
		Ctx:         ctx,
		Symbol:      symbol,
		GatewayAddr: gatewayAddr,
	}
	mock.lockGetTokenAddress.Lock()
	mock.calls.GetTokenAddress = append(mock.calls.GetTokenAddress, callInfo)
	mock.lockGetTokenAddress.Unlock()
	return mock.GetTokenAddressFunc(ctx, symbol, gatewayAddr)
}

// GetTokenAddressCalls gets all the calls that were made to GetTokenAddress.
// Check the length with:
//     len(mockedEthKeeper.GetTokenAddressCalls())
func (mock *EthKeeperMock) GetTokenAddressCalls() []struct {
	Ctx         sdk.Context
	Symbol      string
	GatewayAddr common.Address
} {
	var calls []struct {
		Ctx         sdk.Context
		Symbol      string
		GatewayAddr common.Address
	}
	mock.lockGetTokenAddress.RLock()
	calls = mock.calls.GetTokenAddress
	mock.lockGetTokenAddress.RUnlock()
	return calls
}

// GetTokenDeploySignature calls GetTokenDeploySignatureFunc.
func (mock *EthKeeperMock) GetTokenDeploySignature(ctx sdk.Context) common.Hash {
	if mock.GetTokenDeploySignatureFunc == nil {
		panic("EthKeeperMock.GetTokenDeploySignatureFunc: method is nil but EthKeeper.GetTokenDeploySignature was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetTokenDeploySignature.Lock()
	mock.calls.GetTokenDeploySignature = append(mock.calls.GetTokenDeploySignature, callInfo)
	mock.lockGetTokenDeploySignature.Unlock()
	return mock.GetTokenDeploySignatureFunc(ctx)
}

// GetTokenDeploySignatureCalls gets all the calls that were made to GetTokenDeploySignature.
// Check the length with:
//     len(mockedEthKeeper.GetTokenDeploySignatureCalls())
func (mock *EthKeeperMock) GetTokenDeploySignatureCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetTokenDeploySignature.RLock()
	calls = mock.calls.GetTokenDeploySignature
	mock.lockGetTokenDeploySignature.RUnlock()
	return calls
}

// SetPendingDeposit calls SetPendingDepositFunc.
func (mock *EthKeeperMock) SetPendingDeposit(ctx sdk.Context, poll vote.PollMeta, deposit *types.ERC20Deposit) {
	if mock.SetPendingDepositFunc == nil {
		panic("EthKeeperMock.SetPendingDepositFunc: method is nil but EthKeeper.SetPendingDeposit was just called")
	}
	callInfo := struct {
		Ctx     sdk.Context
		Poll    vote.PollMeta
		Deposit *types.ERC20Deposit
	}{
		Ctx:     ctx,
		Poll:    poll,
		Deposit: deposit,
	}
	mock.lockSetPendingDeposit.Lock()
	mock.calls.SetPendingDeposit = append(mock.calls.SetPendingDeposit, callInfo)
	mock.lockSetPendingDeposit.Unlock()
	mock.SetPendingDepositFunc(ctx, poll, deposit)
}

// SetPendingDepositCalls gets all the calls that were made to SetPendingDeposit.
// Check the length with:
//     len(mockedEthKeeper.SetPendingDepositCalls())
func (mock *EthKeeperMock) SetPendingDepositCalls() []struct {
	Ctx     sdk.Context
	Poll    vote.PollMeta
	Deposit *types.ERC20Deposit
} {
	var calls []struct {
		Ctx     sdk.Context
		Poll    vote.PollMeta
		Deposit *types.ERC20Deposit
	}
	mock.lockSetPendingDeposit.RLock()
	calls = mock.calls.SetPendingDeposit
	mock.lockSetPendingDeposit.RUnlock()
	return calls
}

// SetPendingTokenDeploy calls SetPendingTokenDeployFunc.
func (mock *EthKeeperMock) SetPendingTokenDeploy(ctx sdk.Context, poll vote.PollMeta, tokenDeploy types.ERC20TokenDeploy) {
	if mock.SetPendingTokenDeployFunc == nil {
		panic("EthKeeperMock.SetPendingTokenDeployFunc: method is nil but EthKeeper.SetPendingTokenDeploy was just called")
	}
	callInfo := struct {
		Ctx         sdk.Context
		Poll        vote.PollMeta
		TokenDeploy types.ERC20TokenDeploy
	}{
		Ctx:         ctx,
		Poll:        poll,
		TokenDeploy: tokenDeploy,
	}
	mock.lockSetPendingTokenDeploy.Lock()
	mock.calls.SetPendingTokenDeploy = append(mock.calls.SetPendingTokenDeploy, callInfo)
	mock.lockSetPendingTokenDeploy.Unlock()
	mock.SetPendingTokenDeployFunc(ctx, poll, tokenDeploy)
}

// SetPendingTokenDeployCalls gets all the calls that were made to SetPendingTokenDeploy.
// Check the length with:
//     len(mockedEthKeeper.SetPendingTokenDeployCalls())
func (mock *EthKeeperMock) SetPendingTokenDeployCalls() []struct {
	Ctx         sdk.Context
	Poll        vote.PollMeta
	TokenDeploy types.ERC20TokenDeploy
} {
	var calls []struct {
		Ctx         sdk.Context
		Poll        vote.PollMeta
		TokenDeploy types.ERC20TokenDeploy
	}
	mock.lockSetPendingTokenDeploy.RLock()
	calls = mock.calls.SetPendingTokenDeploy
	mock.lockSetPendingTokenDeploy.RUnlock()
	return calls
}
