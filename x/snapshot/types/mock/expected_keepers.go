// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"github.com/axelarnetwork/axelar-core/x/snapshot/types"
	sdk "github.com/cosmos/cosmos-sdk/types"
	sdkExported "github.com/cosmos/cosmos-sdk/x/staking/exported"
	typesStaking "github.com/cosmos/cosmos-sdk/x/staking/types"
	"sync"
)

// Ensure, that StakingKeeperMock does implement types.StakingKeeper.
// If this is not the case, regenerate this file with moq.
var _ types.StakingKeeper = &StakingKeeperMock{}

// StakingKeeperMock is a mock implementation of types.StakingKeeper.
//
//     func TestSomethingThatUsesStakingKeeper(t *testing.T) {
//
//         // make and configure a mocked types.StakingKeeper
//         mockedStakingKeeper := &StakingKeeperMock{
//             GetLastTotalPowerFunc: func(ctx sdk.Context) sdk.Int {
// 	               panic("mock out the GetLastTotalPower method")
//             },
//             GetValidatorFunc: func(ctx sdk.Context, addr sdk.ValAddress) (typesStaking.Validator, bool) {
// 	               panic("mock out the GetValidator method")
//             },
//             IterateValidatorsFunc: func(ctx sdk.Context, fn func(index int64, validator sdkExported.ValidatorI) (stop bool))  {
// 	               panic("mock out the IterateValidators method")
//             },
//         }
//
//         // use mockedStakingKeeper in code that requires types.StakingKeeper
//         // and then make assertions.
//
//     }
type StakingKeeperMock struct {
	// GetLastTotalPowerFunc mocks the GetLastTotalPower method.
	GetLastTotalPowerFunc func(ctx sdk.Context) sdk.Int

	// GetValidatorFunc mocks the GetValidator method.
	GetValidatorFunc func(ctx sdk.Context, addr sdk.ValAddress) (typesStaking.Validator, bool)

	// IterateValidatorsFunc mocks the IterateValidators method.
	IterateValidatorsFunc func(ctx sdk.Context, fn func(index int64, validator sdkExported.ValidatorI) (stop bool))

	// calls tracks calls to the methods.
	calls struct {
		// GetLastTotalPower holds details about calls to the GetLastTotalPower method.
		GetLastTotalPower []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetValidator holds details about calls to the GetValidator method.
		GetValidator []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Addr is the addr argument value.
			Addr sdk.ValAddress
		}
		// IterateValidators holds details about calls to the IterateValidators method.
		IterateValidators []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Fn is the fn argument value.
			Fn func(index int64, validator sdkExported.ValidatorI) (stop bool)
		}
	}
	lockGetLastTotalPower sync.RWMutex
	lockGetValidator      sync.RWMutex
	lockIterateValidators sync.RWMutex
}

// GetLastTotalPower calls GetLastTotalPowerFunc.
func (mock *StakingKeeperMock) GetLastTotalPower(ctx sdk.Context) sdk.Int {
	if mock.GetLastTotalPowerFunc == nil {
		panic("StakingKeeperMock.GetLastTotalPowerFunc: method is nil but StakingKeeper.GetLastTotalPower was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetLastTotalPower.Lock()
	mock.calls.GetLastTotalPower = append(mock.calls.GetLastTotalPower, callInfo)
	mock.lockGetLastTotalPower.Unlock()
	return mock.GetLastTotalPowerFunc(ctx)
}

// GetLastTotalPowerCalls gets all the calls that were made to GetLastTotalPower.
// Check the length with:
//     len(mockedStakingKeeper.GetLastTotalPowerCalls())
func (mock *StakingKeeperMock) GetLastTotalPowerCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetLastTotalPower.RLock()
	calls = mock.calls.GetLastTotalPower
	mock.lockGetLastTotalPower.RUnlock()
	return calls
}

// GetValidator calls GetValidatorFunc.
func (mock *StakingKeeperMock) GetValidator(ctx sdk.Context, addr sdk.ValAddress) (typesStaking.Validator, bool) {
	if mock.GetValidatorFunc == nil {
		panic("StakingKeeperMock.GetValidatorFunc: method is nil but StakingKeeper.GetValidator was just called")
	}
	callInfo := struct {
		Ctx  sdk.Context
		Addr sdk.ValAddress
	}{
		Ctx:  ctx,
		Addr: addr,
	}
	mock.lockGetValidator.Lock()
	mock.calls.GetValidator = append(mock.calls.GetValidator, callInfo)
	mock.lockGetValidator.Unlock()
	return mock.GetValidatorFunc(ctx, addr)
}

// GetValidatorCalls gets all the calls that were made to GetValidator.
// Check the length with:
//     len(mockedStakingKeeper.GetValidatorCalls())
func (mock *StakingKeeperMock) GetValidatorCalls() []struct {
	Ctx  sdk.Context
	Addr sdk.ValAddress
} {
	var calls []struct {
		Ctx  sdk.Context
		Addr sdk.ValAddress
	}
	mock.lockGetValidator.RLock()
	calls = mock.calls.GetValidator
	mock.lockGetValidator.RUnlock()
	return calls
}

// IterateValidators calls IterateValidatorsFunc.
func (mock *StakingKeeperMock) IterateValidators(ctx sdk.Context, fn func(index int64, validator sdkExported.ValidatorI) (stop bool)) {
	if mock.IterateValidatorsFunc == nil {
		panic("StakingKeeperMock.IterateValidatorsFunc: method is nil but StakingKeeper.IterateValidators was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
		Fn  func(index int64, validator sdkExported.ValidatorI) (stop bool)
	}{
		Ctx: ctx,
		Fn:  fn,
	}
	mock.lockIterateValidators.Lock()
	mock.calls.IterateValidators = append(mock.calls.IterateValidators, callInfo)
	mock.lockIterateValidators.Unlock()
	mock.IterateValidatorsFunc(ctx, fn)
}

// IterateValidatorsCalls gets all the calls that were made to IterateValidators.
// Check the length with:
//     len(mockedStakingKeeper.IterateValidatorsCalls())
func (mock *StakingKeeperMock) IterateValidatorsCalls() []struct {
	Ctx sdk.Context
	Fn  func(index int64, validator sdkExported.ValidatorI) (stop bool)
} {
	var calls []struct {
		Ctx sdk.Context
		Fn  func(index int64, validator sdkExported.ValidatorI) (stop bool)
	}
	mock.lockIterateValidators.RLock()
	calls = mock.calls.IterateValidators
	mock.lockIterateValidators.RUnlock()
	return calls
}
