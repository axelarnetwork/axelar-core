// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	context "context"
	"cosmossdk.io/math"
	snapshottypes "github.com/axelarnetwork/axelar-core/x/snapshot/types"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	slashingtypes "github.com/cosmos/cosmos-sdk/x/slashing/types"
	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
	"sync"
)

// Ensure, that StakingKeeperMock does implement snapshottypes.StakingKeeper.
// If this is not the case, regenerate this file with moq.
var _ snapshottypes.StakingKeeper = &StakingKeeperMock{}

// StakingKeeperMock is a mock implementation of snapshottypes.StakingKeeper.
//
//	func TestSomethingThatUsesStakingKeeper(t *testing.T) {
//
//		// make and configure a mocked snapshottypes.StakingKeeper
//		mockedStakingKeeper := &StakingKeeperMock{
//			BondDenomFunc: func(ctx context.Context) (string, error) {
//				panic("mock out the BondDenom method")
//			},
//			GetLastTotalPowerFunc: func(ctx context.Context) (math.Int, error) {
//				panic("mock out the GetLastTotalPower method")
//			},
//			IterateBondedValidatorsByPowerFunc: func(ctx context.Context, fn func(index int64, validator stakingtypes.ValidatorI) (stop bool)) error {
//				panic("mock out the IterateBondedValidatorsByPower method")
//			},
//			PowerReductionFunc: func(ctx context.Context) math.Int {
//				panic("mock out the PowerReduction method")
//			},
//			ValidatorFunc: func(ctx context.Context, addr github_com_cosmos_cosmos_sdk_types.ValAddress) (stakingtypes.ValidatorI, error) {
//				panic("mock out the Validator method")
//			},
//		}
//
//		// use mockedStakingKeeper in code that requires snapshottypes.StakingKeeper
//		// and then make assertions.
//
//	}
type StakingKeeperMock struct {
	// BondDenomFunc mocks the BondDenom method.
	BondDenomFunc func(ctx context.Context) (string, error)

	// GetLastTotalPowerFunc mocks the GetLastTotalPower method.
	GetLastTotalPowerFunc func(ctx context.Context) (math.Int, error)

	// IterateBondedValidatorsByPowerFunc mocks the IterateBondedValidatorsByPower method.
	IterateBondedValidatorsByPowerFunc func(ctx context.Context, fn func(index int64, validator stakingtypes.ValidatorI) (stop bool)) error

	// PowerReductionFunc mocks the PowerReduction method.
	PowerReductionFunc func(ctx context.Context) math.Int

	// ValidatorFunc mocks the Validator method.
	ValidatorFunc func(ctx context.Context, addr github_com_cosmos_cosmos_sdk_types.ValAddress) (stakingtypes.ValidatorI, error)

	// calls tracks calls to the methods.
	calls struct {
		// BondDenom holds details about calls to the BondDenom method.
		BondDenom []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetLastTotalPower holds details about calls to the GetLastTotalPower method.
		GetLastTotalPower []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// IterateBondedValidatorsByPower holds details about calls to the IterateBondedValidatorsByPower method.
		IterateBondedValidatorsByPower []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Fn is the fn argument value.
			Fn func(index int64, validator stakingtypes.ValidatorI) (stop bool)
		}
		// PowerReduction holds details about calls to the PowerReduction method.
		PowerReduction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Validator holds details about calls to the Validator method.
		Validator []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Addr is the addr argument value.
			Addr github_com_cosmos_cosmos_sdk_types.ValAddress
		}
	}
	lockBondDenom                      sync.RWMutex
	lockGetLastTotalPower              sync.RWMutex
	lockIterateBondedValidatorsByPower sync.RWMutex
	lockPowerReduction                 sync.RWMutex
	lockValidator                      sync.RWMutex
}

// BondDenom calls BondDenomFunc.
func (mock *StakingKeeperMock) BondDenom(ctx context.Context) (string, error) {
	if mock.BondDenomFunc == nil {
		panic("StakingKeeperMock.BondDenomFunc: method is nil but StakingKeeper.BondDenom was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockBondDenom.Lock()
	mock.calls.BondDenom = append(mock.calls.BondDenom, callInfo)
	mock.lockBondDenom.Unlock()
	return mock.BondDenomFunc(ctx)
}

// BondDenomCalls gets all the calls that were made to BondDenom.
// Check the length with:
//
//	len(mockedStakingKeeper.BondDenomCalls())
func (mock *StakingKeeperMock) BondDenomCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockBondDenom.RLock()
	calls = mock.calls.BondDenom
	mock.lockBondDenom.RUnlock()
	return calls
}

// GetLastTotalPower calls GetLastTotalPowerFunc.
func (mock *StakingKeeperMock) GetLastTotalPower(ctx context.Context) (math.Int, error) {
	if mock.GetLastTotalPowerFunc == nil {
		panic("StakingKeeperMock.GetLastTotalPowerFunc: method is nil but StakingKeeper.GetLastTotalPower was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetLastTotalPower.Lock()
	mock.calls.GetLastTotalPower = append(mock.calls.GetLastTotalPower, callInfo)
	mock.lockGetLastTotalPower.Unlock()
	return mock.GetLastTotalPowerFunc(ctx)
}

// GetLastTotalPowerCalls gets all the calls that were made to GetLastTotalPower.
// Check the length with:
//
//	len(mockedStakingKeeper.GetLastTotalPowerCalls())
func (mock *StakingKeeperMock) GetLastTotalPowerCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetLastTotalPower.RLock()
	calls = mock.calls.GetLastTotalPower
	mock.lockGetLastTotalPower.RUnlock()
	return calls
}

// IterateBondedValidatorsByPower calls IterateBondedValidatorsByPowerFunc.
func (mock *StakingKeeperMock) IterateBondedValidatorsByPower(ctx context.Context, fn func(index int64, validator stakingtypes.ValidatorI) (stop bool)) error {
	if mock.IterateBondedValidatorsByPowerFunc == nil {
		panic("StakingKeeperMock.IterateBondedValidatorsByPowerFunc: method is nil but StakingKeeper.IterateBondedValidatorsByPower was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Fn  func(index int64, validator stakingtypes.ValidatorI) (stop bool)
	}{
		Ctx: ctx,
		Fn:  fn,
	}
	mock.lockIterateBondedValidatorsByPower.Lock()
	mock.calls.IterateBondedValidatorsByPower = append(mock.calls.IterateBondedValidatorsByPower, callInfo)
	mock.lockIterateBondedValidatorsByPower.Unlock()
	return mock.IterateBondedValidatorsByPowerFunc(ctx, fn)
}

// IterateBondedValidatorsByPowerCalls gets all the calls that were made to IterateBondedValidatorsByPower.
// Check the length with:
//
//	len(mockedStakingKeeper.IterateBondedValidatorsByPowerCalls())
func (mock *StakingKeeperMock) IterateBondedValidatorsByPowerCalls() []struct {
	Ctx context.Context
	Fn  func(index int64, validator stakingtypes.ValidatorI) (stop bool)
} {
	var calls []struct {
		Ctx context.Context
		Fn  func(index int64, validator stakingtypes.ValidatorI) (stop bool)
	}
	mock.lockIterateBondedValidatorsByPower.RLock()
	calls = mock.calls.IterateBondedValidatorsByPower
	mock.lockIterateBondedValidatorsByPower.RUnlock()
	return calls
}

// PowerReduction calls PowerReductionFunc.
func (mock *StakingKeeperMock) PowerReduction(ctx context.Context) math.Int {
	if mock.PowerReductionFunc == nil {
		panic("StakingKeeperMock.PowerReductionFunc: method is nil but StakingKeeper.PowerReduction was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockPowerReduction.Lock()
	mock.calls.PowerReduction = append(mock.calls.PowerReduction, callInfo)
	mock.lockPowerReduction.Unlock()
	return mock.PowerReductionFunc(ctx)
}

// PowerReductionCalls gets all the calls that were made to PowerReduction.
// Check the length with:
//
//	len(mockedStakingKeeper.PowerReductionCalls())
func (mock *StakingKeeperMock) PowerReductionCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockPowerReduction.RLock()
	calls = mock.calls.PowerReduction
	mock.lockPowerReduction.RUnlock()
	return calls
}

// Validator calls ValidatorFunc.
func (mock *StakingKeeperMock) Validator(ctx context.Context, addr github_com_cosmos_cosmos_sdk_types.ValAddress) (stakingtypes.ValidatorI, error) {
	if mock.ValidatorFunc == nil {
		panic("StakingKeeperMock.ValidatorFunc: method is nil but StakingKeeper.Validator was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Addr github_com_cosmos_cosmos_sdk_types.ValAddress
	}{
		Ctx:  ctx,
		Addr: addr,
	}
	mock.lockValidator.Lock()
	mock.calls.Validator = append(mock.calls.Validator, callInfo)
	mock.lockValidator.Unlock()
	return mock.ValidatorFunc(ctx, addr)
}

// ValidatorCalls gets all the calls that were made to Validator.
// Check the length with:
//
//	len(mockedStakingKeeper.ValidatorCalls())
func (mock *StakingKeeperMock) ValidatorCalls() []struct {
	Ctx  context.Context
	Addr github_com_cosmos_cosmos_sdk_types.ValAddress
} {
	var calls []struct {
		Ctx  context.Context
		Addr github_com_cosmos_cosmos_sdk_types.ValAddress
	}
	mock.lockValidator.RLock()
	calls = mock.calls.Validator
	mock.lockValidator.RUnlock()
	return calls
}

// Ensure, that BankKeeperMock does implement snapshottypes.BankKeeper.
// If this is not the case, regenerate this file with moq.
var _ snapshottypes.BankKeeper = &BankKeeperMock{}

// BankKeeperMock is a mock implementation of snapshottypes.BankKeeper.
//
//	func TestSomethingThatUsesBankKeeper(t *testing.T) {
//
//		// make and configure a mocked snapshottypes.BankKeeper
//		mockedBankKeeper := &BankKeeperMock{
//			SpendableBalanceFunc: func(ctx context.Context, address github_com_cosmos_cosmos_sdk_types.AccAddress, denom string) github_com_cosmos_cosmos_sdk_types.Coin {
//				panic("mock out the SpendableBalance method")
//			},
//		}
//
//		// use mockedBankKeeper in code that requires snapshottypes.BankKeeper
//		// and then make assertions.
//
//	}
type BankKeeperMock struct {
	// SpendableBalanceFunc mocks the SpendableBalance method.
	SpendableBalanceFunc func(ctx context.Context, address github_com_cosmos_cosmos_sdk_types.AccAddress, denom string) github_com_cosmos_cosmos_sdk_types.Coin

	// calls tracks calls to the methods.
	calls struct {
		// SpendableBalance holds details about calls to the SpendableBalance method.
		SpendableBalance []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Address is the address argument value.
			Address github_com_cosmos_cosmos_sdk_types.AccAddress
			// Denom is the denom argument value.
			Denom string
		}
	}
	lockSpendableBalance sync.RWMutex
}

// SpendableBalance calls SpendableBalanceFunc.
func (mock *BankKeeperMock) SpendableBalance(ctx context.Context, address github_com_cosmos_cosmos_sdk_types.AccAddress, denom string) github_com_cosmos_cosmos_sdk_types.Coin {
	if mock.SpendableBalanceFunc == nil {
		panic("BankKeeperMock.SpendableBalanceFunc: method is nil but BankKeeper.SpendableBalance was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Address github_com_cosmos_cosmos_sdk_types.AccAddress
		Denom   string
	}{
		Ctx:     ctx,
		Address: address,
		Denom:   denom,
	}
	mock.lockSpendableBalance.Lock()
	mock.calls.SpendableBalance = append(mock.calls.SpendableBalance, callInfo)
	mock.lockSpendableBalance.Unlock()
	return mock.SpendableBalanceFunc(ctx, address, denom)
}

// SpendableBalanceCalls gets all the calls that were made to SpendableBalance.
// Check the length with:
//
//	len(mockedBankKeeper.SpendableBalanceCalls())
func (mock *BankKeeperMock) SpendableBalanceCalls() []struct {
	Ctx     context.Context
	Address github_com_cosmos_cosmos_sdk_types.AccAddress
	Denom   string
} {
	var calls []struct {
		Ctx     context.Context
		Address github_com_cosmos_cosmos_sdk_types.AccAddress
		Denom   string
	}
	mock.lockSpendableBalance.RLock()
	calls = mock.calls.SpendableBalance
	mock.lockSpendableBalance.RUnlock()
	return calls
}

// Ensure, that SlasherMock does implement snapshottypes.Slasher.
// If this is not the case, regenerate this file with moq.
var _ snapshottypes.Slasher = &SlasherMock{}

// SlasherMock is a mock implementation of snapshottypes.Slasher.
//
//	func TestSomethingThatUsesSlasher(t *testing.T) {
//
//		// make and configure a mocked snapshottypes.Slasher
//		mockedSlasher := &SlasherMock{
//			GetMissedBlockBitmapValueFunc: func(ctx context.Context, addr github_com_cosmos_cosmos_sdk_types.ConsAddress, index int64) (bool, error) {
//				panic("mock out the GetMissedBlockBitmapValue method")
//			},
//			GetValidatorSigningInfoFunc: func(ctx context.Context, address github_com_cosmos_cosmos_sdk_types.ConsAddress) (slashingtypes.ValidatorSigningInfo, error) {
//				panic("mock out the GetValidatorSigningInfo method")
//			},
//			SignedBlocksWindowFunc: func(ctx context.Context) (int64, error) {
//				panic("mock out the SignedBlocksWindow method")
//			},
//		}
//
//		// use mockedSlasher in code that requires snapshottypes.Slasher
//		// and then make assertions.
//
//	}
type SlasherMock struct {
	// GetMissedBlockBitmapValueFunc mocks the GetMissedBlockBitmapValue method.
	GetMissedBlockBitmapValueFunc func(ctx context.Context, addr github_com_cosmos_cosmos_sdk_types.ConsAddress, index int64) (bool, error)

	// GetValidatorSigningInfoFunc mocks the GetValidatorSigningInfo method.
	GetValidatorSigningInfoFunc func(ctx context.Context, address github_com_cosmos_cosmos_sdk_types.ConsAddress) (slashingtypes.ValidatorSigningInfo, error)

	// SignedBlocksWindowFunc mocks the SignedBlocksWindow method.
	SignedBlocksWindowFunc func(ctx context.Context) (int64, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetMissedBlockBitmapValue holds details about calls to the GetMissedBlockBitmapValue method.
		GetMissedBlockBitmapValue []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Addr is the addr argument value.
			Addr github_com_cosmos_cosmos_sdk_types.ConsAddress
			// Index is the index argument value.
			Index int64
		}
		// GetValidatorSigningInfo holds details about calls to the GetValidatorSigningInfo method.
		GetValidatorSigningInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Address is the address argument value.
			Address github_com_cosmos_cosmos_sdk_types.ConsAddress
		}
		// SignedBlocksWindow holds details about calls to the SignedBlocksWindow method.
		SignedBlocksWindow []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockGetMissedBlockBitmapValue sync.RWMutex
	lockGetValidatorSigningInfo   sync.RWMutex
	lockSignedBlocksWindow        sync.RWMutex
}

// GetMissedBlockBitmapValue calls GetMissedBlockBitmapValueFunc.
func (mock *SlasherMock) GetMissedBlockBitmapValue(ctx context.Context, addr github_com_cosmos_cosmos_sdk_types.ConsAddress, index int64) (bool, error) {
	if mock.GetMissedBlockBitmapValueFunc == nil {
		panic("SlasherMock.GetMissedBlockBitmapValueFunc: method is nil but Slasher.GetMissedBlockBitmapValue was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Addr  github_com_cosmos_cosmos_sdk_types.ConsAddress
		Index int64
	}{
		Ctx:   ctx,
		Addr:  addr,
		Index: index,
	}
	mock.lockGetMissedBlockBitmapValue.Lock()
	mock.calls.GetMissedBlockBitmapValue = append(mock.calls.GetMissedBlockBitmapValue, callInfo)
	mock.lockGetMissedBlockBitmapValue.Unlock()
	return mock.GetMissedBlockBitmapValueFunc(ctx, addr, index)
}

// GetMissedBlockBitmapValueCalls gets all the calls that were made to GetMissedBlockBitmapValue.
// Check the length with:
//
//	len(mockedSlasher.GetMissedBlockBitmapValueCalls())
func (mock *SlasherMock) GetMissedBlockBitmapValueCalls() []struct {
	Ctx   context.Context
	Addr  github_com_cosmos_cosmos_sdk_types.ConsAddress
	Index int64
} {
	var calls []struct {
		Ctx   context.Context
		Addr  github_com_cosmos_cosmos_sdk_types.ConsAddress
		Index int64
	}
	mock.lockGetMissedBlockBitmapValue.RLock()
	calls = mock.calls.GetMissedBlockBitmapValue
	mock.lockGetMissedBlockBitmapValue.RUnlock()
	return calls
}

// GetValidatorSigningInfo calls GetValidatorSigningInfoFunc.
func (mock *SlasherMock) GetValidatorSigningInfo(ctx context.Context, address github_com_cosmos_cosmos_sdk_types.ConsAddress) (slashingtypes.ValidatorSigningInfo, error) {
	if mock.GetValidatorSigningInfoFunc == nil {
		panic("SlasherMock.GetValidatorSigningInfoFunc: method is nil but Slasher.GetValidatorSigningInfo was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Address github_com_cosmos_cosmos_sdk_types.ConsAddress
	}{
		Ctx:     ctx,
		Address: address,
	}
	mock.lockGetValidatorSigningInfo.Lock()
	mock.calls.GetValidatorSigningInfo = append(mock.calls.GetValidatorSigningInfo, callInfo)
	mock.lockGetValidatorSigningInfo.Unlock()
	return mock.GetValidatorSigningInfoFunc(ctx, address)
}

// GetValidatorSigningInfoCalls gets all the calls that were made to GetValidatorSigningInfo.
// Check the length with:
//
//	len(mockedSlasher.GetValidatorSigningInfoCalls())
func (mock *SlasherMock) GetValidatorSigningInfoCalls() []struct {
	Ctx     context.Context
	Address github_com_cosmos_cosmos_sdk_types.ConsAddress
} {
	var calls []struct {
		Ctx     context.Context
		Address github_com_cosmos_cosmos_sdk_types.ConsAddress
	}
	mock.lockGetValidatorSigningInfo.RLock()
	calls = mock.calls.GetValidatorSigningInfo
	mock.lockGetValidatorSigningInfo.RUnlock()
	return calls
}

// SignedBlocksWindow calls SignedBlocksWindowFunc.
func (mock *SlasherMock) SignedBlocksWindow(ctx context.Context) (int64, error) {
	if mock.SignedBlocksWindowFunc == nil {
		panic("SlasherMock.SignedBlocksWindowFunc: method is nil but Slasher.SignedBlocksWindow was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockSignedBlocksWindow.Lock()
	mock.calls.SignedBlocksWindow = append(mock.calls.SignedBlocksWindow, callInfo)
	mock.lockSignedBlocksWindow.Unlock()
	return mock.SignedBlocksWindowFunc(ctx)
}

// SignedBlocksWindowCalls gets all the calls that were made to SignedBlocksWindow.
// Check the length with:
//
//	len(mockedSlasher.SignedBlocksWindowCalls())
func (mock *SlasherMock) SignedBlocksWindowCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockSignedBlocksWindow.RLock()
	calls = mock.calls.SignedBlocksWindow
	mock.lockSignedBlocksWindow.RUnlock()
	return calls
}
