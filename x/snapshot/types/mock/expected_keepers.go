// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"github.com/axelarnetwork/axelar-core/x/snapshot/types"
	sdk "github.com/cosmos/cosmos-sdk/types"
	sdkExported "github.com/cosmos/cosmos-sdk/x/staking/exported"
	"sync"
)

// Ensure, that StakingKeeperMock does implement types.StakingKeeper.
// If this is not the case, regenerate this file with moq.
var _ types.StakingKeeper = &StakingKeeperMock{}

// StakingKeeperMock is a mock implementation of types.StakingKeeper.
//
// 	func TestSomethingThatUsesStakingKeeper(t *testing.T) {
//
// 		// make and configure a mocked types.StakingKeeper
// 		mockedStakingKeeper := &StakingKeeperMock{
// 			GetLastTotalPowerFunc: func(ctx sdk.Context) sdk.Int {
// 				panic("mock out the GetLastTotalPower method")
// 			},
// 			IterateLastValidatorsFunc: func(ctx sdk.Context, fn func(index int64, validator sdkExported.ValidatorI) (stop bool))  {
// 				panic("mock out the IterateLastValidators method")
// 			},
// 			ValidatorFunc: func(ctx sdk.Context, addr sdk.ValAddress) sdkExported.ValidatorI {
// 				panic("mock out the Validator method")
// 			},
// 		}
//
// 		// use mockedStakingKeeper in code that requires types.StakingKeeper
// 		// and then make assertions.
//
// 	}
type StakingKeeperMock struct {
	// GetLastTotalPowerFunc mocks the GetLastTotalPower method.
	GetLastTotalPowerFunc func(ctx sdk.Context) sdk.Int

	// IterateLastValidatorsFunc mocks the IterateLastValidators method.
	IterateLastValidatorsFunc func(ctx sdk.Context, fn func(index int64, validator sdkExported.ValidatorI) (stop bool))

	// ValidatorFunc mocks the Validator method.
	ValidatorFunc func(ctx sdk.Context, addr sdk.ValAddress) sdkExported.ValidatorI

	// calls tracks calls to the methods.
	calls struct {
		// GetLastTotalPower holds details about calls to the GetLastTotalPower method.
		GetLastTotalPower []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// IterateLastValidators holds details about calls to the IterateLastValidators method.
		IterateLastValidators []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Fn is the fn argument value.
			Fn func(index int64, validator sdkExported.ValidatorI) (stop bool)
		}
		// Validator holds details about calls to the Validator method.
		Validator []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Addr is the addr argument value.
			Addr sdk.ValAddress
		}
	}
	lockGetLastTotalPower     sync.RWMutex
	lockIterateLastValidators sync.RWMutex
	lockValidator             sync.RWMutex
}

// GetLastTotalPower calls GetLastTotalPowerFunc.
func (mock *StakingKeeperMock) GetLastTotalPower(ctx sdk.Context) sdk.Int {
	if mock.GetLastTotalPowerFunc == nil {
		panic("StakingKeeperMock.GetLastTotalPowerFunc: method is nil but StakingKeeper.GetLastTotalPower was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetLastTotalPower.Lock()
	mock.calls.GetLastTotalPower = append(mock.calls.GetLastTotalPower, callInfo)
	mock.lockGetLastTotalPower.Unlock()
	return mock.GetLastTotalPowerFunc(ctx)
}

// GetLastTotalPowerCalls gets all the calls that were made to GetLastTotalPower.
// Check the length with:
//     len(mockedStakingKeeper.GetLastTotalPowerCalls())
func (mock *StakingKeeperMock) GetLastTotalPowerCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetLastTotalPower.RLock()
	calls = mock.calls.GetLastTotalPower
	mock.lockGetLastTotalPower.RUnlock()
	return calls
}

// IterateLastValidators calls IterateLastValidatorsFunc.
func (mock *StakingKeeperMock) IterateLastValidators(ctx sdk.Context, fn func(index int64, validator sdkExported.ValidatorI) (stop bool)) {
	if mock.IterateLastValidatorsFunc == nil {
		panic("StakingKeeperMock.IterateLastValidatorsFunc: method is nil but StakingKeeper.IterateLastValidators was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
		Fn  func(index int64, validator sdkExported.ValidatorI) (stop bool)
	}{
		Ctx: ctx,
		Fn:  fn,
	}
	mock.lockIterateLastValidators.Lock()
	mock.calls.IterateLastValidators = append(mock.calls.IterateLastValidators, callInfo)
	mock.lockIterateLastValidators.Unlock()
	mock.IterateLastValidatorsFunc(ctx, fn)
}

// IterateLastValidatorsCalls gets all the calls that were made to IterateLastValidators.
// Check the length with:
//     len(mockedStakingKeeper.IterateLastValidatorsCalls())
func (mock *StakingKeeperMock) IterateLastValidatorsCalls() []struct {
	Ctx sdk.Context
	Fn  func(index int64, validator sdkExported.ValidatorI) (stop bool)
} {
	var calls []struct {
		Ctx sdk.Context
		Fn  func(index int64, validator sdkExported.ValidatorI) (stop bool)
	}
	mock.lockIterateLastValidators.RLock()
	calls = mock.calls.IterateLastValidators
	mock.lockIterateLastValidators.RUnlock()
	return calls
}

// Validator calls ValidatorFunc.
func (mock *StakingKeeperMock) Validator(ctx sdk.Context, addr sdk.ValAddress) sdkExported.ValidatorI {
	if mock.ValidatorFunc == nil {
		panic("StakingKeeperMock.ValidatorFunc: method is nil but StakingKeeper.Validator was just called")
	}
	callInfo := struct {
		Ctx  sdk.Context
		Addr sdk.ValAddress
	}{
		Ctx:  ctx,
		Addr: addr,
	}
	mock.lockValidator.Lock()
	mock.calls.Validator = append(mock.calls.Validator, callInfo)
	mock.lockValidator.Unlock()
	return mock.ValidatorFunc(ctx, addr)
}

// ValidatorCalls gets all the calls that were made to Validator.
// Check the length with:
//     len(mockedStakingKeeper.ValidatorCalls())
func (mock *StakingKeeperMock) ValidatorCalls() []struct {
	Ctx  sdk.Context
	Addr sdk.ValAddress
} {
	var calls []struct {
		Ctx  sdk.Context
		Addr sdk.ValAddress
	}
	mock.lockValidator.RLock()
	calls = mock.calls.Validator
	mock.lockValidator.RUnlock()
	return calls
}

// Ensure, that SlasherMock does implement types.Slasher.
// If this is not the case, regenerate this file with moq.
var _ types.Slasher = &SlasherMock{}

// SlasherMock is a mock implementation of types.Slasher.
//
// 	func TestSomethingThatUsesSlasher(t *testing.T) {
//
// 		// make and configure a mocked types.Slasher
// 		mockedSlasher := &SlasherMock{
// 			GetValidatorSigningInfoFunc: func(ctx sdk.Context, address sdk.ConsAddress) (types.ValidatorInfo, bool) {
// 				panic("mock out the GetValidatorSigningInfo method")
// 			},
// 		}
//
// 		// use mockedSlasher in code that requires types.Slasher
// 		// and then make assertions.
//
// 	}
type SlasherMock struct {
	// GetValidatorSigningInfoFunc mocks the GetValidatorSigningInfo method.
	GetValidatorSigningInfoFunc func(ctx sdk.Context, address sdk.ConsAddress) (types.ValidatorInfo, bool)

	// calls tracks calls to the methods.
	calls struct {
		// GetValidatorSigningInfo holds details about calls to the GetValidatorSigningInfo method.
		GetValidatorSigningInfo []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Address is the address argument value.
			Address sdk.ConsAddress
		}
	}
	lockGetValidatorSigningInfo sync.RWMutex
}

// GetValidatorSigningInfo calls GetValidatorSigningInfoFunc.
func (mock *SlasherMock) GetValidatorSigningInfo(ctx sdk.Context, address sdk.ConsAddress) (types.ValidatorInfo, bool) {
	if mock.GetValidatorSigningInfoFunc == nil {
		panic("SlasherMock.GetValidatorSigningInfoFunc: method is nil but Slasher.GetValidatorSigningInfo was just called")
	}
	callInfo := struct {
		Ctx     sdk.Context
		Address sdk.ConsAddress
	}{
		Ctx:     ctx,
		Address: address,
	}
	mock.lockGetValidatorSigningInfo.Lock()
	mock.calls.GetValidatorSigningInfo = append(mock.calls.GetValidatorSigningInfo, callInfo)
	mock.lockGetValidatorSigningInfo.Unlock()
	return mock.GetValidatorSigningInfoFunc(ctx, address)
}

// GetValidatorSigningInfoCalls gets all the calls that were made to GetValidatorSigningInfo.
// Check the length with:
//     len(mockedSlasher.GetValidatorSigningInfoCalls())
func (mock *SlasherMock) GetValidatorSigningInfoCalls() []struct {
	Ctx     sdk.Context
	Address sdk.ConsAddress
} {
	var calls []struct {
		Ctx     sdk.Context
		Address sdk.ConsAddress
	}
	mock.lockGetValidatorSigningInfo.RLock()
	calls = mock.calls.GetValidatorSigningInfo
	mock.lockGetValidatorSigningInfo.RUnlock()
	return calls
}

// Ensure, that BroadcasterMock does implement types.Broadcaster.
// If this is not the case, regenerate this file with moq.
var _ types.Broadcaster = &BroadcasterMock{}

// BroadcasterMock is a mock implementation of types.Broadcaster.
//
// 	func TestSomethingThatUsesBroadcaster(t *testing.T) {
//
// 		// make and configure a mocked types.Broadcaster
// 		mockedBroadcaster := &BroadcasterMock{
// 			GetProxyFunc: func(ctx sdk.Context, principal sdk.ValAddress) sdk.AccAddress {
// 				panic("mock out the GetProxy method")
// 			},
// 		}
//
// 		// use mockedBroadcaster in code that requires types.Broadcaster
// 		// and then make assertions.
//
// 	}
type BroadcasterMock struct {
	// GetProxyFunc mocks the GetProxy method.
	GetProxyFunc func(ctx sdk.Context, principal sdk.ValAddress) sdk.AccAddress

	// calls tracks calls to the methods.
	calls struct {
		// GetProxy holds details about calls to the GetProxy method.
		GetProxy []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Principal is the principal argument value.
			Principal sdk.ValAddress
		}
	}
	lockGetProxy sync.RWMutex
}

// GetProxy calls GetProxyFunc.
func (mock *BroadcasterMock) GetProxy(ctx sdk.Context, principal sdk.ValAddress) sdk.AccAddress {
	if mock.GetProxyFunc == nil {
		panic("BroadcasterMock.GetProxyFunc: method is nil but Broadcaster.GetProxy was just called")
	}
	callInfo := struct {
		Ctx       sdk.Context
		Principal sdk.ValAddress
	}{
		Ctx:       ctx,
		Principal: principal,
	}
	mock.lockGetProxy.Lock()
	mock.calls.GetProxy = append(mock.calls.GetProxy, callInfo)
	mock.lockGetProxy.Unlock()
	return mock.GetProxyFunc(ctx, principal)
}

// GetProxyCalls gets all the calls that were made to GetProxy.
// Check the length with:
//     len(mockedBroadcaster.GetProxyCalls())
func (mock *BroadcasterMock) GetProxyCalls() []struct {
	Ctx       sdk.Context
	Principal sdk.ValAddress
} {
	var calls []struct {
		Ctx       sdk.Context
		Principal sdk.ValAddress
	}
	mock.lockGetProxy.RLock()
	calls = mock.calls.GetProxy
	mock.lockGetProxy.RUnlock()
	return calls
}

// Ensure, that TssMock does implement types.Tss.
// If this is not the case, regenerate this file with moq.
var _ types.Tss = &TssMock{}

// TssMock is a mock implementation of types.Tss.
//
// 	func TestSomethingThatUsesTss(t *testing.T) {
//
// 		// make and configure a mocked types.Tss
// 		mockedTss := &TssMock{
// 			GetValidatorDeregisteredBlockHeightFunc: func(ctx sdk.Context, valAddr sdk.ValAddress) int64 {
// 				panic("mock out the GetValidatorDeregisteredBlockHeight method")
// 			},
// 		}
//
// 		// use mockedTss in code that requires types.Tss
// 		// and then make assertions.
//
// 	}
type TssMock struct {
	// GetValidatorDeregisteredBlockHeightFunc mocks the GetValidatorDeregisteredBlockHeight method.
	GetValidatorDeregisteredBlockHeightFunc func(ctx sdk.Context, valAddr sdk.ValAddress) int64

	// calls tracks calls to the methods.
	calls struct {
		// GetValidatorDeregisteredBlockHeight holds details about calls to the GetValidatorDeregisteredBlockHeight method.
		GetValidatorDeregisteredBlockHeight []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// ValAddr is the valAddr argument value.
			ValAddr sdk.ValAddress
		}
	}
	lockGetValidatorDeregisteredBlockHeight sync.RWMutex
}

// GetValidatorDeregisteredBlockHeight calls GetValidatorDeregisteredBlockHeightFunc.
func (mock *TssMock) GetValidatorDeregisteredBlockHeight(ctx sdk.Context, valAddr sdk.ValAddress) int64 {
	if mock.GetValidatorDeregisteredBlockHeightFunc == nil {
		panic("TssMock.GetValidatorDeregisteredBlockHeightFunc: method is nil but Tss.GetValidatorDeregisteredBlockHeight was just called")
	}
	callInfo := struct {
		Ctx     sdk.Context
		ValAddr sdk.ValAddress
	}{
		Ctx:     ctx,
		ValAddr: valAddr,
	}
	mock.lockGetValidatorDeregisteredBlockHeight.Lock()
	mock.calls.GetValidatorDeregisteredBlockHeight = append(mock.calls.GetValidatorDeregisteredBlockHeight, callInfo)
	mock.lockGetValidatorDeregisteredBlockHeight.Unlock()
	return mock.GetValidatorDeregisteredBlockHeightFunc(ctx, valAddr)
}

// GetValidatorDeregisteredBlockHeightCalls gets all the calls that were made to GetValidatorDeregisteredBlockHeight.
// Check the length with:
//     len(mockedTss.GetValidatorDeregisteredBlockHeightCalls())
func (mock *TssMock) GetValidatorDeregisteredBlockHeightCalls() []struct {
	Ctx     sdk.Context
	ValAddr sdk.ValAddress
} {
	var calls []struct {
		Ctx     sdk.Context
		ValAddr sdk.ValAddress
	}
	mock.lockGetValidatorDeregisteredBlockHeight.RLock()
	calls = mock.calls.GetValidatorDeregisteredBlockHeight
	mock.lockGetValidatorDeregisteredBlockHeight.RUnlock()
	return calls
}
