// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"github.com/axelarnetwork/axelar-core/x/snapshot/exported"
	sdk "github.com/cosmos/cosmos-sdk/types"
	"sync"
)

// Ensure, that SnapshotterMock does implement exported.Snapshotter.
// If this is not the case, regenerate this file with moq.
var _ exported.Snapshotter = &SnapshotterMock{}

// SnapshotterMock is a mock implementation of exported.Snapshotter.
//
// 	func TestSomethingThatUsesSnapshotter(t *testing.T) {
//
// 		// make and configure a mocked exported.Snapshotter
// 		mockedSnapshotter := &SnapshotterMock{
// 			GetLatestRoundFunc: func(ctx sdk.Context) int64 {
// 				panic("mock out the GetLatestRound method")
// 			},
// 			GetLatestSnapshotFunc: func(ctx sdk.Context) (exported.Snapshot, bool) {
// 				panic("mock out the GetLatestSnapshot method")
// 			},
// 			GetSnapshotFunc: func(ctx sdk.Context, round int64) (exported.Snapshot, bool) {
// 				panic("mock out the GetSnapshot method")
// 			},
// 			GetValidatorFunc: func(ctx sdk.Context, address sdk.ValAddress) (exported.Validator, bool) {
// 				panic("mock out the GetValidator method")
// 			},
// 		}
//
// 		// use mockedSnapshotter in code that requires exported.Snapshotter
// 		// and then make assertions.
//
// 	}
type SnapshotterMock struct {
	// GetLatestRoundFunc mocks the GetLatestRound method.
	GetLatestRoundFunc func(ctx sdk.Context) int64

	// GetLatestSnapshotFunc mocks the GetLatestSnapshot method.
	GetLatestSnapshotFunc func(ctx sdk.Context) (exported.Snapshot, bool)

	// GetSnapshotFunc mocks the GetSnapshot method.
	GetSnapshotFunc func(ctx sdk.Context, round int64) (exported.Snapshot, bool)

	// GetValidatorFunc mocks the GetValidator method.
	GetValidatorFunc func(ctx sdk.Context, address sdk.ValAddress) (exported.Validator, bool)

	// calls tracks calls to the methods.
	calls struct {
		// GetLatestRound holds details about calls to the GetLatestRound method.
		GetLatestRound []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetLatestSnapshot holds details about calls to the GetLatestSnapshot method.
		GetLatestSnapshot []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
		}
		// GetSnapshot holds details about calls to the GetSnapshot method.
		GetSnapshot []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Round is the round argument value.
			Round int64
		}
		// GetValidator holds details about calls to the GetValidator method.
		GetValidator []struct {
			// Ctx is the ctx argument value.
			Ctx sdk.Context
			// Address is the address argument value.
			Address sdk.ValAddress
		}
	}
	lockGetLatestRound    sync.RWMutex
	lockGetLatestSnapshot sync.RWMutex
	lockGetSnapshot       sync.RWMutex
	lockGetValidator      sync.RWMutex
}

// GetLatestRound calls GetLatestRoundFunc.
func (mock *SnapshotterMock) GetLatestRound(ctx sdk.Context) int64 {
	if mock.GetLatestRoundFunc == nil {
		panic("SnapshotterMock.GetLatestRoundFunc: method is nil but Snapshotter.GetLatestRound was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetLatestRound.Lock()
	mock.calls.GetLatestRound = append(mock.calls.GetLatestRound, callInfo)
	mock.lockGetLatestRound.Unlock()
	return mock.GetLatestRoundFunc(ctx)
}

// GetLatestRoundCalls gets all the calls that were made to GetLatestRound.
// Check the length with:
//     len(mockedSnapshotter.GetLatestRoundCalls())
func (mock *SnapshotterMock) GetLatestRoundCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetLatestRound.RLock()
	calls = mock.calls.GetLatestRound
	mock.lockGetLatestRound.RUnlock()
	return calls
}

// GetLatestSnapshot calls GetLatestSnapshotFunc.
func (mock *SnapshotterMock) GetLatestSnapshot(ctx sdk.Context) (exported.Snapshot, bool) {
	if mock.GetLatestSnapshotFunc == nil {
		panic("SnapshotterMock.GetLatestSnapshotFunc: method is nil but Snapshotter.GetLatestSnapshot was just called")
	}
	callInfo := struct {
		Ctx sdk.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetLatestSnapshot.Lock()
	mock.calls.GetLatestSnapshot = append(mock.calls.GetLatestSnapshot, callInfo)
	mock.lockGetLatestSnapshot.Unlock()
	return mock.GetLatestSnapshotFunc(ctx)
}

// GetLatestSnapshotCalls gets all the calls that were made to GetLatestSnapshot.
// Check the length with:
//     len(mockedSnapshotter.GetLatestSnapshotCalls())
func (mock *SnapshotterMock) GetLatestSnapshotCalls() []struct {
	Ctx sdk.Context
} {
	var calls []struct {
		Ctx sdk.Context
	}
	mock.lockGetLatestSnapshot.RLock()
	calls = mock.calls.GetLatestSnapshot
	mock.lockGetLatestSnapshot.RUnlock()
	return calls
}

// GetSnapshot calls GetSnapshotFunc.
func (mock *SnapshotterMock) GetSnapshot(ctx sdk.Context, round int64) (exported.Snapshot, bool) {
	if mock.GetSnapshotFunc == nil {
		panic("SnapshotterMock.GetSnapshotFunc: method is nil but Snapshotter.GetSnapshot was just called")
	}
	callInfo := struct {
		Ctx   sdk.Context
		Round int64
	}{
		Ctx:   ctx,
		Round: round,
	}
	mock.lockGetSnapshot.Lock()
	mock.calls.GetSnapshot = append(mock.calls.GetSnapshot, callInfo)
	mock.lockGetSnapshot.Unlock()
	return mock.GetSnapshotFunc(ctx, round)
}

// GetSnapshotCalls gets all the calls that were made to GetSnapshot.
// Check the length with:
//     len(mockedSnapshotter.GetSnapshotCalls())
func (mock *SnapshotterMock) GetSnapshotCalls() []struct {
	Ctx   sdk.Context
	Round int64
} {
	var calls []struct {
		Ctx   sdk.Context
		Round int64
	}
	mock.lockGetSnapshot.RLock()
	calls = mock.calls.GetSnapshot
	mock.lockGetSnapshot.RUnlock()
	return calls
}

// GetValidator calls GetValidatorFunc.
func (mock *SnapshotterMock) GetValidator(ctx sdk.Context, address sdk.ValAddress) (exported.Validator, bool) {
	if mock.GetValidatorFunc == nil {
		panic("SnapshotterMock.GetValidatorFunc: method is nil but Snapshotter.GetValidator was just called")
	}
	callInfo := struct {
		Ctx     sdk.Context
		Address sdk.ValAddress
	}{
		Ctx:     ctx,
		Address: address,
	}
	mock.lockGetValidator.Lock()
	mock.calls.GetValidator = append(mock.calls.GetValidator, callInfo)
	mock.lockGetValidator.Unlock()
	return mock.GetValidatorFunc(ctx, address)
}

// GetValidatorCalls gets all the calls that were made to GetValidator.
// Check the length with:
//     len(mockedSnapshotter.GetValidatorCalls())
func (mock *SnapshotterMock) GetValidatorCalls() []struct {
	Ctx     sdk.Context
	Address sdk.ValAddress
} {
	var calls []struct {
		Ctx     sdk.Context
		Address sdk.ValAddress
	}
	mock.lockGetValidator.RLock()
	calls = mock.calls.GetValidator
	mock.lockGetValidator.RUnlock()
	return calls
}

// Ensure, that ValidatorMock does implement exported.Validator.
// If this is not the case, regenerate this file with moq.
var _ exported.Validator = &ValidatorMock{}

// ValidatorMock is a mock implementation of exported.Validator.
//
// 	func TestSomethingThatUsesValidator(t *testing.T) {
//
// 		// make and configure a mocked exported.Validator
// 		mockedValidator := &ValidatorMock{
// 			GetConsensusPowerFunc: func() int64 {
// 				panic("mock out the GetConsensusPower method")
// 			},
// 			GetOperatorFunc: func() sdk.ValAddress {
// 				panic("mock out the GetOperator method")
// 			},
// 		}
//
// 		// use mockedValidator in code that requires exported.Validator
// 		// and then make assertions.
//
// 	}
type ValidatorMock struct {
	// GetConsensusPowerFunc mocks the GetConsensusPower method.
	GetConsensusPowerFunc func() int64

	// GetOperatorFunc mocks the GetOperator method.
	GetOperatorFunc func() sdk.ValAddress

	// calls tracks calls to the methods.
	calls struct {
		// GetConsensusPower holds details about calls to the GetConsensusPower method.
		GetConsensusPower []struct {
		}
		// GetOperator holds details about calls to the GetOperator method.
		GetOperator []struct {
		}
	}
	lockGetConsensusPower sync.RWMutex
	lockGetOperator       sync.RWMutex
}

// GetConsensusPower calls GetConsensusPowerFunc.
func (mock *ValidatorMock) GetConsensusPower() int64 {
	if mock.GetConsensusPowerFunc == nil {
		panic("ValidatorMock.GetConsensusPowerFunc: method is nil but Validator.GetConsensusPower was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetConsensusPower.Lock()
	mock.calls.GetConsensusPower = append(mock.calls.GetConsensusPower, callInfo)
	mock.lockGetConsensusPower.Unlock()
	return mock.GetConsensusPowerFunc()
}

// GetConsensusPowerCalls gets all the calls that were made to GetConsensusPower.
// Check the length with:
//     len(mockedValidator.GetConsensusPowerCalls())
func (mock *ValidatorMock) GetConsensusPowerCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetConsensusPower.RLock()
	calls = mock.calls.GetConsensusPower
	mock.lockGetConsensusPower.RUnlock()
	return calls
}

// GetOperator calls GetOperatorFunc.
func (mock *ValidatorMock) GetOperator() sdk.ValAddress {
	if mock.GetOperatorFunc == nil {
		panic("ValidatorMock.GetOperatorFunc: method is nil but Validator.GetOperator was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetOperator.Lock()
	mock.calls.GetOperator = append(mock.calls.GetOperator, callInfo)
	mock.lockGetOperator.Unlock()
	return mock.GetOperatorFunc()
}

// GetOperatorCalls gets all the calls that were made to GetOperator.
// Check the length with:
//     len(mockedValidator.GetOperatorCalls())
func (mock *ValidatorMock) GetOperatorCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetOperator.RLock()
	calls = mock.calls.GetOperator
	mock.lockGetOperator.RUnlock()
	return calls
}
