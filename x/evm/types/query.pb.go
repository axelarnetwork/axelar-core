// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: evm/v1beta1/query.proto

package types

import (
	fmt "fmt"
	github_com_axelarnetwork_axelar_core_x_tss_exported "github.com/axelarnetwork/axelar-core/x/tss/exported"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// DepositQueryParams describe the parameters used to query for an EVM
// deposit address
type DepositQueryParams struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Asset   string `protobuf:"bytes,2,opt,name=asset,proto3" json:"asset,omitempty"`
	Chain   string `protobuf:"bytes,3,opt,name=chain,proto3" json:"chain,omitempty"`
}

func (m *DepositQueryParams) Reset()         { *m = DepositQueryParams{} }
func (m *DepositQueryParams) String() string { return proto.CompactTextString(m) }
func (*DepositQueryParams) ProtoMessage()    {}
func (*DepositQueryParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_78a1f61c7ae3396c, []int{0}
}
func (m *DepositQueryParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DepositQueryParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DepositQueryParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DepositQueryParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DepositQueryParams.Merge(m, src)
}
func (m *DepositQueryParams) XXX_Size() int {
	return m.Size()
}
func (m *DepositQueryParams) XXX_DiscardUnknown() {
	xxx_messageInfo_DepositQueryParams.DiscardUnknown(m)
}

var xxx_messageInfo_DepositQueryParams proto.InternalMessageInfo

type QueryBatchedCommandsResponse struct {
	ID                    string                                                    `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Data                  string                                                    `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	Status                BatchedCommandsStatus                                     `protobuf:"varint,3,opt,name=status,proto3,enum=evm.v1beta1.BatchedCommandsStatus" json:"status,omitempty"`
	KeyID                 github_com_axelarnetwork_axelar_core_x_tss_exported.KeyID `protobuf:"bytes,4,opt,name=key_id,json=keyId,proto3,casttype=github.com/axelarnetwork/axelar-core/x/tss/exported.KeyID" json:"key_id,omitempty"`
	Signature             []string                                                  `protobuf:"bytes,5,rep,name=signature,proto3" json:"signature,omitempty"`
	ExecuteData           string                                                    `protobuf:"bytes,6,opt,name=execute_data,json=executeData,proto3" json:"execute_data,omitempty"`
	PrevBatchedCommandsID string                                                    `protobuf:"bytes,7,opt,name=prev_batched_commands_id,json=prevBatchedCommandsId,proto3" json:"prev_batched_commands_id,omitempty"`
	CommandIDs            []string                                                  `protobuf:"bytes,8,rep,name=command_ids,json=commandIds,proto3" json:"command_ids,omitempty"`
}

func (m *QueryBatchedCommandsResponse) Reset()         { *m = QueryBatchedCommandsResponse{} }
func (m *QueryBatchedCommandsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryBatchedCommandsResponse) ProtoMessage()    {}
func (*QueryBatchedCommandsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78a1f61c7ae3396c, []int{1}
}
func (m *QueryBatchedCommandsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryBatchedCommandsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryBatchedCommandsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryBatchedCommandsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryBatchedCommandsResponse.Merge(m, src)
}
func (m *QueryBatchedCommandsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryBatchedCommandsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryBatchedCommandsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryBatchedCommandsResponse proto.InternalMessageInfo

type QueryAddressResponse struct {
	KeyID github_com_axelarnetwork_axelar_core_x_tss_exported.KeyID `protobuf:"bytes,1,opt,name=key_id,json=keyId,proto3,casttype=github.com/axelarnetwork/axelar-core/x/tss/exported.KeyID" json:"key_id,omitempty"`
	// Types that are valid to be assigned to Address:
	//	*QueryAddressResponse_MultisigAddresses_
	//	*QueryAddressResponse_ThresholdAddress_
	Address isQueryAddressResponse_Address `protobuf_oneof:"address"`
}

func (m *QueryAddressResponse) Reset()         { *m = QueryAddressResponse{} }
func (m *QueryAddressResponse) String() string { return proto.CompactTextString(m) }
func (*QueryAddressResponse) ProtoMessage()    {}
func (*QueryAddressResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78a1f61c7ae3396c, []int{2}
}
func (m *QueryAddressResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAddressResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAddressResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAddressResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAddressResponse.Merge(m, src)
}
func (m *QueryAddressResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryAddressResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAddressResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAddressResponse proto.InternalMessageInfo

type isQueryAddressResponse_Address interface {
	isQueryAddressResponse_Address()
	MarshalTo([]byte) (int, error)
	Size() int
}

type QueryAddressResponse_MultisigAddresses_ struct {
	MultisigAddresses *QueryAddressResponse_MultisigAddresses `protobuf:"bytes,2,opt,name=multisig_addresses,json=multisigAddresses,proto3,oneof" json:"multisig_addresses,omitempty"`
}
type QueryAddressResponse_ThresholdAddress_ struct {
	ThresholdAddress *QueryAddressResponse_ThresholdAddress `protobuf:"bytes,3,opt,name=threshold_address,json=thresholdAddress,proto3,oneof" json:"threshold_address,omitempty"`
}

func (*QueryAddressResponse_MultisigAddresses_) isQueryAddressResponse_Address() {}
func (*QueryAddressResponse_ThresholdAddress_) isQueryAddressResponse_Address()  {}

func (m *QueryAddressResponse) GetAddress() isQueryAddressResponse_Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *QueryAddressResponse) GetMultisigAddresses() *QueryAddressResponse_MultisigAddresses {
	if x, ok := m.GetAddress().(*QueryAddressResponse_MultisigAddresses_); ok {
		return x.MultisigAddresses
	}
	return nil
}

func (m *QueryAddressResponse) GetThresholdAddress() *QueryAddressResponse_ThresholdAddress {
	if x, ok := m.GetAddress().(*QueryAddressResponse_ThresholdAddress_); ok {
		return x.ThresholdAddress
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*QueryAddressResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*QueryAddressResponse_MultisigAddresses_)(nil),
		(*QueryAddressResponse_ThresholdAddress_)(nil),
	}
}

type QueryAddressResponse_MultisigAddresses struct {
	Addresses []string `protobuf:"bytes,1,rep,name=addresses,proto3" json:"addresses,omitempty"`
	Threshold uint32   `protobuf:"varint,2,opt,name=threshold,proto3" json:"threshold,omitempty"`
}

func (m *QueryAddressResponse_MultisigAddresses) Reset() {
	*m = QueryAddressResponse_MultisigAddresses{}
}
func (m *QueryAddressResponse_MultisigAddresses) String() string { return proto.CompactTextString(m) }
func (*QueryAddressResponse_MultisigAddresses) ProtoMessage()    {}
func (*QueryAddressResponse_MultisigAddresses) Descriptor() ([]byte, []int) {
	return fileDescriptor_78a1f61c7ae3396c, []int{2, 0}
}
func (m *QueryAddressResponse_MultisigAddresses) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAddressResponse_MultisigAddresses) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAddressResponse_MultisigAddresses.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAddressResponse_MultisigAddresses) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAddressResponse_MultisigAddresses.Merge(m, src)
}
func (m *QueryAddressResponse_MultisigAddresses) XXX_Size() int {
	return m.Size()
}
func (m *QueryAddressResponse_MultisigAddresses) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAddressResponse_MultisigAddresses.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAddressResponse_MultisigAddresses proto.InternalMessageInfo

type QueryAddressResponse_ThresholdAddress struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *QueryAddressResponse_ThresholdAddress) Reset()         { *m = QueryAddressResponse_ThresholdAddress{} }
func (m *QueryAddressResponse_ThresholdAddress) String() string { return proto.CompactTextString(m) }
func (*QueryAddressResponse_ThresholdAddress) ProtoMessage()    {}
func (*QueryAddressResponse_ThresholdAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_78a1f61c7ae3396c, []int{2, 1}
}
func (m *QueryAddressResponse_ThresholdAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAddressResponse_ThresholdAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAddressResponse_ThresholdAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAddressResponse_ThresholdAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAddressResponse_ThresholdAddress.Merge(m, src)
}
func (m *QueryAddressResponse_ThresholdAddress) XXX_Size() int {
	return m.Size()
}
func (m *QueryAddressResponse_ThresholdAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAddressResponse_ThresholdAddress.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAddressResponse_ThresholdAddress proto.InternalMessageInfo

type QueryTokenAddressResponse struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *QueryTokenAddressResponse) Reset()         { *m = QueryTokenAddressResponse{} }
func (m *QueryTokenAddressResponse) String() string { return proto.CompactTextString(m) }
func (*QueryTokenAddressResponse) ProtoMessage()    {}
func (*QueryTokenAddressResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78a1f61c7ae3396c, []int{3}
}
func (m *QueryTokenAddressResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryTokenAddressResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryTokenAddressResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryTokenAddressResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryTokenAddressResponse.Merge(m, src)
}
func (m *QueryTokenAddressResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryTokenAddressResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryTokenAddressResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryTokenAddressResponse proto.InternalMessageInfo

type QueryDepositStateParams struct {
	TxID          Hash    `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3,customtype=Hash" json:"tx_id"`
	BurnerAddress Address `protobuf:"bytes,2,opt,name=burner_address,json=burnerAddress,proto3,customtype=Address" json:"burner_address"`
	Amount        string  `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *QueryDepositStateParams) Reset()         { *m = QueryDepositStateParams{} }
func (m *QueryDepositStateParams) String() string { return proto.CompactTextString(m) }
func (*QueryDepositStateParams) ProtoMessage()    {}
func (*QueryDepositStateParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_78a1f61c7ae3396c, []int{4}
}
func (m *QueryDepositStateParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDepositStateParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDepositStateParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDepositStateParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDepositStateParams.Merge(m, src)
}
func (m *QueryDepositStateParams) XXX_Size() int {
	return m.Size()
}
func (m *QueryDepositStateParams) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDepositStateParams.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDepositStateParams proto.InternalMessageInfo

type QueryDepositStateResponse struct {
	Log    string        `protobuf:"bytes,1,opt,name=log,proto3" json:"log,omitempty"`
	Status DepositStatus `protobuf:"varint,2,opt,name=status,proto3,enum=evm.v1beta1.DepositStatus" json:"status,omitempty"`
}

func (m *QueryDepositStateResponse) Reset()         { *m = QueryDepositStateResponse{} }
func (m *QueryDepositStateResponse) String() string { return proto.CompactTextString(m) }
func (*QueryDepositStateResponse) ProtoMessage()    {}
func (*QueryDepositStateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78a1f61c7ae3396c, []int{5}
}
func (m *QueryDepositStateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDepositStateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDepositStateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDepositStateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDepositStateResponse.Merge(m, src)
}
func (m *QueryDepositStateResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryDepositStateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDepositStateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDepositStateResponse proto.InternalMessageInfo

type QueryBurnerAddressResponse struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *QueryBurnerAddressResponse) Reset()         { *m = QueryBurnerAddressResponse{} }
func (m *QueryBurnerAddressResponse) String() string { return proto.CompactTextString(m) }
func (*QueryBurnerAddressResponse) ProtoMessage()    {}
func (*QueryBurnerAddressResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78a1f61c7ae3396c, []int{6}
}
func (m *QueryBurnerAddressResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryBurnerAddressResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryBurnerAddressResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryBurnerAddressResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryBurnerAddressResponse.Merge(m, src)
}
func (m *QueryBurnerAddressResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryBurnerAddressResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryBurnerAddressResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryBurnerAddressResponse proto.InternalMessageInfo

type QueryChainsResponse struct {
	Chains []string `protobuf:"bytes,1,rep,name=chains,proto3" json:"chains,omitempty"`
}

func (m *QueryChainsResponse) Reset()         { *m = QueryChainsResponse{} }
func (m *QueryChainsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryChainsResponse) ProtoMessage()    {}
func (*QueryChainsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78a1f61c7ae3396c, []int{7}
}
func (m *QueryChainsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryChainsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryChainsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryChainsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryChainsResponse.Merge(m, src)
}
func (m *QueryChainsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryChainsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryChainsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryChainsResponse proto.InternalMessageInfo

type QueryPendingCommandsResponse struct {
	Commands []QueryCommandResponse `protobuf:"bytes,1,rep,name=commands,proto3" json:"commands"`
}

func (m *QueryPendingCommandsResponse) Reset()         { *m = QueryPendingCommandsResponse{} }
func (m *QueryPendingCommandsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryPendingCommandsResponse) ProtoMessage()    {}
func (*QueryPendingCommandsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78a1f61c7ae3396c, []int{8}
}
func (m *QueryPendingCommandsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryPendingCommandsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryPendingCommandsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryPendingCommandsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryPendingCommandsResponse.Merge(m, src)
}
func (m *QueryPendingCommandsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryPendingCommandsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryPendingCommandsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryPendingCommandsResponse proto.InternalMessageInfo

type QueryCommandResponse struct {
	ID         string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Type       string            `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	Params     map[string]string `protobuf:"bytes,3,rep,name=params,proto3" json:"params" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	KeyID      string            `protobuf:"bytes,4,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	MaxGasCost uint32            `protobuf:"varint,5,opt,name=max_gas_cost,json=maxGasCost,proto3" json:"max_gas_cost,omitempty"`
}

func (m *QueryCommandResponse) Reset()         { *m = QueryCommandResponse{} }
func (m *QueryCommandResponse) String() string { return proto.CompactTextString(m) }
func (*QueryCommandResponse) ProtoMessage()    {}
func (*QueryCommandResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78a1f61c7ae3396c, []int{9}
}
func (m *QueryCommandResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryCommandResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryCommandResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryCommandResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryCommandResponse.Merge(m, src)
}
func (m *QueryCommandResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryCommandResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryCommandResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryCommandResponse proto.InternalMessageInfo

type BurnerInfoRequest struct {
	Address Address `protobuf:"bytes,1,opt,name=address,proto3,customtype=Address" json:"address"`
}

func (m *BurnerInfoRequest) Reset()         { *m = BurnerInfoRequest{} }
func (m *BurnerInfoRequest) String() string { return proto.CompactTextString(m) }
func (*BurnerInfoRequest) ProtoMessage()    {}
func (*BurnerInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_78a1f61c7ae3396c, []int{10}
}
func (m *BurnerInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BurnerInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BurnerInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BurnerInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BurnerInfoRequest.Merge(m, src)
}
func (m *BurnerInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *BurnerInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BurnerInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BurnerInfoRequest proto.InternalMessageInfo

type BurnerInfoResponse struct {
	Chain      string      `protobuf:"bytes,1,opt,name=chain,proto3" json:"chain,omitempty"`
	BurnerInfo *BurnerInfo `protobuf:"bytes,2,opt,name=burner_info,json=burnerInfo,proto3" json:"burner_info,omitempty"`
}

func (m *BurnerInfoResponse) Reset()         { *m = BurnerInfoResponse{} }
func (m *BurnerInfoResponse) String() string { return proto.CompactTextString(m) }
func (*BurnerInfoResponse) ProtoMessage()    {}
func (*BurnerInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_78a1f61c7ae3396c, []int{11}
}
func (m *BurnerInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BurnerInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BurnerInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BurnerInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BurnerInfoResponse.Merge(m, src)
}
func (m *BurnerInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *BurnerInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BurnerInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BurnerInfoResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*DepositQueryParams)(nil), "evm.v1beta1.DepositQueryParams")
	proto.RegisterType((*QueryBatchedCommandsResponse)(nil), "evm.v1beta1.QueryBatchedCommandsResponse")
	proto.RegisterType((*QueryAddressResponse)(nil), "evm.v1beta1.QueryAddressResponse")
	proto.RegisterType((*QueryAddressResponse_MultisigAddresses)(nil), "evm.v1beta1.QueryAddressResponse.MultisigAddresses")
	proto.RegisterType((*QueryAddressResponse_ThresholdAddress)(nil), "evm.v1beta1.QueryAddressResponse.ThresholdAddress")
	proto.RegisterType((*QueryTokenAddressResponse)(nil), "evm.v1beta1.QueryTokenAddressResponse")
	proto.RegisterType((*QueryDepositStateParams)(nil), "evm.v1beta1.QueryDepositStateParams")
	proto.RegisterType((*QueryDepositStateResponse)(nil), "evm.v1beta1.QueryDepositStateResponse")
	proto.RegisterType((*QueryBurnerAddressResponse)(nil), "evm.v1beta1.QueryBurnerAddressResponse")
	proto.RegisterType((*QueryChainsResponse)(nil), "evm.v1beta1.QueryChainsResponse")
	proto.RegisterType((*QueryPendingCommandsResponse)(nil), "evm.v1beta1.QueryPendingCommandsResponse")
	proto.RegisterType((*QueryCommandResponse)(nil), "evm.v1beta1.QueryCommandResponse")
	proto.RegisterMapType((map[string]string)(nil), "evm.v1beta1.QueryCommandResponse.ParamsEntry")
	proto.RegisterType((*BurnerInfoRequest)(nil), "evm.v1beta1.BurnerInfoRequest")
	proto.RegisterType((*BurnerInfoResponse)(nil), "evm.v1beta1.BurnerInfoResponse")
}

func init() { proto.RegisterFile("evm/v1beta1/query.proto", fileDescriptor_78a1f61c7ae3396c) }

var fileDescriptor_78a1f61c7ae3396c = []byte{
	// 931 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x55, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0x16, 0xf5, 0xe7, 0x68, 0xe4, 0xb8, 0xf6, 0xd6, 0x89, 0x19, 0x21, 0x90, 0x1c, 0x9e, 0x12,
	0xa0, 0x96, 0x1a, 0x05, 0x0d, 0x92, 0x1c, 0x0a, 0x44, 0x56, 0x5b, 0x0b, 0x41, 0x5b, 0x97, 0xf5,
	0x29, 0x40, 0x21, 0xac, 0xb4, 0x13, 0x89, 0x90, 0xc8, 0x55, 0xb8, 0x4b, 0x95, 0x7a, 0x89, 0xa2,
	0x87, 0xbe, 0x45, 0x5f, 0xc4, 0xc7, 0x1c, 0x8b, 0x1e, 0x84, 0x56, 0x7e, 0x8b, 0x9e, 0x0a, 0x2e,
	0x97, 0x14, 0x25, 0x3b, 0x4d, 0x2e, 0xbd, 0xed, 0xce, 0xee, 0x37, 0x33, 0xdf, 0xce, 0xec, 0x37,
	0x70, 0x84, 0x73, 0xb7, 0x35, 0x7f, 0x3c, 0x40, 0x49, 0x1f, 0xb7, 0xde, 0x06, 0xe8, 0x2f, 0x9a,
	0x33, 0x9f, 0x4b, 0x4e, 0xaa, 0x38, 0x77, 0x9b, 0xfa, 0xa0, 0x76, 0x38, 0xe2, 0x23, 0xae, 0xec,
	0xad, 0x68, 0x15, 0x5f, 0xa9, 0x6d, 0x60, 0xe5, 0x62, 0x86, 0x22, 0x3e, 0xb0, 0x5e, 0x03, 0xe9,
	0xe2, 0x8c, 0x0b, 0x47, 0xfe, 0x10, 0x79, 0x3c, 0xa7, 0x3e, 0x75, 0x05, 0x31, 0x61, 0x87, 0x32,
	0xe6, 0xa3, 0x10, 0xa6, 0x71, 0x6c, 0x3c, 0xac, 0xd8, 0xc9, 0x96, 0x1c, 0x42, 0x89, 0x0a, 0x81,
	0xd2, 0xcc, 0x2b, 0x7b, 0xbc, 0x89, 0xac, 0xc3, 0x31, 0x75, 0x3c, 0xb3, 0x10, 0x5b, 0xd5, 0xc6,
	0xfa, 0xbd, 0x00, 0xf7, 0x95, 0xd7, 0x0e, 0x95, 0xc3, 0x31, 0xb2, 0x53, 0xee, 0xba, 0xd4, 0x63,
	0xc2, 0x46, 0x31, 0xe3, 0x9e, 0x40, 0x72, 0x17, 0xf2, 0x0e, 0x8b, 0x23, 0x74, 0xca, 0xab, 0x65,
	0x23, 0xdf, 0xeb, 0xda, 0x79, 0x87, 0x11, 0x02, 0x45, 0x46, 0x25, 0xd5, 0x31, 0xd4, 0x9a, 0xbc,
	0x80, 0xb2, 0x90, 0x54, 0x06, 0x42, 0xc5, 0xd8, 0x6b, 0x5b, 0xcd, 0x0c, 0xeb, 0xe6, 0x56, 0x84,
	0x1f, 0xd5, 0x4d, 0x5b, 0x23, 0xc8, 0x4f, 0x50, 0x9e, 0xe0, 0xa2, 0xef, 0x30, 0xb3, 0xa8, 0x62,
	0x7d, 0xbd, 0x5a, 0x36, 0x4a, 0xaf, 0x70, 0xd1, 0xeb, 0xfe, 0xb3, 0x6c, 0x3c, 0x1f, 0x39, 0x72,
	0x1c, 0x0c, 0x9a, 0x43, 0xee, 0xb6, 0x68, 0x88, 0x53, 0xea, 0x7b, 0x28, 0x7f, 0xe6, 0xfe, 0x44,
	0xef, 0x4e, 0x86, 0xdc, 0xc7, 0x56, 0xd8, 0x92, 0x42, 0xb4, 0x30, 0x9c, 0x71, 0x5f, 0x22, 0x6b,
	0x2a, 0xb0, 0x5d, 0x9a, 0xe0, 0xa2, 0xc7, 0xc8, 0x7d, 0xa8, 0x08, 0x67, 0xe4, 0x51, 0x19, 0xf8,
	0x68, 0x96, 0x8e, 0x0b, 0x0f, 0x2b, 0xf6, 0xda, 0x40, 0x1e, 0xc0, 0x2e, 0x86, 0x38, 0x0c, 0x24,
	0xf6, 0x15, 0xa9, 0xb2, 0x22, 0x55, 0xd5, 0xb6, 0x6e, 0xc4, 0xcd, 0x06, 0x73, 0xe6, 0xe3, 0xbc,
	0x3f, 0x88, 0x59, 0xf4, 0x87, 0x9a, 0x46, 0x94, 0xf1, 0x8e, 0xca, 0xf8, 0xde, 0x6a, 0xd9, 0xb8,
	0x73, 0xee, 0xe3, 0x7c, 0x8b, 0x68, 0xaf, 0x6b, 0xdf, 0x99, 0xdd, 0x60, 0x66, 0xa4, 0x05, 0x55,
	0xed, 0xa6, 0xef, 0x30, 0x61, 0xde, 0x8a, 0xd2, 0xea, 0xec, 0xad, 0x96, 0x0d, 0xd0, 0x97, 0x7a,
	0x5d, 0x61, 0x83, 0xbe, 0xd2, 0x63, 0xc2, 0xba, 0x2c, 0xc0, 0xa1, 0xaa, 0xd6, 0xcb, 0xb8, 0xd4,
	0x69, 0x95, 0xd6, 0xaf, 0x67, 0xfc, 0x1f, 0xaf, 0xc7, 0x80, 0xb8, 0xc1, 0x54, 0x3a, 0xc2, 0x19,
	0xf5, 0x75, 0x97, 0xa1, 0x50, 0xa5, 0xaf, 0xb6, 0x9f, 0x6c, 0x14, 0xf9, 0xa6, 0xec, 0x9a, 0xdf,
	0x6a, 0xec, 0xcb, 0x04, 0x7a, 0x96, 0xb3, 0x0f, 0xdc, 0x6d, 0x23, 0xa1, 0x70, 0x20, 0xc7, 0x3e,
	0x8a, 0x31, 0x9f, 0xb2, 0x24, 0x8c, 0xea, 0xa4, 0x6a, 0xbb, 0xfd, 0xe1, 0x20, 0x17, 0x09, 0x54,
	0x1f, 0x9c, 0xe5, 0xec, 0x7d, 0xb9, 0x65, 0xab, 0x7d, 0x0f, 0x07, 0xd7, 0x92, 0x89, 0x7a, 0x63,
	0x4d, 0xca, 0x88, 0x7b, 0x83, 0x66, 0x4f, 0x53, 0x37, 0x8a, 0xf2, 0x6d, 0x7b, 0x6d, 0xa8, 0x7d,
	0x06, 0xfb, 0xdb, 0x81, 0xdf, 0xff, 0x33, 0x3b, 0x95, 0xf4, 0xc4, 0xfa, 0x02, 0xee, 0x29, 0x1a,
	0x17, 0x7c, 0x82, 0xde, 0x76, 0x39, 0xdf, 0xeb, 0xc1, 0xfa, 0xcd, 0x80, 0x23, 0x85, 0xd3, 0x8a,
	0x10, 0xfd, 0x22, 0xd4, 0x8a, 0xf0, 0x08, 0x4a, 0x32, 0x4c, 0x7a, 0x60, 0xb7, 0x73, 0x78, 0xb9,
	0x6c, 0xe4, 0xfe, 0x5c, 0x36, 0x8a, 0x67, 0x54, 0x8c, 0x57, 0xcb, 0x46, 0xf1, 0x22, 0xec, 0x75,
	0xed, 0xa2, 0x0c, 0x7b, 0x8c, 0x3c, 0x85, 0xbd, 0x41, 0xe0, 0x7b, 0xe8, 0xa7, 0xef, 0x9c, 0x57,
	0x98, 0x4f, 0x34, 0x66, 0x27, 0xc9, 0xe8, 0x76, 0x7c, 0x2d, 0xa1, 0x76, 0x17, 0xca, 0xd4, 0xe5,
	0x81, 0x27, 0xb5, 0x8a, 0xe8, 0x9d, 0x45, 0x35, 0x9b, 0x6c, 0x56, 0x29, 0x9b, 0x7d, 0x28, 0x4c,
	0xf9, 0x48, 0x33, 0x89, 0x96, 0xa4, 0x9d, 0x0a, 0x45, 0x5e, 0x09, 0x45, 0x6d, 0xa3, 0xbc, 0x19,
	0x27, 0x6b, 0x81, 0xb0, 0x9e, 0x42, 0x2d, 0x16, 0xaa, 0x6c, 0x42, 0x1f, 0xf1, 0x62, 0x27, 0xf0,
	0xa9, 0xc2, 0x9d, 0x46, 0x7a, 0x97, 0xd5, 0xb5, 0xb2, 0x52, 0xc0, 0xa4, 0xe2, 0x7a, 0x67, 0x0d,
	0xb5, 0x1e, 0x9e, 0xa3, 0xc7, 0x1c, 0x6f, 0x74, 0x4d, 0x0f, 0x4f, 0xe1, 0x56, 0xf2, 0xf5, 0x15,
	0xb2, 0xda, 0x7e, 0x70, 0xbd, 0x37, 0x35, 0x2a, 0x01, 0x75, 0x8a, 0xd1, 0xb3, 0xda, 0x29, 0xd0,
	0xfa, 0x25, 0xaf, 0xff, 0xf1, 0xd6, 0xc5, 0xff, 0x52, 0xdb, 0x68, 0x22, 0x24, 0x6a, 0x1b, 0xad,
	0xc9, 0x2b, 0x28, 0xcf, 0x54, 0xe1, 0xcd, 0x82, 0xca, 0xe3, 0xe4, 0x83, 0x79, 0x34, 0xe3, 0x46,
	0xf9, 0xca, 0x93, 0xfe, 0x42, 0xe7, 0xa4, 0x5d, 0x90, 0xe3, 0x2d, 0xf9, 0xad, 0xa4, 0x02, 0x92,
	0x68, 0xc0, 0x31, 0xec, 0xba, 0x34, 0xec, 0x8f, 0xa8, 0xe8, 0x0f, 0xb9, 0x90, 0x66, 0x49, 0x7d,
	0x05, 0x70, 0x69, 0xf8, 0x0d, 0x15, 0xa7, 0x5c, 0xc8, 0xda, 0x73, 0xa8, 0x66, 0x02, 0x44, 0x65,
	0x9f, 0xe0, 0x22, 0x29, 0xfb, 0x04, 0x17, 0xd1, 0x08, 0x9a, 0xd3, 0x69, 0x90, 0xd0, 0x88, 0x37,
	0x2f, 0xf2, 0xcf, 0x0c, 0xeb, 0x4b, 0x38, 0x88, 0xeb, 0xda, 0xf3, 0xde, 0x70, 0x1b, 0xdf, 0x06,
	0x28, 0x24, 0x79, 0xb4, 0x59, 0xd3, 0x1b, 0xba, 0x33, 0x2d, 0x32, 0x03, 0x92, 0xc5, 0xeb, 0xd7,
	0x4c, 0x47, 0x9e, 0x91, 0x19, 0x79, 0xe4, 0x19, 0x54, 0x75, 0xef, 0x3b, 0xde, 0x1b, 0xae, 0x55,
	0xec, 0x68, 0x73, 0x54, 0xad, 0x7d, 0xc1, 0x20, 0x5d, 0x77, 0xbe, 0xbb, 0xfc, 0xbb, 0x9e, 0xbb,
	0x5c, 0xd5, 0x8d, 0x77, 0xab, 0xba, 0xf1, 0xd7, 0xaa, 0x6e, 0xfc, 0x7a, 0x55, 0xcf, 0xbd, 0xbb,
	0xaa, 0xe7, 0xfe, 0xb8, 0xaa, 0xe7, 0x5e, 0x7f, 0xfe, 0x91, 0x32, 0x1b, 0x8d, 0x79, 0x35, 0xde,
	0x07, 0x65, 0x35, 0xdf, 0x9f, 0xfc, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x63, 0x2a, 0xa8, 0x9b, 0x36,
	0x08, 0x00, 0x00,
}

func (m *DepositQueryParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DepositQueryParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DepositQueryParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Chain) > 0 {
		i -= len(m.Chain)
		copy(dAtA[i:], m.Chain)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Chain)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Asset) > 0 {
		i -= len(m.Asset)
		copy(dAtA[i:], m.Asset)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Asset)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryBatchedCommandsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryBatchedCommandsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryBatchedCommandsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CommandIDs) > 0 {
		for iNdEx := len(m.CommandIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CommandIDs[iNdEx])
			copy(dAtA[i:], m.CommandIDs[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.CommandIDs[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.PrevBatchedCommandsID) > 0 {
		i -= len(m.PrevBatchedCommandsID)
		copy(dAtA[i:], m.PrevBatchedCommandsID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.PrevBatchedCommandsID)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ExecuteData) > 0 {
		i -= len(m.ExecuteData)
		copy(dAtA[i:], m.ExecuteData)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ExecuteData)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Signature) > 0 {
		for iNdEx := len(m.Signature) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Signature[iNdEx])
			copy(dAtA[i:], m.Signature[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.Signature[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.KeyID) > 0 {
		i -= len(m.KeyID)
		copy(dAtA[i:], m.KeyID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.KeyID)))
		i--
		dAtA[i] = 0x22
	}
	if m.Status != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryAddressResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAddressResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAddressResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Address != nil {
		{
			size := m.Address.Size()
			i -= size
			if _, err := m.Address.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.KeyID) > 0 {
		i -= len(m.KeyID)
		copy(dAtA[i:], m.KeyID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.KeyID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryAddressResponse_MultisigAddresses_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAddressResponse_MultisigAddresses_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MultisigAddresses != nil {
		{
			size, err := m.MultisigAddresses.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *QueryAddressResponse_ThresholdAddress_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAddressResponse_ThresholdAddress_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ThresholdAddress != nil {
		{
			size, err := m.ThresholdAddress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *QueryAddressResponse_MultisigAddresses) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAddressResponse_MultisigAddresses) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAddressResponse_MultisigAddresses) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Threshold != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Threshold))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Addresses) > 0 {
		for iNdEx := len(m.Addresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Addresses[iNdEx])
			copy(dAtA[i:], m.Addresses[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.Addresses[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryAddressResponse_ThresholdAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAddressResponse_ThresholdAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAddressResponse_ThresholdAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryTokenAddressResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryTokenAddressResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryTokenAddressResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryDepositStateParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDepositStateParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDepositStateParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.BurnerAddress.Size()
		i -= size
		if _, err := m.BurnerAddress.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.TxID.Size()
		i -= size
		if _, err := m.TxID.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryDepositStateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDepositStateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDepositStateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Log) > 0 {
		i -= len(m.Log)
		copy(dAtA[i:], m.Log)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Log)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryBurnerAddressResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryBurnerAddressResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryBurnerAddressResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryChainsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryChainsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryChainsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Chains) > 0 {
		for iNdEx := len(m.Chains) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Chains[iNdEx])
			copy(dAtA[i:], m.Chains[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.Chains[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryPendingCommandsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPendingCommandsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryPendingCommandsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Commands) > 0 {
		for iNdEx := len(m.Commands) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Commands[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryCommandResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryCommandResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryCommandResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxGasCost != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.MaxGasCost))
		i--
		dAtA[i] = 0x28
	}
	if len(m.KeyID) > 0 {
		i -= len(m.KeyID)
		copy(dAtA[i:], m.KeyID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.KeyID)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Params) > 0 {
		for k := range m.Params {
			v := m.Params[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintQuery(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintQuery(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintQuery(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BurnerInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BurnerInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BurnerInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Address.Size()
		i -= size
		if _, err := m.Address.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BurnerInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BurnerInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BurnerInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BurnerInfo != nil {
		{
			size, err := m.BurnerInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Chain) > 0 {
		i -= len(m.Chain)
		copy(dAtA[i:], m.Chain)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Chain)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintQuery(dAtA []byte, offset int, v uint64) int {
	offset -= sovQuery(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DepositQueryParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Asset)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryBatchedCommandsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovQuery(uint64(m.Status))
	}
	l = len(m.KeyID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if len(m.Signature) > 0 {
		for _, s := range m.Signature {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	l = len(m.ExecuteData)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.PrevBatchedCommandsID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if len(m.CommandIDs) > 0 {
		for _, s := range m.CommandIDs {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryAddressResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KeyID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Address != nil {
		n += m.Address.Size()
	}
	return n
}

func (m *QueryAddressResponse_MultisigAddresses_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MultisigAddresses != nil {
		l = m.MultisigAddresses.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}
func (m *QueryAddressResponse_ThresholdAddress_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ThresholdAddress != nil {
		l = m.ThresholdAddress.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}
func (m *QueryAddressResponse_MultisigAddresses) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Addresses) > 0 {
		for _, s := range m.Addresses {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Threshold != 0 {
		n += 1 + sovQuery(uint64(m.Threshold))
	}
	return n
}

func (m *QueryAddressResponse_ThresholdAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryTokenAddressResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryDepositStateParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TxID.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.BurnerAddress.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryDepositStateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Log)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovQuery(uint64(m.Status))
	}
	return n
}

func (m *QueryBurnerAddressResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryChainsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Chains) > 0 {
		for _, s := range m.Chains {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryPendingCommandsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Commands) > 0 {
		for _, e := range m.Commands {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryCommandResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if len(m.Params) > 0 {
		for k, v := range m.Params {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovQuery(uint64(len(k))) + 1 + len(v) + sovQuery(uint64(len(v)))
			n += mapEntrySize + 1 + sovQuery(uint64(mapEntrySize))
		}
	}
	l = len(m.KeyID)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.MaxGasCost != 0 {
		n += 1 + sovQuery(uint64(m.MaxGasCost))
	}
	return n
}

func (m *BurnerInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Address.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *BurnerInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.BurnerInfo != nil {
		l = m.BurnerInfo.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func sovQuery(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozQuery(x uint64) (n int) {
	return sovQuery(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DepositQueryParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DepositQueryParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DepositQueryParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Asset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Asset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryBatchedCommandsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryBatchedCommandsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryBatchedCommandsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= BatchedCommandsStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyID = github_com_axelarnetwork_axelar_core_x_tss_exported.KeyID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecuteData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecuteData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevBatchedCommandsID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrevBatchedCommandsID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommandIDs = append(m.CommandIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAddressResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAddressResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAddressResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyID = github_com_axelarnetwork_axelar_core_x_tss_exported.KeyID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultisigAddresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QueryAddressResponse_MultisigAddresses{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Address = &QueryAddressResponse_MultisigAddresses_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThresholdAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QueryAddressResponse_ThresholdAddress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Address = &QueryAddressResponse_ThresholdAddress_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAddressResponse_MultisigAddresses) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultisigAddresses: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultisigAddresses: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addresses = append(m.Addresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			m.Threshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Threshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAddressResponse_ThresholdAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThresholdAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThresholdAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryTokenAddressResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryTokenAddressResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryTokenAddressResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDepositStateParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDepositStateParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDepositStateParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnerAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BurnerAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDepositStateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDepositStateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDepositStateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Log", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Log = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= DepositStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryBurnerAddressResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryBurnerAddressResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryBurnerAddressResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryChainsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryChainsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryChainsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chains = append(m.Chains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPendingCommandsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPendingCommandsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPendingCommandsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commands", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commands = append(m.Commands, QueryCommandResponse{})
			if err := m.Commands[len(m.Commands)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryCommandResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryCommandResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryCommandResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuery
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQuery
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthQuery
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthQuery
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQuery
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthQuery
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthQuery
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipQuery(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthQuery
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Params[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxGasCost", wireType)
			}
			m.MaxGasCost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxGasCost |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BurnerInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BurnerInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BurnerInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BurnerInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BurnerInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BurnerInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BurnerInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BurnerInfo == nil {
				m.BurnerInfo = &BurnerInfo{}
			}
			if err := m.BurnerInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQuery(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQuery
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupQuery
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthQuery
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthQuery        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQuery          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupQuery = fmt.Errorf("proto: unexpected end of group")
)
