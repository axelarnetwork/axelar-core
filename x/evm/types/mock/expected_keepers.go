// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	utils "github.com/axelarnetwork/axelar-core/utils"
	evmtypes "github.com/axelarnetwork/axelar-core/x/evm/types"
	github_com_axelarnetwork_axelar_core_x_multisig_exported "github.com/axelarnetwork/axelar-core/x/multisig/exported"
	github_com_axelarnetwork_axelar_core_x_nexus_exported "github.com/axelarnetwork/axelar-core/x/nexus/exported"
	reward "github.com/axelarnetwork/axelar-core/x/reward/exported"
	snapshot "github.com/axelarnetwork/axelar-core/x/snapshot/exported"
	exported "github.com/axelarnetwork/axelar-core/x/tss/exported"
	tsstypes "github.com/axelarnetwork/axelar-core/x/tss/types"
	vote "github.com/axelarnetwork/axelar-core/x/vote/exported"
	"github.com/cosmos/cosmos-sdk/codec"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	"github.com/tendermint/tendermint/libs/log"
	"sync"
)

// Ensure, that VoterMock does implement evmtypes.Voter.
// If this is not the case, regenerate this file with moq.
var _ evmtypes.Voter = &VoterMock{}

// VoterMock is a mock implementation of evmtypes.Voter.
//
// 	func TestSomethingThatUsesVoter(t *testing.T) {
//
// 		// make and configure a mocked evmtypes.Voter
// 		mockedVoter := &VoterMock{
// 			InitializePollFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, pollBuilder vote.PollBuilder) (vote.PollID, error) {
// 				panic("mock out the InitializePoll method")
// 			},
// 		}
//
// 		// use mockedVoter in code that requires evmtypes.Voter
// 		// and then make assertions.
//
// 	}
type VoterMock struct {
	// InitializePollFunc mocks the InitializePoll method.
	InitializePollFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, pollBuilder vote.PollBuilder) (vote.PollID, error)

	// calls tracks calls to the methods.
	calls struct {
		// InitializePoll holds details about calls to the InitializePoll method.
		InitializePoll []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// PollBuilder is the pollBuilder argument value.
			PollBuilder vote.PollBuilder
		}
	}
	lockInitializePoll sync.RWMutex
}

// InitializePoll calls InitializePollFunc.
func (mock *VoterMock) InitializePoll(ctx github_com_cosmos_cosmos_sdk_types.Context, pollBuilder vote.PollBuilder) (vote.PollID, error) {
	if mock.InitializePollFunc == nil {
		panic("VoterMock.InitializePollFunc: method is nil but Voter.InitializePoll was just called")
	}
	callInfo := struct {
		Ctx         github_com_cosmos_cosmos_sdk_types.Context
		PollBuilder vote.PollBuilder
	}{
		Ctx:         ctx,
		PollBuilder: pollBuilder,
	}
	mock.lockInitializePoll.Lock()
	mock.calls.InitializePoll = append(mock.calls.InitializePoll, callInfo)
	mock.lockInitializePoll.Unlock()
	return mock.InitializePollFunc(ctx, pollBuilder)
}

// InitializePollCalls gets all the calls that were made to InitializePoll.
// Check the length with:
//     len(mockedVoter.InitializePollCalls())
func (mock *VoterMock) InitializePollCalls() []struct {
	Ctx         github_com_cosmos_cosmos_sdk_types.Context
	PollBuilder vote.PollBuilder
} {
	var calls []struct {
		Ctx         github_com_cosmos_cosmos_sdk_types.Context
		PollBuilder vote.PollBuilder
	}
	mock.lockInitializePoll.RLock()
	calls = mock.calls.InitializePoll
	mock.lockInitializePoll.RUnlock()
	return calls
}

// Ensure, that SignerMock does implement evmtypes.Signer.
// If this is not the case, regenerate this file with moq.
var _ evmtypes.Signer = &SignerMock{}

// SignerMock is a mock implementation of evmtypes.Signer.
//
// 	func TestSomethingThatUsesSigner(t *testing.T) {
//
// 		// make and configure a mocked evmtypes.Signer
// 		mockedSigner := &SignerMock{
// 			GetKeyFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, keyID exported.KeyID) (exported.Key, bool) {
// 				panic("mock out the GetKey method")
// 			},
// 			GetMultisigSignInfoFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, sigID string) (tsstypes.MultisigSignInfo, bool) {
// 				panic("mock out the GetMultisigSignInfo method")
// 			},
// 			GetSigFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, sigID string) (exported.Signature, exported.SigStatus) {
// 				panic("mock out the GetSig method")
// 			},
// 		}
//
// 		// use mockedSigner in code that requires evmtypes.Signer
// 		// and then make assertions.
//
// 	}
type SignerMock struct {
	// GetKeyFunc mocks the GetKey method.
	GetKeyFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, keyID exported.KeyID) (exported.Key, bool)

	// GetMultisigSignInfoFunc mocks the GetMultisigSignInfo method.
	GetMultisigSignInfoFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, sigID string) (tsstypes.MultisigSignInfo, bool)

	// GetSigFunc mocks the GetSig method.
	GetSigFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, sigID string) (exported.Signature, exported.SigStatus)

	// calls tracks calls to the methods.
	calls struct {
		// GetKey holds details about calls to the GetKey method.
		GetKey []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// KeyID is the keyID argument value.
			KeyID exported.KeyID
		}
		// GetMultisigSignInfo holds details about calls to the GetMultisigSignInfo method.
		GetMultisigSignInfo []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// SigID is the sigID argument value.
			SigID string
		}
		// GetSig holds details about calls to the GetSig method.
		GetSig []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// SigID is the sigID argument value.
			SigID string
		}
	}
	lockGetKey              sync.RWMutex
	lockGetMultisigSignInfo sync.RWMutex
	lockGetSig              sync.RWMutex
}

// GetKey calls GetKeyFunc.
func (mock *SignerMock) GetKey(ctx github_com_cosmos_cosmos_sdk_types.Context, keyID exported.KeyID) (exported.Key, bool) {
	if mock.GetKeyFunc == nil {
		panic("SignerMock.GetKeyFunc: method is nil but Signer.GetKey was just called")
	}
	callInfo := struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		KeyID exported.KeyID
	}{
		Ctx:   ctx,
		KeyID: keyID,
	}
	mock.lockGetKey.Lock()
	mock.calls.GetKey = append(mock.calls.GetKey, callInfo)
	mock.lockGetKey.Unlock()
	return mock.GetKeyFunc(ctx, keyID)
}

// GetKeyCalls gets all the calls that were made to GetKey.
// Check the length with:
//     len(mockedSigner.GetKeyCalls())
func (mock *SignerMock) GetKeyCalls() []struct {
	Ctx   github_com_cosmos_cosmos_sdk_types.Context
	KeyID exported.KeyID
} {
	var calls []struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		KeyID exported.KeyID
	}
	mock.lockGetKey.RLock()
	calls = mock.calls.GetKey
	mock.lockGetKey.RUnlock()
	return calls
}

// GetMultisigSignInfo calls GetMultisigSignInfoFunc.
func (mock *SignerMock) GetMultisigSignInfo(ctx github_com_cosmos_cosmos_sdk_types.Context, sigID string) (tsstypes.MultisigSignInfo, bool) {
	if mock.GetMultisigSignInfoFunc == nil {
		panic("SignerMock.GetMultisigSignInfoFunc: method is nil but Signer.GetMultisigSignInfo was just called")
	}
	callInfo := struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		SigID string
	}{
		Ctx:   ctx,
		SigID: sigID,
	}
	mock.lockGetMultisigSignInfo.Lock()
	mock.calls.GetMultisigSignInfo = append(mock.calls.GetMultisigSignInfo, callInfo)
	mock.lockGetMultisigSignInfo.Unlock()
	return mock.GetMultisigSignInfoFunc(ctx, sigID)
}

// GetMultisigSignInfoCalls gets all the calls that were made to GetMultisigSignInfo.
// Check the length with:
//     len(mockedSigner.GetMultisigSignInfoCalls())
func (mock *SignerMock) GetMultisigSignInfoCalls() []struct {
	Ctx   github_com_cosmos_cosmos_sdk_types.Context
	SigID string
} {
	var calls []struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		SigID string
	}
	mock.lockGetMultisigSignInfo.RLock()
	calls = mock.calls.GetMultisigSignInfo
	mock.lockGetMultisigSignInfo.RUnlock()
	return calls
}

// GetSig calls GetSigFunc.
func (mock *SignerMock) GetSig(ctx github_com_cosmos_cosmos_sdk_types.Context, sigID string) (exported.Signature, exported.SigStatus) {
	if mock.GetSigFunc == nil {
		panic("SignerMock.GetSigFunc: method is nil but Signer.GetSig was just called")
	}
	callInfo := struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		SigID string
	}{
		Ctx:   ctx,
		SigID: sigID,
	}
	mock.lockGetSig.Lock()
	mock.calls.GetSig = append(mock.calls.GetSig, callInfo)
	mock.lockGetSig.Unlock()
	return mock.GetSigFunc(ctx, sigID)
}

// GetSigCalls gets all the calls that were made to GetSig.
// Check the length with:
//     len(mockedSigner.GetSigCalls())
func (mock *SignerMock) GetSigCalls() []struct {
	Ctx   github_com_cosmos_cosmos_sdk_types.Context
	SigID string
} {
	var calls []struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		SigID string
	}
	mock.lockGetSig.RLock()
	calls = mock.calls.GetSig
	mock.lockGetSig.RUnlock()
	return calls
}

// Ensure, that NexusMock does implement evmtypes.Nexus.
// If this is not the case, regenerate this file with moq.
var _ evmtypes.Nexus = &NexusMock{}

// NexusMock is a mock implementation of evmtypes.Nexus.
//
// 	func TestSomethingThatUsesNexus(t *testing.T) {
//
// 		// make and configure a mocked evmtypes.Nexus
// 		mockedNexus := &NexusMock{
// 			AddTransferFeeFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, coin github_com_cosmos_cosmos_sdk_types.Coin)  {
// 				panic("mock out the AddTransferFee method")
// 			},
// 			ArchivePendingTransferFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, transfer github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainTransfer)  {
// 				panic("mock out the ArchivePendingTransfer method")
// 			},
// 			ComputeTransferFeeFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, sourceChain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, destinationChain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, asset github_com_cosmos_cosmos_sdk_types.Coin) (github_com_cosmos_cosmos_sdk_types.Coin, error) {
// 				panic("mock out the ComputeTransferFee method")
// 			},
// 			EnqueueForTransferFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, amount github_com_cosmos_cosmos_sdk_types.Coin) (github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferID, error) {
// 				panic("mock out the EnqueueForTransfer method")
// 			},
// 			EnqueueTransferFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, senderChain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, asset github_com_cosmos_cosmos_sdk_types.Coin) (github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferID, error) {
// 				panic("mock out the EnqueueTransfer method")
// 			},
// 			GetChainFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, bool) {
// 				panic("mock out the GetChain method")
// 			},
// 			GetChainByNativeAssetFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, asset string) (github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, bool) {
// 				panic("mock out the GetChainByNativeAsset method")
// 			},
// 			GetChainMaintainersFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) []github_com_cosmos_cosmos_sdk_types.ValAddress {
// 				panic("mock out the GetChainMaintainers method")
// 			},
// 			GetChainsFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context) []github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain {
// 				panic("mock out the GetChains method")
// 			},
// 			GetRecipientFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress) (github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, bool) {
// 				panic("mock out the GetRecipient method")
// 			},
// 			GetTransfersForChainFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, state github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferState) []github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainTransfer {
// 				panic("mock out the GetTransfersForChain method")
// 			},
// 			IsAssetRegisteredFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, denom string) bool {
// 				panic("mock out the IsAssetRegistered method")
// 			},
// 			IsChainActivatedFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) bool {
// 				panic("mock out the IsChainActivated method")
// 			},
// 			LinkAddressesFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress) error {
// 				panic("mock out the LinkAddresses method")
// 			},
// 			MarkChainMaintainerIncorrectVoteFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, address github_com_cosmos_cosmos_sdk_types.ValAddress, incorrectVote bool)  {
// 				panic("mock out the MarkChainMaintainerIncorrectVote method")
// 			},
// 			MarkChainMaintainerMissingVoteFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, address github_com_cosmos_cosmos_sdk_types.ValAddress, missingVote bool)  {
// 				panic("mock out the MarkChainMaintainerMissingVote method")
// 			},
// 			RegisterAssetFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, asset github_com_axelarnetwork_axelar_core_x_nexus_exported.Asset) error {
// 				panic("mock out the RegisterAsset method")
// 			},
// 			SetChainFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain)  {
// 				panic("mock out the SetChain method")
// 			},
// 		}
//
// 		// use mockedNexus in code that requires evmtypes.Nexus
// 		// and then make assertions.
//
// 	}
type NexusMock struct {
	// AddTransferFeeFunc mocks the AddTransferFee method.
	AddTransferFeeFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, coin github_com_cosmos_cosmos_sdk_types.Coin)

	// ArchivePendingTransferFunc mocks the ArchivePendingTransfer method.
	ArchivePendingTransferFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, transfer github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainTransfer)

	// ComputeTransferFeeFunc mocks the ComputeTransferFee method.
	ComputeTransferFeeFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, sourceChain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, destinationChain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, asset github_com_cosmos_cosmos_sdk_types.Coin) (github_com_cosmos_cosmos_sdk_types.Coin, error)

	// EnqueueForTransferFunc mocks the EnqueueForTransfer method.
	EnqueueForTransferFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, amount github_com_cosmos_cosmos_sdk_types.Coin) (github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferID, error)

	// EnqueueTransferFunc mocks the EnqueueTransfer method.
	EnqueueTransferFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, senderChain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, asset github_com_cosmos_cosmos_sdk_types.Coin) (github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferID, error)

	// GetChainFunc mocks the GetChain method.
	GetChainFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, bool)

	// GetChainByNativeAssetFunc mocks the GetChainByNativeAsset method.
	GetChainByNativeAssetFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, asset string) (github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, bool)

	// GetChainMaintainersFunc mocks the GetChainMaintainers method.
	GetChainMaintainersFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) []github_com_cosmos_cosmos_sdk_types.ValAddress

	// GetChainsFunc mocks the GetChains method.
	GetChainsFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context) []github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain

	// GetRecipientFunc mocks the GetRecipient method.
	GetRecipientFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress) (github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, bool)

	// GetTransfersForChainFunc mocks the GetTransfersForChain method.
	GetTransfersForChainFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, state github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferState) []github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainTransfer

	// IsAssetRegisteredFunc mocks the IsAssetRegistered method.
	IsAssetRegisteredFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, denom string) bool

	// IsChainActivatedFunc mocks the IsChainActivated method.
	IsChainActivatedFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) bool

	// LinkAddressesFunc mocks the LinkAddresses method.
	LinkAddressesFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress) error

	// MarkChainMaintainerIncorrectVoteFunc mocks the MarkChainMaintainerIncorrectVote method.
	MarkChainMaintainerIncorrectVoteFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, address github_com_cosmos_cosmos_sdk_types.ValAddress, incorrectVote bool)

	// MarkChainMaintainerMissingVoteFunc mocks the MarkChainMaintainerMissingVote method.
	MarkChainMaintainerMissingVoteFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, address github_com_cosmos_cosmos_sdk_types.ValAddress, missingVote bool)

	// RegisterAssetFunc mocks the RegisterAsset method.
	RegisterAssetFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, asset github_com_axelarnetwork_axelar_core_x_nexus_exported.Asset) error

	// SetChainFunc mocks the SetChain method.
	SetChainFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain)

	// calls tracks calls to the methods.
	calls struct {
		// AddTransferFee holds details about calls to the AddTransferFee method.
		AddTransferFee []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Coin is the coin argument value.
			Coin github_com_cosmos_cosmos_sdk_types.Coin
		}
		// ArchivePendingTransfer holds details about calls to the ArchivePendingTransfer method.
		ArchivePendingTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Transfer is the transfer argument value.
			Transfer github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainTransfer
		}
		// ComputeTransferFee holds details about calls to the ComputeTransferFee method.
		ComputeTransferFee []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// SourceChain is the sourceChain argument value.
			SourceChain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
			// DestinationChain is the destinationChain argument value.
			DestinationChain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
			// Asset is the asset argument value.
			Asset github_com_cosmos_cosmos_sdk_types.Coin
		}
		// EnqueueForTransfer holds details about calls to the EnqueueForTransfer method.
		EnqueueForTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Sender is the sender argument value.
			Sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
			// Amount is the amount argument value.
			Amount github_com_cosmos_cosmos_sdk_types.Coin
		}
		// EnqueueTransfer holds details about calls to the EnqueueTransfer method.
		EnqueueTransfer []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// SenderChain is the senderChain argument value.
			SenderChain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
			// Recipient is the recipient argument value.
			Recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
			// Asset is the asset argument value.
			Asset github_com_cosmos_cosmos_sdk_types.Coin
		}
		// GetChain holds details about calls to the GetChain method.
		GetChain []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
		}
		// GetChainByNativeAsset holds details about calls to the GetChainByNativeAsset method.
		GetChainByNativeAsset []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Asset is the asset argument value.
			Asset string
		}
		// GetChainMaintainers holds details about calls to the GetChainMaintainers method.
		GetChainMaintainers []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		}
		// GetChains holds details about calls to the GetChains method.
		GetChains []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
		}
		// GetRecipient holds details about calls to the GetRecipient method.
		GetRecipient []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Sender is the sender argument value.
			Sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
		}
		// GetTransfersForChain holds details about calls to the GetTransfersForChain method.
		GetTransfersForChain []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
			// State is the state argument value.
			State github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferState
		}
		// IsAssetRegistered holds details about calls to the IsAssetRegistered method.
		IsAssetRegistered []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
			// Denom is the denom argument value.
			Denom string
		}
		// IsChainActivated holds details about calls to the IsChainActivated method.
		IsChainActivated []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		}
		// LinkAddresses holds details about calls to the LinkAddresses method.
		LinkAddresses []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Sender is the sender argument value.
			Sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
			// Recipient is the recipient argument value.
			Recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
		}
		// MarkChainMaintainerIncorrectVote holds details about calls to the MarkChainMaintainerIncorrectVote method.
		MarkChainMaintainerIncorrectVote []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
			// Address is the address argument value.
			Address github_com_cosmos_cosmos_sdk_types.ValAddress
			// IncorrectVote is the incorrectVote argument value.
			IncorrectVote bool
		}
		// MarkChainMaintainerMissingVote holds details about calls to the MarkChainMaintainerMissingVote method.
		MarkChainMaintainerMissingVote []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
			// Address is the address argument value.
			Address github_com_cosmos_cosmos_sdk_types.ValAddress
			// MissingVote is the missingVote argument value.
			MissingVote bool
		}
		// RegisterAsset holds details about calls to the RegisterAsset method.
		RegisterAsset []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
			// Asset is the asset argument value.
			Asset github_com_axelarnetwork_axelar_core_x_nexus_exported.Asset
		}
		// SetChain holds details about calls to the SetChain method.
		SetChain []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		}
	}
	lockAddTransferFee                   sync.RWMutex
	lockArchivePendingTransfer           sync.RWMutex
	lockComputeTransferFee               sync.RWMutex
	lockEnqueueForTransfer               sync.RWMutex
	lockEnqueueTransfer                  sync.RWMutex
	lockGetChain                         sync.RWMutex
	lockGetChainByNativeAsset            sync.RWMutex
	lockGetChainMaintainers              sync.RWMutex
	lockGetChains                        sync.RWMutex
	lockGetRecipient                     sync.RWMutex
	lockGetTransfersForChain             sync.RWMutex
	lockIsAssetRegistered                sync.RWMutex
	lockIsChainActivated                 sync.RWMutex
	lockLinkAddresses                    sync.RWMutex
	lockMarkChainMaintainerIncorrectVote sync.RWMutex
	lockMarkChainMaintainerMissingVote   sync.RWMutex
	lockRegisterAsset                    sync.RWMutex
	lockSetChain                         sync.RWMutex
}

// AddTransferFee calls AddTransferFeeFunc.
func (mock *NexusMock) AddTransferFee(ctx github_com_cosmos_cosmos_sdk_types.Context, coin github_com_cosmos_cosmos_sdk_types.Coin) {
	if mock.AddTransferFeeFunc == nil {
		panic("NexusMock.AddTransferFeeFunc: method is nil but Nexus.AddTransferFee was just called")
	}
	callInfo := struct {
		Ctx  github_com_cosmos_cosmos_sdk_types.Context
		Coin github_com_cosmos_cosmos_sdk_types.Coin
	}{
		Ctx:  ctx,
		Coin: coin,
	}
	mock.lockAddTransferFee.Lock()
	mock.calls.AddTransferFee = append(mock.calls.AddTransferFee, callInfo)
	mock.lockAddTransferFee.Unlock()
	mock.AddTransferFeeFunc(ctx, coin)
}

// AddTransferFeeCalls gets all the calls that were made to AddTransferFee.
// Check the length with:
//     len(mockedNexus.AddTransferFeeCalls())
func (mock *NexusMock) AddTransferFeeCalls() []struct {
	Ctx  github_com_cosmos_cosmos_sdk_types.Context
	Coin github_com_cosmos_cosmos_sdk_types.Coin
} {
	var calls []struct {
		Ctx  github_com_cosmos_cosmos_sdk_types.Context
		Coin github_com_cosmos_cosmos_sdk_types.Coin
	}
	mock.lockAddTransferFee.RLock()
	calls = mock.calls.AddTransferFee
	mock.lockAddTransferFee.RUnlock()
	return calls
}

// ArchivePendingTransfer calls ArchivePendingTransferFunc.
func (mock *NexusMock) ArchivePendingTransfer(ctx github_com_cosmos_cosmos_sdk_types.Context, transfer github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainTransfer) {
	if mock.ArchivePendingTransferFunc == nil {
		panic("NexusMock.ArchivePendingTransferFunc: method is nil but Nexus.ArchivePendingTransfer was just called")
	}
	callInfo := struct {
		Ctx      github_com_cosmos_cosmos_sdk_types.Context
		Transfer github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainTransfer
	}{
		Ctx:      ctx,
		Transfer: transfer,
	}
	mock.lockArchivePendingTransfer.Lock()
	mock.calls.ArchivePendingTransfer = append(mock.calls.ArchivePendingTransfer, callInfo)
	mock.lockArchivePendingTransfer.Unlock()
	mock.ArchivePendingTransferFunc(ctx, transfer)
}

// ArchivePendingTransferCalls gets all the calls that were made to ArchivePendingTransfer.
// Check the length with:
//     len(mockedNexus.ArchivePendingTransferCalls())
func (mock *NexusMock) ArchivePendingTransferCalls() []struct {
	Ctx      github_com_cosmos_cosmos_sdk_types.Context
	Transfer github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainTransfer
} {
	var calls []struct {
		Ctx      github_com_cosmos_cosmos_sdk_types.Context
		Transfer github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainTransfer
	}
	mock.lockArchivePendingTransfer.RLock()
	calls = mock.calls.ArchivePendingTransfer
	mock.lockArchivePendingTransfer.RUnlock()
	return calls
}

// ComputeTransferFee calls ComputeTransferFeeFunc.
func (mock *NexusMock) ComputeTransferFee(ctx github_com_cosmos_cosmos_sdk_types.Context, sourceChain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, destinationChain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, asset github_com_cosmos_cosmos_sdk_types.Coin) (github_com_cosmos_cosmos_sdk_types.Coin, error) {
	if mock.ComputeTransferFeeFunc == nil {
		panic("NexusMock.ComputeTransferFeeFunc: method is nil but Nexus.ComputeTransferFee was just called")
	}
	callInfo := struct {
		Ctx              github_com_cosmos_cosmos_sdk_types.Context
		SourceChain      github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		DestinationChain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Asset            github_com_cosmos_cosmos_sdk_types.Coin
	}{
		Ctx:              ctx,
		SourceChain:      sourceChain,
		DestinationChain: destinationChain,
		Asset:            asset,
	}
	mock.lockComputeTransferFee.Lock()
	mock.calls.ComputeTransferFee = append(mock.calls.ComputeTransferFee, callInfo)
	mock.lockComputeTransferFee.Unlock()
	return mock.ComputeTransferFeeFunc(ctx, sourceChain, destinationChain, asset)
}

// ComputeTransferFeeCalls gets all the calls that were made to ComputeTransferFee.
// Check the length with:
//     len(mockedNexus.ComputeTransferFeeCalls())
func (mock *NexusMock) ComputeTransferFeeCalls() []struct {
	Ctx              github_com_cosmos_cosmos_sdk_types.Context
	SourceChain      github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	DestinationChain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	Asset            github_com_cosmos_cosmos_sdk_types.Coin
} {
	var calls []struct {
		Ctx              github_com_cosmos_cosmos_sdk_types.Context
		SourceChain      github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		DestinationChain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Asset            github_com_cosmos_cosmos_sdk_types.Coin
	}
	mock.lockComputeTransferFee.RLock()
	calls = mock.calls.ComputeTransferFee
	mock.lockComputeTransferFee.RUnlock()
	return calls
}

// EnqueueForTransfer calls EnqueueForTransferFunc.
func (mock *NexusMock) EnqueueForTransfer(ctx github_com_cosmos_cosmos_sdk_types.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, amount github_com_cosmos_cosmos_sdk_types.Coin) (github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferID, error) {
	if mock.EnqueueForTransferFunc == nil {
		panic("NexusMock.EnqueueForTransferFunc: method is nil but Nexus.EnqueueForTransfer was just called")
	}
	callInfo := struct {
		Ctx    github_com_cosmos_cosmos_sdk_types.Context
		Sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
		Amount github_com_cosmos_cosmos_sdk_types.Coin
	}{
		Ctx:    ctx,
		Sender: sender,
		Amount: amount,
	}
	mock.lockEnqueueForTransfer.Lock()
	mock.calls.EnqueueForTransfer = append(mock.calls.EnqueueForTransfer, callInfo)
	mock.lockEnqueueForTransfer.Unlock()
	return mock.EnqueueForTransferFunc(ctx, sender, amount)
}

// EnqueueForTransferCalls gets all the calls that were made to EnqueueForTransfer.
// Check the length with:
//     len(mockedNexus.EnqueueForTransferCalls())
func (mock *NexusMock) EnqueueForTransferCalls() []struct {
	Ctx    github_com_cosmos_cosmos_sdk_types.Context
	Sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
	Amount github_com_cosmos_cosmos_sdk_types.Coin
} {
	var calls []struct {
		Ctx    github_com_cosmos_cosmos_sdk_types.Context
		Sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
		Amount github_com_cosmos_cosmos_sdk_types.Coin
	}
	mock.lockEnqueueForTransfer.RLock()
	calls = mock.calls.EnqueueForTransfer
	mock.lockEnqueueForTransfer.RUnlock()
	return calls
}

// EnqueueTransfer calls EnqueueTransferFunc.
func (mock *NexusMock) EnqueueTransfer(ctx github_com_cosmos_cosmos_sdk_types.Context, senderChain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, asset github_com_cosmos_cosmos_sdk_types.Coin) (github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferID, error) {
	if mock.EnqueueTransferFunc == nil {
		panic("NexusMock.EnqueueTransferFunc: method is nil but Nexus.EnqueueTransfer was just called")
	}
	callInfo := struct {
		Ctx         github_com_cosmos_cosmos_sdk_types.Context
		SenderChain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Recipient   github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
		Asset       github_com_cosmos_cosmos_sdk_types.Coin
	}{
		Ctx:         ctx,
		SenderChain: senderChain,
		Recipient:   recipient,
		Asset:       asset,
	}
	mock.lockEnqueueTransfer.Lock()
	mock.calls.EnqueueTransfer = append(mock.calls.EnqueueTransfer, callInfo)
	mock.lockEnqueueTransfer.Unlock()
	return mock.EnqueueTransferFunc(ctx, senderChain, recipient, asset)
}

// EnqueueTransferCalls gets all the calls that were made to EnqueueTransfer.
// Check the length with:
//     len(mockedNexus.EnqueueTransferCalls())
func (mock *NexusMock) EnqueueTransferCalls() []struct {
	Ctx         github_com_cosmos_cosmos_sdk_types.Context
	SenderChain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	Recipient   github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
	Asset       github_com_cosmos_cosmos_sdk_types.Coin
} {
	var calls []struct {
		Ctx         github_com_cosmos_cosmos_sdk_types.Context
		SenderChain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Recipient   github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
		Asset       github_com_cosmos_cosmos_sdk_types.Coin
	}
	mock.lockEnqueueTransfer.RLock()
	calls = mock.calls.EnqueueTransfer
	mock.lockEnqueueTransfer.RUnlock()
	return calls
}

// GetChain calls GetChainFunc.
func (mock *NexusMock) GetChain(ctx github_com_cosmos_cosmos_sdk_types.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, bool) {
	if mock.GetChainFunc == nil {
		panic("NexusMock.GetChainFunc: method is nil but Nexus.GetChain was just called")
	}
	callInfo := struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockGetChain.Lock()
	mock.calls.GetChain = append(mock.calls.GetChain, callInfo)
	mock.lockGetChain.Unlock()
	return mock.GetChainFunc(ctx, chain)
}

// GetChainCalls gets all the calls that were made to GetChain.
// Check the length with:
//     len(mockedNexus.GetChainCalls())
func (mock *NexusMock) GetChainCalls() []struct {
	Ctx   github_com_cosmos_cosmos_sdk_types.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
} {
	var calls []struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}
	mock.lockGetChain.RLock()
	calls = mock.calls.GetChain
	mock.lockGetChain.RUnlock()
	return calls
}

// GetChainByNativeAsset calls GetChainByNativeAssetFunc.
func (mock *NexusMock) GetChainByNativeAsset(ctx github_com_cosmos_cosmos_sdk_types.Context, asset string) (github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, bool) {
	if mock.GetChainByNativeAssetFunc == nil {
		panic("NexusMock.GetChainByNativeAssetFunc: method is nil but Nexus.GetChainByNativeAsset was just called")
	}
	callInfo := struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Asset string
	}{
		Ctx:   ctx,
		Asset: asset,
	}
	mock.lockGetChainByNativeAsset.Lock()
	mock.calls.GetChainByNativeAsset = append(mock.calls.GetChainByNativeAsset, callInfo)
	mock.lockGetChainByNativeAsset.Unlock()
	return mock.GetChainByNativeAssetFunc(ctx, asset)
}

// GetChainByNativeAssetCalls gets all the calls that were made to GetChainByNativeAsset.
// Check the length with:
//     len(mockedNexus.GetChainByNativeAssetCalls())
func (mock *NexusMock) GetChainByNativeAssetCalls() []struct {
	Ctx   github_com_cosmos_cosmos_sdk_types.Context
	Asset string
} {
	var calls []struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Asset string
	}
	mock.lockGetChainByNativeAsset.RLock()
	calls = mock.calls.GetChainByNativeAsset
	mock.lockGetChainByNativeAsset.RUnlock()
	return calls
}

// GetChainMaintainers calls GetChainMaintainersFunc.
func (mock *NexusMock) GetChainMaintainers(ctx github_com_cosmos_cosmos_sdk_types.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) []github_com_cosmos_cosmos_sdk_types.ValAddress {
	if mock.GetChainMaintainersFunc == nil {
		panic("NexusMock.GetChainMaintainersFunc: method is nil but Nexus.GetChainMaintainers was just called")
	}
	callInfo := struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockGetChainMaintainers.Lock()
	mock.calls.GetChainMaintainers = append(mock.calls.GetChainMaintainers, callInfo)
	mock.lockGetChainMaintainers.Unlock()
	return mock.GetChainMaintainersFunc(ctx, chain)
}

// GetChainMaintainersCalls gets all the calls that were made to GetChainMaintainers.
// Check the length with:
//     len(mockedNexus.GetChainMaintainersCalls())
func (mock *NexusMock) GetChainMaintainersCalls() []struct {
	Ctx   github_com_cosmos_cosmos_sdk_types.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
} {
	var calls []struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}
	mock.lockGetChainMaintainers.RLock()
	calls = mock.calls.GetChainMaintainers
	mock.lockGetChainMaintainers.RUnlock()
	return calls
}

// GetChains calls GetChainsFunc.
func (mock *NexusMock) GetChains(ctx github_com_cosmos_cosmos_sdk_types.Context) []github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain {
	if mock.GetChainsFunc == nil {
		panic("NexusMock.GetChainsFunc: method is nil but Nexus.GetChains was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetChains.Lock()
	mock.calls.GetChains = append(mock.calls.GetChains, callInfo)
	mock.lockGetChains.Unlock()
	return mock.GetChainsFunc(ctx)
}

// GetChainsCalls gets all the calls that were made to GetChains.
// Check the length with:
//     len(mockedNexus.GetChainsCalls())
func (mock *NexusMock) GetChainsCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}
	mock.lockGetChains.RLock()
	calls = mock.calls.GetChains
	mock.lockGetChains.RUnlock()
	return calls
}

// GetRecipient calls GetRecipientFunc.
func (mock *NexusMock) GetRecipient(ctx github_com_cosmos_cosmos_sdk_types.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress) (github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, bool) {
	if mock.GetRecipientFunc == nil {
		panic("NexusMock.GetRecipientFunc: method is nil but Nexus.GetRecipient was just called")
	}
	callInfo := struct {
		Ctx    github_com_cosmos_cosmos_sdk_types.Context
		Sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
	}{
		Ctx:    ctx,
		Sender: sender,
	}
	mock.lockGetRecipient.Lock()
	mock.calls.GetRecipient = append(mock.calls.GetRecipient, callInfo)
	mock.lockGetRecipient.Unlock()
	return mock.GetRecipientFunc(ctx, sender)
}

// GetRecipientCalls gets all the calls that were made to GetRecipient.
// Check the length with:
//     len(mockedNexus.GetRecipientCalls())
func (mock *NexusMock) GetRecipientCalls() []struct {
	Ctx    github_com_cosmos_cosmos_sdk_types.Context
	Sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
} {
	var calls []struct {
		Ctx    github_com_cosmos_cosmos_sdk_types.Context
		Sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
	}
	mock.lockGetRecipient.RLock()
	calls = mock.calls.GetRecipient
	mock.lockGetRecipient.RUnlock()
	return calls
}

// GetTransfersForChain calls GetTransfersForChainFunc.
func (mock *NexusMock) GetTransfersForChain(ctx github_com_cosmos_cosmos_sdk_types.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, state github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferState) []github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainTransfer {
	if mock.GetTransfersForChainFunc == nil {
		panic("NexusMock.GetTransfersForChainFunc: method is nil but Nexus.GetTransfersForChain was just called")
	}
	callInfo := struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		State github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferState
	}{
		Ctx:   ctx,
		Chain: chain,
		State: state,
	}
	mock.lockGetTransfersForChain.Lock()
	mock.calls.GetTransfersForChain = append(mock.calls.GetTransfersForChain, callInfo)
	mock.lockGetTransfersForChain.Unlock()
	return mock.GetTransfersForChainFunc(ctx, chain, state)
}

// GetTransfersForChainCalls gets all the calls that were made to GetTransfersForChain.
// Check the length with:
//     len(mockedNexus.GetTransfersForChainCalls())
func (mock *NexusMock) GetTransfersForChainCalls() []struct {
	Ctx   github_com_cosmos_cosmos_sdk_types.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	State github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferState
} {
	var calls []struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		State github_com_axelarnetwork_axelar_core_x_nexus_exported.TransferState
	}
	mock.lockGetTransfersForChain.RLock()
	calls = mock.calls.GetTransfersForChain
	mock.lockGetTransfersForChain.RUnlock()
	return calls
}

// IsAssetRegistered calls IsAssetRegisteredFunc.
func (mock *NexusMock) IsAssetRegistered(ctx github_com_cosmos_cosmos_sdk_types.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, denom string) bool {
	if mock.IsAssetRegisteredFunc == nil {
		panic("NexusMock.IsAssetRegisteredFunc: method is nil but Nexus.IsAssetRegistered was just called")
	}
	callInfo := struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Denom string
	}{
		Ctx:   ctx,
		Chain: chain,
		Denom: denom,
	}
	mock.lockIsAssetRegistered.Lock()
	mock.calls.IsAssetRegistered = append(mock.calls.IsAssetRegistered, callInfo)
	mock.lockIsAssetRegistered.Unlock()
	return mock.IsAssetRegisteredFunc(ctx, chain, denom)
}

// IsAssetRegisteredCalls gets all the calls that were made to IsAssetRegistered.
// Check the length with:
//     len(mockedNexus.IsAssetRegisteredCalls())
func (mock *NexusMock) IsAssetRegisteredCalls() []struct {
	Ctx   github_com_cosmos_cosmos_sdk_types.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	Denom string
} {
	var calls []struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Denom string
	}
	mock.lockIsAssetRegistered.RLock()
	calls = mock.calls.IsAssetRegistered
	mock.lockIsAssetRegistered.RUnlock()
	return calls
}

// IsChainActivated calls IsChainActivatedFunc.
func (mock *NexusMock) IsChainActivated(ctx github_com_cosmos_cosmos_sdk_types.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) bool {
	if mock.IsChainActivatedFunc == nil {
		panic("NexusMock.IsChainActivatedFunc: method is nil but Nexus.IsChainActivated was just called")
	}
	callInfo := struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockIsChainActivated.Lock()
	mock.calls.IsChainActivated = append(mock.calls.IsChainActivated, callInfo)
	mock.lockIsChainActivated.Unlock()
	return mock.IsChainActivatedFunc(ctx, chain)
}

// IsChainActivatedCalls gets all the calls that were made to IsChainActivated.
// Check the length with:
//     len(mockedNexus.IsChainActivatedCalls())
func (mock *NexusMock) IsChainActivatedCalls() []struct {
	Ctx   github_com_cosmos_cosmos_sdk_types.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
} {
	var calls []struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}
	mock.lockIsChainActivated.RLock()
	calls = mock.calls.IsChainActivated
	mock.lockIsChainActivated.RUnlock()
	return calls
}

// LinkAddresses calls LinkAddressesFunc.
func (mock *NexusMock) LinkAddresses(ctx github_com_cosmos_cosmos_sdk_types.Context, sender github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress, recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress) error {
	if mock.LinkAddressesFunc == nil {
		panic("NexusMock.LinkAddressesFunc: method is nil but Nexus.LinkAddresses was just called")
	}
	callInfo := struct {
		Ctx       github_com_cosmos_cosmos_sdk_types.Context
		Sender    github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
		Recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
	}{
		Ctx:       ctx,
		Sender:    sender,
		Recipient: recipient,
	}
	mock.lockLinkAddresses.Lock()
	mock.calls.LinkAddresses = append(mock.calls.LinkAddresses, callInfo)
	mock.lockLinkAddresses.Unlock()
	return mock.LinkAddressesFunc(ctx, sender, recipient)
}

// LinkAddressesCalls gets all the calls that were made to LinkAddresses.
// Check the length with:
//     len(mockedNexus.LinkAddressesCalls())
func (mock *NexusMock) LinkAddressesCalls() []struct {
	Ctx       github_com_cosmos_cosmos_sdk_types.Context
	Sender    github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
	Recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
} {
	var calls []struct {
		Ctx       github_com_cosmos_cosmos_sdk_types.Context
		Sender    github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
		Recipient github_com_axelarnetwork_axelar_core_x_nexus_exported.CrossChainAddress
	}
	mock.lockLinkAddresses.RLock()
	calls = mock.calls.LinkAddresses
	mock.lockLinkAddresses.RUnlock()
	return calls
}

// MarkChainMaintainerIncorrectVote calls MarkChainMaintainerIncorrectVoteFunc.
func (mock *NexusMock) MarkChainMaintainerIncorrectVote(ctx github_com_cosmos_cosmos_sdk_types.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, address github_com_cosmos_cosmos_sdk_types.ValAddress, incorrectVote bool) {
	if mock.MarkChainMaintainerIncorrectVoteFunc == nil {
		panic("NexusMock.MarkChainMaintainerIncorrectVoteFunc: method is nil but Nexus.MarkChainMaintainerIncorrectVote was just called")
	}
	callInfo := struct {
		Ctx           github_com_cosmos_cosmos_sdk_types.Context
		Chain         github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Address       github_com_cosmos_cosmos_sdk_types.ValAddress
		IncorrectVote bool
	}{
		Ctx:           ctx,
		Chain:         chain,
		Address:       address,
		IncorrectVote: incorrectVote,
	}
	mock.lockMarkChainMaintainerIncorrectVote.Lock()
	mock.calls.MarkChainMaintainerIncorrectVote = append(mock.calls.MarkChainMaintainerIncorrectVote, callInfo)
	mock.lockMarkChainMaintainerIncorrectVote.Unlock()
	mock.MarkChainMaintainerIncorrectVoteFunc(ctx, chain, address, incorrectVote)
}

// MarkChainMaintainerIncorrectVoteCalls gets all the calls that were made to MarkChainMaintainerIncorrectVote.
// Check the length with:
//     len(mockedNexus.MarkChainMaintainerIncorrectVoteCalls())
func (mock *NexusMock) MarkChainMaintainerIncorrectVoteCalls() []struct {
	Ctx           github_com_cosmos_cosmos_sdk_types.Context
	Chain         github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	Address       github_com_cosmos_cosmos_sdk_types.ValAddress
	IncorrectVote bool
} {
	var calls []struct {
		Ctx           github_com_cosmos_cosmos_sdk_types.Context
		Chain         github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Address       github_com_cosmos_cosmos_sdk_types.ValAddress
		IncorrectVote bool
	}
	mock.lockMarkChainMaintainerIncorrectVote.RLock()
	calls = mock.calls.MarkChainMaintainerIncorrectVote
	mock.lockMarkChainMaintainerIncorrectVote.RUnlock()
	return calls
}

// MarkChainMaintainerMissingVote calls MarkChainMaintainerMissingVoteFunc.
func (mock *NexusMock) MarkChainMaintainerMissingVote(ctx github_com_cosmos_cosmos_sdk_types.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, address github_com_cosmos_cosmos_sdk_types.ValAddress, missingVote bool) {
	if mock.MarkChainMaintainerMissingVoteFunc == nil {
		panic("NexusMock.MarkChainMaintainerMissingVoteFunc: method is nil but Nexus.MarkChainMaintainerMissingVote was just called")
	}
	callInfo := struct {
		Ctx         github_com_cosmos_cosmos_sdk_types.Context
		Chain       github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Address     github_com_cosmos_cosmos_sdk_types.ValAddress
		MissingVote bool
	}{
		Ctx:         ctx,
		Chain:       chain,
		Address:     address,
		MissingVote: missingVote,
	}
	mock.lockMarkChainMaintainerMissingVote.Lock()
	mock.calls.MarkChainMaintainerMissingVote = append(mock.calls.MarkChainMaintainerMissingVote, callInfo)
	mock.lockMarkChainMaintainerMissingVote.Unlock()
	mock.MarkChainMaintainerMissingVoteFunc(ctx, chain, address, missingVote)
}

// MarkChainMaintainerMissingVoteCalls gets all the calls that were made to MarkChainMaintainerMissingVote.
// Check the length with:
//     len(mockedNexus.MarkChainMaintainerMissingVoteCalls())
func (mock *NexusMock) MarkChainMaintainerMissingVoteCalls() []struct {
	Ctx         github_com_cosmos_cosmos_sdk_types.Context
	Chain       github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	Address     github_com_cosmos_cosmos_sdk_types.ValAddress
	MissingVote bool
} {
	var calls []struct {
		Ctx         github_com_cosmos_cosmos_sdk_types.Context
		Chain       github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Address     github_com_cosmos_cosmos_sdk_types.ValAddress
		MissingVote bool
	}
	mock.lockMarkChainMaintainerMissingVote.RLock()
	calls = mock.calls.MarkChainMaintainerMissingVote
	mock.lockMarkChainMaintainerMissingVote.RUnlock()
	return calls
}

// RegisterAsset calls RegisterAssetFunc.
func (mock *NexusMock) RegisterAsset(ctx github_com_cosmos_cosmos_sdk_types.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain, asset github_com_axelarnetwork_axelar_core_x_nexus_exported.Asset) error {
	if mock.RegisterAssetFunc == nil {
		panic("NexusMock.RegisterAssetFunc: method is nil but Nexus.RegisterAsset was just called")
	}
	callInfo := struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Asset github_com_axelarnetwork_axelar_core_x_nexus_exported.Asset
	}{
		Ctx:   ctx,
		Chain: chain,
		Asset: asset,
	}
	mock.lockRegisterAsset.Lock()
	mock.calls.RegisterAsset = append(mock.calls.RegisterAsset, callInfo)
	mock.lockRegisterAsset.Unlock()
	return mock.RegisterAssetFunc(ctx, chain, asset)
}

// RegisterAssetCalls gets all the calls that were made to RegisterAsset.
// Check the length with:
//     len(mockedNexus.RegisterAssetCalls())
func (mock *NexusMock) RegisterAssetCalls() []struct {
	Ctx   github_com_cosmos_cosmos_sdk_types.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	Asset github_com_axelarnetwork_axelar_core_x_nexus_exported.Asset
} {
	var calls []struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
		Asset github_com_axelarnetwork_axelar_core_x_nexus_exported.Asset
	}
	mock.lockRegisterAsset.RLock()
	calls = mock.calls.RegisterAsset
	mock.lockRegisterAsset.RUnlock()
	return calls
}

// SetChain calls SetChainFunc.
func (mock *NexusMock) SetChain(ctx github_com_cosmos_cosmos_sdk_types.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain) {
	if mock.SetChainFunc == nil {
		panic("NexusMock.SetChainFunc: method is nil but Nexus.SetChain was just called")
	}
	callInfo := struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockSetChain.Lock()
	mock.calls.SetChain = append(mock.calls.SetChain, callInfo)
	mock.lockSetChain.Unlock()
	mock.SetChainFunc(ctx, chain)
}

// SetChainCalls gets all the calls that were made to SetChain.
// Check the length with:
//     len(mockedNexus.SetChainCalls())
func (mock *NexusMock) SetChainCalls() []struct {
	Ctx   github_com_cosmos_cosmos_sdk_types.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
} {
	var calls []struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.Chain
	}
	mock.lockSetChain.RLock()
	calls = mock.calls.SetChain
	mock.lockSetChain.RUnlock()
	return calls
}

// Ensure, that SnapshotterMock does implement evmtypes.Snapshotter.
// If this is not the case, regenerate this file with moq.
var _ evmtypes.Snapshotter = &SnapshotterMock{}

// SnapshotterMock is a mock implementation of evmtypes.Snapshotter.
//
// 	func TestSomethingThatUsesSnapshotter(t *testing.T) {
//
// 		// make and configure a mocked evmtypes.Snapshotter
// 		mockedSnapshotter := &SnapshotterMock{
// 			CreateSnapshotFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, candidates []github_com_cosmos_cosmos_sdk_types.ValAddress, filterFunc func(snapshot.ValidatorI) bool, weightFunc func(consensusPower github_com_cosmos_cosmos_sdk_types.Uint) github_com_cosmos_cosmos_sdk_types.Uint, threshold utils.Threshold) (snapshot.Snapshot, error) {
// 				panic("mock out the CreateSnapshot method")
// 			},
// 			GetLatestSnapshotFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context) (snapshot.Snapshot, bool) {
// 				panic("mock out the GetLatestSnapshot method")
// 			},
// 			GetOperatorFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, proxy github_com_cosmos_cosmos_sdk_types.AccAddress) github_com_cosmos_cosmos_sdk_types.ValAddress {
// 				panic("mock out the GetOperator method")
// 			},
// 			GetProxyFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, principal github_com_cosmos_cosmos_sdk_types.ValAddress) (github_com_cosmos_cosmos_sdk_types.AccAddress, bool) {
// 				panic("mock out the GetProxy method")
// 			},
// 			GetSnapshotFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, seqNo int64) (snapshot.Snapshot, bool) {
// 				panic("mock out the GetSnapshot method")
// 			},
// 			GetValidatorIllegibilityFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, validator snapshot.SDKValidator) (snapshot.ValidatorIllegibility, error) {
// 				panic("mock out the GetValidatorIllegibility method")
// 			},
// 			TakeSnapshotFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, keyRequirement exported.KeyRequirement) (snapshot.Snapshot, error) {
// 				panic("mock out the TakeSnapshot method")
// 			},
// 		}
//
// 		// use mockedSnapshotter in code that requires evmtypes.Snapshotter
// 		// and then make assertions.
//
// 	}
type SnapshotterMock struct {
	// CreateSnapshotFunc mocks the CreateSnapshot method.
	CreateSnapshotFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, candidates []github_com_cosmos_cosmos_sdk_types.ValAddress, filterFunc func(snapshot.ValidatorI) bool, weightFunc func(consensusPower github_com_cosmos_cosmos_sdk_types.Uint) github_com_cosmos_cosmos_sdk_types.Uint, threshold utils.Threshold) (snapshot.Snapshot, error)

	// GetLatestSnapshotFunc mocks the GetLatestSnapshot method.
	GetLatestSnapshotFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context) (snapshot.Snapshot, bool)

	// GetOperatorFunc mocks the GetOperator method.
	GetOperatorFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, proxy github_com_cosmos_cosmos_sdk_types.AccAddress) github_com_cosmos_cosmos_sdk_types.ValAddress

	// GetProxyFunc mocks the GetProxy method.
	GetProxyFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, principal github_com_cosmos_cosmos_sdk_types.ValAddress) (github_com_cosmos_cosmos_sdk_types.AccAddress, bool)

	// GetSnapshotFunc mocks the GetSnapshot method.
	GetSnapshotFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, seqNo int64) (snapshot.Snapshot, bool)

	// GetValidatorIllegibilityFunc mocks the GetValidatorIllegibility method.
	GetValidatorIllegibilityFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, validator snapshot.SDKValidator) (snapshot.ValidatorIllegibility, error)

	// TakeSnapshotFunc mocks the TakeSnapshot method.
	TakeSnapshotFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, keyRequirement exported.KeyRequirement) (snapshot.Snapshot, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateSnapshot holds details about calls to the CreateSnapshot method.
		CreateSnapshot []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Candidates is the candidates argument value.
			Candidates []github_com_cosmos_cosmos_sdk_types.ValAddress
			// FilterFunc is the filterFunc argument value.
			FilterFunc func(snapshot.ValidatorI) bool
			// WeightFunc is the weightFunc argument value.
			WeightFunc func(consensusPower github_com_cosmos_cosmos_sdk_types.Uint) github_com_cosmos_cosmos_sdk_types.Uint
			// Threshold is the threshold argument value.
			Threshold utils.Threshold
		}
		// GetLatestSnapshot holds details about calls to the GetLatestSnapshot method.
		GetLatestSnapshot []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
		}
		// GetOperator holds details about calls to the GetOperator method.
		GetOperator []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Proxy is the proxy argument value.
			Proxy github_com_cosmos_cosmos_sdk_types.AccAddress
		}
		// GetProxy holds details about calls to the GetProxy method.
		GetProxy []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Principal is the principal argument value.
			Principal github_com_cosmos_cosmos_sdk_types.ValAddress
		}
		// GetSnapshot holds details about calls to the GetSnapshot method.
		GetSnapshot []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// SeqNo is the seqNo argument value.
			SeqNo int64
		}
		// GetValidatorIllegibility holds details about calls to the GetValidatorIllegibility method.
		GetValidatorIllegibility []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Validator is the validator argument value.
			Validator snapshot.SDKValidator
		}
		// TakeSnapshot holds details about calls to the TakeSnapshot method.
		TakeSnapshot []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// KeyRequirement is the keyRequirement argument value.
			KeyRequirement exported.KeyRequirement
		}
	}
	lockCreateSnapshot           sync.RWMutex
	lockGetLatestSnapshot        sync.RWMutex
	lockGetOperator              sync.RWMutex
	lockGetProxy                 sync.RWMutex
	lockGetSnapshot              sync.RWMutex
	lockGetValidatorIllegibility sync.RWMutex
	lockTakeSnapshot             sync.RWMutex
}

// CreateSnapshot calls CreateSnapshotFunc.
func (mock *SnapshotterMock) CreateSnapshot(ctx github_com_cosmos_cosmos_sdk_types.Context, candidates []github_com_cosmos_cosmos_sdk_types.ValAddress, filterFunc func(snapshot.ValidatorI) bool, weightFunc func(consensusPower github_com_cosmos_cosmos_sdk_types.Uint) github_com_cosmos_cosmos_sdk_types.Uint, threshold utils.Threshold) (snapshot.Snapshot, error) {
	if mock.CreateSnapshotFunc == nil {
		panic("SnapshotterMock.CreateSnapshotFunc: method is nil but Snapshotter.CreateSnapshot was just called")
	}
	callInfo := struct {
		Ctx        github_com_cosmos_cosmos_sdk_types.Context
		Candidates []github_com_cosmos_cosmos_sdk_types.ValAddress
		FilterFunc func(snapshot.ValidatorI) bool
		WeightFunc func(consensusPower github_com_cosmos_cosmos_sdk_types.Uint) github_com_cosmos_cosmos_sdk_types.Uint
		Threshold  utils.Threshold
	}{
		Ctx:        ctx,
		Candidates: candidates,
		FilterFunc: filterFunc,
		WeightFunc: weightFunc,
		Threshold:  threshold,
	}
	mock.lockCreateSnapshot.Lock()
	mock.calls.CreateSnapshot = append(mock.calls.CreateSnapshot, callInfo)
	mock.lockCreateSnapshot.Unlock()
	return mock.CreateSnapshotFunc(ctx, candidates, filterFunc, weightFunc, threshold)
}

// CreateSnapshotCalls gets all the calls that were made to CreateSnapshot.
// Check the length with:
//     len(mockedSnapshotter.CreateSnapshotCalls())
func (mock *SnapshotterMock) CreateSnapshotCalls() []struct {
	Ctx        github_com_cosmos_cosmos_sdk_types.Context
	Candidates []github_com_cosmos_cosmos_sdk_types.ValAddress
	FilterFunc func(snapshot.ValidatorI) bool
	WeightFunc func(consensusPower github_com_cosmos_cosmos_sdk_types.Uint) github_com_cosmos_cosmos_sdk_types.Uint
	Threshold  utils.Threshold
} {
	var calls []struct {
		Ctx        github_com_cosmos_cosmos_sdk_types.Context
		Candidates []github_com_cosmos_cosmos_sdk_types.ValAddress
		FilterFunc func(snapshot.ValidatorI) bool
		WeightFunc func(consensusPower github_com_cosmos_cosmos_sdk_types.Uint) github_com_cosmos_cosmos_sdk_types.Uint
		Threshold  utils.Threshold
	}
	mock.lockCreateSnapshot.RLock()
	calls = mock.calls.CreateSnapshot
	mock.lockCreateSnapshot.RUnlock()
	return calls
}

// GetLatestSnapshot calls GetLatestSnapshotFunc.
func (mock *SnapshotterMock) GetLatestSnapshot(ctx github_com_cosmos_cosmos_sdk_types.Context) (snapshot.Snapshot, bool) {
	if mock.GetLatestSnapshotFunc == nil {
		panic("SnapshotterMock.GetLatestSnapshotFunc: method is nil but Snapshotter.GetLatestSnapshot was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetLatestSnapshot.Lock()
	mock.calls.GetLatestSnapshot = append(mock.calls.GetLatestSnapshot, callInfo)
	mock.lockGetLatestSnapshot.Unlock()
	return mock.GetLatestSnapshotFunc(ctx)
}

// GetLatestSnapshotCalls gets all the calls that were made to GetLatestSnapshot.
// Check the length with:
//     len(mockedSnapshotter.GetLatestSnapshotCalls())
func (mock *SnapshotterMock) GetLatestSnapshotCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}
	mock.lockGetLatestSnapshot.RLock()
	calls = mock.calls.GetLatestSnapshot
	mock.lockGetLatestSnapshot.RUnlock()
	return calls
}

// GetOperator calls GetOperatorFunc.
func (mock *SnapshotterMock) GetOperator(ctx github_com_cosmos_cosmos_sdk_types.Context, proxy github_com_cosmos_cosmos_sdk_types.AccAddress) github_com_cosmos_cosmos_sdk_types.ValAddress {
	if mock.GetOperatorFunc == nil {
		panic("SnapshotterMock.GetOperatorFunc: method is nil but Snapshotter.GetOperator was just called")
	}
	callInfo := struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Proxy github_com_cosmos_cosmos_sdk_types.AccAddress
	}{
		Ctx:   ctx,
		Proxy: proxy,
	}
	mock.lockGetOperator.Lock()
	mock.calls.GetOperator = append(mock.calls.GetOperator, callInfo)
	mock.lockGetOperator.Unlock()
	return mock.GetOperatorFunc(ctx, proxy)
}

// GetOperatorCalls gets all the calls that were made to GetOperator.
// Check the length with:
//     len(mockedSnapshotter.GetOperatorCalls())
func (mock *SnapshotterMock) GetOperatorCalls() []struct {
	Ctx   github_com_cosmos_cosmos_sdk_types.Context
	Proxy github_com_cosmos_cosmos_sdk_types.AccAddress
} {
	var calls []struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Proxy github_com_cosmos_cosmos_sdk_types.AccAddress
	}
	mock.lockGetOperator.RLock()
	calls = mock.calls.GetOperator
	mock.lockGetOperator.RUnlock()
	return calls
}

// GetProxy calls GetProxyFunc.
func (mock *SnapshotterMock) GetProxy(ctx github_com_cosmos_cosmos_sdk_types.Context, principal github_com_cosmos_cosmos_sdk_types.ValAddress) (github_com_cosmos_cosmos_sdk_types.AccAddress, bool) {
	if mock.GetProxyFunc == nil {
		panic("SnapshotterMock.GetProxyFunc: method is nil but Snapshotter.GetProxy was just called")
	}
	callInfo := struct {
		Ctx       github_com_cosmos_cosmos_sdk_types.Context
		Principal github_com_cosmos_cosmos_sdk_types.ValAddress
	}{
		Ctx:       ctx,
		Principal: principal,
	}
	mock.lockGetProxy.Lock()
	mock.calls.GetProxy = append(mock.calls.GetProxy, callInfo)
	mock.lockGetProxy.Unlock()
	return mock.GetProxyFunc(ctx, principal)
}

// GetProxyCalls gets all the calls that were made to GetProxy.
// Check the length with:
//     len(mockedSnapshotter.GetProxyCalls())
func (mock *SnapshotterMock) GetProxyCalls() []struct {
	Ctx       github_com_cosmos_cosmos_sdk_types.Context
	Principal github_com_cosmos_cosmos_sdk_types.ValAddress
} {
	var calls []struct {
		Ctx       github_com_cosmos_cosmos_sdk_types.Context
		Principal github_com_cosmos_cosmos_sdk_types.ValAddress
	}
	mock.lockGetProxy.RLock()
	calls = mock.calls.GetProxy
	mock.lockGetProxy.RUnlock()
	return calls
}

// GetSnapshot calls GetSnapshotFunc.
func (mock *SnapshotterMock) GetSnapshot(ctx github_com_cosmos_cosmos_sdk_types.Context, seqNo int64) (snapshot.Snapshot, bool) {
	if mock.GetSnapshotFunc == nil {
		panic("SnapshotterMock.GetSnapshotFunc: method is nil but Snapshotter.GetSnapshot was just called")
	}
	callInfo := struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		SeqNo int64
	}{
		Ctx:   ctx,
		SeqNo: seqNo,
	}
	mock.lockGetSnapshot.Lock()
	mock.calls.GetSnapshot = append(mock.calls.GetSnapshot, callInfo)
	mock.lockGetSnapshot.Unlock()
	return mock.GetSnapshotFunc(ctx, seqNo)
}

// GetSnapshotCalls gets all the calls that were made to GetSnapshot.
// Check the length with:
//     len(mockedSnapshotter.GetSnapshotCalls())
func (mock *SnapshotterMock) GetSnapshotCalls() []struct {
	Ctx   github_com_cosmos_cosmos_sdk_types.Context
	SeqNo int64
} {
	var calls []struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		SeqNo int64
	}
	mock.lockGetSnapshot.RLock()
	calls = mock.calls.GetSnapshot
	mock.lockGetSnapshot.RUnlock()
	return calls
}

// GetValidatorIllegibility calls GetValidatorIllegibilityFunc.
func (mock *SnapshotterMock) GetValidatorIllegibility(ctx github_com_cosmos_cosmos_sdk_types.Context, validator snapshot.SDKValidator) (snapshot.ValidatorIllegibility, error) {
	if mock.GetValidatorIllegibilityFunc == nil {
		panic("SnapshotterMock.GetValidatorIllegibilityFunc: method is nil but Snapshotter.GetValidatorIllegibility was just called")
	}
	callInfo := struct {
		Ctx       github_com_cosmos_cosmos_sdk_types.Context
		Validator snapshot.SDKValidator
	}{
		Ctx:       ctx,
		Validator: validator,
	}
	mock.lockGetValidatorIllegibility.Lock()
	mock.calls.GetValidatorIllegibility = append(mock.calls.GetValidatorIllegibility, callInfo)
	mock.lockGetValidatorIllegibility.Unlock()
	return mock.GetValidatorIllegibilityFunc(ctx, validator)
}

// GetValidatorIllegibilityCalls gets all the calls that were made to GetValidatorIllegibility.
// Check the length with:
//     len(mockedSnapshotter.GetValidatorIllegibilityCalls())
func (mock *SnapshotterMock) GetValidatorIllegibilityCalls() []struct {
	Ctx       github_com_cosmos_cosmos_sdk_types.Context
	Validator snapshot.SDKValidator
} {
	var calls []struct {
		Ctx       github_com_cosmos_cosmos_sdk_types.Context
		Validator snapshot.SDKValidator
	}
	mock.lockGetValidatorIllegibility.RLock()
	calls = mock.calls.GetValidatorIllegibility
	mock.lockGetValidatorIllegibility.RUnlock()
	return calls
}

// TakeSnapshot calls TakeSnapshotFunc.
func (mock *SnapshotterMock) TakeSnapshot(ctx github_com_cosmos_cosmos_sdk_types.Context, keyRequirement exported.KeyRequirement) (snapshot.Snapshot, error) {
	if mock.TakeSnapshotFunc == nil {
		panic("SnapshotterMock.TakeSnapshotFunc: method is nil but Snapshotter.TakeSnapshot was just called")
	}
	callInfo := struct {
		Ctx            github_com_cosmos_cosmos_sdk_types.Context
		KeyRequirement exported.KeyRequirement
	}{
		Ctx:            ctx,
		KeyRequirement: keyRequirement,
	}
	mock.lockTakeSnapshot.Lock()
	mock.calls.TakeSnapshot = append(mock.calls.TakeSnapshot, callInfo)
	mock.lockTakeSnapshot.Unlock()
	return mock.TakeSnapshotFunc(ctx, keyRequirement)
}

// TakeSnapshotCalls gets all the calls that were made to TakeSnapshot.
// Check the length with:
//     len(mockedSnapshotter.TakeSnapshotCalls())
func (mock *SnapshotterMock) TakeSnapshotCalls() []struct {
	Ctx            github_com_cosmos_cosmos_sdk_types.Context
	KeyRequirement exported.KeyRequirement
} {
	var calls []struct {
		Ctx            github_com_cosmos_cosmos_sdk_types.Context
		KeyRequirement exported.KeyRequirement
	}
	mock.lockTakeSnapshot.RLock()
	calls = mock.calls.TakeSnapshot
	mock.lockTakeSnapshot.RUnlock()
	return calls
}

// Ensure, that BaseKeeperMock does implement evmtypes.BaseKeeper.
// If this is not the case, regenerate this file with moq.
var _ evmtypes.BaseKeeper = &BaseKeeperMock{}

// BaseKeeperMock is a mock implementation of evmtypes.BaseKeeper.
//
// 	func TestSomethingThatUsesBaseKeeper(t *testing.T) {
//
// 		// make and configure a mocked evmtypes.BaseKeeper
// 		mockedBaseKeeper := &BaseKeeperMock{
// 			ExportGenesisFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context) evmtypes.GenesisState {
// 				panic("mock out the ExportGenesis method")
// 			},
// 			ForChainFunc: func(chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) evmtypes.ChainKeeper {
// 				panic("mock out the ForChain method")
// 			},
// 			HasChainFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) bool {
// 				panic("mock out the HasChain method")
// 			},
// 			InitGenesisFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, state evmtypes.GenesisState)  {
// 				panic("mock out the InitGenesis method")
// 			},
// 			LoggerFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context) log.Logger {
// 				panic("mock out the Logger method")
// 			},
// 		}
//
// 		// use mockedBaseKeeper in code that requires evmtypes.BaseKeeper
// 		// and then make assertions.
//
// 	}
type BaseKeeperMock struct {
	// ExportGenesisFunc mocks the ExportGenesis method.
	ExportGenesisFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context) evmtypes.GenesisState

	// ForChainFunc mocks the ForChain method.
	ForChainFunc func(chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) evmtypes.ChainKeeper

	// HasChainFunc mocks the HasChain method.
	HasChainFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) bool

	// InitGenesisFunc mocks the InitGenesis method.
	InitGenesisFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, state evmtypes.GenesisState)

	// LoggerFunc mocks the Logger method.
	LoggerFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context) log.Logger

	// calls tracks calls to the methods.
	calls struct {
		// ExportGenesis holds details about calls to the ExportGenesis method.
		ExportGenesis []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
		}
		// ForChain holds details about calls to the ForChain method.
		ForChain []struct {
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
		}
		// HasChain holds details about calls to the HasChain method.
		HasChain []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Chain is the chain argument value.
			Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
		}
		// InitGenesis holds details about calls to the InitGenesis method.
		InitGenesis []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// State is the state argument value.
			State evmtypes.GenesisState
		}
		// Logger holds details about calls to the Logger method.
		Logger []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
		}
	}
	lockExportGenesis sync.RWMutex
	lockForChain      sync.RWMutex
	lockHasChain      sync.RWMutex
	lockInitGenesis   sync.RWMutex
	lockLogger        sync.RWMutex
}

// ExportGenesis calls ExportGenesisFunc.
func (mock *BaseKeeperMock) ExportGenesis(ctx github_com_cosmos_cosmos_sdk_types.Context) evmtypes.GenesisState {
	if mock.ExportGenesisFunc == nil {
		panic("BaseKeeperMock.ExportGenesisFunc: method is nil but BaseKeeper.ExportGenesis was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}{
		Ctx: ctx,
	}
	mock.lockExportGenesis.Lock()
	mock.calls.ExportGenesis = append(mock.calls.ExportGenesis, callInfo)
	mock.lockExportGenesis.Unlock()
	return mock.ExportGenesisFunc(ctx)
}

// ExportGenesisCalls gets all the calls that were made to ExportGenesis.
// Check the length with:
//     len(mockedBaseKeeper.ExportGenesisCalls())
func (mock *BaseKeeperMock) ExportGenesisCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}
	mock.lockExportGenesis.RLock()
	calls = mock.calls.ExportGenesis
	mock.lockExportGenesis.RUnlock()
	return calls
}

// ForChain calls ForChainFunc.
func (mock *BaseKeeperMock) ForChain(chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) evmtypes.ChainKeeper {
	if mock.ForChainFunc == nil {
		panic("BaseKeeperMock.ForChainFunc: method is nil but BaseKeeper.ForChain was just called")
	}
	callInfo := struct {
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}{
		Chain: chain,
	}
	mock.lockForChain.Lock()
	mock.calls.ForChain = append(mock.calls.ForChain, callInfo)
	mock.lockForChain.Unlock()
	return mock.ForChainFunc(chain)
}

// ForChainCalls gets all the calls that were made to ForChain.
// Check the length with:
//     len(mockedBaseKeeper.ForChainCalls())
func (mock *BaseKeeperMock) ForChainCalls() []struct {
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
} {
	var calls []struct {
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}
	mock.lockForChain.RLock()
	calls = mock.calls.ForChain
	mock.lockForChain.RUnlock()
	return calls
}

// HasChain calls HasChainFunc.
func (mock *BaseKeeperMock) HasChain(ctx github_com_cosmos_cosmos_sdk_types.Context, chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) bool {
	if mock.HasChainFunc == nil {
		panic("BaseKeeperMock.HasChainFunc: method is nil but BaseKeeper.HasChain was just called")
	}
	callInfo := struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}{
		Ctx:   ctx,
		Chain: chain,
	}
	mock.lockHasChain.Lock()
	mock.calls.HasChain = append(mock.calls.HasChain, callInfo)
	mock.lockHasChain.Unlock()
	return mock.HasChainFunc(ctx, chain)
}

// HasChainCalls gets all the calls that were made to HasChain.
// Check the length with:
//     len(mockedBaseKeeper.HasChainCalls())
func (mock *BaseKeeperMock) HasChainCalls() []struct {
	Ctx   github_com_cosmos_cosmos_sdk_types.Context
	Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
} {
	var calls []struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Chain github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}
	mock.lockHasChain.RLock()
	calls = mock.calls.HasChain
	mock.lockHasChain.RUnlock()
	return calls
}

// InitGenesis calls InitGenesisFunc.
func (mock *BaseKeeperMock) InitGenesis(ctx github_com_cosmos_cosmos_sdk_types.Context, state evmtypes.GenesisState) {
	if mock.InitGenesisFunc == nil {
		panic("BaseKeeperMock.InitGenesisFunc: method is nil but BaseKeeper.InitGenesis was just called")
	}
	callInfo := struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		State evmtypes.GenesisState
	}{
		Ctx:   ctx,
		State: state,
	}
	mock.lockInitGenesis.Lock()
	mock.calls.InitGenesis = append(mock.calls.InitGenesis, callInfo)
	mock.lockInitGenesis.Unlock()
	mock.InitGenesisFunc(ctx, state)
}

// InitGenesisCalls gets all the calls that were made to InitGenesis.
// Check the length with:
//     len(mockedBaseKeeper.InitGenesisCalls())
func (mock *BaseKeeperMock) InitGenesisCalls() []struct {
	Ctx   github_com_cosmos_cosmos_sdk_types.Context
	State evmtypes.GenesisState
} {
	var calls []struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		State evmtypes.GenesisState
	}
	mock.lockInitGenesis.RLock()
	calls = mock.calls.InitGenesis
	mock.lockInitGenesis.RUnlock()
	return calls
}

// Logger calls LoggerFunc.
func (mock *BaseKeeperMock) Logger(ctx github_com_cosmos_cosmos_sdk_types.Context) log.Logger {
	if mock.LoggerFunc == nil {
		panic("BaseKeeperMock.LoggerFunc: method is nil but BaseKeeper.Logger was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}{
		Ctx: ctx,
	}
	mock.lockLogger.Lock()
	mock.calls.Logger = append(mock.calls.Logger, callInfo)
	mock.lockLogger.Unlock()
	return mock.LoggerFunc(ctx)
}

// LoggerCalls gets all the calls that were made to Logger.
// Check the length with:
//     len(mockedBaseKeeper.LoggerCalls())
func (mock *BaseKeeperMock) LoggerCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}
	mock.lockLogger.RLock()
	calls = mock.calls.Logger
	mock.lockLogger.RUnlock()
	return calls
}

// Ensure, that ChainKeeperMock does implement evmtypes.ChainKeeper.
// If this is not the case, regenerate this file with moq.
var _ evmtypes.ChainKeeper = &ChainKeeperMock{}

// ChainKeeperMock is a mock implementation of evmtypes.ChainKeeper.
//
// 	func TestSomethingThatUsesChainKeeper(t *testing.T) {
//
// 		// make and configure a mocked evmtypes.ChainKeeper
// 		mockedChainKeeper := &ChainKeeperMock{
// 			CreateERC20TokenFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, asset string, details evmtypes.TokenDetails, address evmtypes.Address) (evmtypes.ERC20Token, error) {
// 				panic("mock out the CreateERC20Token method")
// 			},
// 			CreateNewBatchToSignFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context) (evmtypes.CommandBatch, error) {
// 				panic("mock out the CreateNewBatchToSign method")
// 			},
// 			DeleteDepositFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, deposit evmtypes.ERC20Deposit)  {
// 				panic("mock out the DeleteDeposit method")
// 			},
// 			DeleteUnsignedCommandBatchIDFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context)  {
// 				panic("mock out the DeleteUnsignedCommandBatchID method")
// 			},
// 			EnqueueCommandFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, cmd evmtypes.Command) error {
// 				panic("mock out the EnqueueCommand method")
// 			},
// 			GetBatchByIDFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, id []byte) evmtypes.CommandBatch {
// 				panic("mock out the GetBatchByID method")
// 			},
// 			GetBurnerAddressAndSaltFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, token evmtypes.ERC20Token, recipient string, gatewayAddr evmtypes.Address) (evmtypes.Address, evmtypes.Hash, error) {
// 				panic("mock out the GetBurnerAddressAndSalt method")
// 			},
// 			GetBurnerByteCodeFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context) ([]byte, bool) {
// 				panic("mock out the GetBurnerByteCode method")
// 			},
// 			GetBurnerInfoFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, address evmtypes.Address) *evmtypes.BurnerInfo {
// 				panic("mock out the GetBurnerInfo method")
// 			},
// 			GetChainIDFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context) (github_com_cosmos_cosmos_sdk_types.Int, bool) {
// 				panic("mock out the GetChainID method")
// 			},
// 			GetChainIDByNetworkFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, network string) (github_com_cosmos_cosmos_sdk_types.Int, bool) {
// 				panic("mock out the GetChainIDByNetwork method")
// 			},
// 			GetCommandFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, id evmtypes.CommandID) (evmtypes.Command, bool) {
// 				panic("mock out the GetCommand method")
// 			},
// 			GetConfirmedDepositsFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context) []evmtypes.ERC20Deposit {
// 				panic("mock out the GetConfirmedDeposits method")
// 			},
// 			GetConfirmedEventQueueFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context) utils.KVQueue {
// 				panic("mock out the GetConfirmedEventQueue method")
// 			},
// 			GetDepositFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, txID evmtypes.Hash, burnerAddr evmtypes.Address) (evmtypes.ERC20Deposit, evmtypes.DepositStatus, bool) {
// 				panic("mock out the GetDeposit method")
// 			},
// 			GetERC20TokenByAssetFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, asset string) evmtypes.ERC20Token {
// 				panic("mock out the GetERC20TokenByAsset method")
// 			},
// 			GetERC20TokenBySymbolFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, symbol string) evmtypes.ERC20Token {
// 				panic("mock out the GetERC20TokenBySymbol method")
// 			},
// 			GetEventFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, eventID evmtypes.EventID) (evmtypes.Event, bool) {
// 				panic("mock out the GetEvent method")
// 			},
// 			GetGatewayAddressFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context) (evmtypes.Address, bool) {
// 				panic("mock out the GetGatewayAddress method")
// 			},
// 			GetLatestCommandBatchFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context) evmtypes.CommandBatch {
// 				panic("mock out the GetLatestCommandBatch method")
// 			},
// 			GetMinVoterCountFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context) (int64, bool) {
// 				panic("mock out the GetMinVoterCount method")
// 			},
// 			GetNameFunc: func() string {
// 				panic("mock out the GetName method")
// 			},
// 			GetNetworkFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context) (string, bool) {
// 				panic("mock out the GetNetwork method")
// 			},
// 			GetNetworkByIDFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, id github_com_cosmos_cosmos_sdk_types.Int) (string, bool) {
// 				panic("mock out the GetNetworkByID method")
// 			},
// 			GetParamsFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context) evmtypes.Params {
// 				panic("mock out the GetParams method")
// 			},
// 			GetPendingCommandsFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context) []evmtypes.Command {
// 				panic("mock out the GetPendingCommands method")
// 			},
// 			GetRequiredConfirmationHeightFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context) (uint64, bool) {
// 				panic("mock out the GetRequiredConfirmationHeight method")
// 			},
// 			GetRevoteLockingPeriodFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context) (int64, bool) {
// 				panic("mock out the GetRevoteLockingPeriod method")
// 			},
// 			GetTokenByteCodeFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context) ([]byte, bool) {
// 				panic("mock out the GetTokenByteCode method")
// 			},
// 			GetTokensFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context) []evmtypes.ERC20Token {
// 				panic("mock out the GetTokens method")
// 			},
// 			GetVotingThresholdFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context) (utils.Threshold, bool) {
// 				panic("mock out the GetVotingThreshold method")
// 			},
// 			LoggerFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context) log.Logger {
// 				panic("mock out the Logger method")
// 			},
// 			SetBurnerInfoFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, burnerInfo evmtypes.BurnerInfo)  {
// 				panic("mock out the SetBurnerInfo method")
// 			},
// 			SetConfirmedEventFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, event evmtypes.Event) error {
// 				panic("mock out the SetConfirmedEvent method")
// 			},
// 			SetDepositFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, deposit evmtypes.ERC20Deposit, state evmtypes.DepositStatus)  {
// 				panic("mock out the SetDeposit method")
// 			},
// 			SetEventCompletedFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, eventID evmtypes.EventID) error {
// 				panic("mock out the SetEventCompleted method")
// 			},
// 			SetEventFailedFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, eventID evmtypes.EventID) error {
// 				panic("mock out the SetEventFailed method")
// 			},
// 			SetGatewayFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, address evmtypes.Address)  {
// 				panic("mock out the SetGateway method")
// 			},
// 			SetLatestSignedCommandBatchIDFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, id []byte)  {
// 				panic("mock out the SetLatestSignedCommandBatchID method")
// 			},
// 			SetParamsFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, p evmtypes.Params)  {
// 				panic("mock out the SetParams method")
// 			},
// 		}
//
// 		// use mockedChainKeeper in code that requires evmtypes.ChainKeeper
// 		// and then make assertions.
//
// 	}
type ChainKeeperMock struct {
	// CreateERC20TokenFunc mocks the CreateERC20Token method.
	CreateERC20TokenFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, asset string, details evmtypes.TokenDetails, address evmtypes.Address) (evmtypes.ERC20Token, error)

	// CreateNewBatchToSignFunc mocks the CreateNewBatchToSign method.
	CreateNewBatchToSignFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context) (evmtypes.CommandBatch, error)

	// DeleteDepositFunc mocks the DeleteDeposit method.
	DeleteDepositFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, deposit evmtypes.ERC20Deposit)

	// DeleteUnsignedCommandBatchIDFunc mocks the DeleteUnsignedCommandBatchID method.
	DeleteUnsignedCommandBatchIDFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context)

	// EnqueueCommandFunc mocks the EnqueueCommand method.
	EnqueueCommandFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, cmd evmtypes.Command) error

	// GetBatchByIDFunc mocks the GetBatchByID method.
	GetBatchByIDFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, id []byte) evmtypes.CommandBatch

	// GetBurnerAddressAndSaltFunc mocks the GetBurnerAddressAndSalt method.
	GetBurnerAddressAndSaltFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, token evmtypes.ERC20Token, recipient string, gatewayAddr evmtypes.Address) (evmtypes.Address, evmtypes.Hash, error)

	// GetBurnerByteCodeFunc mocks the GetBurnerByteCode method.
	GetBurnerByteCodeFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context) ([]byte, bool)

	// GetBurnerInfoFunc mocks the GetBurnerInfo method.
	GetBurnerInfoFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, address evmtypes.Address) *evmtypes.BurnerInfo

	// GetChainIDFunc mocks the GetChainID method.
	GetChainIDFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context) (github_com_cosmos_cosmos_sdk_types.Int, bool)

	// GetChainIDByNetworkFunc mocks the GetChainIDByNetwork method.
	GetChainIDByNetworkFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, network string) (github_com_cosmos_cosmos_sdk_types.Int, bool)

	// GetCommandFunc mocks the GetCommand method.
	GetCommandFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, id evmtypes.CommandID) (evmtypes.Command, bool)

	// GetConfirmedDepositsFunc mocks the GetConfirmedDeposits method.
	GetConfirmedDepositsFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context) []evmtypes.ERC20Deposit

	// GetConfirmedEventQueueFunc mocks the GetConfirmedEventQueue method.
	GetConfirmedEventQueueFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context) utils.KVQueue

	// GetDepositFunc mocks the GetDeposit method.
	GetDepositFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, txID evmtypes.Hash, burnerAddr evmtypes.Address) (evmtypes.ERC20Deposit, evmtypes.DepositStatus, bool)

	// GetERC20TokenByAssetFunc mocks the GetERC20TokenByAsset method.
	GetERC20TokenByAssetFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, asset string) evmtypes.ERC20Token

	// GetERC20TokenBySymbolFunc mocks the GetERC20TokenBySymbol method.
	GetERC20TokenBySymbolFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, symbol string) evmtypes.ERC20Token

	// GetEventFunc mocks the GetEvent method.
	GetEventFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, eventID evmtypes.EventID) (evmtypes.Event, bool)

	// GetGatewayAddressFunc mocks the GetGatewayAddress method.
	GetGatewayAddressFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context) (evmtypes.Address, bool)

	// GetLatestCommandBatchFunc mocks the GetLatestCommandBatch method.
	GetLatestCommandBatchFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context) evmtypes.CommandBatch

	// GetMinVoterCountFunc mocks the GetMinVoterCount method.
	GetMinVoterCountFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context) (int64, bool)

	// GetNameFunc mocks the GetName method.
	GetNameFunc func() string

	// GetNetworkFunc mocks the GetNetwork method.
	GetNetworkFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context) (string, bool)

	// GetNetworkByIDFunc mocks the GetNetworkByID method.
	GetNetworkByIDFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, id github_com_cosmos_cosmos_sdk_types.Int) (string, bool)

	// GetParamsFunc mocks the GetParams method.
	GetParamsFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context) evmtypes.Params

	// GetPendingCommandsFunc mocks the GetPendingCommands method.
	GetPendingCommandsFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context) []evmtypes.Command

	// GetRequiredConfirmationHeightFunc mocks the GetRequiredConfirmationHeight method.
	GetRequiredConfirmationHeightFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context) (uint64, bool)

	// GetRevoteLockingPeriodFunc mocks the GetRevoteLockingPeriod method.
	GetRevoteLockingPeriodFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context) (int64, bool)

	// GetTokenByteCodeFunc mocks the GetTokenByteCode method.
	GetTokenByteCodeFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context) ([]byte, bool)

	// GetTokensFunc mocks the GetTokens method.
	GetTokensFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context) []evmtypes.ERC20Token

	// GetVotingThresholdFunc mocks the GetVotingThreshold method.
	GetVotingThresholdFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context) (utils.Threshold, bool)

	// LoggerFunc mocks the Logger method.
	LoggerFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context) log.Logger

	// SetBurnerInfoFunc mocks the SetBurnerInfo method.
	SetBurnerInfoFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, burnerInfo evmtypes.BurnerInfo)

	// SetConfirmedEventFunc mocks the SetConfirmedEvent method.
	SetConfirmedEventFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, event evmtypes.Event) error

	// SetDepositFunc mocks the SetDeposit method.
	SetDepositFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, deposit evmtypes.ERC20Deposit, state evmtypes.DepositStatus)

	// SetEventCompletedFunc mocks the SetEventCompleted method.
	SetEventCompletedFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, eventID evmtypes.EventID) error

	// SetEventFailedFunc mocks the SetEventFailed method.
	SetEventFailedFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, eventID evmtypes.EventID) error

	// SetGatewayFunc mocks the SetGateway method.
	SetGatewayFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, address evmtypes.Address)

	// SetLatestSignedCommandBatchIDFunc mocks the SetLatestSignedCommandBatchID method.
	SetLatestSignedCommandBatchIDFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, id []byte)

	// SetParamsFunc mocks the SetParams method.
	SetParamsFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, p evmtypes.Params)

	// calls tracks calls to the methods.
	calls struct {
		// CreateERC20Token holds details about calls to the CreateERC20Token method.
		CreateERC20Token []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Asset is the asset argument value.
			Asset string
			// Details is the details argument value.
			Details evmtypes.TokenDetails
			// Address is the address argument value.
			Address evmtypes.Address
		}
		// CreateNewBatchToSign holds details about calls to the CreateNewBatchToSign method.
		CreateNewBatchToSign []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
		}
		// DeleteDeposit holds details about calls to the DeleteDeposit method.
		DeleteDeposit []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Deposit is the deposit argument value.
			Deposit evmtypes.ERC20Deposit
		}
		// DeleteUnsignedCommandBatchID holds details about calls to the DeleteUnsignedCommandBatchID method.
		DeleteUnsignedCommandBatchID []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
		}
		// EnqueueCommand holds details about calls to the EnqueueCommand method.
		EnqueueCommand []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Cmd is the cmd argument value.
			Cmd evmtypes.Command
		}
		// GetBatchByID holds details about calls to the GetBatchByID method.
		GetBatchByID []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// ID is the id argument value.
			ID []byte
		}
		// GetBurnerAddressAndSalt holds details about calls to the GetBurnerAddressAndSalt method.
		GetBurnerAddressAndSalt []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Token is the token argument value.
			Token evmtypes.ERC20Token
			// Recipient is the recipient argument value.
			Recipient string
			// GatewayAddr is the gatewayAddr argument value.
			GatewayAddr evmtypes.Address
		}
		// GetBurnerByteCode holds details about calls to the GetBurnerByteCode method.
		GetBurnerByteCode []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
		}
		// GetBurnerInfo holds details about calls to the GetBurnerInfo method.
		GetBurnerInfo []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Address is the address argument value.
			Address evmtypes.Address
		}
		// GetChainID holds details about calls to the GetChainID method.
		GetChainID []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
		}
		// GetChainIDByNetwork holds details about calls to the GetChainIDByNetwork method.
		GetChainIDByNetwork []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Network is the network argument value.
			Network string
		}
		// GetCommand holds details about calls to the GetCommand method.
		GetCommand []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// ID is the id argument value.
			ID evmtypes.CommandID
		}
		// GetConfirmedDeposits holds details about calls to the GetConfirmedDeposits method.
		GetConfirmedDeposits []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
		}
		// GetConfirmedEventQueue holds details about calls to the GetConfirmedEventQueue method.
		GetConfirmedEventQueue []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
		}
		// GetDeposit holds details about calls to the GetDeposit method.
		GetDeposit []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// TxID is the txID argument value.
			TxID evmtypes.Hash
			// BurnerAddr is the burnerAddr argument value.
			BurnerAddr evmtypes.Address
		}
		// GetERC20TokenByAsset holds details about calls to the GetERC20TokenByAsset method.
		GetERC20TokenByAsset []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Asset is the asset argument value.
			Asset string
		}
		// GetERC20TokenBySymbol holds details about calls to the GetERC20TokenBySymbol method.
		GetERC20TokenBySymbol []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Symbol is the symbol argument value.
			Symbol string
		}
		// GetEvent holds details about calls to the GetEvent method.
		GetEvent []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// EventID is the eventID argument value.
			EventID evmtypes.EventID
		}
		// GetGatewayAddress holds details about calls to the GetGatewayAddress method.
		GetGatewayAddress []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
		}
		// GetLatestCommandBatch holds details about calls to the GetLatestCommandBatch method.
		GetLatestCommandBatch []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
		}
		// GetMinVoterCount holds details about calls to the GetMinVoterCount method.
		GetMinVoterCount []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
		}
		// GetName holds details about calls to the GetName method.
		GetName []struct {
		}
		// GetNetwork holds details about calls to the GetNetwork method.
		GetNetwork []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
		}
		// GetNetworkByID holds details about calls to the GetNetworkByID method.
		GetNetworkByID []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// ID is the id argument value.
			ID github_com_cosmos_cosmos_sdk_types.Int
		}
		// GetParams holds details about calls to the GetParams method.
		GetParams []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
		}
		// GetPendingCommands holds details about calls to the GetPendingCommands method.
		GetPendingCommands []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
		}
		// GetRequiredConfirmationHeight holds details about calls to the GetRequiredConfirmationHeight method.
		GetRequiredConfirmationHeight []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
		}
		// GetRevoteLockingPeriod holds details about calls to the GetRevoteLockingPeriod method.
		GetRevoteLockingPeriod []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
		}
		// GetTokenByteCode holds details about calls to the GetTokenByteCode method.
		GetTokenByteCode []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
		}
		// GetTokens holds details about calls to the GetTokens method.
		GetTokens []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
		}
		// GetVotingThreshold holds details about calls to the GetVotingThreshold method.
		GetVotingThreshold []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
		}
		// Logger holds details about calls to the Logger method.
		Logger []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
		}
		// SetBurnerInfo holds details about calls to the SetBurnerInfo method.
		SetBurnerInfo []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// BurnerInfo is the burnerInfo argument value.
			BurnerInfo evmtypes.BurnerInfo
		}
		// SetConfirmedEvent holds details about calls to the SetConfirmedEvent method.
		SetConfirmedEvent []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Event is the event argument value.
			Event evmtypes.Event
		}
		// SetDeposit holds details about calls to the SetDeposit method.
		SetDeposit []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Deposit is the deposit argument value.
			Deposit evmtypes.ERC20Deposit
			// State is the state argument value.
			State evmtypes.DepositStatus
		}
		// SetEventCompleted holds details about calls to the SetEventCompleted method.
		SetEventCompleted []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// EventID is the eventID argument value.
			EventID evmtypes.EventID
		}
		// SetEventFailed holds details about calls to the SetEventFailed method.
		SetEventFailed []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// EventID is the eventID argument value.
			EventID evmtypes.EventID
		}
		// SetGateway holds details about calls to the SetGateway method.
		SetGateway []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Address is the address argument value.
			Address evmtypes.Address
		}
		// SetLatestSignedCommandBatchID holds details about calls to the SetLatestSignedCommandBatchID method.
		SetLatestSignedCommandBatchID []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// ID is the id argument value.
			ID []byte
		}
		// SetParams holds details about calls to the SetParams method.
		SetParams []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// P is the p argument value.
			P evmtypes.Params
		}
	}
	lockCreateERC20Token              sync.RWMutex
	lockCreateNewBatchToSign          sync.RWMutex
	lockDeleteDeposit                 sync.RWMutex
	lockDeleteUnsignedCommandBatchID  sync.RWMutex
	lockEnqueueCommand                sync.RWMutex
	lockGetBatchByID                  sync.RWMutex
	lockGetBurnerAddressAndSalt       sync.RWMutex
	lockGetBurnerByteCode             sync.RWMutex
	lockGetBurnerInfo                 sync.RWMutex
	lockGetChainID                    sync.RWMutex
	lockGetChainIDByNetwork           sync.RWMutex
	lockGetCommand                    sync.RWMutex
	lockGetConfirmedDeposits          sync.RWMutex
	lockGetConfirmedEventQueue        sync.RWMutex
	lockGetDeposit                    sync.RWMutex
	lockGetERC20TokenByAsset          sync.RWMutex
	lockGetERC20TokenBySymbol         sync.RWMutex
	lockGetEvent                      sync.RWMutex
	lockGetGatewayAddress             sync.RWMutex
	lockGetLatestCommandBatch         sync.RWMutex
	lockGetMinVoterCount              sync.RWMutex
	lockGetName                       sync.RWMutex
	lockGetNetwork                    sync.RWMutex
	lockGetNetworkByID                sync.RWMutex
	lockGetParams                     sync.RWMutex
	lockGetPendingCommands            sync.RWMutex
	lockGetRequiredConfirmationHeight sync.RWMutex
	lockGetRevoteLockingPeriod        sync.RWMutex
	lockGetTokenByteCode              sync.RWMutex
	lockGetTokens                     sync.RWMutex
	lockGetVotingThreshold            sync.RWMutex
	lockLogger                        sync.RWMutex
	lockSetBurnerInfo                 sync.RWMutex
	lockSetConfirmedEvent             sync.RWMutex
	lockSetDeposit                    sync.RWMutex
	lockSetEventCompleted             sync.RWMutex
	lockSetEventFailed                sync.RWMutex
	lockSetGateway                    sync.RWMutex
	lockSetLatestSignedCommandBatchID sync.RWMutex
	lockSetParams                     sync.RWMutex
}

// CreateERC20Token calls CreateERC20TokenFunc.
func (mock *ChainKeeperMock) CreateERC20Token(ctx github_com_cosmos_cosmos_sdk_types.Context, asset string, details evmtypes.TokenDetails, address evmtypes.Address) (evmtypes.ERC20Token, error) {
	if mock.CreateERC20TokenFunc == nil {
		panic("ChainKeeperMock.CreateERC20TokenFunc: method is nil but ChainKeeper.CreateERC20Token was just called")
	}
	callInfo := struct {
		Ctx     github_com_cosmos_cosmos_sdk_types.Context
		Asset   string
		Details evmtypes.TokenDetails
		Address evmtypes.Address
	}{
		Ctx:     ctx,
		Asset:   asset,
		Details: details,
		Address: address,
	}
	mock.lockCreateERC20Token.Lock()
	mock.calls.CreateERC20Token = append(mock.calls.CreateERC20Token, callInfo)
	mock.lockCreateERC20Token.Unlock()
	return mock.CreateERC20TokenFunc(ctx, asset, details, address)
}

// CreateERC20TokenCalls gets all the calls that were made to CreateERC20Token.
// Check the length with:
//     len(mockedChainKeeper.CreateERC20TokenCalls())
func (mock *ChainKeeperMock) CreateERC20TokenCalls() []struct {
	Ctx     github_com_cosmos_cosmos_sdk_types.Context
	Asset   string
	Details evmtypes.TokenDetails
	Address evmtypes.Address
} {
	var calls []struct {
		Ctx     github_com_cosmos_cosmos_sdk_types.Context
		Asset   string
		Details evmtypes.TokenDetails
		Address evmtypes.Address
	}
	mock.lockCreateERC20Token.RLock()
	calls = mock.calls.CreateERC20Token
	mock.lockCreateERC20Token.RUnlock()
	return calls
}

// CreateNewBatchToSign calls CreateNewBatchToSignFunc.
func (mock *ChainKeeperMock) CreateNewBatchToSign(ctx github_com_cosmos_cosmos_sdk_types.Context) (evmtypes.CommandBatch, error) {
	if mock.CreateNewBatchToSignFunc == nil {
		panic("ChainKeeperMock.CreateNewBatchToSignFunc: method is nil but ChainKeeper.CreateNewBatchToSign was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}{
		Ctx: ctx,
	}
	mock.lockCreateNewBatchToSign.Lock()
	mock.calls.CreateNewBatchToSign = append(mock.calls.CreateNewBatchToSign, callInfo)
	mock.lockCreateNewBatchToSign.Unlock()
	return mock.CreateNewBatchToSignFunc(ctx)
}

// CreateNewBatchToSignCalls gets all the calls that were made to CreateNewBatchToSign.
// Check the length with:
//     len(mockedChainKeeper.CreateNewBatchToSignCalls())
func (mock *ChainKeeperMock) CreateNewBatchToSignCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}
	mock.lockCreateNewBatchToSign.RLock()
	calls = mock.calls.CreateNewBatchToSign
	mock.lockCreateNewBatchToSign.RUnlock()
	return calls
}

// DeleteDeposit calls DeleteDepositFunc.
func (mock *ChainKeeperMock) DeleteDeposit(ctx github_com_cosmos_cosmos_sdk_types.Context, deposit evmtypes.ERC20Deposit) {
	if mock.DeleteDepositFunc == nil {
		panic("ChainKeeperMock.DeleteDepositFunc: method is nil but ChainKeeper.DeleteDeposit was just called")
	}
	callInfo := struct {
		Ctx     github_com_cosmos_cosmos_sdk_types.Context
		Deposit evmtypes.ERC20Deposit
	}{
		Ctx:     ctx,
		Deposit: deposit,
	}
	mock.lockDeleteDeposit.Lock()
	mock.calls.DeleteDeposit = append(mock.calls.DeleteDeposit, callInfo)
	mock.lockDeleteDeposit.Unlock()
	mock.DeleteDepositFunc(ctx, deposit)
}

// DeleteDepositCalls gets all the calls that were made to DeleteDeposit.
// Check the length with:
//     len(mockedChainKeeper.DeleteDepositCalls())
func (mock *ChainKeeperMock) DeleteDepositCalls() []struct {
	Ctx     github_com_cosmos_cosmos_sdk_types.Context
	Deposit evmtypes.ERC20Deposit
} {
	var calls []struct {
		Ctx     github_com_cosmos_cosmos_sdk_types.Context
		Deposit evmtypes.ERC20Deposit
	}
	mock.lockDeleteDeposit.RLock()
	calls = mock.calls.DeleteDeposit
	mock.lockDeleteDeposit.RUnlock()
	return calls
}

// DeleteUnsignedCommandBatchID calls DeleteUnsignedCommandBatchIDFunc.
func (mock *ChainKeeperMock) DeleteUnsignedCommandBatchID(ctx github_com_cosmos_cosmos_sdk_types.Context) {
	if mock.DeleteUnsignedCommandBatchIDFunc == nil {
		panic("ChainKeeperMock.DeleteUnsignedCommandBatchIDFunc: method is nil but ChainKeeper.DeleteUnsignedCommandBatchID was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}{
		Ctx: ctx,
	}
	mock.lockDeleteUnsignedCommandBatchID.Lock()
	mock.calls.DeleteUnsignedCommandBatchID = append(mock.calls.DeleteUnsignedCommandBatchID, callInfo)
	mock.lockDeleteUnsignedCommandBatchID.Unlock()
	mock.DeleteUnsignedCommandBatchIDFunc(ctx)
}

// DeleteUnsignedCommandBatchIDCalls gets all the calls that were made to DeleteUnsignedCommandBatchID.
// Check the length with:
//     len(mockedChainKeeper.DeleteUnsignedCommandBatchIDCalls())
func (mock *ChainKeeperMock) DeleteUnsignedCommandBatchIDCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}
	mock.lockDeleteUnsignedCommandBatchID.RLock()
	calls = mock.calls.DeleteUnsignedCommandBatchID
	mock.lockDeleteUnsignedCommandBatchID.RUnlock()
	return calls
}

// EnqueueCommand calls EnqueueCommandFunc.
func (mock *ChainKeeperMock) EnqueueCommand(ctx github_com_cosmos_cosmos_sdk_types.Context, cmd evmtypes.Command) error {
	if mock.EnqueueCommandFunc == nil {
		panic("ChainKeeperMock.EnqueueCommandFunc: method is nil but ChainKeeper.EnqueueCommand was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
		Cmd evmtypes.Command
	}{
		Ctx: ctx,
		Cmd: cmd,
	}
	mock.lockEnqueueCommand.Lock()
	mock.calls.EnqueueCommand = append(mock.calls.EnqueueCommand, callInfo)
	mock.lockEnqueueCommand.Unlock()
	return mock.EnqueueCommandFunc(ctx, cmd)
}

// EnqueueCommandCalls gets all the calls that were made to EnqueueCommand.
// Check the length with:
//     len(mockedChainKeeper.EnqueueCommandCalls())
func (mock *ChainKeeperMock) EnqueueCommandCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
	Cmd evmtypes.Command
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
		Cmd evmtypes.Command
	}
	mock.lockEnqueueCommand.RLock()
	calls = mock.calls.EnqueueCommand
	mock.lockEnqueueCommand.RUnlock()
	return calls
}

// GetBatchByID calls GetBatchByIDFunc.
func (mock *ChainKeeperMock) GetBatchByID(ctx github_com_cosmos_cosmos_sdk_types.Context, id []byte) evmtypes.CommandBatch {
	if mock.GetBatchByIDFunc == nil {
		panic("ChainKeeperMock.GetBatchByIDFunc: method is nil but ChainKeeper.GetBatchByID was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
		ID  []byte
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetBatchByID.Lock()
	mock.calls.GetBatchByID = append(mock.calls.GetBatchByID, callInfo)
	mock.lockGetBatchByID.Unlock()
	return mock.GetBatchByIDFunc(ctx, id)
}

// GetBatchByIDCalls gets all the calls that were made to GetBatchByID.
// Check the length with:
//     len(mockedChainKeeper.GetBatchByIDCalls())
func (mock *ChainKeeperMock) GetBatchByIDCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
	ID  []byte
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
		ID  []byte
	}
	mock.lockGetBatchByID.RLock()
	calls = mock.calls.GetBatchByID
	mock.lockGetBatchByID.RUnlock()
	return calls
}

// GetBurnerAddressAndSalt calls GetBurnerAddressAndSaltFunc.
func (mock *ChainKeeperMock) GetBurnerAddressAndSalt(ctx github_com_cosmos_cosmos_sdk_types.Context, token evmtypes.ERC20Token, recipient string, gatewayAddr evmtypes.Address) (evmtypes.Address, evmtypes.Hash, error) {
	if mock.GetBurnerAddressAndSaltFunc == nil {
		panic("ChainKeeperMock.GetBurnerAddressAndSaltFunc: method is nil but ChainKeeper.GetBurnerAddressAndSalt was just called")
	}
	callInfo := struct {
		Ctx         github_com_cosmos_cosmos_sdk_types.Context
		Token       evmtypes.ERC20Token
		Recipient   string
		GatewayAddr evmtypes.Address
	}{
		Ctx:         ctx,
		Token:       token,
		Recipient:   recipient,
		GatewayAddr: gatewayAddr,
	}
	mock.lockGetBurnerAddressAndSalt.Lock()
	mock.calls.GetBurnerAddressAndSalt = append(mock.calls.GetBurnerAddressAndSalt, callInfo)
	mock.lockGetBurnerAddressAndSalt.Unlock()
	return mock.GetBurnerAddressAndSaltFunc(ctx, token, recipient, gatewayAddr)
}

// GetBurnerAddressAndSaltCalls gets all the calls that were made to GetBurnerAddressAndSalt.
// Check the length with:
//     len(mockedChainKeeper.GetBurnerAddressAndSaltCalls())
func (mock *ChainKeeperMock) GetBurnerAddressAndSaltCalls() []struct {
	Ctx         github_com_cosmos_cosmos_sdk_types.Context
	Token       evmtypes.ERC20Token
	Recipient   string
	GatewayAddr evmtypes.Address
} {
	var calls []struct {
		Ctx         github_com_cosmos_cosmos_sdk_types.Context
		Token       evmtypes.ERC20Token
		Recipient   string
		GatewayAddr evmtypes.Address
	}
	mock.lockGetBurnerAddressAndSalt.RLock()
	calls = mock.calls.GetBurnerAddressAndSalt
	mock.lockGetBurnerAddressAndSalt.RUnlock()
	return calls
}

// GetBurnerByteCode calls GetBurnerByteCodeFunc.
func (mock *ChainKeeperMock) GetBurnerByteCode(ctx github_com_cosmos_cosmos_sdk_types.Context) ([]byte, bool) {
	if mock.GetBurnerByteCodeFunc == nil {
		panic("ChainKeeperMock.GetBurnerByteCodeFunc: method is nil but ChainKeeper.GetBurnerByteCode was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetBurnerByteCode.Lock()
	mock.calls.GetBurnerByteCode = append(mock.calls.GetBurnerByteCode, callInfo)
	mock.lockGetBurnerByteCode.Unlock()
	return mock.GetBurnerByteCodeFunc(ctx)
}

// GetBurnerByteCodeCalls gets all the calls that were made to GetBurnerByteCode.
// Check the length with:
//     len(mockedChainKeeper.GetBurnerByteCodeCalls())
func (mock *ChainKeeperMock) GetBurnerByteCodeCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}
	mock.lockGetBurnerByteCode.RLock()
	calls = mock.calls.GetBurnerByteCode
	mock.lockGetBurnerByteCode.RUnlock()
	return calls
}

// GetBurnerInfo calls GetBurnerInfoFunc.
func (mock *ChainKeeperMock) GetBurnerInfo(ctx github_com_cosmos_cosmos_sdk_types.Context, address evmtypes.Address) *evmtypes.BurnerInfo {
	if mock.GetBurnerInfoFunc == nil {
		panic("ChainKeeperMock.GetBurnerInfoFunc: method is nil but ChainKeeper.GetBurnerInfo was just called")
	}
	callInfo := struct {
		Ctx     github_com_cosmos_cosmos_sdk_types.Context
		Address evmtypes.Address
	}{
		Ctx:     ctx,
		Address: address,
	}
	mock.lockGetBurnerInfo.Lock()
	mock.calls.GetBurnerInfo = append(mock.calls.GetBurnerInfo, callInfo)
	mock.lockGetBurnerInfo.Unlock()
	return mock.GetBurnerInfoFunc(ctx, address)
}

// GetBurnerInfoCalls gets all the calls that were made to GetBurnerInfo.
// Check the length with:
//     len(mockedChainKeeper.GetBurnerInfoCalls())
func (mock *ChainKeeperMock) GetBurnerInfoCalls() []struct {
	Ctx     github_com_cosmos_cosmos_sdk_types.Context
	Address evmtypes.Address
} {
	var calls []struct {
		Ctx     github_com_cosmos_cosmos_sdk_types.Context
		Address evmtypes.Address
	}
	mock.lockGetBurnerInfo.RLock()
	calls = mock.calls.GetBurnerInfo
	mock.lockGetBurnerInfo.RUnlock()
	return calls
}

// GetChainID calls GetChainIDFunc.
func (mock *ChainKeeperMock) GetChainID(ctx github_com_cosmos_cosmos_sdk_types.Context) (github_com_cosmos_cosmos_sdk_types.Int, bool) {
	if mock.GetChainIDFunc == nil {
		panic("ChainKeeperMock.GetChainIDFunc: method is nil but ChainKeeper.GetChainID was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetChainID.Lock()
	mock.calls.GetChainID = append(mock.calls.GetChainID, callInfo)
	mock.lockGetChainID.Unlock()
	return mock.GetChainIDFunc(ctx)
}

// GetChainIDCalls gets all the calls that were made to GetChainID.
// Check the length with:
//     len(mockedChainKeeper.GetChainIDCalls())
func (mock *ChainKeeperMock) GetChainIDCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}
	mock.lockGetChainID.RLock()
	calls = mock.calls.GetChainID
	mock.lockGetChainID.RUnlock()
	return calls
}

// GetChainIDByNetwork calls GetChainIDByNetworkFunc.
func (mock *ChainKeeperMock) GetChainIDByNetwork(ctx github_com_cosmos_cosmos_sdk_types.Context, network string) (github_com_cosmos_cosmos_sdk_types.Int, bool) {
	if mock.GetChainIDByNetworkFunc == nil {
		panic("ChainKeeperMock.GetChainIDByNetworkFunc: method is nil but ChainKeeper.GetChainIDByNetwork was just called")
	}
	callInfo := struct {
		Ctx     github_com_cosmos_cosmos_sdk_types.Context
		Network string
	}{
		Ctx:     ctx,
		Network: network,
	}
	mock.lockGetChainIDByNetwork.Lock()
	mock.calls.GetChainIDByNetwork = append(mock.calls.GetChainIDByNetwork, callInfo)
	mock.lockGetChainIDByNetwork.Unlock()
	return mock.GetChainIDByNetworkFunc(ctx, network)
}

// GetChainIDByNetworkCalls gets all the calls that were made to GetChainIDByNetwork.
// Check the length with:
//     len(mockedChainKeeper.GetChainIDByNetworkCalls())
func (mock *ChainKeeperMock) GetChainIDByNetworkCalls() []struct {
	Ctx     github_com_cosmos_cosmos_sdk_types.Context
	Network string
} {
	var calls []struct {
		Ctx     github_com_cosmos_cosmos_sdk_types.Context
		Network string
	}
	mock.lockGetChainIDByNetwork.RLock()
	calls = mock.calls.GetChainIDByNetwork
	mock.lockGetChainIDByNetwork.RUnlock()
	return calls
}

// GetCommand calls GetCommandFunc.
func (mock *ChainKeeperMock) GetCommand(ctx github_com_cosmos_cosmos_sdk_types.Context, id evmtypes.CommandID) (evmtypes.Command, bool) {
	if mock.GetCommandFunc == nil {
		panic("ChainKeeperMock.GetCommandFunc: method is nil but ChainKeeper.GetCommand was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
		ID  evmtypes.CommandID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetCommand.Lock()
	mock.calls.GetCommand = append(mock.calls.GetCommand, callInfo)
	mock.lockGetCommand.Unlock()
	return mock.GetCommandFunc(ctx, id)
}

// GetCommandCalls gets all the calls that were made to GetCommand.
// Check the length with:
//     len(mockedChainKeeper.GetCommandCalls())
func (mock *ChainKeeperMock) GetCommandCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
	ID  evmtypes.CommandID
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
		ID  evmtypes.CommandID
	}
	mock.lockGetCommand.RLock()
	calls = mock.calls.GetCommand
	mock.lockGetCommand.RUnlock()
	return calls
}

// GetConfirmedDeposits calls GetConfirmedDepositsFunc.
func (mock *ChainKeeperMock) GetConfirmedDeposits(ctx github_com_cosmos_cosmos_sdk_types.Context) []evmtypes.ERC20Deposit {
	if mock.GetConfirmedDepositsFunc == nil {
		panic("ChainKeeperMock.GetConfirmedDepositsFunc: method is nil but ChainKeeper.GetConfirmedDeposits was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetConfirmedDeposits.Lock()
	mock.calls.GetConfirmedDeposits = append(mock.calls.GetConfirmedDeposits, callInfo)
	mock.lockGetConfirmedDeposits.Unlock()
	return mock.GetConfirmedDepositsFunc(ctx)
}

// GetConfirmedDepositsCalls gets all the calls that were made to GetConfirmedDeposits.
// Check the length with:
//     len(mockedChainKeeper.GetConfirmedDepositsCalls())
func (mock *ChainKeeperMock) GetConfirmedDepositsCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}
	mock.lockGetConfirmedDeposits.RLock()
	calls = mock.calls.GetConfirmedDeposits
	mock.lockGetConfirmedDeposits.RUnlock()
	return calls
}

// GetConfirmedEventQueue calls GetConfirmedEventQueueFunc.
func (mock *ChainKeeperMock) GetConfirmedEventQueue(ctx github_com_cosmos_cosmos_sdk_types.Context) utils.KVQueue {
	if mock.GetConfirmedEventQueueFunc == nil {
		panic("ChainKeeperMock.GetConfirmedEventQueueFunc: method is nil but ChainKeeper.GetConfirmedEventQueue was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetConfirmedEventQueue.Lock()
	mock.calls.GetConfirmedEventQueue = append(mock.calls.GetConfirmedEventQueue, callInfo)
	mock.lockGetConfirmedEventQueue.Unlock()
	return mock.GetConfirmedEventQueueFunc(ctx)
}

// GetConfirmedEventQueueCalls gets all the calls that were made to GetConfirmedEventQueue.
// Check the length with:
//     len(mockedChainKeeper.GetConfirmedEventQueueCalls())
func (mock *ChainKeeperMock) GetConfirmedEventQueueCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}
	mock.lockGetConfirmedEventQueue.RLock()
	calls = mock.calls.GetConfirmedEventQueue
	mock.lockGetConfirmedEventQueue.RUnlock()
	return calls
}

// GetDeposit calls GetDepositFunc.
func (mock *ChainKeeperMock) GetDeposit(ctx github_com_cosmos_cosmos_sdk_types.Context, txID evmtypes.Hash, burnerAddr evmtypes.Address) (evmtypes.ERC20Deposit, evmtypes.DepositStatus, bool) {
	if mock.GetDepositFunc == nil {
		panic("ChainKeeperMock.GetDepositFunc: method is nil but ChainKeeper.GetDeposit was just called")
	}
	callInfo := struct {
		Ctx        github_com_cosmos_cosmos_sdk_types.Context
		TxID       evmtypes.Hash
		BurnerAddr evmtypes.Address
	}{
		Ctx:        ctx,
		TxID:       txID,
		BurnerAddr: burnerAddr,
	}
	mock.lockGetDeposit.Lock()
	mock.calls.GetDeposit = append(mock.calls.GetDeposit, callInfo)
	mock.lockGetDeposit.Unlock()
	return mock.GetDepositFunc(ctx, txID, burnerAddr)
}

// GetDepositCalls gets all the calls that were made to GetDeposit.
// Check the length with:
//     len(mockedChainKeeper.GetDepositCalls())
func (mock *ChainKeeperMock) GetDepositCalls() []struct {
	Ctx        github_com_cosmos_cosmos_sdk_types.Context
	TxID       evmtypes.Hash
	BurnerAddr evmtypes.Address
} {
	var calls []struct {
		Ctx        github_com_cosmos_cosmos_sdk_types.Context
		TxID       evmtypes.Hash
		BurnerAddr evmtypes.Address
	}
	mock.lockGetDeposit.RLock()
	calls = mock.calls.GetDeposit
	mock.lockGetDeposit.RUnlock()
	return calls
}

// GetERC20TokenByAsset calls GetERC20TokenByAssetFunc.
func (mock *ChainKeeperMock) GetERC20TokenByAsset(ctx github_com_cosmos_cosmos_sdk_types.Context, asset string) evmtypes.ERC20Token {
	if mock.GetERC20TokenByAssetFunc == nil {
		panic("ChainKeeperMock.GetERC20TokenByAssetFunc: method is nil but ChainKeeper.GetERC20TokenByAsset was just called")
	}
	callInfo := struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Asset string
	}{
		Ctx:   ctx,
		Asset: asset,
	}
	mock.lockGetERC20TokenByAsset.Lock()
	mock.calls.GetERC20TokenByAsset = append(mock.calls.GetERC20TokenByAsset, callInfo)
	mock.lockGetERC20TokenByAsset.Unlock()
	return mock.GetERC20TokenByAssetFunc(ctx, asset)
}

// GetERC20TokenByAssetCalls gets all the calls that were made to GetERC20TokenByAsset.
// Check the length with:
//     len(mockedChainKeeper.GetERC20TokenByAssetCalls())
func (mock *ChainKeeperMock) GetERC20TokenByAssetCalls() []struct {
	Ctx   github_com_cosmos_cosmos_sdk_types.Context
	Asset string
} {
	var calls []struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Asset string
	}
	mock.lockGetERC20TokenByAsset.RLock()
	calls = mock.calls.GetERC20TokenByAsset
	mock.lockGetERC20TokenByAsset.RUnlock()
	return calls
}

// GetERC20TokenBySymbol calls GetERC20TokenBySymbolFunc.
func (mock *ChainKeeperMock) GetERC20TokenBySymbol(ctx github_com_cosmos_cosmos_sdk_types.Context, symbol string) evmtypes.ERC20Token {
	if mock.GetERC20TokenBySymbolFunc == nil {
		panic("ChainKeeperMock.GetERC20TokenBySymbolFunc: method is nil but ChainKeeper.GetERC20TokenBySymbol was just called")
	}
	callInfo := struct {
		Ctx    github_com_cosmos_cosmos_sdk_types.Context
		Symbol string
	}{
		Ctx:    ctx,
		Symbol: symbol,
	}
	mock.lockGetERC20TokenBySymbol.Lock()
	mock.calls.GetERC20TokenBySymbol = append(mock.calls.GetERC20TokenBySymbol, callInfo)
	mock.lockGetERC20TokenBySymbol.Unlock()
	return mock.GetERC20TokenBySymbolFunc(ctx, symbol)
}

// GetERC20TokenBySymbolCalls gets all the calls that were made to GetERC20TokenBySymbol.
// Check the length with:
//     len(mockedChainKeeper.GetERC20TokenBySymbolCalls())
func (mock *ChainKeeperMock) GetERC20TokenBySymbolCalls() []struct {
	Ctx    github_com_cosmos_cosmos_sdk_types.Context
	Symbol string
} {
	var calls []struct {
		Ctx    github_com_cosmos_cosmos_sdk_types.Context
		Symbol string
	}
	mock.lockGetERC20TokenBySymbol.RLock()
	calls = mock.calls.GetERC20TokenBySymbol
	mock.lockGetERC20TokenBySymbol.RUnlock()
	return calls
}

// GetEvent calls GetEventFunc.
func (mock *ChainKeeperMock) GetEvent(ctx github_com_cosmos_cosmos_sdk_types.Context, eventID evmtypes.EventID) (evmtypes.Event, bool) {
	if mock.GetEventFunc == nil {
		panic("ChainKeeperMock.GetEventFunc: method is nil but ChainKeeper.GetEvent was just called")
	}
	callInfo := struct {
		Ctx     github_com_cosmos_cosmos_sdk_types.Context
		EventID evmtypes.EventID
	}{
		Ctx:     ctx,
		EventID: eventID,
	}
	mock.lockGetEvent.Lock()
	mock.calls.GetEvent = append(mock.calls.GetEvent, callInfo)
	mock.lockGetEvent.Unlock()
	return mock.GetEventFunc(ctx, eventID)
}

// GetEventCalls gets all the calls that were made to GetEvent.
// Check the length with:
//     len(mockedChainKeeper.GetEventCalls())
func (mock *ChainKeeperMock) GetEventCalls() []struct {
	Ctx     github_com_cosmos_cosmos_sdk_types.Context
	EventID evmtypes.EventID
} {
	var calls []struct {
		Ctx     github_com_cosmos_cosmos_sdk_types.Context
		EventID evmtypes.EventID
	}
	mock.lockGetEvent.RLock()
	calls = mock.calls.GetEvent
	mock.lockGetEvent.RUnlock()
	return calls
}

// GetGatewayAddress calls GetGatewayAddressFunc.
func (mock *ChainKeeperMock) GetGatewayAddress(ctx github_com_cosmos_cosmos_sdk_types.Context) (evmtypes.Address, bool) {
	if mock.GetGatewayAddressFunc == nil {
		panic("ChainKeeperMock.GetGatewayAddressFunc: method is nil but ChainKeeper.GetGatewayAddress was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetGatewayAddress.Lock()
	mock.calls.GetGatewayAddress = append(mock.calls.GetGatewayAddress, callInfo)
	mock.lockGetGatewayAddress.Unlock()
	return mock.GetGatewayAddressFunc(ctx)
}

// GetGatewayAddressCalls gets all the calls that were made to GetGatewayAddress.
// Check the length with:
//     len(mockedChainKeeper.GetGatewayAddressCalls())
func (mock *ChainKeeperMock) GetGatewayAddressCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}
	mock.lockGetGatewayAddress.RLock()
	calls = mock.calls.GetGatewayAddress
	mock.lockGetGatewayAddress.RUnlock()
	return calls
}

// GetLatestCommandBatch calls GetLatestCommandBatchFunc.
func (mock *ChainKeeperMock) GetLatestCommandBatch(ctx github_com_cosmos_cosmos_sdk_types.Context) evmtypes.CommandBatch {
	if mock.GetLatestCommandBatchFunc == nil {
		panic("ChainKeeperMock.GetLatestCommandBatchFunc: method is nil but ChainKeeper.GetLatestCommandBatch was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetLatestCommandBatch.Lock()
	mock.calls.GetLatestCommandBatch = append(mock.calls.GetLatestCommandBatch, callInfo)
	mock.lockGetLatestCommandBatch.Unlock()
	return mock.GetLatestCommandBatchFunc(ctx)
}

// GetLatestCommandBatchCalls gets all the calls that were made to GetLatestCommandBatch.
// Check the length with:
//     len(mockedChainKeeper.GetLatestCommandBatchCalls())
func (mock *ChainKeeperMock) GetLatestCommandBatchCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}
	mock.lockGetLatestCommandBatch.RLock()
	calls = mock.calls.GetLatestCommandBatch
	mock.lockGetLatestCommandBatch.RUnlock()
	return calls
}

// GetMinVoterCount calls GetMinVoterCountFunc.
func (mock *ChainKeeperMock) GetMinVoterCount(ctx github_com_cosmos_cosmos_sdk_types.Context) (int64, bool) {
	if mock.GetMinVoterCountFunc == nil {
		panic("ChainKeeperMock.GetMinVoterCountFunc: method is nil but ChainKeeper.GetMinVoterCount was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetMinVoterCount.Lock()
	mock.calls.GetMinVoterCount = append(mock.calls.GetMinVoterCount, callInfo)
	mock.lockGetMinVoterCount.Unlock()
	return mock.GetMinVoterCountFunc(ctx)
}

// GetMinVoterCountCalls gets all the calls that were made to GetMinVoterCount.
// Check the length with:
//     len(mockedChainKeeper.GetMinVoterCountCalls())
func (mock *ChainKeeperMock) GetMinVoterCountCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}
	mock.lockGetMinVoterCount.RLock()
	calls = mock.calls.GetMinVoterCount
	mock.lockGetMinVoterCount.RUnlock()
	return calls
}

// GetName calls GetNameFunc.
func (mock *ChainKeeperMock) GetName() string {
	if mock.GetNameFunc == nil {
		panic("ChainKeeperMock.GetNameFunc: method is nil but ChainKeeper.GetName was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetName.Lock()
	mock.calls.GetName = append(mock.calls.GetName, callInfo)
	mock.lockGetName.Unlock()
	return mock.GetNameFunc()
}

// GetNameCalls gets all the calls that were made to GetName.
// Check the length with:
//     len(mockedChainKeeper.GetNameCalls())
func (mock *ChainKeeperMock) GetNameCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetName.RLock()
	calls = mock.calls.GetName
	mock.lockGetName.RUnlock()
	return calls
}

// GetNetwork calls GetNetworkFunc.
func (mock *ChainKeeperMock) GetNetwork(ctx github_com_cosmos_cosmos_sdk_types.Context) (string, bool) {
	if mock.GetNetworkFunc == nil {
		panic("ChainKeeperMock.GetNetworkFunc: method is nil but ChainKeeper.GetNetwork was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetNetwork.Lock()
	mock.calls.GetNetwork = append(mock.calls.GetNetwork, callInfo)
	mock.lockGetNetwork.Unlock()
	return mock.GetNetworkFunc(ctx)
}

// GetNetworkCalls gets all the calls that were made to GetNetwork.
// Check the length with:
//     len(mockedChainKeeper.GetNetworkCalls())
func (mock *ChainKeeperMock) GetNetworkCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}
	mock.lockGetNetwork.RLock()
	calls = mock.calls.GetNetwork
	mock.lockGetNetwork.RUnlock()
	return calls
}

// GetNetworkByID calls GetNetworkByIDFunc.
func (mock *ChainKeeperMock) GetNetworkByID(ctx github_com_cosmos_cosmos_sdk_types.Context, id github_com_cosmos_cosmos_sdk_types.Int) (string, bool) {
	if mock.GetNetworkByIDFunc == nil {
		panic("ChainKeeperMock.GetNetworkByIDFunc: method is nil but ChainKeeper.GetNetworkByID was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
		ID  github_com_cosmos_cosmos_sdk_types.Int
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetNetworkByID.Lock()
	mock.calls.GetNetworkByID = append(mock.calls.GetNetworkByID, callInfo)
	mock.lockGetNetworkByID.Unlock()
	return mock.GetNetworkByIDFunc(ctx, id)
}

// GetNetworkByIDCalls gets all the calls that were made to GetNetworkByID.
// Check the length with:
//     len(mockedChainKeeper.GetNetworkByIDCalls())
func (mock *ChainKeeperMock) GetNetworkByIDCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
	ID  github_com_cosmos_cosmos_sdk_types.Int
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
		ID  github_com_cosmos_cosmos_sdk_types.Int
	}
	mock.lockGetNetworkByID.RLock()
	calls = mock.calls.GetNetworkByID
	mock.lockGetNetworkByID.RUnlock()
	return calls
}

// GetParams calls GetParamsFunc.
func (mock *ChainKeeperMock) GetParams(ctx github_com_cosmos_cosmos_sdk_types.Context) evmtypes.Params {
	if mock.GetParamsFunc == nil {
		panic("ChainKeeperMock.GetParamsFunc: method is nil but ChainKeeper.GetParams was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetParams.Lock()
	mock.calls.GetParams = append(mock.calls.GetParams, callInfo)
	mock.lockGetParams.Unlock()
	return mock.GetParamsFunc(ctx)
}

// GetParamsCalls gets all the calls that were made to GetParams.
// Check the length with:
//     len(mockedChainKeeper.GetParamsCalls())
func (mock *ChainKeeperMock) GetParamsCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}
	mock.lockGetParams.RLock()
	calls = mock.calls.GetParams
	mock.lockGetParams.RUnlock()
	return calls
}

// GetPendingCommands calls GetPendingCommandsFunc.
func (mock *ChainKeeperMock) GetPendingCommands(ctx github_com_cosmos_cosmos_sdk_types.Context) []evmtypes.Command {
	if mock.GetPendingCommandsFunc == nil {
		panic("ChainKeeperMock.GetPendingCommandsFunc: method is nil but ChainKeeper.GetPendingCommands was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetPendingCommands.Lock()
	mock.calls.GetPendingCommands = append(mock.calls.GetPendingCommands, callInfo)
	mock.lockGetPendingCommands.Unlock()
	return mock.GetPendingCommandsFunc(ctx)
}

// GetPendingCommandsCalls gets all the calls that were made to GetPendingCommands.
// Check the length with:
//     len(mockedChainKeeper.GetPendingCommandsCalls())
func (mock *ChainKeeperMock) GetPendingCommandsCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}
	mock.lockGetPendingCommands.RLock()
	calls = mock.calls.GetPendingCommands
	mock.lockGetPendingCommands.RUnlock()
	return calls
}

// GetRequiredConfirmationHeight calls GetRequiredConfirmationHeightFunc.
func (mock *ChainKeeperMock) GetRequiredConfirmationHeight(ctx github_com_cosmos_cosmos_sdk_types.Context) (uint64, bool) {
	if mock.GetRequiredConfirmationHeightFunc == nil {
		panic("ChainKeeperMock.GetRequiredConfirmationHeightFunc: method is nil but ChainKeeper.GetRequiredConfirmationHeight was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetRequiredConfirmationHeight.Lock()
	mock.calls.GetRequiredConfirmationHeight = append(mock.calls.GetRequiredConfirmationHeight, callInfo)
	mock.lockGetRequiredConfirmationHeight.Unlock()
	return mock.GetRequiredConfirmationHeightFunc(ctx)
}

// GetRequiredConfirmationHeightCalls gets all the calls that were made to GetRequiredConfirmationHeight.
// Check the length with:
//     len(mockedChainKeeper.GetRequiredConfirmationHeightCalls())
func (mock *ChainKeeperMock) GetRequiredConfirmationHeightCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}
	mock.lockGetRequiredConfirmationHeight.RLock()
	calls = mock.calls.GetRequiredConfirmationHeight
	mock.lockGetRequiredConfirmationHeight.RUnlock()
	return calls
}

// GetRevoteLockingPeriod calls GetRevoteLockingPeriodFunc.
func (mock *ChainKeeperMock) GetRevoteLockingPeriod(ctx github_com_cosmos_cosmos_sdk_types.Context) (int64, bool) {
	if mock.GetRevoteLockingPeriodFunc == nil {
		panic("ChainKeeperMock.GetRevoteLockingPeriodFunc: method is nil but ChainKeeper.GetRevoteLockingPeriod was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetRevoteLockingPeriod.Lock()
	mock.calls.GetRevoteLockingPeriod = append(mock.calls.GetRevoteLockingPeriod, callInfo)
	mock.lockGetRevoteLockingPeriod.Unlock()
	return mock.GetRevoteLockingPeriodFunc(ctx)
}

// GetRevoteLockingPeriodCalls gets all the calls that were made to GetRevoteLockingPeriod.
// Check the length with:
//     len(mockedChainKeeper.GetRevoteLockingPeriodCalls())
func (mock *ChainKeeperMock) GetRevoteLockingPeriodCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}
	mock.lockGetRevoteLockingPeriod.RLock()
	calls = mock.calls.GetRevoteLockingPeriod
	mock.lockGetRevoteLockingPeriod.RUnlock()
	return calls
}

// GetTokenByteCode calls GetTokenByteCodeFunc.
func (mock *ChainKeeperMock) GetTokenByteCode(ctx github_com_cosmos_cosmos_sdk_types.Context) ([]byte, bool) {
	if mock.GetTokenByteCodeFunc == nil {
		panic("ChainKeeperMock.GetTokenByteCodeFunc: method is nil but ChainKeeper.GetTokenByteCode was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetTokenByteCode.Lock()
	mock.calls.GetTokenByteCode = append(mock.calls.GetTokenByteCode, callInfo)
	mock.lockGetTokenByteCode.Unlock()
	return mock.GetTokenByteCodeFunc(ctx)
}

// GetTokenByteCodeCalls gets all the calls that were made to GetTokenByteCode.
// Check the length with:
//     len(mockedChainKeeper.GetTokenByteCodeCalls())
func (mock *ChainKeeperMock) GetTokenByteCodeCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}
	mock.lockGetTokenByteCode.RLock()
	calls = mock.calls.GetTokenByteCode
	mock.lockGetTokenByteCode.RUnlock()
	return calls
}

// GetTokens calls GetTokensFunc.
func (mock *ChainKeeperMock) GetTokens(ctx github_com_cosmos_cosmos_sdk_types.Context) []evmtypes.ERC20Token {
	if mock.GetTokensFunc == nil {
		panic("ChainKeeperMock.GetTokensFunc: method is nil but ChainKeeper.GetTokens was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetTokens.Lock()
	mock.calls.GetTokens = append(mock.calls.GetTokens, callInfo)
	mock.lockGetTokens.Unlock()
	return mock.GetTokensFunc(ctx)
}

// GetTokensCalls gets all the calls that were made to GetTokens.
// Check the length with:
//     len(mockedChainKeeper.GetTokensCalls())
func (mock *ChainKeeperMock) GetTokensCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}
	mock.lockGetTokens.RLock()
	calls = mock.calls.GetTokens
	mock.lockGetTokens.RUnlock()
	return calls
}

// GetVotingThreshold calls GetVotingThresholdFunc.
func (mock *ChainKeeperMock) GetVotingThreshold(ctx github_com_cosmos_cosmos_sdk_types.Context) (utils.Threshold, bool) {
	if mock.GetVotingThresholdFunc == nil {
		panic("ChainKeeperMock.GetVotingThresholdFunc: method is nil but ChainKeeper.GetVotingThreshold was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetVotingThreshold.Lock()
	mock.calls.GetVotingThreshold = append(mock.calls.GetVotingThreshold, callInfo)
	mock.lockGetVotingThreshold.Unlock()
	return mock.GetVotingThresholdFunc(ctx)
}

// GetVotingThresholdCalls gets all the calls that were made to GetVotingThreshold.
// Check the length with:
//     len(mockedChainKeeper.GetVotingThresholdCalls())
func (mock *ChainKeeperMock) GetVotingThresholdCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}
	mock.lockGetVotingThreshold.RLock()
	calls = mock.calls.GetVotingThreshold
	mock.lockGetVotingThreshold.RUnlock()
	return calls
}

// Logger calls LoggerFunc.
func (mock *ChainKeeperMock) Logger(ctx github_com_cosmos_cosmos_sdk_types.Context) log.Logger {
	if mock.LoggerFunc == nil {
		panic("ChainKeeperMock.LoggerFunc: method is nil but ChainKeeper.Logger was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}{
		Ctx: ctx,
	}
	mock.lockLogger.Lock()
	mock.calls.Logger = append(mock.calls.Logger, callInfo)
	mock.lockLogger.Unlock()
	return mock.LoggerFunc(ctx)
}

// LoggerCalls gets all the calls that were made to Logger.
// Check the length with:
//     len(mockedChainKeeper.LoggerCalls())
func (mock *ChainKeeperMock) LoggerCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}
	mock.lockLogger.RLock()
	calls = mock.calls.Logger
	mock.lockLogger.RUnlock()
	return calls
}

// SetBurnerInfo calls SetBurnerInfoFunc.
func (mock *ChainKeeperMock) SetBurnerInfo(ctx github_com_cosmos_cosmos_sdk_types.Context, burnerInfo evmtypes.BurnerInfo) {
	if mock.SetBurnerInfoFunc == nil {
		panic("ChainKeeperMock.SetBurnerInfoFunc: method is nil but ChainKeeper.SetBurnerInfo was just called")
	}
	callInfo := struct {
		Ctx        github_com_cosmos_cosmos_sdk_types.Context
		BurnerInfo evmtypes.BurnerInfo
	}{
		Ctx:        ctx,
		BurnerInfo: burnerInfo,
	}
	mock.lockSetBurnerInfo.Lock()
	mock.calls.SetBurnerInfo = append(mock.calls.SetBurnerInfo, callInfo)
	mock.lockSetBurnerInfo.Unlock()
	mock.SetBurnerInfoFunc(ctx, burnerInfo)
}

// SetBurnerInfoCalls gets all the calls that were made to SetBurnerInfo.
// Check the length with:
//     len(mockedChainKeeper.SetBurnerInfoCalls())
func (mock *ChainKeeperMock) SetBurnerInfoCalls() []struct {
	Ctx        github_com_cosmos_cosmos_sdk_types.Context
	BurnerInfo evmtypes.BurnerInfo
} {
	var calls []struct {
		Ctx        github_com_cosmos_cosmos_sdk_types.Context
		BurnerInfo evmtypes.BurnerInfo
	}
	mock.lockSetBurnerInfo.RLock()
	calls = mock.calls.SetBurnerInfo
	mock.lockSetBurnerInfo.RUnlock()
	return calls
}

// SetConfirmedEvent calls SetConfirmedEventFunc.
func (mock *ChainKeeperMock) SetConfirmedEvent(ctx github_com_cosmos_cosmos_sdk_types.Context, event evmtypes.Event) error {
	if mock.SetConfirmedEventFunc == nil {
		panic("ChainKeeperMock.SetConfirmedEventFunc: method is nil but ChainKeeper.SetConfirmedEvent was just called")
	}
	callInfo := struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Event evmtypes.Event
	}{
		Ctx:   ctx,
		Event: event,
	}
	mock.lockSetConfirmedEvent.Lock()
	mock.calls.SetConfirmedEvent = append(mock.calls.SetConfirmedEvent, callInfo)
	mock.lockSetConfirmedEvent.Unlock()
	return mock.SetConfirmedEventFunc(ctx, event)
}

// SetConfirmedEventCalls gets all the calls that were made to SetConfirmedEvent.
// Check the length with:
//     len(mockedChainKeeper.SetConfirmedEventCalls())
func (mock *ChainKeeperMock) SetConfirmedEventCalls() []struct {
	Ctx   github_com_cosmos_cosmos_sdk_types.Context
	Event evmtypes.Event
} {
	var calls []struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		Event evmtypes.Event
	}
	mock.lockSetConfirmedEvent.RLock()
	calls = mock.calls.SetConfirmedEvent
	mock.lockSetConfirmedEvent.RUnlock()
	return calls
}

// SetDeposit calls SetDepositFunc.
func (mock *ChainKeeperMock) SetDeposit(ctx github_com_cosmos_cosmos_sdk_types.Context, deposit evmtypes.ERC20Deposit, state evmtypes.DepositStatus) {
	if mock.SetDepositFunc == nil {
		panic("ChainKeeperMock.SetDepositFunc: method is nil but ChainKeeper.SetDeposit was just called")
	}
	callInfo := struct {
		Ctx     github_com_cosmos_cosmos_sdk_types.Context
		Deposit evmtypes.ERC20Deposit
		State   evmtypes.DepositStatus
	}{
		Ctx:     ctx,
		Deposit: deposit,
		State:   state,
	}
	mock.lockSetDeposit.Lock()
	mock.calls.SetDeposit = append(mock.calls.SetDeposit, callInfo)
	mock.lockSetDeposit.Unlock()
	mock.SetDepositFunc(ctx, deposit, state)
}

// SetDepositCalls gets all the calls that were made to SetDeposit.
// Check the length with:
//     len(mockedChainKeeper.SetDepositCalls())
func (mock *ChainKeeperMock) SetDepositCalls() []struct {
	Ctx     github_com_cosmos_cosmos_sdk_types.Context
	Deposit evmtypes.ERC20Deposit
	State   evmtypes.DepositStatus
} {
	var calls []struct {
		Ctx     github_com_cosmos_cosmos_sdk_types.Context
		Deposit evmtypes.ERC20Deposit
		State   evmtypes.DepositStatus
	}
	mock.lockSetDeposit.RLock()
	calls = mock.calls.SetDeposit
	mock.lockSetDeposit.RUnlock()
	return calls
}

// SetEventCompleted calls SetEventCompletedFunc.
func (mock *ChainKeeperMock) SetEventCompleted(ctx github_com_cosmos_cosmos_sdk_types.Context, eventID evmtypes.EventID) error {
	if mock.SetEventCompletedFunc == nil {
		panic("ChainKeeperMock.SetEventCompletedFunc: method is nil but ChainKeeper.SetEventCompleted was just called")
	}
	callInfo := struct {
		Ctx     github_com_cosmos_cosmos_sdk_types.Context
		EventID evmtypes.EventID
	}{
		Ctx:     ctx,
		EventID: eventID,
	}
	mock.lockSetEventCompleted.Lock()
	mock.calls.SetEventCompleted = append(mock.calls.SetEventCompleted, callInfo)
	mock.lockSetEventCompleted.Unlock()
	return mock.SetEventCompletedFunc(ctx, eventID)
}

// SetEventCompletedCalls gets all the calls that were made to SetEventCompleted.
// Check the length with:
//     len(mockedChainKeeper.SetEventCompletedCalls())
func (mock *ChainKeeperMock) SetEventCompletedCalls() []struct {
	Ctx     github_com_cosmos_cosmos_sdk_types.Context
	EventID evmtypes.EventID
} {
	var calls []struct {
		Ctx     github_com_cosmos_cosmos_sdk_types.Context
		EventID evmtypes.EventID
	}
	mock.lockSetEventCompleted.RLock()
	calls = mock.calls.SetEventCompleted
	mock.lockSetEventCompleted.RUnlock()
	return calls
}

// SetEventFailed calls SetEventFailedFunc.
func (mock *ChainKeeperMock) SetEventFailed(ctx github_com_cosmos_cosmos_sdk_types.Context, eventID evmtypes.EventID) error {
	if mock.SetEventFailedFunc == nil {
		panic("ChainKeeperMock.SetEventFailedFunc: method is nil but ChainKeeper.SetEventFailed was just called")
	}
	callInfo := struct {
		Ctx     github_com_cosmos_cosmos_sdk_types.Context
		EventID evmtypes.EventID
	}{
		Ctx:     ctx,
		EventID: eventID,
	}
	mock.lockSetEventFailed.Lock()
	mock.calls.SetEventFailed = append(mock.calls.SetEventFailed, callInfo)
	mock.lockSetEventFailed.Unlock()
	return mock.SetEventFailedFunc(ctx, eventID)
}

// SetEventFailedCalls gets all the calls that were made to SetEventFailed.
// Check the length with:
//     len(mockedChainKeeper.SetEventFailedCalls())
func (mock *ChainKeeperMock) SetEventFailedCalls() []struct {
	Ctx     github_com_cosmos_cosmos_sdk_types.Context
	EventID evmtypes.EventID
} {
	var calls []struct {
		Ctx     github_com_cosmos_cosmos_sdk_types.Context
		EventID evmtypes.EventID
	}
	mock.lockSetEventFailed.RLock()
	calls = mock.calls.SetEventFailed
	mock.lockSetEventFailed.RUnlock()
	return calls
}

// SetGateway calls SetGatewayFunc.
func (mock *ChainKeeperMock) SetGateway(ctx github_com_cosmos_cosmos_sdk_types.Context, address evmtypes.Address) {
	if mock.SetGatewayFunc == nil {
		panic("ChainKeeperMock.SetGatewayFunc: method is nil but ChainKeeper.SetGateway was just called")
	}
	callInfo := struct {
		Ctx     github_com_cosmos_cosmos_sdk_types.Context
		Address evmtypes.Address
	}{
		Ctx:     ctx,
		Address: address,
	}
	mock.lockSetGateway.Lock()
	mock.calls.SetGateway = append(mock.calls.SetGateway, callInfo)
	mock.lockSetGateway.Unlock()
	mock.SetGatewayFunc(ctx, address)
}

// SetGatewayCalls gets all the calls that were made to SetGateway.
// Check the length with:
//     len(mockedChainKeeper.SetGatewayCalls())
func (mock *ChainKeeperMock) SetGatewayCalls() []struct {
	Ctx     github_com_cosmos_cosmos_sdk_types.Context
	Address evmtypes.Address
} {
	var calls []struct {
		Ctx     github_com_cosmos_cosmos_sdk_types.Context
		Address evmtypes.Address
	}
	mock.lockSetGateway.RLock()
	calls = mock.calls.SetGateway
	mock.lockSetGateway.RUnlock()
	return calls
}

// SetLatestSignedCommandBatchID calls SetLatestSignedCommandBatchIDFunc.
func (mock *ChainKeeperMock) SetLatestSignedCommandBatchID(ctx github_com_cosmos_cosmos_sdk_types.Context, id []byte) {
	if mock.SetLatestSignedCommandBatchIDFunc == nil {
		panic("ChainKeeperMock.SetLatestSignedCommandBatchIDFunc: method is nil but ChainKeeper.SetLatestSignedCommandBatchID was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
		ID  []byte
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockSetLatestSignedCommandBatchID.Lock()
	mock.calls.SetLatestSignedCommandBatchID = append(mock.calls.SetLatestSignedCommandBatchID, callInfo)
	mock.lockSetLatestSignedCommandBatchID.Unlock()
	mock.SetLatestSignedCommandBatchIDFunc(ctx, id)
}

// SetLatestSignedCommandBatchIDCalls gets all the calls that were made to SetLatestSignedCommandBatchID.
// Check the length with:
//     len(mockedChainKeeper.SetLatestSignedCommandBatchIDCalls())
func (mock *ChainKeeperMock) SetLatestSignedCommandBatchIDCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
	ID  []byte
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
		ID  []byte
	}
	mock.lockSetLatestSignedCommandBatchID.RLock()
	calls = mock.calls.SetLatestSignedCommandBatchID
	mock.lockSetLatestSignedCommandBatchID.RUnlock()
	return calls
}

// SetParams calls SetParamsFunc.
func (mock *ChainKeeperMock) SetParams(ctx github_com_cosmos_cosmos_sdk_types.Context, p evmtypes.Params) {
	if mock.SetParamsFunc == nil {
		panic("ChainKeeperMock.SetParamsFunc: method is nil but ChainKeeper.SetParams was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
		P   evmtypes.Params
	}{
		Ctx: ctx,
		P:   p,
	}
	mock.lockSetParams.Lock()
	mock.calls.SetParams = append(mock.calls.SetParams, callInfo)
	mock.lockSetParams.Unlock()
	mock.SetParamsFunc(ctx, p)
}

// SetParamsCalls gets all the calls that were made to SetParams.
// Check the length with:
//     len(mockedChainKeeper.SetParamsCalls())
func (mock *ChainKeeperMock) SetParamsCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
	P   evmtypes.Params
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
		P   evmtypes.Params
	}
	mock.lockSetParams.RLock()
	calls = mock.calls.SetParams
	mock.lockSetParams.RUnlock()
	return calls
}

// Ensure, that RewarderMock does implement evmtypes.Rewarder.
// If this is not the case, regenerate this file with moq.
var _ evmtypes.Rewarder = &RewarderMock{}

// RewarderMock is a mock implementation of evmtypes.Rewarder.
//
// 	func TestSomethingThatUsesRewarder(t *testing.T) {
//
// 		// make and configure a mocked evmtypes.Rewarder
// 		mockedRewarder := &RewarderMock{
// 			GetPoolFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, name string) reward.RewardPool {
// 				panic("mock out the GetPool method")
// 			},
// 		}
//
// 		// use mockedRewarder in code that requires evmtypes.Rewarder
// 		// and then make assertions.
//
// 	}
type RewarderMock struct {
	// GetPoolFunc mocks the GetPool method.
	GetPoolFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, name string) reward.RewardPool

	// calls tracks calls to the methods.
	calls struct {
		// GetPool holds details about calls to the GetPool method.
		GetPool []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// Name is the name argument value.
			Name string
		}
	}
	lockGetPool sync.RWMutex
}

// GetPool calls GetPoolFunc.
func (mock *RewarderMock) GetPool(ctx github_com_cosmos_cosmos_sdk_types.Context, name string) reward.RewardPool {
	if mock.GetPoolFunc == nil {
		panic("RewarderMock.GetPoolFunc: method is nil but Rewarder.GetPool was just called")
	}
	callInfo := struct {
		Ctx  github_com_cosmos_cosmos_sdk_types.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockGetPool.Lock()
	mock.calls.GetPool = append(mock.calls.GetPool, callInfo)
	mock.lockGetPool.Unlock()
	return mock.GetPoolFunc(ctx, name)
}

// GetPoolCalls gets all the calls that were made to GetPool.
// Check the length with:
//     len(mockedRewarder.GetPoolCalls())
func (mock *RewarderMock) GetPoolCalls() []struct {
	Ctx  github_com_cosmos_cosmos_sdk_types.Context
	Name string
} {
	var calls []struct {
		Ctx  github_com_cosmos_cosmos_sdk_types.Context
		Name string
	}
	mock.lockGetPool.RLock()
	calls = mock.calls.GetPool
	mock.lockGetPool.RUnlock()
	return calls
}

// Ensure, that StakingKeeperMock does implement evmtypes.StakingKeeper.
// If this is not the case, regenerate this file with moq.
var _ evmtypes.StakingKeeper = &StakingKeeperMock{}

// StakingKeeperMock is a mock implementation of evmtypes.StakingKeeper.
//
// 	func TestSomethingThatUsesStakingKeeper(t *testing.T) {
//
// 		// make and configure a mocked evmtypes.StakingKeeper
// 		mockedStakingKeeper := &StakingKeeperMock{
// 			PowerReductionFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context) github_com_cosmos_cosmos_sdk_types.Int {
// 				panic("mock out the PowerReduction method")
// 			},
// 		}
//
// 		// use mockedStakingKeeper in code that requires evmtypes.StakingKeeper
// 		// and then make assertions.
//
// 	}
type StakingKeeperMock struct {
	// PowerReductionFunc mocks the PowerReduction method.
	PowerReductionFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context) github_com_cosmos_cosmos_sdk_types.Int

	// calls tracks calls to the methods.
	calls struct {
		// PowerReduction holds details about calls to the PowerReduction method.
		PowerReduction []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
		}
	}
	lockPowerReduction sync.RWMutex
}

// PowerReduction calls PowerReductionFunc.
func (mock *StakingKeeperMock) PowerReduction(ctx github_com_cosmos_cosmos_sdk_types.Context) github_com_cosmos_cosmos_sdk_types.Int {
	if mock.PowerReductionFunc == nil {
		panic("StakingKeeperMock.PowerReductionFunc: method is nil but StakingKeeper.PowerReduction was just called")
	}
	callInfo := struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}{
		Ctx: ctx,
	}
	mock.lockPowerReduction.Lock()
	mock.calls.PowerReduction = append(mock.calls.PowerReduction, callInfo)
	mock.lockPowerReduction.Unlock()
	return mock.PowerReductionFunc(ctx)
}

// PowerReductionCalls gets all the calls that were made to PowerReduction.
// Check the length with:
//     len(mockedStakingKeeper.PowerReductionCalls())
func (mock *StakingKeeperMock) PowerReductionCalls() []struct {
	Ctx github_com_cosmos_cosmos_sdk_types.Context
} {
	var calls []struct {
		Ctx github_com_cosmos_cosmos_sdk_types.Context
	}
	mock.lockPowerReduction.RLock()
	calls = mock.calls.PowerReduction
	mock.lockPowerReduction.RUnlock()
	return calls
}

// Ensure, that SlashingKeeperMock does implement evmtypes.SlashingKeeper.
// If this is not the case, regenerate this file with moq.
var _ evmtypes.SlashingKeeper = &SlashingKeeperMock{}

// SlashingKeeperMock is a mock implementation of evmtypes.SlashingKeeper.
//
// 	func TestSomethingThatUsesSlashingKeeper(t *testing.T) {
//
// 		// make and configure a mocked evmtypes.SlashingKeeper
// 		mockedSlashingKeeper := &SlashingKeeperMock{
// 			IsTombstonedFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, consAddr github_com_cosmos_cosmos_sdk_types.ConsAddress) bool {
// 				panic("mock out the IsTombstoned method")
// 			},
// 		}
//
// 		// use mockedSlashingKeeper in code that requires evmtypes.SlashingKeeper
// 		// and then make assertions.
//
// 	}
type SlashingKeeperMock struct {
	// IsTombstonedFunc mocks the IsTombstoned method.
	IsTombstonedFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, consAddr github_com_cosmos_cosmos_sdk_types.ConsAddress) bool

	// calls tracks calls to the methods.
	calls struct {
		// IsTombstoned holds details about calls to the IsTombstoned method.
		IsTombstoned []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// ConsAddr is the consAddr argument value.
			ConsAddr github_com_cosmos_cosmos_sdk_types.ConsAddress
		}
	}
	lockIsTombstoned sync.RWMutex
}

// IsTombstoned calls IsTombstonedFunc.
func (mock *SlashingKeeperMock) IsTombstoned(ctx github_com_cosmos_cosmos_sdk_types.Context, consAddr github_com_cosmos_cosmos_sdk_types.ConsAddress) bool {
	if mock.IsTombstonedFunc == nil {
		panic("SlashingKeeperMock.IsTombstonedFunc: method is nil but SlashingKeeper.IsTombstoned was just called")
	}
	callInfo := struct {
		Ctx      github_com_cosmos_cosmos_sdk_types.Context
		ConsAddr github_com_cosmos_cosmos_sdk_types.ConsAddress
	}{
		Ctx:      ctx,
		ConsAddr: consAddr,
	}
	mock.lockIsTombstoned.Lock()
	mock.calls.IsTombstoned = append(mock.calls.IsTombstoned, callInfo)
	mock.lockIsTombstoned.Unlock()
	return mock.IsTombstonedFunc(ctx, consAddr)
}

// IsTombstonedCalls gets all the calls that were made to IsTombstoned.
// Check the length with:
//     len(mockedSlashingKeeper.IsTombstonedCalls())
func (mock *SlashingKeeperMock) IsTombstonedCalls() []struct {
	Ctx      github_com_cosmos_cosmos_sdk_types.Context
	ConsAddr github_com_cosmos_cosmos_sdk_types.ConsAddress
} {
	var calls []struct {
		Ctx      github_com_cosmos_cosmos_sdk_types.Context
		ConsAddr github_com_cosmos_cosmos_sdk_types.ConsAddress
	}
	mock.lockIsTombstoned.RLock()
	calls = mock.calls.IsTombstoned
	mock.lockIsTombstoned.RUnlock()
	return calls
}

// Ensure, that MultisigKeeperMock does implement evmtypes.MultisigKeeper.
// If this is not the case, regenerate this file with moq.
var _ evmtypes.MultisigKeeper = &MultisigKeeperMock{}

// MultisigKeeperMock is a mock implementation of evmtypes.MultisigKeeper.
//
// 	func TestSomethingThatUsesMultisigKeeper(t *testing.T) {
//
// 		// make and configure a mocked evmtypes.MultisigKeeper
// 		mockedMultisigKeeper := &MultisigKeeperMock{
// 			AssignKeyFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, chainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName, keyID github_com_axelarnetwork_axelar_core_x_multisig_exported.KeyID) error {
// 				panic("mock out the AssignKey method")
// 			},
// 			GetCurrentKeyIDFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, chainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (github_com_axelarnetwork_axelar_core_x_multisig_exported.KeyID, bool) {
// 				panic("mock out the GetCurrentKeyID method")
// 			},
// 			GetKeyFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, keyID github_com_axelarnetwork_axelar_core_x_multisig_exported.KeyID) (github_com_axelarnetwork_axelar_core_x_multisig_exported.Key, bool) {
// 				panic("mock out the GetKey method")
// 			},
// 			GetNextKeyIDFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, chainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (github_com_axelarnetwork_axelar_core_x_multisig_exported.KeyID, bool) {
// 				panic("mock out the GetNextKeyID method")
// 			},
// 			RotateKeyFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, chainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) error {
// 				panic("mock out the RotateKey method")
// 			},
// 			SignFunc: func(ctx github_com_cosmos_cosmos_sdk_types.Context, keyID github_com_axelarnetwork_axelar_core_x_multisig_exported.KeyID, payloadHash github_com_axelarnetwork_axelar_core_x_multisig_exported.Hash, module string, moduleMetadata ...codec.ProtoMarshaler) error {
// 				panic("mock out the Sign method")
// 			},
// 		}
//
// 		// use mockedMultisigKeeper in code that requires evmtypes.MultisigKeeper
// 		// and then make assertions.
//
// 	}
type MultisigKeeperMock struct {
	// AssignKeyFunc mocks the AssignKey method.
	AssignKeyFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, chainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName, keyID github_com_axelarnetwork_axelar_core_x_multisig_exported.KeyID) error

	// GetCurrentKeyIDFunc mocks the GetCurrentKeyID method.
	GetCurrentKeyIDFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, chainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (github_com_axelarnetwork_axelar_core_x_multisig_exported.KeyID, bool)

	// GetKeyFunc mocks the GetKey method.
	GetKeyFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, keyID github_com_axelarnetwork_axelar_core_x_multisig_exported.KeyID) (github_com_axelarnetwork_axelar_core_x_multisig_exported.Key, bool)

	// GetNextKeyIDFunc mocks the GetNextKeyID method.
	GetNextKeyIDFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, chainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (github_com_axelarnetwork_axelar_core_x_multisig_exported.KeyID, bool)

	// RotateKeyFunc mocks the RotateKey method.
	RotateKeyFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, chainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) error

	// SignFunc mocks the Sign method.
	SignFunc func(ctx github_com_cosmos_cosmos_sdk_types.Context, keyID github_com_axelarnetwork_axelar_core_x_multisig_exported.KeyID, payloadHash github_com_axelarnetwork_axelar_core_x_multisig_exported.Hash, module string, moduleMetadata ...codec.ProtoMarshaler) error

	// calls tracks calls to the methods.
	calls struct {
		// AssignKey holds details about calls to the AssignKey method.
		AssignKey []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// ChainName is the chainName argument value.
			ChainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
			// KeyID is the keyID argument value.
			KeyID github_com_axelarnetwork_axelar_core_x_multisig_exported.KeyID
		}
		// GetCurrentKeyID holds details about calls to the GetCurrentKeyID method.
		GetCurrentKeyID []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// ChainName is the chainName argument value.
			ChainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
		}
		// GetKey holds details about calls to the GetKey method.
		GetKey []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// KeyID is the keyID argument value.
			KeyID github_com_axelarnetwork_axelar_core_x_multisig_exported.KeyID
		}
		// GetNextKeyID holds details about calls to the GetNextKeyID method.
		GetNextKeyID []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// ChainName is the chainName argument value.
			ChainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
		}
		// RotateKey holds details about calls to the RotateKey method.
		RotateKey []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// ChainName is the chainName argument value.
			ChainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
		}
		// Sign holds details about calls to the Sign method.
		Sign []struct {
			// Ctx is the ctx argument value.
			Ctx github_com_cosmos_cosmos_sdk_types.Context
			// KeyID is the keyID argument value.
			KeyID github_com_axelarnetwork_axelar_core_x_multisig_exported.KeyID
			// PayloadHash is the payloadHash argument value.
			PayloadHash github_com_axelarnetwork_axelar_core_x_multisig_exported.Hash
			// Module is the module argument value.
			Module string
			// ModuleMetadata is the moduleMetadata argument value.
			ModuleMetadata []codec.ProtoMarshaler
		}
	}
	lockAssignKey       sync.RWMutex
	lockGetCurrentKeyID sync.RWMutex
	lockGetKey          sync.RWMutex
	lockGetNextKeyID    sync.RWMutex
	lockRotateKey       sync.RWMutex
	lockSign            sync.RWMutex
}

// AssignKey calls AssignKeyFunc.
func (mock *MultisigKeeperMock) AssignKey(ctx github_com_cosmos_cosmos_sdk_types.Context, chainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName, keyID github_com_axelarnetwork_axelar_core_x_multisig_exported.KeyID) error {
	if mock.AssignKeyFunc == nil {
		panic("MultisigKeeperMock.AssignKeyFunc: method is nil but MultisigKeeper.AssignKey was just called")
	}
	callInfo := struct {
		Ctx       github_com_cosmos_cosmos_sdk_types.Context
		ChainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
		KeyID     github_com_axelarnetwork_axelar_core_x_multisig_exported.KeyID
	}{
		Ctx:       ctx,
		ChainName: chainName,
		KeyID:     keyID,
	}
	mock.lockAssignKey.Lock()
	mock.calls.AssignKey = append(mock.calls.AssignKey, callInfo)
	mock.lockAssignKey.Unlock()
	return mock.AssignKeyFunc(ctx, chainName, keyID)
}

// AssignKeyCalls gets all the calls that were made to AssignKey.
// Check the length with:
//     len(mockedMultisigKeeper.AssignKeyCalls())
func (mock *MultisigKeeperMock) AssignKeyCalls() []struct {
	Ctx       github_com_cosmos_cosmos_sdk_types.Context
	ChainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	KeyID     github_com_axelarnetwork_axelar_core_x_multisig_exported.KeyID
} {
	var calls []struct {
		Ctx       github_com_cosmos_cosmos_sdk_types.Context
		ChainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
		KeyID     github_com_axelarnetwork_axelar_core_x_multisig_exported.KeyID
	}
	mock.lockAssignKey.RLock()
	calls = mock.calls.AssignKey
	mock.lockAssignKey.RUnlock()
	return calls
}

// GetCurrentKeyID calls GetCurrentKeyIDFunc.
func (mock *MultisigKeeperMock) GetCurrentKeyID(ctx github_com_cosmos_cosmos_sdk_types.Context, chainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (github_com_axelarnetwork_axelar_core_x_multisig_exported.KeyID, bool) {
	if mock.GetCurrentKeyIDFunc == nil {
		panic("MultisigKeeperMock.GetCurrentKeyIDFunc: method is nil but MultisigKeeper.GetCurrentKeyID was just called")
	}
	callInfo := struct {
		Ctx       github_com_cosmos_cosmos_sdk_types.Context
		ChainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}{
		Ctx:       ctx,
		ChainName: chainName,
	}
	mock.lockGetCurrentKeyID.Lock()
	mock.calls.GetCurrentKeyID = append(mock.calls.GetCurrentKeyID, callInfo)
	mock.lockGetCurrentKeyID.Unlock()
	return mock.GetCurrentKeyIDFunc(ctx, chainName)
}

// GetCurrentKeyIDCalls gets all the calls that were made to GetCurrentKeyID.
// Check the length with:
//     len(mockedMultisigKeeper.GetCurrentKeyIDCalls())
func (mock *MultisigKeeperMock) GetCurrentKeyIDCalls() []struct {
	Ctx       github_com_cosmos_cosmos_sdk_types.Context
	ChainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
} {
	var calls []struct {
		Ctx       github_com_cosmos_cosmos_sdk_types.Context
		ChainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}
	mock.lockGetCurrentKeyID.RLock()
	calls = mock.calls.GetCurrentKeyID
	mock.lockGetCurrentKeyID.RUnlock()
	return calls
}

// GetKey calls GetKeyFunc.
func (mock *MultisigKeeperMock) GetKey(ctx github_com_cosmos_cosmos_sdk_types.Context, keyID github_com_axelarnetwork_axelar_core_x_multisig_exported.KeyID) (github_com_axelarnetwork_axelar_core_x_multisig_exported.Key, bool) {
	if mock.GetKeyFunc == nil {
		panic("MultisigKeeperMock.GetKeyFunc: method is nil but MultisigKeeper.GetKey was just called")
	}
	callInfo := struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		KeyID github_com_axelarnetwork_axelar_core_x_multisig_exported.KeyID
	}{
		Ctx:   ctx,
		KeyID: keyID,
	}
	mock.lockGetKey.Lock()
	mock.calls.GetKey = append(mock.calls.GetKey, callInfo)
	mock.lockGetKey.Unlock()
	return mock.GetKeyFunc(ctx, keyID)
}

// GetKeyCalls gets all the calls that were made to GetKey.
// Check the length with:
//     len(mockedMultisigKeeper.GetKeyCalls())
func (mock *MultisigKeeperMock) GetKeyCalls() []struct {
	Ctx   github_com_cosmos_cosmos_sdk_types.Context
	KeyID github_com_axelarnetwork_axelar_core_x_multisig_exported.KeyID
} {
	var calls []struct {
		Ctx   github_com_cosmos_cosmos_sdk_types.Context
		KeyID github_com_axelarnetwork_axelar_core_x_multisig_exported.KeyID
	}
	mock.lockGetKey.RLock()
	calls = mock.calls.GetKey
	mock.lockGetKey.RUnlock()
	return calls
}

// GetNextKeyID calls GetNextKeyIDFunc.
func (mock *MultisigKeeperMock) GetNextKeyID(ctx github_com_cosmos_cosmos_sdk_types.Context, chainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) (github_com_axelarnetwork_axelar_core_x_multisig_exported.KeyID, bool) {
	if mock.GetNextKeyIDFunc == nil {
		panic("MultisigKeeperMock.GetNextKeyIDFunc: method is nil but MultisigKeeper.GetNextKeyID was just called")
	}
	callInfo := struct {
		Ctx       github_com_cosmos_cosmos_sdk_types.Context
		ChainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}{
		Ctx:       ctx,
		ChainName: chainName,
	}
	mock.lockGetNextKeyID.Lock()
	mock.calls.GetNextKeyID = append(mock.calls.GetNextKeyID, callInfo)
	mock.lockGetNextKeyID.Unlock()
	return mock.GetNextKeyIDFunc(ctx, chainName)
}

// GetNextKeyIDCalls gets all the calls that were made to GetNextKeyID.
// Check the length with:
//     len(mockedMultisigKeeper.GetNextKeyIDCalls())
func (mock *MultisigKeeperMock) GetNextKeyIDCalls() []struct {
	Ctx       github_com_cosmos_cosmos_sdk_types.Context
	ChainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
} {
	var calls []struct {
		Ctx       github_com_cosmos_cosmos_sdk_types.Context
		ChainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}
	mock.lockGetNextKeyID.RLock()
	calls = mock.calls.GetNextKeyID
	mock.lockGetNextKeyID.RUnlock()
	return calls
}

// RotateKey calls RotateKeyFunc.
func (mock *MultisigKeeperMock) RotateKey(ctx github_com_cosmos_cosmos_sdk_types.Context, chainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName) error {
	if mock.RotateKeyFunc == nil {
		panic("MultisigKeeperMock.RotateKeyFunc: method is nil but MultisigKeeper.RotateKey was just called")
	}
	callInfo := struct {
		Ctx       github_com_cosmos_cosmos_sdk_types.Context
		ChainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}{
		Ctx:       ctx,
		ChainName: chainName,
	}
	mock.lockRotateKey.Lock()
	mock.calls.RotateKey = append(mock.calls.RotateKey, callInfo)
	mock.lockRotateKey.Unlock()
	return mock.RotateKeyFunc(ctx, chainName)
}

// RotateKeyCalls gets all the calls that were made to RotateKey.
// Check the length with:
//     len(mockedMultisigKeeper.RotateKeyCalls())
func (mock *MultisigKeeperMock) RotateKeyCalls() []struct {
	Ctx       github_com_cosmos_cosmos_sdk_types.Context
	ChainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
} {
	var calls []struct {
		Ctx       github_com_cosmos_cosmos_sdk_types.Context
		ChainName github_com_axelarnetwork_axelar_core_x_nexus_exported.ChainName
	}
	mock.lockRotateKey.RLock()
	calls = mock.calls.RotateKey
	mock.lockRotateKey.RUnlock()
	return calls
}

// Sign calls SignFunc.
func (mock *MultisigKeeperMock) Sign(ctx github_com_cosmos_cosmos_sdk_types.Context, keyID github_com_axelarnetwork_axelar_core_x_multisig_exported.KeyID, payloadHash github_com_axelarnetwork_axelar_core_x_multisig_exported.Hash, module string, moduleMetadata ...codec.ProtoMarshaler) error {
	if mock.SignFunc == nil {
		panic("MultisigKeeperMock.SignFunc: method is nil but MultisigKeeper.Sign was just called")
	}
	callInfo := struct {
		Ctx            github_com_cosmos_cosmos_sdk_types.Context
		KeyID          github_com_axelarnetwork_axelar_core_x_multisig_exported.KeyID
		PayloadHash    github_com_axelarnetwork_axelar_core_x_multisig_exported.Hash
		Module         string
		ModuleMetadata []codec.ProtoMarshaler
	}{
		Ctx:            ctx,
		KeyID:          keyID,
		PayloadHash:    payloadHash,
		Module:         module,
		ModuleMetadata: moduleMetadata,
	}
	mock.lockSign.Lock()
	mock.calls.Sign = append(mock.calls.Sign, callInfo)
	mock.lockSign.Unlock()
	return mock.SignFunc(ctx, keyID, payloadHash, module, moduleMetadata...)
}

// SignCalls gets all the calls that were made to Sign.
// Check the length with:
//     len(mockedMultisigKeeper.SignCalls())
func (mock *MultisigKeeperMock) SignCalls() []struct {
	Ctx            github_com_cosmos_cosmos_sdk_types.Context
	KeyID          github_com_axelarnetwork_axelar_core_x_multisig_exported.KeyID
	PayloadHash    github_com_axelarnetwork_axelar_core_x_multisig_exported.Hash
	Module         string
	ModuleMetadata []codec.ProtoMarshaler
} {
	var calls []struct {
		Ctx            github_com_cosmos_cosmos_sdk_types.Context
		KeyID          github_com_axelarnetwork_axelar_core_x_multisig_exported.KeyID
		PayloadHash    github_com_axelarnetwork_axelar_core_x_multisig_exported.Hash
		Module         string
		ModuleMetadata []codec.ProtoMarshaler
	}
	mock.lockSign.RLock()
	calls = mock.calls.Sign
	mock.lockSign.RUnlock()
	return calls
}
