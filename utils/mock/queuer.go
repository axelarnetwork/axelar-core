// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"github.com/axelarnetwork/axelar-core/utils"
	"github.com/cosmos/cosmos-sdk/codec"
	"sync"
)

// Ensure, that KVQueueMock does implement utils.KVQueue.
// If this is not the case, regenerate this file with moq.
var _ utils.KVQueue = &KVQueueMock{}

// KVQueueMock is a mock implementation of utils.KVQueue.
//
//	func TestSomethingThatUsesKVQueue(t *testing.T) {
//
//		// make and configure a mocked utils.KVQueue
//		mockedKVQueue := &KVQueueMock{
//			DequeueFunc: func(value codec.ProtoMarshaler) bool {
//				panic("mock out the Dequeue method")
//			},
//			DequeueIfFunc: func(value codec.ProtoMarshaler, filter func(value codec.ProtoMarshaler) bool) bool {
//				panic("mock out the DequeueIf method")
//			},
//			DequeueUntilFunc: func(value codec.ProtoMarshaler, filter func(value codec.ProtoMarshaler) bool) bool {
//				panic("mock out the DequeueUntil method")
//			},
//			EnqueueFunc: func(key utils.Key, value codec.ProtoMarshaler)  {
//				panic("mock out the Enqueue method")
//			},
//			IsEmptyFunc: func() bool {
//				panic("mock out the IsEmpty method")
//			},
//			KeysFunc: func() []utils.Key {
//				panic("mock out the Keys method")
//			},
//		}
//
//		// use mockedKVQueue in code that requires utils.KVQueue
//		// and then make assertions.
//
//	}
type KVQueueMock struct {
	// DequeueFunc mocks the Dequeue method.
	DequeueFunc func(value codec.ProtoMarshaler) bool

	// DequeueIfFunc mocks the DequeueIf method.
	DequeueIfFunc func(value codec.ProtoMarshaler, filter func(value codec.ProtoMarshaler) bool) bool

	// DequeueUntilFunc mocks the DequeueUntil method.
	DequeueUntilFunc func(value codec.ProtoMarshaler, filter func(value codec.ProtoMarshaler) bool) bool

	// EnqueueFunc mocks the Enqueue method.
	EnqueueFunc func(key utils.Key, value codec.ProtoMarshaler)

	// IsEmptyFunc mocks the IsEmpty method.
	IsEmptyFunc func() bool

	// KeysFunc mocks the Keys method.
	KeysFunc func() []utils.Key

	// calls tracks calls to the methods.
	calls struct {
		// Dequeue holds details about calls to the Dequeue method.
		Dequeue []struct {
			// Value is the value argument value.
			Value codec.ProtoMarshaler
		}
		// DequeueIf holds details about calls to the DequeueIf method.
		DequeueIf []struct {
			// Value is the value argument value.
			Value codec.ProtoMarshaler
			// Filter is the filter argument value.
			Filter func(value codec.ProtoMarshaler) bool
		}
		// DequeueUntil holds details about calls to the DequeueUntil method.
		DequeueUntil []struct {
			// Value is the value argument value.
			Value codec.ProtoMarshaler
			// Filter is the filter argument value.
			Filter func(value codec.ProtoMarshaler) bool
		}
		// Enqueue holds details about calls to the Enqueue method.
		Enqueue []struct {
			// Key is the key argument value.
			Key utils.Key
			// Value is the value argument value.
			Value codec.ProtoMarshaler
		}
		// IsEmpty holds details about calls to the IsEmpty method.
		IsEmpty []struct {
		}
		// Keys holds details about calls to the Keys method.
		Keys []struct {
		}
	}
	lockDequeue      sync.RWMutex
	lockDequeueIf    sync.RWMutex
	lockDequeueUntil sync.RWMutex
	lockEnqueue      sync.RWMutex
	lockIsEmpty      sync.RWMutex
	lockKeys         sync.RWMutex
}

// Dequeue calls DequeueFunc.
func (mock *KVQueueMock) Dequeue(value codec.ProtoMarshaler) bool {
	if mock.DequeueFunc == nil {
		panic("KVQueueMock.DequeueFunc: method is nil but KVQueue.Dequeue was just called")
	}
	callInfo := struct {
		Value codec.ProtoMarshaler
	}{
		Value: value,
	}
	mock.lockDequeue.Lock()
	mock.calls.Dequeue = append(mock.calls.Dequeue, callInfo)
	mock.lockDequeue.Unlock()
	return mock.DequeueFunc(value)
}

// DequeueCalls gets all the calls that were made to Dequeue.
// Check the length with:
//
//	len(mockedKVQueue.DequeueCalls())
func (mock *KVQueueMock) DequeueCalls() []struct {
	Value codec.ProtoMarshaler
} {
	var calls []struct {
		Value codec.ProtoMarshaler
	}
	mock.lockDequeue.RLock()
	calls = mock.calls.Dequeue
	mock.lockDequeue.RUnlock()
	return calls
}

// DequeueIf calls DequeueIfFunc.
func (mock *KVQueueMock) DequeueIf(value codec.ProtoMarshaler, filter func(value codec.ProtoMarshaler) bool) bool {
	if mock.DequeueIfFunc == nil {
		panic("KVQueueMock.DequeueIfFunc: method is nil but KVQueue.DequeueIf was just called")
	}
	callInfo := struct {
		Value  codec.ProtoMarshaler
		Filter func(value codec.ProtoMarshaler) bool
	}{
		Value:  value,
		Filter: filter,
	}
	mock.lockDequeueIf.Lock()
	mock.calls.DequeueIf = append(mock.calls.DequeueIf, callInfo)
	mock.lockDequeueIf.Unlock()
	return mock.DequeueIfFunc(value, filter)
}

// DequeueIfCalls gets all the calls that were made to DequeueIf.
// Check the length with:
//
//	len(mockedKVQueue.DequeueIfCalls())
func (mock *KVQueueMock) DequeueIfCalls() []struct {
	Value  codec.ProtoMarshaler
	Filter func(value codec.ProtoMarshaler) bool
} {
	var calls []struct {
		Value  codec.ProtoMarshaler
		Filter func(value codec.ProtoMarshaler) bool
	}
	mock.lockDequeueIf.RLock()
	calls = mock.calls.DequeueIf
	mock.lockDequeueIf.RUnlock()
	return calls
}

// DequeueUntil calls DequeueUntilFunc.
func (mock *KVQueueMock) DequeueUntil(value codec.ProtoMarshaler, filter func(value codec.ProtoMarshaler) bool) bool {
	if mock.DequeueUntilFunc == nil {
		panic("KVQueueMock.DequeueUntilFunc: method is nil but KVQueue.DequeueUntil was just called")
	}
	callInfo := struct {
		Value  codec.ProtoMarshaler
		Filter func(value codec.ProtoMarshaler) bool
	}{
		Value:  value,
		Filter: filter,
	}
	mock.lockDequeueUntil.Lock()
	mock.calls.DequeueUntil = append(mock.calls.DequeueUntil, callInfo)
	mock.lockDequeueUntil.Unlock()
	return mock.DequeueUntilFunc(value, filter)
}

// DequeueUntilCalls gets all the calls that were made to DequeueUntil.
// Check the length with:
//
//	len(mockedKVQueue.DequeueUntilCalls())
func (mock *KVQueueMock) DequeueUntilCalls() []struct {
	Value  codec.ProtoMarshaler
	Filter func(value codec.ProtoMarshaler) bool
} {
	var calls []struct {
		Value  codec.ProtoMarshaler
		Filter func(value codec.ProtoMarshaler) bool
	}
	mock.lockDequeueUntil.RLock()
	calls = mock.calls.DequeueUntil
	mock.lockDequeueUntil.RUnlock()
	return calls
}

// Enqueue calls EnqueueFunc.
func (mock *KVQueueMock) Enqueue(key utils.Key, value codec.ProtoMarshaler) {
	if mock.EnqueueFunc == nil {
		panic("KVQueueMock.EnqueueFunc: method is nil but KVQueue.Enqueue was just called")
	}
	callInfo := struct {
		Key   utils.Key
		Value codec.ProtoMarshaler
	}{
		Key:   key,
		Value: value,
	}
	mock.lockEnqueue.Lock()
	mock.calls.Enqueue = append(mock.calls.Enqueue, callInfo)
	mock.lockEnqueue.Unlock()
	mock.EnqueueFunc(key, value)
}

// EnqueueCalls gets all the calls that were made to Enqueue.
// Check the length with:
//
//	len(mockedKVQueue.EnqueueCalls())
func (mock *KVQueueMock) EnqueueCalls() []struct {
	Key   utils.Key
	Value codec.ProtoMarshaler
} {
	var calls []struct {
		Key   utils.Key
		Value codec.ProtoMarshaler
	}
	mock.lockEnqueue.RLock()
	calls = mock.calls.Enqueue
	mock.lockEnqueue.RUnlock()
	return calls
}

// IsEmpty calls IsEmptyFunc.
func (mock *KVQueueMock) IsEmpty() bool {
	if mock.IsEmptyFunc == nil {
		panic("KVQueueMock.IsEmptyFunc: method is nil but KVQueue.IsEmpty was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIsEmpty.Lock()
	mock.calls.IsEmpty = append(mock.calls.IsEmpty, callInfo)
	mock.lockIsEmpty.Unlock()
	return mock.IsEmptyFunc()
}

// IsEmptyCalls gets all the calls that were made to IsEmpty.
// Check the length with:
//
//	len(mockedKVQueue.IsEmptyCalls())
func (mock *KVQueueMock) IsEmptyCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsEmpty.RLock()
	calls = mock.calls.IsEmpty
	mock.lockIsEmpty.RUnlock()
	return calls
}

// Keys calls KeysFunc.
func (mock *KVQueueMock) Keys() []utils.Key {
	if mock.KeysFunc == nil {
		panic("KVQueueMock.KeysFunc: method is nil but KVQueue.Keys was just called")
	}
	callInfo := struct {
	}{}
	mock.lockKeys.Lock()
	mock.calls.Keys = append(mock.calls.Keys, callInfo)
	mock.lockKeys.Unlock()
	return mock.KeysFunc()
}

// KeysCalls gets all the calls that were made to Keys.
// Check the length with:
//
//	len(mockedKVQueue.KeysCalls())
func (mock *KVQueueMock) KeysCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockKeys.RLock()
	calls = mock.calls.Keys
	mock.lockKeys.RUnlock()
	return calls
}
