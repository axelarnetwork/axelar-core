// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"github.com/axelarnetwork/axelar-core/testutils/fake/interfaces"
	"github.com/cosmos/cosmos-sdk/store/types"
	"github.com/tendermint/tm-db"
	"io"
	"sync"
)

// Ensure, that MultiStoreMock does implement interfaces.MultiStore.
// If this is not the case, regenerate this file with moq.
var _ interfaces.MultiStore = &MultiStoreMock{}

// MultiStoreMock is a mock implementation of interfaces.MultiStore.
//
//	func TestSomethingThatUsesMultiStore(t *testing.T) {
//
//		// make and configure a mocked interfaces.MultiStore
//		mockedMultiStore := &MultiStoreMock{
//			CacheMultiStoreFunc: func() types.CacheMultiStore {
//				panic("mock out the CacheMultiStore method")
//			},
//			CacheMultiStoreWithVersionFunc: func(version int64) (types.CacheMultiStore, error) {
//				panic("mock out the CacheMultiStoreWithVersion method")
//			},
//			CacheWrapFunc: func() types.CacheWrap {
//				panic("mock out the CacheWrap method")
//			},
//			CacheWrapWithTraceFunc: func(w io.Writer, tc types.TraceContext) types.CacheWrap {
//				panic("mock out the CacheWrapWithTrace method")
//			},
//			GetKVStoreFunc: func(storeKey types.StoreKey) types.KVStore {
//				panic("mock out the GetKVStore method")
//			},
//			GetStoreFunc: func(storeKey types.StoreKey) types.Store {
//				panic("mock out the GetStore method")
//			},
//			GetStoreTypeFunc: func() types.StoreType {
//				panic("mock out the GetStoreType method")
//			},
//			SetTracerFunc: func(w io.Writer) types.MultiStore {
//				panic("mock out the SetTracer method")
//			},
//			SetTracingContextFunc: func(traceContext types.TraceContext) types.MultiStore {
//				panic("mock out the SetTracingContext method")
//			},
//			TracingEnabledFunc: func() bool {
//				panic("mock out the TracingEnabled method")
//			},
//		}
//
//		// use mockedMultiStore in code that requires interfaces.MultiStore
//		// and then make assertions.
//
//	}
type MultiStoreMock struct {
	// CacheMultiStoreFunc mocks the CacheMultiStore method.
	CacheMultiStoreFunc func() types.CacheMultiStore

	// CacheMultiStoreWithVersionFunc mocks the CacheMultiStoreWithVersion method.
	CacheMultiStoreWithVersionFunc func(version int64) (types.CacheMultiStore, error)

	// CacheWrapFunc mocks the CacheWrap method.
	CacheWrapFunc func() types.CacheWrap

	// CacheWrapWithTraceFunc mocks the CacheWrapWithTrace method.
	CacheWrapWithTraceFunc func(w io.Writer, tc types.TraceContext) types.CacheWrap

	// GetKVStoreFunc mocks the GetKVStore method.
	GetKVStoreFunc func(storeKey types.StoreKey) types.KVStore

	// GetStoreFunc mocks the GetStore method.
	GetStoreFunc func(storeKey types.StoreKey) types.Store

	// GetStoreTypeFunc mocks the GetStoreType method.
	GetStoreTypeFunc func() types.StoreType

	// SetTracerFunc mocks the SetTracer method.
	SetTracerFunc func(w io.Writer) types.MultiStore

	// SetTracingContextFunc mocks the SetTracingContext method.
	SetTracingContextFunc func(traceContext types.TraceContext) types.MultiStore

	// TracingEnabledFunc mocks the TracingEnabled method.
	TracingEnabledFunc func() bool

	// calls tracks calls to the methods.
	calls struct {
		// CacheMultiStore holds details about calls to the CacheMultiStore method.
		CacheMultiStore []struct {
		}
		// CacheMultiStoreWithVersion holds details about calls to the CacheMultiStoreWithVersion method.
		CacheMultiStoreWithVersion []struct {
			// Version is the version argument value.
			Version int64
		}
		// CacheWrap holds details about calls to the CacheWrap method.
		CacheWrap []struct {
		}
		// CacheWrapWithTrace holds details about calls to the CacheWrapWithTrace method.
		CacheWrapWithTrace []struct {
			// W is the w argument value.
			W io.Writer
			// Tc is the tc argument value.
			Tc types.TraceContext
		}
		// GetKVStore holds details about calls to the GetKVStore method.
		GetKVStore []struct {
			// StoreKey is the storeKey argument value.
			StoreKey types.StoreKey
		}
		// GetStore holds details about calls to the GetStore method.
		GetStore []struct {
			// StoreKey is the storeKey argument value.
			StoreKey types.StoreKey
		}
		// GetStoreType holds details about calls to the GetStoreType method.
		GetStoreType []struct {
		}
		// SetTracer holds details about calls to the SetTracer method.
		SetTracer []struct {
			// W is the w argument value.
			W io.Writer
		}
		// SetTracingContext holds details about calls to the SetTracingContext method.
		SetTracingContext []struct {
			// TraceContext is the traceContext argument value.
			TraceContext types.TraceContext
		}
		// TracingEnabled holds details about calls to the TracingEnabled method.
		TracingEnabled []struct {
		}
	}
	lockCacheMultiStore            sync.RWMutex
	lockCacheMultiStoreWithVersion sync.RWMutex
	lockCacheWrap                  sync.RWMutex
	lockCacheWrapWithTrace         sync.RWMutex
	lockGetKVStore                 sync.RWMutex
	lockGetStore                   sync.RWMutex
	lockGetStoreType               sync.RWMutex
	lockSetTracer                  sync.RWMutex
	lockSetTracingContext          sync.RWMutex
	lockTracingEnabled             sync.RWMutex
}

// CacheMultiStore calls CacheMultiStoreFunc.
func (mock *MultiStoreMock) CacheMultiStore() types.CacheMultiStore {
	if mock.CacheMultiStoreFunc == nil {
		panic("MultiStoreMock.CacheMultiStoreFunc: method is nil but MultiStore.CacheMultiStore was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCacheMultiStore.Lock()
	mock.calls.CacheMultiStore = append(mock.calls.CacheMultiStore, callInfo)
	mock.lockCacheMultiStore.Unlock()
	return mock.CacheMultiStoreFunc()
}

// CacheMultiStoreCalls gets all the calls that were made to CacheMultiStore.
// Check the length with:
//
//	len(mockedMultiStore.CacheMultiStoreCalls())
func (mock *MultiStoreMock) CacheMultiStoreCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCacheMultiStore.RLock()
	calls = mock.calls.CacheMultiStore
	mock.lockCacheMultiStore.RUnlock()
	return calls
}

// CacheMultiStoreWithVersion calls CacheMultiStoreWithVersionFunc.
func (mock *MultiStoreMock) CacheMultiStoreWithVersion(version int64) (types.CacheMultiStore, error) {
	if mock.CacheMultiStoreWithVersionFunc == nil {
		panic("MultiStoreMock.CacheMultiStoreWithVersionFunc: method is nil but MultiStore.CacheMultiStoreWithVersion was just called")
	}
	callInfo := struct {
		Version int64
	}{
		Version: version,
	}
	mock.lockCacheMultiStoreWithVersion.Lock()
	mock.calls.CacheMultiStoreWithVersion = append(mock.calls.CacheMultiStoreWithVersion, callInfo)
	mock.lockCacheMultiStoreWithVersion.Unlock()
	return mock.CacheMultiStoreWithVersionFunc(version)
}

// CacheMultiStoreWithVersionCalls gets all the calls that were made to CacheMultiStoreWithVersion.
// Check the length with:
//
//	len(mockedMultiStore.CacheMultiStoreWithVersionCalls())
func (mock *MultiStoreMock) CacheMultiStoreWithVersionCalls() []struct {
	Version int64
} {
	var calls []struct {
		Version int64
	}
	mock.lockCacheMultiStoreWithVersion.RLock()
	calls = mock.calls.CacheMultiStoreWithVersion
	mock.lockCacheMultiStoreWithVersion.RUnlock()
	return calls
}

// CacheWrap calls CacheWrapFunc.
func (mock *MultiStoreMock) CacheWrap() types.CacheWrap {
	if mock.CacheWrapFunc == nil {
		panic("MultiStoreMock.CacheWrapFunc: method is nil but MultiStore.CacheWrap was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCacheWrap.Lock()
	mock.calls.CacheWrap = append(mock.calls.CacheWrap, callInfo)
	mock.lockCacheWrap.Unlock()
	return mock.CacheWrapFunc()
}

// CacheWrapCalls gets all the calls that were made to CacheWrap.
// Check the length with:
//
//	len(mockedMultiStore.CacheWrapCalls())
func (mock *MultiStoreMock) CacheWrapCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCacheWrap.RLock()
	calls = mock.calls.CacheWrap
	mock.lockCacheWrap.RUnlock()
	return calls
}

// CacheWrapWithTrace calls CacheWrapWithTraceFunc.
func (mock *MultiStoreMock) CacheWrapWithTrace(w io.Writer, tc types.TraceContext) types.CacheWrap {
	if mock.CacheWrapWithTraceFunc == nil {
		panic("MultiStoreMock.CacheWrapWithTraceFunc: method is nil but MultiStore.CacheWrapWithTrace was just called")
	}
	callInfo := struct {
		W  io.Writer
		Tc types.TraceContext
	}{
		W:  w,
		Tc: tc,
	}
	mock.lockCacheWrapWithTrace.Lock()
	mock.calls.CacheWrapWithTrace = append(mock.calls.CacheWrapWithTrace, callInfo)
	mock.lockCacheWrapWithTrace.Unlock()
	return mock.CacheWrapWithTraceFunc(w, tc)
}

// CacheWrapWithTraceCalls gets all the calls that were made to CacheWrapWithTrace.
// Check the length with:
//
//	len(mockedMultiStore.CacheWrapWithTraceCalls())
func (mock *MultiStoreMock) CacheWrapWithTraceCalls() []struct {
	W  io.Writer
	Tc types.TraceContext
} {
	var calls []struct {
		W  io.Writer
		Tc types.TraceContext
	}
	mock.lockCacheWrapWithTrace.RLock()
	calls = mock.calls.CacheWrapWithTrace
	mock.lockCacheWrapWithTrace.RUnlock()
	return calls
}

// GetKVStore calls GetKVStoreFunc.
func (mock *MultiStoreMock) GetKVStore(storeKey types.StoreKey) types.KVStore {
	if mock.GetKVStoreFunc == nil {
		panic("MultiStoreMock.GetKVStoreFunc: method is nil but MultiStore.GetKVStore was just called")
	}
	callInfo := struct {
		StoreKey types.StoreKey
	}{
		StoreKey: storeKey,
	}
	mock.lockGetKVStore.Lock()
	mock.calls.GetKVStore = append(mock.calls.GetKVStore, callInfo)
	mock.lockGetKVStore.Unlock()
	return mock.GetKVStoreFunc(storeKey)
}

// GetKVStoreCalls gets all the calls that were made to GetKVStore.
// Check the length with:
//
//	len(mockedMultiStore.GetKVStoreCalls())
func (mock *MultiStoreMock) GetKVStoreCalls() []struct {
	StoreKey types.StoreKey
} {
	var calls []struct {
		StoreKey types.StoreKey
	}
	mock.lockGetKVStore.RLock()
	calls = mock.calls.GetKVStore
	mock.lockGetKVStore.RUnlock()
	return calls
}

// GetStore calls GetStoreFunc.
func (mock *MultiStoreMock) GetStore(storeKey types.StoreKey) types.Store {
	if mock.GetStoreFunc == nil {
		panic("MultiStoreMock.GetStoreFunc: method is nil but MultiStore.GetStore was just called")
	}
	callInfo := struct {
		StoreKey types.StoreKey
	}{
		StoreKey: storeKey,
	}
	mock.lockGetStore.Lock()
	mock.calls.GetStore = append(mock.calls.GetStore, callInfo)
	mock.lockGetStore.Unlock()
	return mock.GetStoreFunc(storeKey)
}

// GetStoreCalls gets all the calls that were made to GetStore.
// Check the length with:
//
//	len(mockedMultiStore.GetStoreCalls())
func (mock *MultiStoreMock) GetStoreCalls() []struct {
	StoreKey types.StoreKey
} {
	var calls []struct {
		StoreKey types.StoreKey
	}
	mock.lockGetStore.RLock()
	calls = mock.calls.GetStore
	mock.lockGetStore.RUnlock()
	return calls
}

// GetStoreType calls GetStoreTypeFunc.
func (mock *MultiStoreMock) GetStoreType() types.StoreType {
	if mock.GetStoreTypeFunc == nil {
		panic("MultiStoreMock.GetStoreTypeFunc: method is nil but MultiStore.GetStoreType was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetStoreType.Lock()
	mock.calls.GetStoreType = append(mock.calls.GetStoreType, callInfo)
	mock.lockGetStoreType.Unlock()
	return mock.GetStoreTypeFunc()
}

// GetStoreTypeCalls gets all the calls that were made to GetStoreType.
// Check the length with:
//
//	len(mockedMultiStore.GetStoreTypeCalls())
func (mock *MultiStoreMock) GetStoreTypeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetStoreType.RLock()
	calls = mock.calls.GetStoreType
	mock.lockGetStoreType.RUnlock()
	return calls
}

// SetTracer calls SetTracerFunc.
func (mock *MultiStoreMock) SetTracer(w io.Writer) types.MultiStore {
	if mock.SetTracerFunc == nil {
		panic("MultiStoreMock.SetTracerFunc: method is nil but MultiStore.SetTracer was just called")
	}
	callInfo := struct {
		W io.Writer
	}{
		W: w,
	}
	mock.lockSetTracer.Lock()
	mock.calls.SetTracer = append(mock.calls.SetTracer, callInfo)
	mock.lockSetTracer.Unlock()
	return mock.SetTracerFunc(w)
}

// SetTracerCalls gets all the calls that were made to SetTracer.
// Check the length with:
//
//	len(mockedMultiStore.SetTracerCalls())
func (mock *MultiStoreMock) SetTracerCalls() []struct {
	W io.Writer
} {
	var calls []struct {
		W io.Writer
	}
	mock.lockSetTracer.RLock()
	calls = mock.calls.SetTracer
	mock.lockSetTracer.RUnlock()
	return calls
}

// SetTracingContext calls SetTracingContextFunc.
func (mock *MultiStoreMock) SetTracingContext(traceContext types.TraceContext) types.MultiStore {
	if mock.SetTracingContextFunc == nil {
		panic("MultiStoreMock.SetTracingContextFunc: method is nil but MultiStore.SetTracingContext was just called")
	}
	callInfo := struct {
		TraceContext types.TraceContext
	}{
		TraceContext: traceContext,
	}
	mock.lockSetTracingContext.Lock()
	mock.calls.SetTracingContext = append(mock.calls.SetTracingContext, callInfo)
	mock.lockSetTracingContext.Unlock()
	return mock.SetTracingContextFunc(traceContext)
}

// SetTracingContextCalls gets all the calls that were made to SetTracingContext.
// Check the length with:
//
//	len(mockedMultiStore.SetTracingContextCalls())
func (mock *MultiStoreMock) SetTracingContextCalls() []struct {
	TraceContext types.TraceContext
} {
	var calls []struct {
		TraceContext types.TraceContext
	}
	mock.lockSetTracingContext.RLock()
	calls = mock.calls.SetTracingContext
	mock.lockSetTracingContext.RUnlock()
	return calls
}

// TracingEnabled calls TracingEnabledFunc.
func (mock *MultiStoreMock) TracingEnabled() bool {
	if mock.TracingEnabledFunc == nil {
		panic("MultiStoreMock.TracingEnabledFunc: method is nil but MultiStore.TracingEnabled was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTracingEnabled.Lock()
	mock.calls.TracingEnabled = append(mock.calls.TracingEnabled, callInfo)
	mock.lockTracingEnabled.Unlock()
	return mock.TracingEnabledFunc()
}

// TracingEnabledCalls gets all the calls that were made to TracingEnabled.
// Check the length with:
//
//	len(mockedMultiStore.TracingEnabledCalls())
func (mock *MultiStoreMock) TracingEnabledCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTracingEnabled.RLock()
	calls = mock.calls.TracingEnabled
	mock.lockTracingEnabled.RUnlock()
	return calls
}

// Ensure, that CacheMultiStoreMock does implement interfaces.CacheMultiStore.
// If this is not the case, regenerate this file with moq.
var _ interfaces.CacheMultiStore = &CacheMultiStoreMock{}

// CacheMultiStoreMock is a mock implementation of interfaces.CacheMultiStore.
//
//	func TestSomethingThatUsesCacheMultiStore(t *testing.T) {
//
//		// make and configure a mocked interfaces.CacheMultiStore
//		mockedCacheMultiStore := &CacheMultiStoreMock{
//			CacheMultiStoreFunc: func() types.CacheMultiStore {
//				panic("mock out the CacheMultiStore method")
//			},
//			CacheMultiStoreWithVersionFunc: func(version int64) (types.CacheMultiStore, error) {
//				panic("mock out the CacheMultiStoreWithVersion method")
//			},
//			CacheWrapFunc: func() types.CacheWrap {
//				panic("mock out the CacheWrap method")
//			},
//			CacheWrapWithTraceFunc: func(w io.Writer, tc types.TraceContext) types.CacheWrap {
//				panic("mock out the CacheWrapWithTrace method")
//			},
//			GetKVStoreFunc: func(storeKey types.StoreKey) types.KVStore {
//				panic("mock out the GetKVStore method")
//			},
//			GetStoreFunc: func(storeKey types.StoreKey) types.Store {
//				panic("mock out the GetStore method")
//			},
//			GetStoreTypeFunc: func() types.StoreType {
//				panic("mock out the GetStoreType method")
//			},
//			SetTracerFunc: func(w io.Writer) types.MultiStore {
//				panic("mock out the SetTracer method")
//			},
//			SetTracingContextFunc: func(traceContext types.TraceContext) types.MultiStore {
//				panic("mock out the SetTracingContext method")
//			},
//			TracingEnabledFunc: func() bool {
//				panic("mock out the TracingEnabled method")
//			},
//			WriteFunc: func()  {
//				panic("mock out the Write method")
//			},
//		}
//
//		// use mockedCacheMultiStore in code that requires interfaces.CacheMultiStore
//		// and then make assertions.
//
//	}
type CacheMultiStoreMock struct {
	// CacheMultiStoreFunc mocks the CacheMultiStore method.
	CacheMultiStoreFunc func() types.CacheMultiStore

	// CacheMultiStoreWithVersionFunc mocks the CacheMultiStoreWithVersion method.
	CacheMultiStoreWithVersionFunc func(version int64) (types.CacheMultiStore, error)

	// CacheWrapFunc mocks the CacheWrap method.
	CacheWrapFunc func() types.CacheWrap

	// CacheWrapWithTraceFunc mocks the CacheWrapWithTrace method.
	CacheWrapWithTraceFunc func(w io.Writer, tc types.TraceContext) types.CacheWrap

	// GetKVStoreFunc mocks the GetKVStore method.
	GetKVStoreFunc func(storeKey types.StoreKey) types.KVStore

	// GetStoreFunc mocks the GetStore method.
	GetStoreFunc func(storeKey types.StoreKey) types.Store

	// GetStoreTypeFunc mocks the GetStoreType method.
	GetStoreTypeFunc func() types.StoreType

	// SetTracerFunc mocks the SetTracer method.
	SetTracerFunc func(w io.Writer) types.MultiStore

	// SetTracingContextFunc mocks the SetTracingContext method.
	SetTracingContextFunc func(traceContext types.TraceContext) types.MultiStore

	// TracingEnabledFunc mocks the TracingEnabled method.
	TracingEnabledFunc func() bool

	// WriteFunc mocks the Write method.
	WriteFunc func()

	// calls tracks calls to the methods.
	calls struct {
		// CacheMultiStore holds details about calls to the CacheMultiStore method.
		CacheMultiStore []struct {
		}
		// CacheMultiStoreWithVersion holds details about calls to the CacheMultiStoreWithVersion method.
		CacheMultiStoreWithVersion []struct {
			// Version is the version argument value.
			Version int64
		}
		// CacheWrap holds details about calls to the CacheWrap method.
		CacheWrap []struct {
		}
		// CacheWrapWithTrace holds details about calls to the CacheWrapWithTrace method.
		CacheWrapWithTrace []struct {
			// W is the w argument value.
			W io.Writer
			// Tc is the tc argument value.
			Tc types.TraceContext
		}
		// GetKVStore holds details about calls to the GetKVStore method.
		GetKVStore []struct {
			// StoreKey is the storeKey argument value.
			StoreKey types.StoreKey
		}
		// GetStore holds details about calls to the GetStore method.
		GetStore []struct {
			// StoreKey is the storeKey argument value.
			StoreKey types.StoreKey
		}
		// GetStoreType holds details about calls to the GetStoreType method.
		GetStoreType []struct {
		}
		// SetTracer holds details about calls to the SetTracer method.
		SetTracer []struct {
			// W is the w argument value.
			W io.Writer
		}
		// SetTracingContext holds details about calls to the SetTracingContext method.
		SetTracingContext []struct {
			// TraceContext is the traceContext argument value.
			TraceContext types.TraceContext
		}
		// TracingEnabled holds details about calls to the TracingEnabled method.
		TracingEnabled []struct {
		}
		// Write holds details about calls to the Write method.
		Write []struct {
		}
	}
	lockCacheMultiStore            sync.RWMutex
	lockCacheMultiStoreWithVersion sync.RWMutex
	lockCacheWrap                  sync.RWMutex
	lockCacheWrapWithTrace         sync.RWMutex
	lockGetKVStore                 sync.RWMutex
	lockGetStore                   sync.RWMutex
	lockGetStoreType               sync.RWMutex
	lockSetTracer                  sync.RWMutex
	lockSetTracingContext          sync.RWMutex
	lockTracingEnabled             sync.RWMutex
	lockWrite                      sync.RWMutex
}

// CacheMultiStore calls CacheMultiStoreFunc.
func (mock *CacheMultiStoreMock) CacheMultiStore() types.CacheMultiStore {
	if mock.CacheMultiStoreFunc == nil {
		panic("CacheMultiStoreMock.CacheMultiStoreFunc: method is nil but CacheMultiStore.CacheMultiStore was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCacheMultiStore.Lock()
	mock.calls.CacheMultiStore = append(mock.calls.CacheMultiStore, callInfo)
	mock.lockCacheMultiStore.Unlock()
	return mock.CacheMultiStoreFunc()
}

// CacheMultiStoreCalls gets all the calls that were made to CacheMultiStore.
// Check the length with:
//
//	len(mockedCacheMultiStore.CacheMultiStoreCalls())
func (mock *CacheMultiStoreMock) CacheMultiStoreCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCacheMultiStore.RLock()
	calls = mock.calls.CacheMultiStore
	mock.lockCacheMultiStore.RUnlock()
	return calls
}

// CacheMultiStoreWithVersion calls CacheMultiStoreWithVersionFunc.
func (mock *CacheMultiStoreMock) CacheMultiStoreWithVersion(version int64) (types.CacheMultiStore, error) {
	if mock.CacheMultiStoreWithVersionFunc == nil {
		panic("CacheMultiStoreMock.CacheMultiStoreWithVersionFunc: method is nil but CacheMultiStore.CacheMultiStoreWithVersion was just called")
	}
	callInfo := struct {
		Version int64
	}{
		Version: version,
	}
	mock.lockCacheMultiStoreWithVersion.Lock()
	mock.calls.CacheMultiStoreWithVersion = append(mock.calls.CacheMultiStoreWithVersion, callInfo)
	mock.lockCacheMultiStoreWithVersion.Unlock()
	return mock.CacheMultiStoreWithVersionFunc(version)
}

// CacheMultiStoreWithVersionCalls gets all the calls that were made to CacheMultiStoreWithVersion.
// Check the length with:
//
//	len(mockedCacheMultiStore.CacheMultiStoreWithVersionCalls())
func (mock *CacheMultiStoreMock) CacheMultiStoreWithVersionCalls() []struct {
	Version int64
} {
	var calls []struct {
		Version int64
	}
	mock.lockCacheMultiStoreWithVersion.RLock()
	calls = mock.calls.CacheMultiStoreWithVersion
	mock.lockCacheMultiStoreWithVersion.RUnlock()
	return calls
}

// CacheWrap calls CacheWrapFunc.
func (mock *CacheMultiStoreMock) CacheWrap() types.CacheWrap {
	if mock.CacheWrapFunc == nil {
		panic("CacheMultiStoreMock.CacheWrapFunc: method is nil but CacheMultiStore.CacheWrap was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCacheWrap.Lock()
	mock.calls.CacheWrap = append(mock.calls.CacheWrap, callInfo)
	mock.lockCacheWrap.Unlock()
	return mock.CacheWrapFunc()
}

// CacheWrapCalls gets all the calls that were made to CacheWrap.
// Check the length with:
//
//	len(mockedCacheMultiStore.CacheWrapCalls())
func (mock *CacheMultiStoreMock) CacheWrapCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCacheWrap.RLock()
	calls = mock.calls.CacheWrap
	mock.lockCacheWrap.RUnlock()
	return calls
}

// CacheWrapWithTrace calls CacheWrapWithTraceFunc.
func (mock *CacheMultiStoreMock) CacheWrapWithTrace(w io.Writer, tc types.TraceContext) types.CacheWrap {
	if mock.CacheWrapWithTraceFunc == nil {
		panic("CacheMultiStoreMock.CacheWrapWithTraceFunc: method is nil but CacheMultiStore.CacheWrapWithTrace was just called")
	}
	callInfo := struct {
		W  io.Writer
		Tc types.TraceContext
	}{
		W:  w,
		Tc: tc,
	}
	mock.lockCacheWrapWithTrace.Lock()
	mock.calls.CacheWrapWithTrace = append(mock.calls.CacheWrapWithTrace, callInfo)
	mock.lockCacheWrapWithTrace.Unlock()
	return mock.CacheWrapWithTraceFunc(w, tc)
}

// CacheWrapWithTraceCalls gets all the calls that were made to CacheWrapWithTrace.
// Check the length with:
//
//	len(mockedCacheMultiStore.CacheWrapWithTraceCalls())
func (mock *CacheMultiStoreMock) CacheWrapWithTraceCalls() []struct {
	W  io.Writer
	Tc types.TraceContext
} {
	var calls []struct {
		W  io.Writer
		Tc types.TraceContext
	}
	mock.lockCacheWrapWithTrace.RLock()
	calls = mock.calls.CacheWrapWithTrace
	mock.lockCacheWrapWithTrace.RUnlock()
	return calls
}

// GetKVStore calls GetKVStoreFunc.
func (mock *CacheMultiStoreMock) GetKVStore(storeKey types.StoreKey) types.KVStore {
	if mock.GetKVStoreFunc == nil {
		panic("CacheMultiStoreMock.GetKVStoreFunc: method is nil but CacheMultiStore.GetKVStore was just called")
	}
	callInfo := struct {
		StoreKey types.StoreKey
	}{
		StoreKey: storeKey,
	}
	mock.lockGetKVStore.Lock()
	mock.calls.GetKVStore = append(mock.calls.GetKVStore, callInfo)
	mock.lockGetKVStore.Unlock()
	return mock.GetKVStoreFunc(storeKey)
}

// GetKVStoreCalls gets all the calls that were made to GetKVStore.
// Check the length with:
//
//	len(mockedCacheMultiStore.GetKVStoreCalls())
func (mock *CacheMultiStoreMock) GetKVStoreCalls() []struct {
	StoreKey types.StoreKey
} {
	var calls []struct {
		StoreKey types.StoreKey
	}
	mock.lockGetKVStore.RLock()
	calls = mock.calls.GetKVStore
	mock.lockGetKVStore.RUnlock()
	return calls
}

// GetStore calls GetStoreFunc.
func (mock *CacheMultiStoreMock) GetStore(storeKey types.StoreKey) types.Store {
	if mock.GetStoreFunc == nil {
		panic("CacheMultiStoreMock.GetStoreFunc: method is nil but CacheMultiStore.GetStore was just called")
	}
	callInfo := struct {
		StoreKey types.StoreKey
	}{
		StoreKey: storeKey,
	}
	mock.lockGetStore.Lock()
	mock.calls.GetStore = append(mock.calls.GetStore, callInfo)
	mock.lockGetStore.Unlock()
	return mock.GetStoreFunc(storeKey)
}

// GetStoreCalls gets all the calls that were made to GetStore.
// Check the length with:
//
//	len(mockedCacheMultiStore.GetStoreCalls())
func (mock *CacheMultiStoreMock) GetStoreCalls() []struct {
	StoreKey types.StoreKey
} {
	var calls []struct {
		StoreKey types.StoreKey
	}
	mock.lockGetStore.RLock()
	calls = mock.calls.GetStore
	mock.lockGetStore.RUnlock()
	return calls
}

// GetStoreType calls GetStoreTypeFunc.
func (mock *CacheMultiStoreMock) GetStoreType() types.StoreType {
	if mock.GetStoreTypeFunc == nil {
		panic("CacheMultiStoreMock.GetStoreTypeFunc: method is nil but CacheMultiStore.GetStoreType was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetStoreType.Lock()
	mock.calls.GetStoreType = append(mock.calls.GetStoreType, callInfo)
	mock.lockGetStoreType.Unlock()
	return mock.GetStoreTypeFunc()
}

// GetStoreTypeCalls gets all the calls that were made to GetStoreType.
// Check the length with:
//
//	len(mockedCacheMultiStore.GetStoreTypeCalls())
func (mock *CacheMultiStoreMock) GetStoreTypeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetStoreType.RLock()
	calls = mock.calls.GetStoreType
	mock.lockGetStoreType.RUnlock()
	return calls
}

// SetTracer calls SetTracerFunc.
func (mock *CacheMultiStoreMock) SetTracer(w io.Writer) types.MultiStore {
	if mock.SetTracerFunc == nil {
		panic("CacheMultiStoreMock.SetTracerFunc: method is nil but CacheMultiStore.SetTracer was just called")
	}
	callInfo := struct {
		W io.Writer
	}{
		W: w,
	}
	mock.lockSetTracer.Lock()
	mock.calls.SetTracer = append(mock.calls.SetTracer, callInfo)
	mock.lockSetTracer.Unlock()
	return mock.SetTracerFunc(w)
}

// SetTracerCalls gets all the calls that were made to SetTracer.
// Check the length with:
//
//	len(mockedCacheMultiStore.SetTracerCalls())
func (mock *CacheMultiStoreMock) SetTracerCalls() []struct {
	W io.Writer
} {
	var calls []struct {
		W io.Writer
	}
	mock.lockSetTracer.RLock()
	calls = mock.calls.SetTracer
	mock.lockSetTracer.RUnlock()
	return calls
}

// SetTracingContext calls SetTracingContextFunc.
func (mock *CacheMultiStoreMock) SetTracingContext(traceContext types.TraceContext) types.MultiStore {
	if mock.SetTracingContextFunc == nil {
		panic("CacheMultiStoreMock.SetTracingContextFunc: method is nil but CacheMultiStore.SetTracingContext was just called")
	}
	callInfo := struct {
		TraceContext types.TraceContext
	}{
		TraceContext: traceContext,
	}
	mock.lockSetTracingContext.Lock()
	mock.calls.SetTracingContext = append(mock.calls.SetTracingContext, callInfo)
	mock.lockSetTracingContext.Unlock()
	return mock.SetTracingContextFunc(traceContext)
}

// SetTracingContextCalls gets all the calls that were made to SetTracingContext.
// Check the length with:
//
//	len(mockedCacheMultiStore.SetTracingContextCalls())
func (mock *CacheMultiStoreMock) SetTracingContextCalls() []struct {
	TraceContext types.TraceContext
} {
	var calls []struct {
		TraceContext types.TraceContext
	}
	mock.lockSetTracingContext.RLock()
	calls = mock.calls.SetTracingContext
	mock.lockSetTracingContext.RUnlock()
	return calls
}

// TracingEnabled calls TracingEnabledFunc.
func (mock *CacheMultiStoreMock) TracingEnabled() bool {
	if mock.TracingEnabledFunc == nil {
		panic("CacheMultiStoreMock.TracingEnabledFunc: method is nil but CacheMultiStore.TracingEnabled was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTracingEnabled.Lock()
	mock.calls.TracingEnabled = append(mock.calls.TracingEnabled, callInfo)
	mock.lockTracingEnabled.Unlock()
	return mock.TracingEnabledFunc()
}

// TracingEnabledCalls gets all the calls that were made to TracingEnabled.
// Check the length with:
//
//	len(mockedCacheMultiStore.TracingEnabledCalls())
func (mock *CacheMultiStoreMock) TracingEnabledCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTracingEnabled.RLock()
	calls = mock.calls.TracingEnabled
	mock.lockTracingEnabled.RUnlock()
	return calls
}

// Write calls WriteFunc.
func (mock *CacheMultiStoreMock) Write() {
	if mock.WriteFunc == nil {
		panic("CacheMultiStoreMock.WriteFunc: method is nil but CacheMultiStore.Write was just called")
	}
	callInfo := struct {
	}{}
	mock.lockWrite.Lock()
	mock.calls.Write = append(mock.calls.Write, callInfo)
	mock.lockWrite.Unlock()
	mock.WriteFunc()
}

// WriteCalls gets all the calls that were made to Write.
// Check the length with:
//
//	len(mockedCacheMultiStore.WriteCalls())
func (mock *CacheMultiStoreMock) WriteCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockWrite.RLock()
	calls = mock.calls.Write
	mock.lockWrite.RUnlock()
	return calls
}

// Ensure, that KVStoreMock does implement interfaces.KVStore.
// If this is not the case, regenerate this file with moq.
var _ interfaces.KVStore = &KVStoreMock{}

// KVStoreMock is a mock implementation of interfaces.KVStore.
//
//	func TestSomethingThatUsesKVStore(t *testing.T) {
//
//		// make and configure a mocked interfaces.KVStore
//		mockedKVStore := &KVStoreMock{
//			CacheWrapFunc: func() types.CacheWrap {
//				panic("mock out the CacheWrap method")
//			},
//			CacheWrapWithTraceFunc: func(w io.Writer, tc types.TraceContext) types.CacheWrap {
//				panic("mock out the CacheWrapWithTrace method")
//			},
//			DeleteFunc: func(key []byte)  {
//				panic("mock out the Delete method")
//			},
//			GetFunc: func(key []byte) []byte {
//				panic("mock out the Get method")
//			},
//			GetStoreTypeFunc: func() types.StoreType {
//				panic("mock out the GetStoreType method")
//			},
//			HasFunc: func(key []byte) bool {
//				panic("mock out the Has method")
//			},
//			IteratorFunc: func(start []byte, end []byte) db.Iterator {
//				panic("mock out the Iterator method")
//			},
//			ReverseIteratorFunc: func(start []byte, end []byte) db.Iterator {
//				panic("mock out the ReverseIterator method")
//			},
//			SetFunc: func(key []byte, value []byte)  {
//				panic("mock out the Set method")
//			},
//		}
//
//		// use mockedKVStore in code that requires interfaces.KVStore
//		// and then make assertions.
//
//	}
type KVStoreMock struct {
	// CacheWrapFunc mocks the CacheWrap method.
	CacheWrapFunc func() types.CacheWrap

	// CacheWrapWithTraceFunc mocks the CacheWrapWithTrace method.
	CacheWrapWithTraceFunc func(w io.Writer, tc types.TraceContext) types.CacheWrap

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(key []byte)

	// GetFunc mocks the Get method.
	GetFunc func(key []byte) []byte

	// GetStoreTypeFunc mocks the GetStoreType method.
	GetStoreTypeFunc func() types.StoreType

	// HasFunc mocks the Has method.
	HasFunc func(key []byte) bool

	// IteratorFunc mocks the Iterator method.
	IteratorFunc func(start []byte, end []byte) db.Iterator

	// ReverseIteratorFunc mocks the ReverseIterator method.
	ReverseIteratorFunc func(start []byte, end []byte) db.Iterator

	// SetFunc mocks the Set method.
	SetFunc func(key []byte, value []byte)

	// calls tracks calls to the methods.
	calls struct {
		// CacheWrap holds details about calls to the CacheWrap method.
		CacheWrap []struct {
		}
		// CacheWrapWithTrace holds details about calls to the CacheWrapWithTrace method.
		CacheWrapWithTrace []struct {
			// W is the w argument value.
			W io.Writer
			// Tc is the tc argument value.
			Tc types.TraceContext
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Key is the key argument value.
			Key []byte
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Key is the key argument value.
			Key []byte
		}
		// GetStoreType holds details about calls to the GetStoreType method.
		GetStoreType []struct {
		}
		// Has holds details about calls to the Has method.
		Has []struct {
			// Key is the key argument value.
			Key []byte
		}
		// Iterator holds details about calls to the Iterator method.
		Iterator []struct {
			// Start is the start argument value.
			Start []byte
			// End is the end argument value.
			End []byte
		}
		// ReverseIterator holds details about calls to the ReverseIterator method.
		ReverseIterator []struct {
			// Start is the start argument value.
			Start []byte
			// End is the end argument value.
			End []byte
		}
		// Set holds details about calls to the Set method.
		Set []struct {
			// Key is the key argument value.
			Key []byte
			// Value is the value argument value.
			Value []byte
		}
	}
	lockCacheWrap          sync.RWMutex
	lockCacheWrapWithTrace sync.RWMutex
	lockDelete             sync.RWMutex
	lockGet                sync.RWMutex
	lockGetStoreType       sync.RWMutex
	lockHas                sync.RWMutex
	lockIterator           sync.RWMutex
	lockReverseIterator    sync.RWMutex
	lockSet                sync.RWMutex
}

// CacheWrap calls CacheWrapFunc.
func (mock *KVStoreMock) CacheWrap() types.CacheWrap {
	if mock.CacheWrapFunc == nil {
		panic("KVStoreMock.CacheWrapFunc: method is nil but KVStore.CacheWrap was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCacheWrap.Lock()
	mock.calls.CacheWrap = append(mock.calls.CacheWrap, callInfo)
	mock.lockCacheWrap.Unlock()
	return mock.CacheWrapFunc()
}

// CacheWrapCalls gets all the calls that were made to CacheWrap.
// Check the length with:
//
//	len(mockedKVStore.CacheWrapCalls())
func (mock *KVStoreMock) CacheWrapCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCacheWrap.RLock()
	calls = mock.calls.CacheWrap
	mock.lockCacheWrap.RUnlock()
	return calls
}

// CacheWrapWithTrace calls CacheWrapWithTraceFunc.
func (mock *KVStoreMock) CacheWrapWithTrace(w io.Writer, tc types.TraceContext) types.CacheWrap {
	if mock.CacheWrapWithTraceFunc == nil {
		panic("KVStoreMock.CacheWrapWithTraceFunc: method is nil but KVStore.CacheWrapWithTrace was just called")
	}
	callInfo := struct {
		W  io.Writer
		Tc types.TraceContext
	}{
		W:  w,
		Tc: tc,
	}
	mock.lockCacheWrapWithTrace.Lock()
	mock.calls.CacheWrapWithTrace = append(mock.calls.CacheWrapWithTrace, callInfo)
	mock.lockCacheWrapWithTrace.Unlock()
	return mock.CacheWrapWithTraceFunc(w, tc)
}

// CacheWrapWithTraceCalls gets all the calls that were made to CacheWrapWithTrace.
// Check the length with:
//
//	len(mockedKVStore.CacheWrapWithTraceCalls())
func (mock *KVStoreMock) CacheWrapWithTraceCalls() []struct {
	W  io.Writer
	Tc types.TraceContext
} {
	var calls []struct {
		W  io.Writer
		Tc types.TraceContext
	}
	mock.lockCacheWrapWithTrace.RLock()
	calls = mock.calls.CacheWrapWithTrace
	mock.lockCacheWrapWithTrace.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *KVStoreMock) Delete(key []byte) {
	if mock.DeleteFunc == nil {
		panic("KVStoreMock.DeleteFunc: method is nil but KVStore.Delete was just called")
	}
	callInfo := struct {
		Key []byte
	}{
		Key: key,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	mock.DeleteFunc(key)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedKVStore.DeleteCalls())
func (mock *KVStoreMock) DeleteCalls() []struct {
	Key []byte
} {
	var calls []struct {
		Key []byte
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *KVStoreMock) Get(key []byte) []byte {
	if mock.GetFunc == nil {
		panic("KVStoreMock.GetFunc: method is nil but KVStore.Get was just called")
	}
	callInfo := struct {
		Key []byte
	}{
		Key: key,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(key)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedKVStore.GetCalls())
func (mock *KVStoreMock) GetCalls() []struct {
	Key []byte
} {
	var calls []struct {
		Key []byte
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// GetStoreType calls GetStoreTypeFunc.
func (mock *KVStoreMock) GetStoreType() types.StoreType {
	if mock.GetStoreTypeFunc == nil {
		panic("KVStoreMock.GetStoreTypeFunc: method is nil but KVStore.GetStoreType was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetStoreType.Lock()
	mock.calls.GetStoreType = append(mock.calls.GetStoreType, callInfo)
	mock.lockGetStoreType.Unlock()
	return mock.GetStoreTypeFunc()
}

// GetStoreTypeCalls gets all the calls that were made to GetStoreType.
// Check the length with:
//
//	len(mockedKVStore.GetStoreTypeCalls())
func (mock *KVStoreMock) GetStoreTypeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetStoreType.RLock()
	calls = mock.calls.GetStoreType
	mock.lockGetStoreType.RUnlock()
	return calls
}

// Has calls HasFunc.
func (mock *KVStoreMock) Has(key []byte) bool {
	if mock.HasFunc == nil {
		panic("KVStoreMock.HasFunc: method is nil but KVStore.Has was just called")
	}
	callInfo := struct {
		Key []byte
	}{
		Key: key,
	}
	mock.lockHas.Lock()
	mock.calls.Has = append(mock.calls.Has, callInfo)
	mock.lockHas.Unlock()
	return mock.HasFunc(key)
}

// HasCalls gets all the calls that were made to Has.
// Check the length with:
//
//	len(mockedKVStore.HasCalls())
func (mock *KVStoreMock) HasCalls() []struct {
	Key []byte
} {
	var calls []struct {
		Key []byte
	}
	mock.lockHas.RLock()
	calls = mock.calls.Has
	mock.lockHas.RUnlock()
	return calls
}

// Iterator calls IteratorFunc.
func (mock *KVStoreMock) Iterator(start []byte, end []byte) db.Iterator {
	if mock.IteratorFunc == nil {
		panic("KVStoreMock.IteratorFunc: method is nil but KVStore.Iterator was just called")
	}
	callInfo := struct {
		Start []byte
		End   []byte
	}{
		Start: start,
		End:   end,
	}
	mock.lockIterator.Lock()
	mock.calls.Iterator = append(mock.calls.Iterator, callInfo)
	mock.lockIterator.Unlock()
	return mock.IteratorFunc(start, end)
}

// IteratorCalls gets all the calls that were made to Iterator.
// Check the length with:
//
//	len(mockedKVStore.IteratorCalls())
func (mock *KVStoreMock) IteratorCalls() []struct {
	Start []byte
	End   []byte
} {
	var calls []struct {
		Start []byte
		End   []byte
	}
	mock.lockIterator.RLock()
	calls = mock.calls.Iterator
	mock.lockIterator.RUnlock()
	return calls
}

// ReverseIterator calls ReverseIteratorFunc.
func (mock *KVStoreMock) ReverseIterator(start []byte, end []byte) db.Iterator {
	if mock.ReverseIteratorFunc == nil {
		panic("KVStoreMock.ReverseIteratorFunc: method is nil but KVStore.ReverseIterator was just called")
	}
	callInfo := struct {
		Start []byte
		End   []byte
	}{
		Start: start,
		End:   end,
	}
	mock.lockReverseIterator.Lock()
	mock.calls.ReverseIterator = append(mock.calls.ReverseIterator, callInfo)
	mock.lockReverseIterator.Unlock()
	return mock.ReverseIteratorFunc(start, end)
}

// ReverseIteratorCalls gets all the calls that were made to ReverseIterator.
// Check the length with:
//
//	len(mockedKVStore.ReverseIteratorCalls())
func (mock *KVStoreMock) ReverseIteratorCalls() []struct {
	Start []byte
	End   []byte
} {
	var calls []struct {
		Start []byte
		End   []byte
	}
	mock.lockReverseIterator.RLock()
	calls = mock.calls.ReverseIterator
	mock.lockReverseIterator.RUnlock()
	return calls
}

// Set calls SetFunc.
func (mock *KVStoreMock) Set(key []byte, value []byte) {
	if mock.SetFunc == nil {
		panic("KVStoreMock.SetFunc: method is nil but KVStore.Set was just called")
	}
	callInfo := struct {
		Key   []byte
		Value []byte
	}{
		Key:   key,
		Value: value,
	}
	mock.lockSet.Lock()
	mock.calls.Set = append(mock.calls.Set, callInfo)
	mock.lockSet.Unlock()
	mock.SetFunc(key, value)
}

// SetCalls gets all the calls that were made to Set.
// Check the length with:
//
//	len(mockedKVStore.SetCalls())
func (mock *KVStoreMock) SetCalls() []struct {
	Key   []byte
	Value []byte
} {
	var calls []struct {
		Key   []byte
		Value []byte
	}
	mock.lockSet.RLock()
	calls = mock.calls.Set
	mock.lockSet.RUnlock()
	return calls
}
