// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"github.com/axelarnetwork/axelar-core/testutils/fake/interfaces"
	"github.com/cosmos/cosmos-sdk/store/types"
	"github.com/tendermint/tm-db"
	"io"
	"sync"
)

// Ensure, that MultiStoreMock does implement interfaces.MultiStore.
// If this is not the case, regenerate this file with moq.
var _ interfaces.MultiStore = &MultiStoreMock{}

// MultiStoreMock is a mock implementation of interfaces.MultiStore.
//
// 	func TestSomethingThatUsesMultiStore(t *testing.T) {
//
// 		// make and configure a mocked interfaces.MultiStore
// 		mockedMultiStore := &MultiStoreMock{
// 			AddListenersFunc: func(key types.StoreKey, listeners []types.WriteListener)  {
// 				panic("mock out the AddListeners method")
// 			},
// 			CacheMultiStoreFunc: func() types.CacheMultiStore {
// 				panic("mock out the CacheMultiStore method")
// 			},
// 			CacheMultiStoreWithVersionFunc: func(version int64) (types.CacheMultiStore, error) {
// 				panic("mock out the CacheMultiStoreWithVersion method")
// 			},
// 			CacheWrapFunc: func() types.CacheWrap {
// 				panic("mock out the CacheWrap method")
// 			},
// 			CacheWrapWithListenersFunc: func(storeKey types.StoreKey, listeners []types.WriteListener) types.CacheWrap {
// 				panic("mock out the CacheWrapWithListeners method")
// 			},
// 			CacheWrapWithTraceFunc: func(w io.Writer, tc types.TraceContext) types.CacheWrap {
// 				panic("mock out the CacheWrapWithTrace method")
// 			},
// 			GetKVStoreFunc: func(storeKey types.StoreKey) types.KVStore {
// 				panic("mock out the GetKVStore method")
// 			},
// 			GetStoreFunc: func(storeKey types.StoreKey) types.Store {
// 				panic("mock out the GetStore method")
// 			},
// 			GetStoreTypeFunc: func() types.StoreType {
// 				panic("mock out the GetStoreType method")
// 			},
// 			ListeningEnabledFunc: func(key types.StoreKey) bool {
// 				panic("mock out the ListeningEnabled method")
// 			},
// 			SetTracerFunc: func(w io.Writer) types.MultiStore {
// 				panic("mock out the SetTracer method")
// 			},
// 			SetTracingContextFunc: func(traceContext types.TraceContext) types.MultiStore {
// 				panic("mock out the SetTracingContext method")
// 			},
// 			TracingEnabledFunc: func() bool {
// 				panic("mock out the TracingEnabled method")
// 			},
// 		}
//
// 		// use mockedMultiStore in code that requires interfaces.MultiStore
// 		// and then make assertions.
//
// 	}
type MultiStoreMock struct {
	// AddListenersFunc mocks the AddListeners method.
	AddListenersFunc func(key types.StoreKey, listeners []types.WriteListener)

	// CacheMultiStoreFunc mocks the CacheMultiStore method.
	CacheMultiStoreFunc func() types.CacheMultiStore

	// CacheMultiStoreWithVersionFunc mocks the CacheMultiStoreWithVersion method.
	CacheMultiStoreWithVersionFunc func(version int64) (types.CacheMultiStore, error)

	// CacheWrapFunc mocks the CacheWrap method.
	CacheWrapFunc func() types.CacheWrap

	// CacheWrapWithListenersFunc mocks the CacheWrapWithListeners method.
	CacheWrapWithListenersFunc func(storeKey types.StoreKey, listeners []types.WriteListener) types.CacheWrap

	// CacheWrapWithTraceFunc mocks the CacheWrapWithTrace method.
	CacheWrapWithTraceFunc func(w io.Writer, tc types.TraceContext) types.CacheWrap

	// GetKVStoreFunc mocks the GetKVStore method.
	GetKVStoreFunc func(storeKey types.StoreKey) types.KVStore

	// GetStoreFunc mocks the GetStore method.
	GetStoreFunc func(storeKey types.StoreKey) types.Store

	// GetStoreTypeFunc mocks the GetStoreType method.
	GetStoreTypeFunc func() types.StoreType

	// ListeningEnabledFunc mocks the ListeningEnabled method.
	ListeningEnabledFunc func(key types.StoreKey) bool

	// SetTracerFunc mocks the SetTracer method.
	SetTracerFunc func(w io.Writer) types.MultiStore

	// SetTracingContextFunc mocks the SetTracingContext method.
	SetTracingContextFunc func(traceContext types.TraceContext) types.MultiStore

	// TracingEnabledFunc mocks the TracingEnabled method.
	TracingEnabledFunc func() bool

	// calls tracks calls to the methods.
	calls struct {
		// AddListeners holds details about calls to the AddListeners method.
		AddListeners []struct {
			// Key is the key argument value.
			Key types.StoreKey
			// Listeners is the listeners argument value.
			Listeners []types.WriteListener
		}
		// CacheMultiStore holds details about calls to the CacheMultiStore method.
		CacheMultiStore []struct {
		}
		// CacheMultiStoreWithVersion holds details about calls to the CacheMultiStoreWithVersion method.
		CacheMultiStoreWithVersion []struct {
			// Version is the version argument value.
			Version int64
		}
		// CacheWrap holds details about calls to the CacheWrap method.
		CacheWrap []struct {
		}
		// CacheWrapWithListeners holds details about calls to the CacheWrapWithListeners method.
		CacheWrapWithListeners []struct {
			// StoreKey is the storeKey argument value.
			StoreKey types.StoreKey
			// Listeners is the listeners argument value.
			Listeners []types.WriteListener
		}
		// CacheWrapWithTrace holds details about calls to the CacheWrapWithTrace method.
		CacheWrapWithTrace []struct {
			// W is the w argument value.
			W io.Writer
			// Tc is the tc argument value.
			Tc types.TraceContext
		}
		// GetKVStore holds details about calls to the GetKVStore method.
		GetKVStore []struct {
			// StoreKey is the storeKey argument value.
			StoreKey types.StoreKey
		}
		// GetStore holds details about calls to the GetStore method.
		GetStore []struct {
			// StoreKey is the storeKey argument value.
			StoreKey types.StoreKey
		}
		// GetStoreType holds details about calls to the GetStoreType method.
		GetStoreType []struct {
		}
		// ListeningEnabled holds details about calls to the ListeningEnabled method.
		ListeningEnabled []struct {
			// Key is the key argument value.
			Key types.StoreKey
		}
		// SetTracer holds details about calls to the SetTracer method.
		SetTracer []struct {
			// W is the w argument value.
			W io.Writer
		}
		// SetTracingContext holds details about calls to the SetTracingContext method.
		SetTracingContext []struct {
			// TraceContext is the traceContext argument value.
			TraceContext types.TraceContext
		}
		// TracingEnabled holds details about calls to the TracingEnabled method.
		TracingEnabled []struct {
		}
	}
	lockAddListeners               sync.RWMutex
	lockCacheMultiStore            sync.RWMutex
	lockCacheMultiStoreWithVersion sync.RWMutex
	lockCacheWrap                  sync.RWMutex
	lockCacheWrapWithListeners     sync.RWMutex
	lockCacheWrapWithTrace         sync.RWMutex
	lockGetKVStore                 sync.RWMutex
	lockGetStore                   sync.RWMutex
	lockGetStoreType               sync.RWMutex
	lockListeningEnabled           sync.RWMutex
	lockSetTracer                  sync.RWMutex
	lockSetTracingContext          sync.RWMutex
	lockTracingEnabled             sync.RWMutex
}

// AddListeners calls AddListenersFunc.
func (mock *MultiStoreMock) AddListeners(key types.StoreKey, listeners []types.WriteListener) {
	if mock.AddListenersFunc == nil {
		panic("MultiStoreMock.AddListenersFunc: method is nil but MultiStore.AddListeners was just called")
	}
	callInfo := struct {
		Key       types.StoreKey
		Listeners []types.WriteListener
	}{
		Key:       key,
		Listeners: listeners,
	}
	mock.lockAddListeners.Lock()
	mock.calls.AddListeners = append(mock.calls.AddListeners, callInfo)
	mock.lockAddListeners.Unlock()
	mock.AddListenersFunc(key, listeners)
}

// AddListenersCalls gets all the calls that were made to AddListeners.
// Check the length with:
//     len(mockedMultiStore.AddListenersCalls())
func (mock *MultiStoreMock) AddListenersCalls() []struct {
	Key       types.StoreKey
	Listeners []types.WriteListener
} {
	var calls []struct {
		Key       types.StoreKey
		Listeners []types.WriteListener
	}
	mock.lockAddListeners.RLock()
	calls = mock.calls.AddListeners
	mock.lockAddListeners.RUnlock()
	return calls
}

// CacheMultiStore calls CacheMultiStoreFunc.
func (mock *MultiStoreMock) CacheMultiStore() types.CacheMultiStore {
	if mock.CacheMultiStoreFunc == nil {
		panic("MultiStoreMock.CacheMultiStoreFunc: method is nil but MultiStore.CacheMultiStore was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCacheMultiStore.Lock()
	mock.calls.CacheMultiStore = append(mock.calls.CacheMultiStore, callInfo)
	mock.lockCacheMultiStore.Unlock()
	return mock.CacheMultiStoreFunc()
}

// CacheMultiStoreCalls gets all the calls that were made to CacheMultiStore.
// Check the length with:
//     len(mockedMultiStore.CacheMultiStoreCalls())
func (mock *MultiStoreMock) CacheMultiStoreCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCacheMultiStore.RLock()
	calls = mock.calls.CacheMultiStore
	mock.lockCacheMultiStore.RUnlock()
	return calls
}

// CacheMultiStoreWithVersion calls CacheMultiStoreWithVersionFunc.
func (mock *MultiStoreMock) CacheMultiStoreWithVersion(version int64) (types.CacheMultiStore, error) {
	if mock.CacheMultiStoreWithVersionFunc == nil {
		panic("MultiStoreMock.CacheMultiStoreWithVersionFunc: method is nil but MultiStore.CacheMultiStoreWithVersion was just called")
	}
	callInfo := struct {
		Version int64
	}{
		Version: version,
	}
	mock.lockCacheMultiStoreWithVersion.Lock()
	mock.calls.CacheMultiStoreWithVersion = append(mock.calls.CacheMultiStoreWithVersion, callInfo)
	mock.lockCacheMultiStoreWithVersion.Unlock()
	return mock.CacheMultiStoreWithVersionFunc(version)
}

// CacheMultiStoreWithVersionCalls gets all the calls that were made to CacheMultiStoreWithVersion.
// Check the length with:
//     len(mockedMultiStore.CacheMultiStoreWithVersionCalls())
func (mock *MultiStoreMock) CacheMultiStoreWithVersionCalls() []struct {
	Version int64
} {
	var calls []struct {
		Version int64
	}
	mock.lockCacheMultiStoreWithVersion.RLock()
	calls = mock.calls.CacheMultiStoreWithVersion
	mock.lockCacheMultiStoreWithVersion.RUnlock()
	return calls
}

// CacheWrap calls CacheWrapFunc.
func (mock *MultiStoreMock) CacheWrap() types.CacheWrap {
	if mock.CacheWrapFunc == nil {
		panic("MultiStoreMock.CacheWrapFunc: method is nil but MultiStore.CacheWrap was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCacheWrap.Lock()
	mock.calls.CacheWrap = append(mock.calls.CacheWrap, callInfo)
	mock.lockCacheWrap.Unlock()
	return mock.CacheWrapFunc()
}

// CacheWrapCalls gets all the calls that were made to CacheWrap.
// Check the length with:
//     len(mockedMultiStore.CacheWrapCalls())
func (mock *MultiStoreMock) CacheWrapCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCacheWrap.RLock()
	calls = mock.calls.CacheWrap
	mock.lockCacheWrap.RUnlock()
	return calls
}

// CacheWrapWithListeners calls CacheWrapWithListenersFunc.
func (mock *MultiStoreMock) CacheWrapWithListeners(storeKey types.StoreKey, listeners []types.WriteListener) types.CacheWrap {
	if mock.CacheWrapWithListenersFunc == nil {
		panic("MultiStoreMock.CacheWrapWithListenersFunc: method is nil but MultiStore.CacheWrapWithListeners was just called")
	}
	callInfo := struct {
		StoreKey  types.StoreKey
		Listeners []types.WriteListener
	}{
		StoreKey:  storeKey,
		Listeners: listeners,
	}
	mock.lockCacheWrapWithListeners.Lock()
	mock.calls.CacheWrapWithListeners = append(mock.calls.CacheWrapWithListeners, callInfo)
	mock.lockCacheWrapWithListeners.Unlock()
	return mock.CacheWrapWithListenersFunc(storeKey, listeners)
}

// CacheWrapWithListenersCalls gets all the calls that were made to CacheWrapWithListeners.
// Check the length with:
//     len(mockedMultiStore.CacheWrapWithListenersCalls())
func (mock *MultiStoreMock) CacheWrapWithListenersCalls() []struct {
	StoreKey  types.StoreKey
	Listeners []types.WriteListener
} {
	var calls []struct {
		StoreKey  types.StoreKey
		Listeners []types.WriteListener
	}
	mock.lockCacheWrapWithListeners.RLock()
	calls = mock.calls.CacheWrapWithListeners
	mock.lockCacheWrapWithListeners.RUnlock()
	return calls
}

// CacheWrapWithTrace calls CacheWrapWithTraceFunc.
func (mock *MultiStoreMock) CacheWrapWithTrace(w io.Writer, tc types.TraceContext) types.CacheWrap {
	if mock.CacheWrapWithTraceFunc == nil {
		panic("MultiStoreMock.CacheWrapWithTraceFunc: method is nil but MultiStore.CacheWrapWithTrace was just called")
	}
	callInfo := struct {
		W  io.Writer
		Tc types.TraceContext
	}{
		W:  w,
		Tc: tc,
	}
	mock.lockCacheWrapWithTrace.Lock()
	mock.calls.CacheWrapWithTrace = append(mock.calls.CacheWrapWithTrace, callInfo)
	mock.lockCacheWrapWithTrace.Unlock()
	return mock.CacheWrapWithTraceFunc(w, tc)
}

// CacheWrapWithTraceCalls gets all the calls that were made to CacheWrapWithTrace.
// Check the length with:
//     len(mockedMultiStore.CacheWrapWithTraceCalls())
func (mock *MultiStoreMock) CacheWrapWithTraceCalls() []struct {
	W  io.Writer
	Tc types.TraceContext
} {
	var calls []struct {
		W  io.Writer
		Tc types.TraceContext
	}
	mock.lockCacheWrapWithTrace.RLock()
	calls = mock.calls.CacheWrapWithTrace
	mock.lockCacheWrapWithTrace.RUnlock()
	return calls
}

// GetKVStore calls GetKVStoreFunc.
func (mock *MultiStoreMock) GetKVStore(storeKey types.StoreKey) types.KVStore {
	if mock.GetKVStoreFunc == nil {
		panic("MultiStoreMock.GetKVStoreFunc: method is nil but MultiStore.GetKVStore was just called")
	}
	callInfo := struct {
		StoreKey types.StoreKey
	}{
		StoreKey: storeKey,
	}
	mock.lockGetKVStore.Lock()
	mock.calls.GetKVStore = append(mock.calls.GetKVStore, callInfo)
	mock.lockGetKVStore.Unlock()
	return mock.GetKVStoreFunc(storeKey)
}

// GetKVStoreCalls gets all the calls that were made to GetKVStore.
// Check the length with:
//     len(mockedMultiStore.GetKVStoreCalls())
func (mock *MultiStoreMock) GetKVStoreCalls() []struct {
	StoreKey types.StoreKey
} {
	var calls []struct {
		StoreKey types.StoreKey
	}
	mock.lockGetKVStore.RLock()
	calls = mock.calls.GetKVStore
	mock.lockGetKVStore.RUnlock()
	return calls
}

// GetStore calls GetStoreFunc.
func (mock *MultiStoreMock) GetStore(storeKey types.StoreKey) types.Store {
	if mock.GetStoreFunc == nil {
		panic("MultiStoreMock.GetStoreFunc: method is nil but MultiStore.GetStore was just called")
	}
	callInfo := struct {
		StoreKey types.StoreKey
	}{
		StoreKey: storeKey,
	}
	mock.lockGetStore.Lock()
	mock.calls.GetStore = append(mock.calls.GetStore, callInfo)
	mock.lockGetStore.Unlock()
	return mock.GetStoreFunc(storeKey)
}

// GetStoreCalls gets all the calls that were made to GetStore.
// Check the length with:
//     len(mockedMultiStore.GetStoreCalls())
func (mock *MultiStoreMock) GetStoreCalls() []struct {
	StoreKey types.StoreKey
} {
	var calls []struct {
		StoreKey types.StoreKey
	}
	mock.lockGetStore.RLock()
	calls = mock.calls.GetStore
	mock.lockGetStore.RUnlock()
	return calls
}

// GetStoreType calls GetStoreTypeFunc.
func (mock *MultiStoreMock) GetStoreType() types.StoreType {
	if mock.GetStoreTypeFunc == nil {
		panic("MultiStoreMock.GetStoreTypeFunc: method is nil but MultiStore.GetStoreType was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetStoreType.Lock()
	mock.calls.GetStoreType = append(mock.calls.GetStoreType, callInfo)
	mock.lockGetStoreType.Unlock()
	return mock.GetStoreTypeFunc()
}

// GetStoreTypeCalls gets all the calls that were made to GetStoreType.
// Check the length with:
//     len(mockedMultiStore.GetStoreTypeCalls())
func (mock *MultiStoreMock) GetStoreTypeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetStoreType.RLock()
	calls = mock.calls.GetStoreType
	mock.lockGetStoreType.RUnlock()
	return calls
}

// ListeningEnabled calls ListeningEnabledFunc.
func (mock *MultiStoreMock) ListeningEnabled(key types.StoreKey) bool {
	if mock.ListeningEnabledFunc == nil {
		panic("MultiStoreMock.ListeningEnabledFunc: method is nil but MultiStore.ListeningEnabled was just called")
	}
	callInfo := struct {
		Key types.StoreKey
	}{
		Key: key,
	}
	mock.lockListeningEnabled.Lock()
	mock.calls.ListeningEnabled = append(mock.calls.ListeningEnabled, callInfo)
	mock.lockListeningEnabled.Unlock()
	return mock.ListeningEnabledFunc(key)
}

// ListeningEnabledCalls gets all the calls that were made to ListeningEnabled.
// Check the length with:
//     len(mockedMultiStore.ListeningEnabledCalls())
func (mock *MultiStoreMock) ListeningEnabledCalls() []struct {
	Key types.StoreKey
} {
	var calls []struct {
		Key types.StoreKey
	}
	mock.lockListeningEnabled.RLock()
	calls = mock.calls.ListeningEnabled
	mock.lockListeningEnabled.RUnlock()
	return calls
}

// SetTracer calls SetTracerFunc.
func (mock *MultiStoreMock) SetTracer(w io.Writer) types.MultiStore {
	if mock.SetTracerFunc == nil {
		panic("MultiStoreMock.SetTracerFunc: method is nil but MultiStore.SetTracer was just called")
	}
	callInfo := struct {
		W io.Writer
	}{
		W: w,
	}
	mock.lockSetTracer.Lock()
	mock.calls.SetTracer = append(mock.calls.SetTracer, callInfo)
	mock.lockSetTracer.Unlock()
	return mock.SetTracerFunc(w)
}

// SetTracerCalls gets all the calls that were made to SetTracer.
// Check the length with:
//     len(mockedMultiStore.SetTracerCalls())
func (mock *MultiStoreMock) SetTracerCalls() []struct {
	W io.Writer
} {
	var calls []struct {
		W io.Writer
	}
	mock.lockSetTracer.RLock()
	calls = mock.calls.SetTracer
	mock.lockSetTracer.RUnlock()
	return calls
}

// SetTracingContext calls SetTracingContextFunc.
func (mock *MultiStoreMock) SetTracingContext(traceContext types.TraceContext) types.MultiStore {
	if mock.SetTracingContextFunc == nil {
		panic("MultiStoreMock.SetTracingContextFunc: method is nil but MultiStore.SetTracingContext was just called")
	}
	callInfo := struct {
		TraceContext types.TraceContext
	}{
		TraceContext: traceContext,
	}
	mock.lockSetTracingContext.Lock()
	mock.calls.SetTracingContext = append(mock.calls.SetTracingContext, callInfo)
	mock.lockSetTracingContext.Unlock()
	return mock.SetTracingContextFunc(traceContext)
}

// SetTracingContextCalls gets all the calls that were made to SetTracingContext.
// Check the length with:
//     len(mockedMultiStore.SetTracingContextCalls())
func (mock *MultiStoreMock) SetTracingContextCalls() []struct {
	TraceContext types.TraceContext
} {
	var calls []struct {
		TraceContext types.TraceContext
	}
	mock.lockSetTracingContext.RLock()
	calls = mock.calls.SetTracingContext
	mock.lockSetTracingContext.RUnlock()
	return calls
}

// TracingEnabled calls TracingEnabledFunc.
func (mock *MultiStoreMock) TracingEnabled() bool {
	if mock.TracingEnabledFunc == nil {
		panic("MultiStoreMock.TracingEnabledFunc: method is nil but MultiStore.TracingEnabled was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTracingEnabled.Lock()
	mock.calls.TracingEnabled = append(mock.calls.TracingEnabled, callInfo)
	mock.lockTracingEnabled.Unlock()
	return mock.TracingEnabledFunc()
}

// TracingEnabledCalls gets all the calls that were made to TracingEnabled.
// Check the length with:
//     len(mockedMultiStore.TracingEnabledCalls())
func (mock *MultiStoreMock) TracingEnabledCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTracingEnabled.RLock()
	calls = mock.calls.TracingEnabled
	mock.lockTracingEnabled.RUnlock()
	return calls
}

// Ensure, that KVStoreMock does implement interfaces.KVStore.
// If this is not the case, regenerate this file with moq.
var _ interfaces.KVStore = &KVStoreMock{}

// KVStoreMock is a mock implementation of interfaces.KVStore.
//
// 	func TestSomethingThatUsesKVStore(t *testing.T) {
//
// 		// make and configure a mocked interfaces.KVStore
// 		mockedKVStore := &KVStoreMock{
// 			CacheWrapFunc: func() types.CacheWrap {
// 				panic("mock out the CacheWrap method")
// 			},
// 			CacheWrapWithListenersFunc: func(storeKey types.StoreKey, listeners []types.WriteListener) types.CacheWrap {
// 				panic("mock out the CacheWrapWithListeners method")
// 			},
// 			CacheWrapWithTraceFunc: func(w io.Writer, tc types.TraceContext) types.CacheWrap {
// 				panic("mock out the CacheWrapWithTrace method")
// 			},
// 			DeleteFunc: func(key []byte)  {
// 				panic("mock out the Delete method")
// 			},
// 			GetFunc: func(key []byte) []byte {
// 				panic("mock out the Get method")
// 			},
// 			GetStoreTypeFunc: func() types.StoreType {
// 				panic("mock out the GetStoreType method")
// 			},
// 			HasFunc: func(key []byte) bool {
// 				panic("mock out the Has method")
// 			},
// 			IteratorFunc: func(start []byte, end []byte) db.Iterator {
// 				panic("mock out the Iterator method")
// 			},
// 			ReverseIteratorFunc: func(start []byte, end []byte) db.Iterator {
// 				panic("mock out the ReverseIterator method")
// 			},
// 			SetFunc: func(key []byte, value []byte)  {
// 				panic("mock out the Set method")
// 			},
// 		}
//
// 		// use mockedKVStore in code that requires interfaces.KVStore
// 		// and then make assertions.
//
// 	}
type KVStoreMock struct {
	// CacheWrapFunc mocks the CacheWrap method.
	CacheWrapFunc func() types.CacheWrap

	// CacheWrapWithListenersFunc mocks the CacheWrapWithListeners method.
	CacheWrapWithListenersFunc func(storeKey types.StoreKey, listeners []types.WriteListener) types.CacheWrap

	// CacheWrapWithTraceFunc mocks the CacheWrapWithTrace method.
	CacheWrapWithTraceFunc func(w io.Writer, tc types.TraceContext) types.CacheWrap

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(key []byte)

	// GetFunc mocks the Get method.
	GetFunc func(key []byte) []byte

	// GetStoreTypeFunc mocks the GetStoreType method.
	GetStoreTypeFunc func() types.StoreType

	// HasFunc mocks the Has method.
	HasFunc func(key []byte) bool

	// IteratorFunc mocks the Iterator method.
	IteratorFunc func(start []byte, end []byte) db.Iterator

	// ReverseIteratorFunc mocks the ReverseIterator method.
	ReverseIteratorFunc func(start []byte, end []byte) db.Iterator

	// SetFunc mocks the Set method.
	SetFunc func(key []byte, value []byte)

	// calls tracks calls to the methods.
	calls struct {
		// CacheWrap holds details about calls to the CacheWrap method.
		CacheWrap []struct {
		}
		// CacheWrapWithListeners holds details about calls to the CacheWrapWithListeners method.
		CacheWrapWithListeners []struct {
			// StoreKey is the storeKey argument value.
			StoreKey types.StoreKey
			// Listeners is the listeners argument value.
			Listeners []types.WriteListener
		}
		// CacheWrapWithTrace holds details about calls to the CacheWrapWithTrace method.
		CacheWrapWithTrace []struct {
			// W is the w argument value.
			W io.Writer
			// Tc is the tc argument value.
			Tc types.TraceContext
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Key is the key argument value.
			Key []byte
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Key is the key argument value.
			Key []byte
		}
		// GetStoreType holds details about calls to the GetStoreType method.
		GetStoreType []struct {
		}
		// Has holds details about calls to the Has method.
		Has []struct {
			// Key is the key argument value.
			Key []byte
		}
		// Iterator holds details about calls to the Iterator method.
		Iterator []struct {
			// Start is the start argument value.
			Start []byte
			// End is the end argument value.
			End []byte
		}
		// ReverseIterator holds details about calls to the ReverseIterator method.
		ReverseIterator []struct {
			// Start is the start argument value.
			Start []byte
			// End is the end argument value.
			End []byte
		}
		// Set holds details about calls to the Set method.
		Set []struct {
			// Key is the key argument value.
			Key []byte
			// Value is the value argument value.
			Value []byte
		}
	}
	lockCacheWrap              sync.RWMutex
	lockCacheWrapWithListeners sync.RWMutex
	lockCacheWrapWithTrace     sync.RWMutex
	lockDelete                 sync.RWMutex
	lockGet                    sync.RWMutex
	lockGetStoreType           sync.RWMutex
	lockHas                    sync.RWMutex
	lockIterator               sync.RWMutex
	lockReverseIterator        sync.RWMutex
	lockSet                    sync.RWMutex
}

// CacheWrap calls CacheWrapFunc.
func (mock *KVStoreMock) CacheWrap() types.CacheWrap {
	if mock.CacheWrapFunc == nil {
		panic("KVStoreMock.CacheWrapFunc: method is nil but KVStore.CacheWrap was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCacheWrap.Lock()
	mock.calls.CacheWrap = append(mock.calls.CacheWrap, callInfo)
	mock.lockCacheWrap.Unlock()
	return mock.CacheWrapFunc()
}

// CacheWrapCalls gets all the calls that were made to CacheWrap.
// Check the length with:
//     len(mockedKVStore.CacheWrapCalls())
func (mock *KVStoreMock) CacheWrapCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCacheWrap.RLock()
	calls = mock.calls.CacheWrap
	mock.lockCacheWrap.RUnlock()
	return calls
}

// CacheWrapWithListeners calls CacheWrapWithListenersFunc.
func (mock *KVStoreMock) CacheWrapWithListeners(storeKey types.StoreKey, listeners []types.WriteListener) types.CacheWrap {
	if mock.CacheWrapWithListenersFunc == nil {
		panic("KVStoreMock.CacheWrapWithListenersFunc: method is nil but KVStore.CacheWrapWithListeners was just called")
	}
	callInfo := struct {
		StoreKey  types.StoreKey
		Listeners []types.WriteListener
	}{
		StoreKey:  storeKey,
		Listeners: listeners,
	}
	mock.lockCacheWrapWithListeners.Lock()
	mock.calls.CacheWrapWithListeners = append(mock.calls.CacheWrapWithListeners, callInfo)
	mock.lockCacheWrapWithListeners.Unlock()
	return mock.CacheWrapWithListenersFunc(storeKey, listeners)
}

// CacheWrapWithListenersCalls gets all the calls that were made to CacheWrapWithListeners.
// Check the length with:
//     len(mockedKVStore.CacheWrapWithListenersCalls())
func (mock *KVStoreMock) CacheWrapWithListenersCalls() []struct {
	StoreKey  types.StoreKey
	Listeners []types.WriteListener
} {
	var calls []struct {
		StoreKey  types.StoreKey
		Listeners []types.WriteListener
	}
	mock.lockCacheWrapWithListeners.RLock()
	calls = mock.calls.CacheWrapWithListeners
	mock.lockCacheWrapWithListeners.RUnlock()
	return calls
}

// CacheWrapWithTrace calls CacheWrapWithTraceFunc.
func (mock *KVStoreMock) CacheWrapWithTrace(w io.Writer, tc types.TraceContext) types.CacheWrap {
	if mock.CacheWrapWithTraceFunc == nil {
		panic("KVStoreMock.CacheWrapWithTraceFunc: method is nil but KVStore.CacheWrapWithTrace was just called")
	}
	callInfo := struct {
		W  io.Writer
		Tc types.TraceContext
	}{
		W:  w,
		Tc: tc,
	}
	mock.lockCacheWrapWithTrace.Lock()
	mock.calls.CacheWrapWithTrace = append(mock.calls.CacheWrapWithTrace, callInfo)
	mock.lockCacheWrapWithTrace.Unlock()
	return mock.CacheWrapWithTraceFunc(w, tc)
}

// CacheWrapWithTraceCalls gets all the calls that were made to CacheWrapWithTrace.
// Check the length with:
//     len(mockedKVStore.CacheWrapWithTraceCalls())
func (mock *KVStoreMock) CacheWrapWithTraceCalls() []struct {
	W  io.Writer
	Tc types.TraceContext
} {
	var calls []struct {
		W  io.Writer
		Tc types.TraceContext
	}
	mock.lockCacheWrapWithTrace.RLock()
	calls = mock.calls.CacheWrapWithTrace
	mock.lockCacheWrapWithTrace.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *KVStoreMock) Delete(key []byte) {
	if mock.DeleteFunc == nil {
		panic("KVStoreMock.DeleteFunc: method is nil but KVStore.Delete was just called")
	}
	callInfo := struct {
		Key []byte
	}{
		Key: key,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	mock.DeleteFunc(key)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//     len(mockedKVStore.DeleteCalls())
func (mock *KVStoreMock) DeleteCalls() []struct {
	Key []byte
} {
	var calls []struct {
		Key []byte
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *KVStoreMock) Get(key []byte) []byte {
	if mock.GetFunc == nil {
		panic("KVStoreMock.GetFunc: method is nil but KVStore.Get was just called")
	}
	callInfo := struct {
		Key []byte
	}{
		Key: key,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(key)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//     len(mockedKVStore.GetCalls())
func (mock *KVStoreMock) GetCalls() []struct {
	Key []byte
} {
	var calls []struct {
		Key []byte
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// GetStoreType calls GetStoreTypeFunc.
func (mock *KVStoreMock) GetStoreType() types.StoreType {
	if mock.GetStoreTypeFunc == nil {
		panic("KVStoreMock.GetStoreTypeFunc: method is nil but KVStore.GetStoreType was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetStoreType.Lock()
	mock.calls.GetStoreType = append(mock.calls.GetStoreType, callInfo)
	mock.lockGetStoreType.Unlock()
	return mock.GetStoreTypeFunc()
}

// GetStoreTypeCalls gets all the calls that were made to GetStoreType.
// Check the length with:
//     len(mockedKVStore.GetStoreTypeCalls())
func (mock *KVStoreMock) GetStoreTypeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetStoreType.RLock()
	calls = mock.calls.GetStoreType
	mock.lockGetStoreType.RUnlock()
	return calls
}

// Has calls HasFunc.
func (mock *KVStoreMock) Has(key []byte) bool {
	if mock.HasFunc == nil {
		panic("KVStoreMock.HasFunc: method is nil but KVStore.Has was just called")
	}
	callInfo := struct {
		Key []byte
	}{
		Key: key,
	}
	mock.lockHas.Lock()
	mock.calls.Has = append(mock.calls.Has, callInfo)
	mock.lockHas.Unlock()
	return mock.HasFunc(key)
}

// HasCalls gets all the calls that were made to Has.
// Check the length with:
//     len(mockedKVStore.HasCalls())
func (mock *KVStoreMock) HasCalls() []struct {
	Key []byte
} {
	var calls []struct {
		Key []byte
	}
	mock.lockHas.RLock()
	calls = mock.calls.Has
	mock.lockHas.RUnlock()
	return calls
}

// Iterator calls IteratorFunc.
func (mock *KVStoreMock) Iterator(start []byte, end []byte) db.Iterator {
	if mock.IteratorFunc == nil {
		panic("KVStoreMock.IteratorFunc: method is nil but KVStore.Iterator was just called")
	}
	callInfo := struct {
		Start []byte
		End   []byte
	}{
		Start: start,
		End:   end,
	}
	mock.lockIterator.Lock()
	mock.calls.Iterator = append(mock.calls.Iterator, callInfo)
	mock.lockIterator.Unlock()
	return mock.IteratorFunc(start, end)
}

// IteratorCalls gets all the calls that were made to Iterator.
// Check the length with:
//     len(mockedKVStore.IteratorCalls())
func (mock *KVStoreMock) IteratorCalls() []struct {
	Start []byte
	End   []byte
} {
	var calls []struct {
		Start []byte
		End   []byte
	}
	mock.lockIterator.RLock()
	calls = mock.calls.Iterator
	mock.lockIterator.RUnlock()
	return calls
}

// ReverseIterator calls ReverseIteratorFunc.
func (mock *KVStoreMock) ReverseIterator(start []byte, end []byte) db.Iterator {
	if mock.ReverseIteratorFunc == nil {
		panic("KVStoreMock.ReverseIteratorFunc: method is nil but KVStore.ReverseIterator was just called")
	}
	callInfo := struct {
		Start []byte
		End   []byte
	}{
		Start: start,
		End:   end,
	}
	mock.lockReverseIterator.Lock()
	mock.calls.ReverseIterator = append(mock.calls.ReverseIterator, callInfo)
	mock.lockReverseIterator.Unlock()
	return mock.ReverseIteratorFunc(start, end)
}

// ReverseIteratorCalls gets all the calls that were made to ReverseIterator.
// Check the length with:
//     len(mockedKVStore.ReverseIteratorCalls())
func (mock *KVStoreMock) ReverseIteratorCalls() []struct {
	Start []byte
	End   []byte
} {
	var calls []struct {
		Start []byte
		End   []byte
	}
	mock.lockReverseIterator.RLock()
	calls = mock.calls.ReverseIterator
	mock.lockReverseIterator.RUnlock()
	return calls
}

// Set calls SetFunc.
func (mock *KVStoreMock) Set(key []byte, value []byte) {
	if mock.SetFunc == nil {
		panic("KVStoreMock.SetFunc: method is nil but KVStore.Set was just called")
	}
	callInfo := struct {
		Key   []byte
		Value []byte
	}{
		Key:   key,
		Value: value,
	}
	mock.lockSet.Lock()
	mock.calls.Set = append(mock.calls.Set, callInfo)
	mock.lockSet.Unlock()
	mock.SetFunc(key, value)
}

// SetCalls gets all the calls that were made to Set.
// Check the length with:
//     len(mockedKVStore.SetCalls())
func (mock *KVStoreMock) SetCalls() []struct {
	Key   []byte
	Value []byte
} {
	var calls []struct {
		Key   []byte
		Value []byte
	}
	mock.lockSet.RLock()
	calls = mock.calls.Set
	mock.lockSet.RUnlock()
	return calls
}
