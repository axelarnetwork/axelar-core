// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"github.com/axelarnetwork/axelar-core/cmd/axelard/cmd/vald/broadcast/types"
	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/cosmos/cosmos-sdk/x/auth/legacy/legacytx"
	coretypes "github.com/tendermint/tendermint/rpc/core/types"
	"sync"
)

// Ensure, that ClientMock does implement types.Client.
// If this is not the case, regenerate this file with moq.
var _ types.Client = &ClientMock{}

// ClientMock is a mock implementation of types.Client.
//
// 	func TestSomethingThatUsesClient(t *testing.T) {
//
// 		// make and configure a mocked types.Client
// 		mockedClient := &ClientMock{
// 			BroadcastTxSyncFunc: func(tx legacytx.StdTx) (*coretypes.ResultBroadcastTx, error) {
// 				panic("mock out the BroadcastTxSync method")
// 			},
// 			GetAccountNumberSequenceFunc: func(addr sdk.AccAddress) (uint64, uint64, error) {
// 				panic("mock out the GetAccountNumberSequence method")
// 			},
// 		}
//
// 		// use mockedClient in code that requires types.Client
// 		// and then make assertions.
//
// 	}
type ClientMock struct {
	// BroadcastTxSyncFunc mocks the BroadcastTxSync method.
	BroadcastTxSyncFunc func(tx legacytx.StdTx) (*coretypes.ResultBroadcastTx, error)

	// GetAccountNumberSequenceFunc mocks the GetAccountNumberSequence method.
	GetAccountNumberSequenceFunc func(addr sdk.AccAddress) (uint64, uint64, error)

	// calls tracks calls to the methods.
	calls struct {
		// BroadcastTxSync holds details about calls to the BroadcastTxSync method.
		BroadcastTxSync []struct {
			// Tx is the tx argument value.
			Tx legacytx.StdTx
		}
		// GetAccountNumberSequence holds details about calls to the GetAccountNumberSequence method.
		GetAccountNumberSequence []struct {
			// Addr is the addr argument value.
			Addr sdk.AccAddress
		}
	}
	lockBroadcastTxSync          sync.RWMutex
	lockGetAccountNumberSequence sync.RWMutex
}

// BroadcastTxSync calls BroadcastTxSyncFunc.
func (mock *ClientMock) BroadcastTxSync(tx legacytx.StdTx) (*coretypes.ResultBroadcastTx, error) {
	callInfo := struct {
		Tx legacytx.StdTx
	}{
		Tx: tx,
	}
	mock.lockBroadcastTxSync.Lock()
	mock.calls.BroadcastTxSync = append(mock.calls.BroadcastTxSync, callInfo)
	mock.lockBroadcastTxSync.Unlock()
	if mock.BroadcastTxSyncFunc == nil {
		var (
			resultBroadcastTxOut *coretypes.ResultBroadcastTx
			errOut               error
		)
		return resultBroadcastTxOut, errOut
	}
	return mock.BroadcastTxSyncFunc(tx)
}

// BroadcastTxSyncCalls gets all the calls that were made to BroadcastTxSync.
// Check the length with:
//     len(mockedClient.BroadcastTxSyncCalls())
func (mock *ClientMock) BroadcastTxSyncCalls() []struct {
	Tx legacytx.StdTx
} {
	var calls []struct {
		Tx legacytx.StdTx
	}
	mock.lockBroadcastTxSync.RLock()
	calls = mock.calls.BroadcastTxSync
	mock.lockBroadcastTxSync.RUnlock()
	return calls
}

// GetAccountNumberSequence calls GetAccountNumberSequenceFunc.
func (mock *ClientMock) GetAccountNumberSequence(addr sdk.AccAddress) (uint64, uint64, error) {
	callInfo := struct {
		Addr sdk.AccAddress
	}{
		Addr: addr,
	}
	mock.lockGetAccountNumberSequence.Lock()
	mock.calls.GetAccountNumberSequence = append(mock.calls.GetAccountNumberSequence, callInfo)
	mock.lockGetAccountNumberSequence.Unlock()
	if mock.GetAccountNumberSequenceFunc == nil {
		var (
			accNumOut uint64
			accSeqOut uint64
			errOut    error
		)
		return accNumOut, accSeqOut, errOut
	}
	return mock.GetAccountNumberSequenceFunc(addr)
}

// GetAccountNumberSequenceCalls gets all the calls that were made to GetAccountNumberSequence.
// Check the length with:
//     len(mockedClient.GetAccountNumberSequenceCalls())
func (mock *ClientMock) GetAccountNumberSequenceCalls() []struct {
	Addr sdk.AccAddress
} {
	var calls []struct {
		Addr sdk.AccAddress
	}
	mock.lockGetAccountNumberSequence.RLock()
	calls = mock.calls.GetAccountNumberSequence
	mock.lockGetAccountNumberSequence.RUnlock()
	return calls
}

// Ensure, that MsgMock does implement types.Msg.
// If this is not the case, regenerate this file with moq.
var _ types.Msg = &MsgMock{}

// MsgMock is a mock implementation of types.Msg.
//
// 	func TestSomethingThatUsesMsg(t *testing.T) {
//
// 		// make and configure a mocked types.Msg
// 		mockedMsg := &MsgMock{
// 			GetSignBytesFunc: func() []byte {
// 				panic("mock out the GetSignBytes method")
// 			},
// 			GetSignersFunc: func() []sdk.AccAddress {
// 				panic("mock out the GetSigners method")
// 			},
// 			ProtoMessageFunc: func()  {
// 				panic("mock out the ProtoMessage method")
// 			},
// 			ResetFunc: func()  {
// 				panic("mock out the Reset method")
// 			},
// 			RouteFunc: func() string {
// 				panic("mock out the Route method")
// 			},
// 			StringFunc: func() string {
// 				panic("mock out the String method")
// 			},
// 			TypeFunc: func() string {
// 				panic("mock out the Type method")
// 			},
// 			ValidateBasicFunc: func() error {
// 				panic("mock out the ValidateBasic method")
// 			},
// 		}
//
// 		// use mockedMsg in code that requires types.Msg
// 		// and then make assertions.
//
// 	}
type MsgMock struct {
	// GetSignBytesFunc mocks the GetSignBytes method.
	GetSignBytesFunc func() []byte

	// GetSignersFunc mocks the GetSigners method.
	GetSignersFunc func() []sdk.AccAddress

	// ProtoMessageFunc mocks the ProtoMessage method.
	ProtoMessageFunc func()

	// ResetFunc mocks the Reset method.
	ResetFunc func()

	// RouteFunc mocks the Route method.
	RouteFunc func() string

	// StringFunc mocks the String method.
	StringFunc func() string

	// TypeFunc mocks the Type method.
	TypeFunc func() string

	// ValidateBasicFunc mocks the ValidateBasic method.
	ValidateBasicFunc func() error

	// calls tracks calls to the methods.
	calls struct {
		// GetSignBytes holds details about calls to the GetSignBytes method.
		GetSignBytes []struct {
		}
		// GetSigners holds details about calls to the GetSigners method.
		GetSigners []struct {
		}
		// ProtoMessage holds details about calls to the ProtoMessage method.
		ProtoMessage []struct {
		}
		// Reset holds details about calls to the Reset method.
		Reset []struct {
		}
		// Route holds details about calls to the Route method.
		Route []struct {
		}
		// String holds details about calls to the String method.
		String []struct {
		}
		// Type holds details about calls to the Type method.
		Type []struct {
		}
		// ValidateBasic holds details about calls to the ValidateBasic method.
		ValidateBasic []struct {
		}
	}
	lockGetSignBytes  sync.RWMutex
	lockGetSigners    sync.RWMutex
	lockProtoMessage  sync.RWMutex
	lockReset         sync.RWMutex
	lockRoute         sync.RWMutex
	lockString        sync.RWMutex
	lockType          sync.RWMutex
	lockValidateBasic sync.RWMutex
}

// GetSignBytes calls GetSignBytesFunc.
func (mock *MsgMock) GetSignBytes() []byte {
	callInfo := struct {
	}{}
	mock.lockGetSignBytes.Lock()
	mock.calls.GetSignBytes = append(mock.calls.GetSignBytes, callInfo)
	mock.lockGetSignBytes.Unlock()
	if mock.GetSignBytesFunc == nil {
		var (
			bytesOut []byte
		)
		return bytesOut
	}
	return mock.GetSignBytesFunc()
}

// GetSignBytesCalls gets all the calls that were made to GetSignBytes.
// Check the length with:
//     len(mockedMsg.GetSignBytesCalls())
func (mock *MsgMock) GetSignBytesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetSignBytes.RLock()
	calls = mock.calls.GetSignBytes
	mock.lockGetSignBytes.RUnlock()
	return calls
}

// GetSigners calls GetSignersFunc.
func (mock *MsgMock) GetSigners() []sdk.AccAddress {
	callInfo := struct {
	}{}
	mock.lockGetSigners.Lock()
	mock.calls.GetSigners = append(mock.calls.GetSigners, callInfo)
	mock.lockGetSigners.Unlock()
	if mock.GetSignersFunc == nil {
		var (
			accAddresssOut []sdk.AccAddress
		)
		return accAddresssOut
	}
	return mock.GetSignersFunc()
}

// GetSignersCalls gets all the calls that were made to GetSigners.
// Check the length with:
//     len(mockedMsg.GetSignersCalls())
func (mock *MsgMock) GetSignersCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetSigners.RLock()
	calls = mock.calls.GetSigners
	mock.lockGetSigners.RUnlock()
	return calls
}

// ProtoMessage calls ProtoMessageFunc.
func (mock *MsgMock) ProtoMessage() {
	callInfo := struct {
	}{}
	mock.lockProtoMessage.Lock()
	mock.calls.ProtoMessage = append(mock.calls.ProtoMessage, callInfo)
	mock.lockProtoMessage.Unlock()
	if mock.ProtoMessageFunc == nil {
		return
	}
	mock.ProtoMessageFunc()
}

// ProtoMessageCalls gets all the calls that were made to ProtoMessage.
// Check the length with:
//     len(mockedMsg.ProtoMessageCalls())
func (mock *MsgMock) ProtoMessageCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockProtoMessage.RLock()
	calls = mock.calls.ProtoMessage
	mock.lockProtoMessage.RUnlock()
	return calls
}

// Reset calls ResetFunc.
func (mock *MsgMock) Reset() {
	callInfo := struct {
	}{}
	mock.lockReset.Lock()
	mock.calls.Reset = append(mock.calls.Reset, callInfo)
	mock.lockReset.Unlock()
	if mock.ResetFunc == nil {
		return
	}
	mock.ResetFunc()
}

// ResetCalls gets all the calls that were made to Reset.
// Check the length with:
//     len(mockedMsg.ResetCalls())
func (mock *MsgMock) ResetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockReset.RLock()
	calls = mock.calls.Reset
	mock.lockReset.RUnlock()
	return calls
}

// Route calls RouteFunc.
func (mock *MsgMock) Route() string {
	callInfo := struct {
	}{}
	mock.lockRoute.Lock()
	mock.calls.Route = append(mock.calls.Route, callInfo)
	mock.lockRoute.Unlock()
	if mock.RouteFunc == nil {
		var (
			sOut string
		)
		return sOut
	}
	return mock.RouteFunc()
}

// RouteCalls gets all the calls that were made to Route.
// Check the length with:
//     len(mockedMsg.RouteCalls())
func (mock *MsgMock) RouteCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRoute.RLock()
	calls = mock.calls.Route
	mock.lockRoute.RUnlock()
	return calls
}

// String calls StringFunc.
func (mock *MsgMock) String() string {
	callInfo := struct {
	}{}
	mock.lockString.Lock()
	mock.calls.String = append(mock.calls.String, callInfo)
	mock.lockString.Unlock()
	if mock.StringFunc == nil {
		var (
			sOut string
		)
		return sOut
	}
	return mock.StringFunc()
}

// StringCalls gets all the calls that were made to String.
// Check the length with:
//     len(mockedMsg.StringCalls())
func (mock *MsgMock) StringCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockString.RLock()
	calls = mock.calls.String
	mock.lockString.RUnlock()
	return calls
}

// Type calls TypeFunc.
func (mock *MsgMock) Type() string {
	callInfo := struct {
	}{}
	mock.lockType.Lock()
	mock.calls.Type = append(mock.calls.Type, callInfo)
	mock.lockType.Unlock()
	if mock.TypeFunc == nil {
		var (
			sOut string
		)
		return sOut
	}
	return mock.TypeFunc()
}

// TypeCalls gets all the calls that were made to Type.
// Check the length with:
//     len(mockedMsg.TypeCalls())
func (mock *MsgMock) TypeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockType.RLock()
	calls = mock.calls.Type
	mock.lockType.RUnlock()
	return calls
}

// ValidateBasic calls ValidateBasicFunc.
func (mock *MsgMock) ValidateBasic() error {
	callInfo := struct {
	}{}
	mock.lockValidateBasic.Lock()
	mock.calls.ValidateBasic = append(mock.calls.ValidateBasic, callInfo)
	mock.lockValidateBasic.Unlock()
	if mock.ValidateBasicFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.ValidateBasicFunc()
}

// ValidateBasicCalls gets all the calls that were made to ValidateBasic.
// Check the length with:
//     len(mockedMsg.ValidateBasicCalls())
func (mock *MsgMock) ValidateBasicCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockValidateBasic.RLock()
	calls = mock.calls.ValidateBasic
	mock.lockValidateBasic.RUnlock()
	return calls
}

// Ensure, that BroadcasterMock does implement types.Broadcaster.
// If this is not the case, regenerate this file with moq.
var _ types.Broadcaster = &BroadcasterMock{}

// BroadcasterMock is a mock implementation of types.Broadcaster.
//
// 	func TestSomethingThatUsesBroadcaster(t *testing.T) {
//
// 		// make and configure a mocked types.Broadcaster
// 		mockedBroadcaster := &BroadcasterMock{
// 			BroadcastFunc: func(msgs ...sdk.Msg) error {
// 				panic("mock out the Broadcast method")
// 			},
// 		}
//
// 		// use mockedBroadcaster in code that requires types.Broadcaster
// 		// and then make assertions.
//
// 	}
type BroadcasterMock struct {
	// BroadcastFunc mocks the Broadcast method.
	BroadcastFunc func(msgs ...sdk.Msg) error

	// calls tracks calls to the methods.
	calls struct {
		// Broadcast holds details about calls to the Broadcast method.
		Broadcast []struct {
			// Msgs is the msgs argument value.
			Msgs []sdk.Msg
		}
	}
	lockBroadcast sync.RWMutex
}

// Broadcast calls BroadcastFunc.
func (mock *BroadcasterMock) Broadcast(msgs ...sdk.Msg) error {
	callInfo := struct {
		Msgs []sdk.Msg
	}{
		Msgs: msgs,
	}
	mock.lockBroadcast.Lock()
	mock.calls.Broadcast = append(mock.calls.Broadcast, callInfo)
	mock.lockBroadcast.Unlock()
	if mock.BroadcastFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.BroadcastFunc(msgs...)
}

// BroadcastCalls gets all the calls that were made to Broadcast.
// Check the length with:
//     len(mockedBroadcaster.BroadcastCalls())
func (mock *BroadcasterMock) BroadcastCalls() []struct {
	Msgs []sdk.Msg
} {
	var calls []struct {
		Msgs []sdk.Msg
	}
	mock.lockBroadcast.RLock()
	calls = mock.calls.Broadcast
	mock.lockBroadcast.RUnlock()
	return calls
}
