// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	sdkClient "github.com/cosmos/cosmos-sdk/client"
	"github.com/cosmos/cosmos-sdk/crypto/hd"
	"github.com/cosmos/cosmos-sdk/crypto/keyring"
	cryptotypes "github.com/cosmos/cosmos-sdk/crypto/types"
	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/tendermint/tendermint/libs/bytes"
	"github.com/tendermint/tendermint/libs/log"
	rpcclient "github.com/tendermint/tendermint/rpc/client"
	"github.com/tendermint/tendermint/rpc/core/types"
	tenderminttypes "github.com/tendermint/tendermint/types"
	"sync"
)

// Ensure, that ClientMock does implement Client.
// If this is not the case, regenerate this file with moq.
var _ Client = &ClientMock{}

// ClientMock is a mock implementation of Client.
//
//	func TestSomethingThatUsesClient(t *testing.T) {
//
//		// make and configure a mocked Client
//		mockedClient := &ClientMock{
//			ABCIInfoFunc: func(contextMoqParam context.Context) (*coretypes.ResultABCIInfo, error) {
//				panic("mock out the ABCIInfo method")
//			},
//			ABCIQueryFunc: func(ctx context.Context, path string, data bytes.HexBytes) (*coretypes.ResultABCIQuery, error) {
//				panic("mock out the ABCIQuery method")
//			},
//			ABCIQueryWithOptionsFunc: func(ctx context.Context, path string, data bytes.HexBytes, opts rpcclient.ABCIQueryOptions) (*coretypes.ResultABCIQuery, error) {
//				panic("mock out the ABCIQueryWithOptions method")
//			},
//			BlockFunc: func(ctx context.Context, height *int64) (*coretypes.ResultBlock, error) {
//				panic("mock out the Block method")
//			},
//			BlockByHashFunc: func(ctx context.Context, hash []byte) (*coretypes.ResultBlock, error) {
//				panic("mock out the BlockByHash method")
//			},
//			BlockResultsFunc: func(ctx context.Context, height *int64) (*coretypes.ResultBlockResults, error) {
//				panic("mock out the BlockResults method")
//			},
//			BlockSearchFunc: func(ctx context.Context, query string, page *int, perPage *int, orderBy string) (*coretypes.ResultBlockSearch, error) {
//				panic("mock out the BlockSearch method")
//			},
//			BlockchainInfoFunc: func(ctx context.Context, minHeight int64, maxHeight int64) (*coretypes.ResultBlockchainInfo, error) {
//				panic("mock out the BlockchainInfo method")
//			},
//			BroadcastEvidenceFunc: func(contextMoqParam context.Context, evidence tenderminttypes.Evidence) (*coretypes.ResultBroadcastEvidence, error) {
//				panic("mock out the BroadcastEvidence method")
//			},
//			BroadcastTxAsyncFunc: func(contextMoqParam context.Context, tx tenderminttypes.Tx) (*coretypes.ResultBroadcastTx, error) {
//				panic("mock out the BroadcastTxAsync method")
//			},
//			BroadcastTxCommitFunc: func(contextMoqParam context.Context, tx tenderminttypes.Tx) (*coretypes.ResultBroadcastTxCommit, error) {
//				panic("mock out the BroadcastTxCommit method")
//			},
//			BroadcastTxSyncFunc: func(contextMoqParam context.Context, tx tenderminttypes.Tx) (*coretypes.ResultBroadcastTx, error) {
//				panic("mock out the BroadcastTxSync method")
//			},
//			CheckTxFunc: func(contextMoqParam context.Context, tx tenderminttypes.Tx) (*coretypes.ResultCheckTx, error) {
//				panic("mock out the CheckTx method")
//			},
//			CommitFunc: func(ctx context.Context, height *int64) (*coretypes.ResultCommit, error) {
//				panic("mock out the Commit method")
//			},
//			ConsensusParamsFunc: func(ctx context.Context, height *int64) (*coretypes.ResultConsensusParams, error) {
//				panic("mock out the ConsensusParams method")
//			},
//			ConsensusStateFunc: func(contextMoqParam context.Context) (*coretypes.ResultConsensusState, error) {
//				panic("mock out the ConsensusState method")
//			},
//			DumpConsensusStateFunc: func(contextMoqParam context.Context) (*coretypes.ResultDumpConsensusState, error) {
//				panic("mock out the DumpConsensusState method")
//			},
//			GenesisFunc: func(contextMoqParam context.Context) (*coretypes.ResultGenesis, error) {
//				panic("mock out the Genesis method")
//			},
//			GenesisChunkedFunc: func(contextMoqParam context.Context, v uint) (*coretypes.ResultGenesisChunk, error) {
//				panic("mock out the GenesisChunked method")
//			},
//			HealthFunc: func(contextMoqParam context.Context) (*coretypes.ResultHealth, error) {
//				panic("mock out the Health method")
//			},
//			IsRunningFunc: func() bool {
//				panic("mock out the IsRunning method")
//			},
//			NetInfoFunc: func(contextMoqParam context.Context) (*coretypes.ResultNetInfo, error) {
//				panic("mock out the NetInfo method")
//			},
//			NumUnconfirmedTxsFunc: func(contextMoqParam context.Context) (*coretypes.ResultUnconfirmedTxs, error) {
//				panic("mock out the NumUnconfirmedTxs method")
//			},
//			OnResetFunc: func() error {
//				panic("mock out the OnReset method")
//			},
//			OnStartFunc: func() error {
//				panic("mock out the OnStart method")
//			},
//			OnStopFunc: func()  {
//				panic("mock out the OnStop method")
//			},
//			QuitFunc: func() <-chan struct{} {
//				panic("mock out the Quit method")
//			},
//			ResetFunc: func() error {
//				panic("mock out the Reset method")
//			},
//			SetLoggerFunc: func(logger log.Logger)  {
//				panic("mock out the SetLogger method")
//			},
//			StartFunc: func() error {
//				panic("mock out the Start method")
//			},
//			StatusFunc: func(contextMoqParam context.Context) (*coretypes.ResultStatus, error) {
//				panic("mock out the Status method")
//			},
//			StopFunc: func() error {
//				panic("mock out the Stop method")
//			},
//			StringFunc: func() string {
//				panic("mock out the String method")
//			},
//			SubscribeFunc: func(ctx context.Context, subscriber string, query string, outCapacity ...int) (<-chan coretypes.ResultEvent, error) {
//				panic("mock out the Subscribe method")
//			},
//			TxFunc: func(ctx context.Context, hash []byte, prove bool) (*coretypes.ResultTx, error) {
//				panic("mock out the Tx method")
//			},
//			TxSearchFunc: func(ctx context.Context, query string, prove bool, page *int, perPage *int, orderBy string) (*coretypes.ResultTxSearch, error) {
//				panic("mock out the TxSearch method")
//			},
//			UnconfirmedTxsFunc: func(ctx context.Context, limit *int) (*coretypes.ResultUnconfirmedTxs, error) {
//				panic("mock out the UnconfirmedTxs method")
//			},
//			UnsubscribeFunc: func(ctx context.Context, subscriber string, query string) error {
//				panic("mock out the Unsubscribe method")
//			},
//			UnsubscribeAllFunc: func(ctx context.Context, subscriber string) error {
//				panic("mock out the UnsubscribeAll method")
//			},
//			ValidatorsFunc: func(ctx context.Context, height *int64, page *int, perPage *int) (*coretypes.ResultValidators, error) {
//				panic("mock out the Validators method")
//			},
//		}
//
//		// use mockedClient in code that requires Client
//		// and then make assertions.
//
//	}
type ClientMock struct {
	// ABCIInfoFunc mocks the ABCIInfo method.
	ABCIInfoFunc func(contextMoqParam context.Context) (*coretypes.ResultABCIInfo, error)

	// ABCIQueryFunc mocks the ABCIQuery method.
	ABCIQueryFunc func(ctx context.Context, path string, data bytes.HexBytes) (*coretypes.ResultABCIQuery, error)

	// ABCIQueryWithOptionsFunc mocks the ABCIQueryWithOptions method.
	ABCIQueryWithOptionsFunc func(ctx context.Context, path string, data bytes.HexBytes, opts rpcclient.ABCIQueryOptions) (*coretypes.ResultABCIQuery, error)

	// BlockFunc mocks the Block method.
	BlockFunc func(ctx context.Context, height *int64) (*coretypes.ResultBlock, error)

	// BlockByHashFunc mocks the BlockByHash method.
	BlockByHashFunc func(ctx context.Context, hash []byte) (*coretypes.ResultBlock, error)

	// BlockResultsFunc mocks the BlockResults method.
	BlockResultsFunc func(ctx context.Context, height *int64) (*coretypes.ResultBlockResults, error)

	// BlockSearchFunc mocks the BlockSearch method.
	BlockSearchFunc func(ctx context.Context, query string, page *int, perPage *int, orderBy string) (*coretypes.ResultBlockSearch, error)

	// BlockchainInfoFunc mocks the BlockchainInfo method.
	BlockchainInfoFunc func(ctx context.Context, minHeight int64, maxHeight int64) (*coretypes.ResultBlockchainInfo, error)

	// BroadcastEvidenceFunc mocks the BroadcastEvidence method.
	BroadcastEvidenceFunc func(contextMoqParam context.Context, evidence tenderminttypes.Evidence) (*coretypes.ResultBroadcastEvidence, error)

	// BroadcastTxAsyncFunc mocks the BroadcastTxAsync method.
	BroadcastTxAsyncFunc func(contextMoqParam context.Context, tx tenderminttypes.Tx) (*coretypes.ResultBroadcastTx, error)

	// BroadcastTxCommitFunc mocks the BroadcastTxCommit method.
	BroadcastTxCommitFunc func(contextMoqParam context.Context, tx tenderminttypes.Tx) (*coretypes.ResultBroadcastTxCommit, error)

	// BroadcastTxSyncFunc mocks the BroadcastTxSync method.
	BroadcastTxSyncFunc func(contextMoqParam context.Context, tx tenderminttypes.Tx) (*coretypes.ResultBroadcastTx, error)

	// CheckTxFunc mocks the CheckTx method.
	CheckTxFunc func(contextMoqParam context.Context, tx tenderminttypes.Tx) (*coretypes.ResultCheckTx, error)

	// CommitFunc mocks the Commit method.
	CommitFunc func(ctx context.Context, height *int64) (*coretypes.ResultCommit, error)

	// ConsensusParamsFunc mocks the ConsensusParams method.
	ConsensusParamsFunc func(ctx context.Context, height *int64) (*coretypes.ResultConsensusParams, error)

	// ConsensusStateFunc mocks the ConsensusState method.
	ConsensusStateFunc func(contextMoqParam context.Context) (*coretypes.ResultConsensusState, error)

	// DumpConsensusStateFunc mocks the DumpConsensusState method.
	DumpConsensusStateFunc func(contextMoqParam context.Context) (*coretypes.ResultDumpConsensusState, error)

	// GenesisFunc mocks the Genesis method.
	GenesisFunc func(contextMoqParam context.Context) (*coretypes.ResultGenesis, error)

	// GenesisChunkedFunc mocks the GenesisChunked method.
	GenesisChunkedFunc func(contextMoqParam context.Context, v uint) (*coretypes.ResultGenesisChunk, error)

	// HealthFunc mocks the Health method.
	HealthFunc func(contextMoqParam context.Context) (*coretypes.ResultHealth, error)

	// IsRunningFunc mocks the IsRunning method.
	IsRunningFunc func() bool

	// NetInfoFunc mocks the NetInfo method.
	NetInfoFunc func(contextMoqParam context.Context) (*coretypes.ResultNetInfo, error)

	// NumUnconfirmedTxsFunc mocks the NumUnconfirmedTxs method.
	NumUnconfirmedTxsFunc func(contextMoqParam context.Context) (*coretypes.ResultUnconfirmedTxs, error)

	// OnResetFunc mocks the OnReset method.
	OnResetFunc func() error

	// OnStartFunc mocks the OnStart method.
	OnStartFunc func() error

	// OnStopFunc mocks the OnStop method.
	OnStopFunc func()

	// QuitFunc mocks the Quit method.
	QuitFunc func() <-chan struct{}

	// ResetFunc mocks the Reset method.
	ResetFunc func() error

	// SetLoggerFunc mocks the SetLogger method.
	SetLoggerFunc func(logger log.Logger)

	// StartFunc mocks the Start method.
	StartFunc func() error

	// StatusFunc mocks the Status method.
	StatusFunc func(contextMoqParam context.Context) (*coretypes.ResultStatus, error)

	// StopFunc mocks the Stop method.
	StopFunc func() error

	// StringFunc mocks the String method.
	StringFunc func() string

	// SubscribeFunc mocks the Subscribe method.
	SubscribeFunc func(ctx context.Context, subscriber string, query string, outCapacity ...int) (<-chan coretypes.ResultEvent, error)

	// TxFunc mocks the Tx method.
	TxFunc func(ctx context.Context, hash []byte, prove bool) (*coretypes.ResultTx, error)

	// TxSearchFunc mocks the TxSearch method.
	TxSearchFunc func(ctx context.Context, query string, prove bool, page *int, perPage *int, orderBy string) (*coretypes.ResultTxSearch, error)

	// UnconfirmedTxsFunc mocks the UnconfirmedTxs method.
	UnconfirmedTxsFunc func(ctx context.Context, limit *int) (*coretypes.ResultUnconfirmedTxs, error)

	// UnsubscribeFunc mocks the Unsubscribe method.
	UnsubscribeFunc func(ctx context.Context, subscriber string, query string) error

	// UnsubscribeAllFunc mocks the UnsubscribeAll method.
	UnsubscribeAllFunc func(ctx context.Context, subscriber string) error

	// ValidatorsFunc mocks the Validators method.
	ValidatorsFunc func(ctx context.Context, height *int64, page *int, perPage *int) (*coretypes.ResultValidators, error)

	// calls tracks calls to the methods.
	calls struct {
		// ABCIInfo holds details about calls to the ABCIInfo method.
		ABCIInfo []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// ABCIQuery holds details about calls to the ABCIQuery method.
		ABCIQuery []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Path is the path argument value.
			Path string
			// Data is the data argument value.
			Data bytes.HexBytes
		}
		// ABCIQueryWithOptions holds details about calls to the ABCIQueryWithOptions method.
		ABCIQueryWithOptions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Path is the path argument value.
			Path string
			// Data is the data argument value.
			Data bytes.HexBytes
			// Opts is the opts argument value.
			Opts rpcclient.ABCIQueryOptions
		}
		// Block holds details about calls to the Block method.
		Block []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Height is the height argument value.
			Height *int64
		}
		// BlockByHash holds details about calls to the BlockByHash method.
		BlockByHash []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hash is the hash argument value.
			Hash []byte
		}
		// BlockResults holds details about calls to the BlockResults method.
		BlockResults []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Height is the height argument value.
			Height *int64
		}
		// BlockSearch holds details about calls to the BlockSearch method.
		BlockSearch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Query is the query argument value.
			Query string
			// Page is the page argument value.
			Page *int
			// PerPage is the perPage argument value.
			PerPage *int
			// OrderBy is the orderBy argument value.
			OrderBy string
		}
		// BlockchainInfo holds details about calls to the BlockchainInfo method.
		BlockchainInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// MinHeight is the minHeight argument value.
			MinHeight int64
			// MaxHeight is the maxHeight argument value.
			MaxHeight int64
		}
		// BroadcastEvidence holds details about calls to the BroadcastEvidence method.
		BroadcastEvidence []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// Evidence is the evidence argument value.
			Evidence tenderminttypes.Evidence
		}
		// BroadcastTxAsync holds details about calls to the BroadcastTxAsync method.
		BroadcastTxAsync []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// Tx is the tx argument value.
			Tx tenderminttypes.Tx
		}
		// BroadcastTxCommit holds details about calls to the BroadcastTxCommit method.
		BroadcastTxCommit []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// Tx is the tx argument value.
			Tx tenderminttypes.Tx
		}
		// BroadcastTxSync holds details about calls to the BroadcastTxSync method.
		BroadcastTxSync []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// Tx is the tx argument value.
			Tx tenderminttypes.Tx
		}
		// CheckTx holds details about calls to the CheckTx method.
		CheckTx []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// Tx is the tx argument value.
			Tx tenderminttypes.Tx
		}
		// Commit holds details about calls to the Commit method.
		Commit []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Height is the height argument value.
			Height *int64
		}
		// ConsensusParams holds details about calls to the ConsensusParams method.
		ConsensusParams []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Height is the height argument value.
			Height *int64
		}
		// ConsensusState holds details about calls to the ConsensusState method.
		ConsensusState []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// DumpConsensusState holds details about calls to the DumpConsensusState method.
		DumpConsensusState []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// Genesis holds details about calls to the Genesis method.
		Genesis []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// GenesisChunked holds details about calls to the GenesisChunked method.
		GenesisChunked []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// V is the v argument value.
			V uint
		}
		// Health holds details about calls to the Health method.
		Health []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// IsRunning holds details about calls to the IsRunning method.
		IsRunning []struct {
		}
		// NetInfo holds details about calls to the NetInfo method.
		NetInfo []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// NumUnconfirmedTxs holds details about calls to the NumUnconfirmedTxs method.
		NumUnconfirmedTxs []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// OnReset holds details about calls to the OnReset method.
		OnReset []struct {
		}
		// OnStart holds details about calls to the OnStart method.
		OnStart []struct {
		}
		// OnStop holds details about calls to the OnStop method.
		OnStop []struct {
		}
		// Quit holds details about calls to the Quit method.
		Quit []struct {
		}
		// Reset holds details about calls to the Reset method.
		Reset []struct {
		}
		// SetLogger holds details about calls to the SetLogger method.
		SetLogger []struct {
			// Logger is the logger argument value.
			Logger log.Logger
		}
		// Start holds details about calls to the Start method.
		Start []struct {
		}
		// Status holds details about calls to the Status method.
		Status []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// Stop holds details about calls to the Stop method.
		Stop []struct {
		}
		// String holds details about calls to the String method.
		String []struct {
		}
		// Subscribe holds details about calls to the Subscribe method.
		Subscribe []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Subscriber is the subscriber argument value.
			Subscriber string
			// Query is the query argument value.
			Query string
			// OutCapacity is the outCapacity argument value.
			OutCapacity []int
		}
		// Tx holds details about calls to the Tx method.
		Tx []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hash is the hash argument value.
			Hash []byte
			// Prove is the prove argument value.
			Prove bool
		}
		// TxSearch holds details about calls to the TxSearch method.
		TxSearch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Query is the query argument value.
			Query string
			// Prove is the prove argument value.
			Prove bool
			// Page is the page argument value.
			Page *int
			// PerPage is the perPage argument value.
			PerPage *int
			// OrderBy is the orderBy argument value.
			OrderBy string
		}
		// UnconfirmedTxs holds details about calls to the UnconfirmedTxs method.
		UnconfirmedTxs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Limit is the limit argument value.
			Limit *int
		}
		// Unsubscribe holds details about calls to the Unsubscribe method.
		Unsubscribe []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Subscriber is the subscriber argument value.
			Subscriber string
			// Query is the query argument value.
			Query string
		}
		// UnsubscribeAll holds details about calls to the UnsubscribeAll method.
		UnsubscribeAll []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Subscriber is the subscriber argument value.
			Subscriber string
		}
		// Validators holds details about calls to the Validators method.
		Validators []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Height is the height argument value.
			Height *int64
			// Page is the page argument value.
			Page *int
			// PerPage is the perPage argument value.
			PerPage *int
		}
	}
	lockABCIInfo             sync.RWMutex
	lockABCIQuery            sync.RWMutex
	lockABCIQueryWithOptions sync.RWMutex
	lockBlock                sync.RWMutex
	lockBlockByHash          sync.RWMutex
	lockBlockResults         sync.RWMutex
	lockBlockSearch          sync.RWMutex
	lockBlockchainInfo       sync.RWMutex
	lockBroadcastEvidence    sync.RWMutex
	lockBroadcastTxAsync     sync.RWMutex
	lockBroadcastTxCommit    sync.RWMutex
	lockBroadcastTxSync      sync.RWMutex
	lockCheckTx              sync.RWMutex
	lockCommit               sync.RWMutex
	lockConsensusParams      sync.RWMutex
	lockConsensusState       sync.RWMutex
	lockDumpConsensusState   sync.RWMutex
	lockGenesis              sync.RWMutex
	lockGenesisChunked       sync.RWMutex
	lockHealth               sync.RWMutex
	lockIsRunning            sync.RWMutex
	lockNetInfo              sync.RWMutex
	lockNumUnconfirmedTxs    sync.RWMutex
	lockOnReset              sync.RWMutex
	lockOnStart              sync.RWMutex
	lockOnStop               sync.RWMutex
	lockQuit                 sync.RWMutex
	lockReset                sync.RWMutex
	lockSetLogger            sync.RWMutex
	lockStart                sync.RWMutex
	lockStatus               sync.RWMutex
	lockStop                 sync.RWMutex
	lockString               sync.RWMutex
	lockSubscribe            sync.RWMutex
	lockTx                   sync.RWMutex
	lockTxSearch             sync.RWMutex
	lockUnconfirmedTxs       sync.RWMutex
	lockUnsubscribe          sync.RWMutex
	lockUnsubscribeAll       sync.RWMutex
	lockValidators           sync.RWMutex
}

// ABCIInfo calls ABCIInfoFunc.
func (mock *ClientMock) ABCIInfo(contextMoqParam context.Context) (*coretypes.ResultABCIInfo, error) {
	if mock.ABCIInfoFunc == nil {
		panic("ClientMock.ABCIInfoFunc: method is nil but Client.ABCIInfo was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockABCIInfo.Lock()
	mock.calls.ABCIInfo = append(mock.calls.ABCIInfo, callInfo)
	mock.lockABCIInfo.Unlock()
	return mock.ABCIInfoFunc(contextMoqParam)
}

// ABCIInfoCalls gets all the calls that were made to ABCIInfo.
// Check the length with:
//
//	len(mockedClient.ABCIInfoCalls())
func (mock *ClientMock) ABCIInfoCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockABCIInfo.RLock()
	calls = mock.calls.ABCIInfo
	mock.lockABCIInfo.RUnlock()
	return calls
}

// ABCIQuery calls ABCIQueryFunc.
func (mock *ClientMock) ABCIQuery(ctx context.Context, path string, data bytes.HexBytes) (*coretypes.ResultABCIQuery, error) {
	if mock.ABCIQueryFunc == nil {
		panic("ClientMock.ABCIQueryFunc: method is nil but Client.ABCIQuery was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Path string
		Data bytes.HexBytes
	}{
		Ctx:  ctx,
		Path: path,
		Data: data,
	}
	mock.lockABCIQuery.Lock()
	mock.calls.ABCIQuery = append(mock.calls.ABCIQuery, callInfo)
	mock.lockABCIQuery.Unlock()
	return mock.ABCIQueryFunc(ctx, path, data)
}

// ABCIQueryCalls gets all the calls that were made to ABCIQuery.
// Check the length with:
//
//	len(mockedClient.ABCIQueryCalls())
func (mock *ClientMock) ABCIQueryCalls() []struct {
	Ctx  context.Context
	Path string
	Data bytes.HexBytes
} {
	var calls []struct {
		Ctx  context.Context
		Path string
		Data bytes.HexBytes
	}
	mock.lockABCIQuery.RLock()
	calls = mock.calls.ABCIQuery
	mock.lockABCIQuery.RUnlock()
	return calls
}

// ABCIQueryWithOptions calls ABCIQueryWithOptionsFunc.
func (mock *ClientMock) ABCIQueryWithOptions(ctx context.Context, path string, data bytes.HexBytes, opts rpcclient.ABCIQueryOptions) (*coretypes.ResultABCIQuery, error) {
	if mock.ABCIQueryWithOptionsFunc == nil {
		panic("ClientMock.ABCIQueryWithOptionsFunc: method is nil but Client.ABCIQueryWithOptions was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Path string
		Data bytes.HexBytes
		Opts rpcclient.ABCIQueryOptions
	}{
		Ctx:  ctx,
		Path: path,
		Data: data,
		Opts: opts,
	}
	mock.lockABCIQueryWithOptions.Lock()
	mock.calls.ABCIQueryWithOptions = append(mock.calls.ABCIQueryWithOptions, callInfo)
	mock.lockABCIQueryWithOptions.Unlock()
	return mock.ABCIQueryWithOptionsFunc(ctx, path, data, opts)
}

// ABCIQueryWithOptionsCalls gets all the calls that were made to ABCIQueryWithOptions.
// Check the length with:
//
//	len(mockedClient.ABCIQueryWithOptionsCalls())
func (mock *ClientMock) ABCIQueryWithOptionsCalls() []struct {
	Ctx  context.Context
	Path string
	Data bytes.HexBytes
	Opts rpcclient.ABCIQueryOptions
} {
	var calls []struct {
		Ctx  context.Context
		Path string
		Data bytes.HexBytes
		Opts rpcclient.ABCIQueryOptions
	}
	mock.lockABCIQueryWithOptions.RLock()
	calls = mock.calls.ABCIQueryWithOptions
	mock.lockABCIQueryWithOptions.RUnlock()
	return calls
}

// Block calls BlockFunc.
func (mock *ClientMock) Block(ctx context.Context, height *int64) (*coretypes.ResultBlock, error) {
	if mock.BlockFunc == nil {
		panic("ClientMock.BlockFunc: method is nil but Client.Block was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Height *int64
	}{
		Ctx:    ctx,
		Height: height,
	}
	mock.lockBlock.Lock()
	mock.calls.Block = append(mock.calls.Block, callInfo)
	mock.lockBlock.Unlock()
	return mock.BlockFunc(ctx, height)
}

// BlockCalls gets all the calls that were made to Block.
// Check the length with:
//
//	len(mockedClient.BlockCalls())
func (mock *ClientMock) BlockCalls() []struct {
	Ctx    context.Context
	Height *int64
} {
	var calls []struct {
		Ctx    context.Context
		Height *int64
	}
	mock.lockBlock.RLock()
	calls = mock.calls.Block
	mock.lockBlock.RUnlock()
	return calls
}

// BlockByHash calls BlockByHashFunc.
func (mock *ClientMock) BlockByHash(ctx context.Context, hash []byte) (*coretypes.ResultBlock, error) {
	if mock.BlockByHashFunc == nil {
		panic("ClientMock.BlockByHashFunc: method is nil but Client.BlockByHash was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Hash []byte
	}{
		Ctx:  ctx,
		Hash: hash,
	}
	mock.lockBlockByHash.Lock()
	mock.calls.BlockByHash = append(mock.calls.BlockByHash, callInfo)
	mock.lockBlockByHash.Unlock()
	return mock.BlockByHashFunc(ctx, hash)
}

// BlockByHashCalls gets all the calls that were made to BlockByHash.
// Check the length with:
//
//	len(mockedClient.BlockByHashCalls())
func (mock *ClientMock) BlockByHashCalls() []struct {
	Ctx  context.Context
	Hash []byte
} {
	var calls []struct {
		Ctx  context.Context
		Hash []byte
	}
	mock.lockBlockByHash.RLock()
	calls = mock.calls.BlockByHash
	mock.lockBlockByHash.RUnlock()
	return calls
}

// BlockResults calls BlockResultsFunc.
func (mock *ClientMock) BlockResults(ctx context.Context, height *int64) (*coretypes.ResultBlockResults, error) {
	if mock.BlockResultsFunc == nil {
		panic("ClientMock.BlockResultsFunc: method is nil but Client.BlockResults was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Height *int64
	}{
		Ctx:    ctx,
		Height: height,
	}
	mock.lockBlockResults.Lock()
	mock.calls.BlockResults = append(mock.calls.BlockResults, callInfo)
	mock.lockBlockResults.Unlock()
	return mock.BlockResultsFunc(ctx, height)
}

// BlockResultsCalls gets all the calls that were made to BlockResults.
// Check the length with:
//
//	len(mockedClient.BlockResultsCalls())
func (mock *ClientMock) BlockResultsCalls() []struct {
	Ctx    context.Context
	Height *int64
} {
	var calls []struct {
		Ctx    context.Context
		Height *int64
	}
	mock.lockBlockResults.RLock()
	calls = mock.calls.BlockResults
	mock.lockBlockResults.RUnlock()
	return calls
}

// BlockSearch calls BlockSearchFunc.
func (mock *ClientMock) BlockSearch(ctx context.Context, query string, page *int, perPage *int, orderBy string) (*coretypes.ResultBlockSearch, error) {
	if mock.BlockSearchFunc == nil {
		panic("ClientMock.BlockSearchFunc: method is nil but Client.BlockSearch was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Query   string
		Page    *int
		PerPage *int
		OrderBy string
	}{
		Ctx:     ctx,
		Query:   query,
		Page:    page,
		PerPage: perPage,
		OrderBy: orderBy,
	}
	mock.lockBlockSearch.Lock()
	mock.calls.BlockSearch = append(mock.calls.BlockSearch, callInfo)
	mock.lockBlockSearch.Unlock()
	return mock.BlockSearchFunc(ctx, query, page, perPage, orderBy)
}

// BlockSearchCalls gets all the calls that were made to BlockSearch.
// Check the length with:
//
//	len(mockedClient.BlockSearchCalls())
func (mock *ClientMock) BlockSearchCalls() []struct {
	Ctx     context.Context
	Query   string
	Page    *int
	PerPage *int
	OrderBy string
} {
	var calls []struct {
		Ctx     context.Context
		Query   string
		Page    *int
		PerPage *int
		OrderBy string
	}
	mock.lockBlockSearch.RLock()
	calls = mock.calls.BlockSearch
	mock.lockBlockSearch.RUnlock()
	return calls
}

// BlockchainInfo calls BlockchainInfoFunc.
func (mock *ClientMock) BlockchainInfo(ctx context.Context, minHeight int64, maxHeight int64) (*coretypes.ResultBlockchainInfo, error) {
	if mock.BlockchainInfoFunc == nil {
		panic("ClientMock.BlockchainInfoFunc: method is nil but Client.BlockchainInfo was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		MinHeight int64
		MaxHeight int64
	}{
		Ctx:       ctx,
		MinHeight: minHeight,
		MaxHeight: maxHeight,
	}
	mock.lockBlockchainInfo.Lock()
	mock.calls.BlockchainInfo = append(mock.calls.BlockchainInfo, callInfo)
	mock.lockBlockchainInfo.Unlock()
	return mock.BlockchainInfoFunc(ctx, minHeight, maxHeight)
}

// BlockchainInfoCalls gets all the calls that were made to BlockchainInfo.
// Check the length with:
//
//	len(mockedClient.BlockchainInfoCalls())
func (mock *ClientMock) BlockchainInfoCalls() []struct {
	Ctx       context.Context
	MinHeight int64
	MaxHeight int64
} {
	var calls []struct {
		Ctx       context.Context
		MinHeight int64
		MaxHeight int64
	}
	mock.lockBlockchainInfo.RLock()
	calls = mock.calls.BlockchainInfo
	mock.lockBlockchainInfo.RUnlock()
	return calls
}

// BroadcastEvidence calls BroadcastEvidenceFunc.
func (mock *ClientMock) BroadcastEvidence(contextMoqParam context.Context, evidence tenderminttypes.Evidence) (*coretypes.ResultBroadcastEvidence, error) {
	if mock.BroadcastEvidenceFunc == nil {
		panic("ClientMock.BroadcastEvidenceFunc: method is nil but Client.BroadcastEvidence was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		Evidence        tenderminttypes.Evidence
	}{
		ContextMoqParam: contextMoqParam,
		Evidence:        evidence,
	}
	mock.lockBroadcastEvidence.Lock()
	mock.calls.BroadcastEvidence = append(mock.calls.BroadcastEvidence, callInfo)
	mock.lockBroadcastEvidence.Unlock()
	return mock.BroadcastEvidenceFunc(contextMoqParam, evidence)
}

// BroadcastEvidenceCalls gets all the calls that were made to BroadcastEvidence.
// Check the length with:
//
//	len(mockedClient.BroadcastEvidenceCalls())
func (mock *ClientMock) BroadcastEvidenceCalls() []struct {
	ContextMoqParam context.Context
	Evidence        tenderminttypes.Evidence
} {
	var calls []struct {
		ContextMoqParam context.Context
		Evidence        tenderminttypes.Evidence
	}
	mock.lockBroadcastEvidence.RLock()
	calls = mock.calls.BroadcastEvidence
	mock.lockBroadcastEvidence.RUnlock()
	return calls
}

// BroadcastTxAsync calls BroadcastTxAsyncFunc.
func (mock *ClientMock) BroadcastTxAsync(contextMoqParam context.Context, tx tenderminttypes.Tx) (*coretypes.ResultBroadcastTx, error) {
	if mock.BroadcastTxAsyncFunc == nil {
		panic("ClientMock.BroadcastTxAsyncFunc: method is nil but Client.BroadcastTxAsync was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		Tx              tenderminttypes.Tx
	}{
		ContextMoqParam: contextMoqParam,
		Tx:              tx,
	}
	mock.lockBroadcastTxAsync.Lock()
	mock.calls.BroadcastTxAsync = append(mock.calls.BroadcastTxAsync, callInfo)
	mock.lockBroadcastTxAsync.Unlock()
	return mock.BroadcastTxAsyncFunc(contextMoqParam, tx)
}

// BroadcastTxAsyncCalls gets all the calls that were made to BroadcastTxAsync.
// Check the length with:
//
//	len(mockedClient.BroadcastTxAsyncCalls())
func (mock *ClientMock) BroadcastTxAsyncCalls() []struct {
	ContextMoqParam context.Context
	Tx              tenderminttypes.Tx
} {
	var calls []struct {
		ContextMoqParam context.Context
		Tx              tenderminttypes.Tx
	}
	mock.lockBroadcastTxAsync.RLock()
	calls = mock.calls.BroadcastTxAsync
	mock.lockBroadcastTxAsync.RUnlock()
	return calls
}

// BroadcastTxCommit calls BroadcastTxCommitFunc.
func (mock *ClientMock) BroadcastTxCommit(contextMoqParam context.Context, tx tenderminttypes.Tx) (*coretypes.ResultBroadcastTxCommit, error) {
	if mock.BroadcastTxCommitFunc == nil {
		panic("ClientMock.BroadcastTxCommitFunc: method is nil but Client.BroadcastTxCommit was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		Tx              tenderminttypes.Tx
	}{
		ContextMoqParam: contextMoqParam,
		Tx:              tx,
	}
	mock.lockBroadcastTxCommit.Lock()
	mock.calls.BroadcastTxCommit = append(mock.calls.BroadcastTxCommit, callInfo)
	mock.lockBroadcastTxCommit.Unlock()
	return mock.BroadcastTxCommitFunc(contextMoqParam, tx)
}

// BroadcastTxCommitCalls gets all the calls that were made to BroadcastTxCommit.
// Check the length with:
//
//	len(mockedClient.BroadcastTxCommitCalls())
func (mock *ClientMock) BroadcastTxCommitCalls() []struct {
	ContextMoqParam context.Context
	Tx              tenderminttypes.Tx
} {
	var calls []struct {
		ContextMoqParam context.Context
		Tx              tenderminttypes.Tx
	}
	mock.lockBroadcastTxCommit.RLock()
	calls = mock.calls.BroadcastTxCommit
	mock.lockBroadcastTxCommit.RUnlock()
	return calls
}

// BroadcastTxSync calls BroadcastTxSyncFunc.
func (mock *ClientMock) BroadcastTxSync(contextMoqParam context.Context, tx tenderminttypes.Tx) (*coretypes.ResultBroadcastTx, error) {
	if mock.BroadcastTxSyncFunc == nil {
		panic("ClientMock.BroadcastTxSyncFunc: method is nil but Client.BroadcastTxSync was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		Tx              tenderminttypes.Tx
	}{
		ContextMoqParam: contextMoqParam,
		Tx:              tx,
	}
	mock.lockBroadcastTxSync.Lock()
	mock.calls.BroadcastTxSync = append(mock.calls.BroadcastTxSync, callInfo)
	mock.lockBroadcastTxSync.Unlock()
	return mock.BroadcastTxSyncFunc(contextMoqParam, tx)
}

// BroadcastTxSyncCalls gets all the calls that were made to BroadcastTxSync.
// Check the length with:
//
//	len(mockedClient.BroadcastTxSyncCalls())
func (mock *ClientMock) BroadcastTxSyncCalls() []struct {
	ContextMoqParam context.Context
	Tx              tenderminttypes.Tx
} {
	var calls []struct {
		ContextMoqParam context.Context
		Tx              tenderminttypes.Tx
	}
	mock.lockBroadcastTxSync.RLock()
	calls = mock.calls.BroadcastTxSync
	mock.lockBroadcastTxSync.RUnlock()
	return calls
}

// CheckTx calls CheckTxFunc.
func (mock *ClientMock) CheckTx(contextMoqParam context.Context, tx tenderminttypes.Tx) (*coretypes.ResultCheckTx, error) {
	if mock.CheckTxFunc == nil {
		panic("ClientMock.CheckTxFunc: method is nil but Client.CheckTx was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		Tx              tenderminttypes.Tx
	}{
		ContextMoqParam: contextMoqParam,
		Tx:              tx,
	}
	mock.lockCheckTx.Lock()
	mock.calls.CheckTx = append(mock.calls.CheckTx, callInfo)
	mock.lockCheckTx.Unlock()
	return mock.CheckTxFunc(contextMoqParam, tx)
}

// CheckTxCalls gets all the calls that were made to CheckTx.
// Check the length with:
//
//	len(mockedClient.CheckTxCalls())
func (mock *ClientMock) CheckTxCalls() []struct {
	ContextMoqParam context.Context
	Tx              tenderminttypes.Tx
} {
	var calls []struct {
		ContextMoqParam context.Context
		Tx              tenderminttypes.Tx
	}
	mock.lockCheckTx.RLock()
	calls = mock.calls.CheckTx
	mock.lockCheckTx.RUnlock()
	return calls
}

// Commit calls CommitFunc.
func (mock *ClientMock) Commit(ctx context.Context, height *int64) (*coretypes.ResultCommit, error) {
	if mock.CommitFunc == nil {
		panic("ClientMock.CommitFunc: method is nil but Client.Commit was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Height *int64
	}{
		Ctx:    ctx,
		Height: height,
	}
	mock.lockCommit.Lock()
	mock.calls.Commit = append(mock.calls.Commit, callInfo)
	mock.lockCommit.Unlock()
	return mock.CommitFunc(ctx, height)
}

// CommitCalls gets all the calls that were made to Commit.
// Check the length with:
//
//	len(mockedClient.CommitCalls())
func (mock *ClientMock) CommitCalls() []struct {
	Ctx    context.Context
	Height *int64
} {
	var calls []struct {
		Ctx    context.Context
		Height *int64
	}
	mock.lockCommit.RLock()
	calls = mock.calls.Commit
	mock.lockCommit.RUnlock()
	return calls
}

// ConsensusParams calls ConsensusParamsFunc.
func (mock *ClientMock) ConsensusParams(ctx context.Context, height *int64) (*coretypes.ResultConsensusParams, error) {
	if mock.ConsensusParamsFunc == nil {
		panic("ClientMock.ConsensusParamsFunc: method is nil but Client.ConsensusParams was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Height *int64
	}{
		Ctx:    ctx,
		Height: height,
	}
	mock.lockConsensusParams.Lock()
	mock.calls.ConsensusParams = append(mock.calls.ConsensusParams, callInfo)
	mock.lockConsensusParams.Unlock()
	return mock.ConsensusParamsFunc(ctx, height)
}

// ConsensusParamsCalls gets all the calls that were made to ConsensusParams.
// Check the length with:
//
//	len(mockedClient.ConsensusParamsCalls())
func (mock *ClientMock) ConsensusParamsCalls() []struct {
	Ctx    context.Context
	Height *int64
} {
	var calls []struct {
		Ctx    context.Context
		Height *int64
	}
	mock.lockConsensusParams.RLock()
	calls = mock.calls.ConsensusParams
	mock.lockConsensusParams.RUnlock()
	return calls
}

// ConsensusState calls ConsensusStateFunc.
func (mock *ClientMock) ConsensusState(contextMoqParam context.Context) (*coretypes.ResultConsensusState, error) {
	if mock.ConsensusStateFunc == nil {
		panic("ClientMock.ConsensusStateFunc: method is nil but Client.ConsensusState was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockConsensusState.Lock()
	mock.calls.ConsensusState = append(mock.calls.ConsensusState, callInfo)
	mock.lockConsensusState.Unlock()
	return mock.ConsensusStateFunc(contextMoqParam)
}

// ConsensusStateCalls gets all the calls that were made to ConsensusState.
// Check the length with:
//
//	len(mockedClient.ConsensusStateCalls())
func (mock *ClientMock) ConsensusStateCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockConsensusState.RLock()
	calls = mock.calls.ConsensusState
	mock.lockConsensusState.RUnlock()
	return calls
}

// DumpConsensusState calls DumpConsensusStateFunc.
func (mock *ClientMock) DumpConsensusState(contextMoqParam context.Context) (*coretypes.ResultDumpConsensusState, error) {
	if mock.DumpConsensusStateFunc == nil {
		panic("ClientMock.DumpConsensusStateFunc: method is nil but Client.DumpConsensusState was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockDumpConsensusState.Lock()
	mock.calls.DumpConsensusState = append(mock.calls.DumpConsensusState, callInfo)
	mock.lockDumpConsensusState.Unlock()
	return mock.DumpConsensusStateFunc(contextMoqParam)
}

// DumpConsensusStateCalls gets all the calls that were made to DumpConsensusState.
// Check the length with:
//
//	len(mockedClient.DumpConsensusStateCalls())
func (mock *ClientMock) DumpConsensusStateCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockDumpConsensusState.RLock()
	calls = mock.calls.DumpConsensusState
	mock.lockDumpConsensusState.RUnlock()
	return calls
}

// Genesis calls GenesisFunc.
func (mock *ClientMock) Genesis(contextMoqParam context.Context) (*coretypes.ResultGenesis, error) {
	if mock.GenesisFunc == nil {
		panic("ClientMock.GenesisFunc: method is nil but Client.Genesis was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockGenesis.Lock()
	mock.calls.Genesis = append(mock.calls.Genesis, callInfo)
	mock.lockGenesis.Unlock()
	return mock.GenesisFunc(contextMoqParam)
}

// GenesisCalls gets all the calls that were made to Genesis.
// Check the length with:
//
//	len(mockedClient.GenesisCalls())
func (mock *ClientMock) GenesisCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockGenesis.RLock()
	calls = mock.calls.Genesis
	mock.lockGenesis.RUnlock()
	return calls
}

// GenesisChunked calls GenesisChunkedFunc.
func (mock *ClientMock) GenesisChunked(contextMoqParam context.Context, v uint) (*coretypes.ResultGenesisChunk, error) {
	if mock.GenesisChunkedFunc == nil {
		panic("ClientMock.GenesisChunkedFunc: method is nil but Client.GenesisChunked was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
		V               uint
	}{
		ContextMoqParam: contextMoqParam,
		V:               v,
	}
	mock.lockGenesisChunked.Lock()
	mock.calls.GenesisChunked = append(mock.calls.GenesisChunked, callInfo)
	mock.lockGenesisChunked.Unlock()
	return mock.GenesisChunkedFunc(contextMoqParam, v)
}

// GenesisChunkedCalls gets all the calls that were made to GenesisChunked.
// Check the length with:
//
//	len(mockedClient.GenesisChunkedCalls())
func (mock *ClientMock) GenesisChunkedCalls() []struct {
	ContextMoqParam context.Context
	V               uint
} {
	var calls []struct {
		ContextMoqParam context.Context
		V               uint
	}
	mock.lockGenesisChunked.RLock()
	calls = mock.calls.GenesisChunked
	mock.lockGenesisChunked.RUnlock()
	return calls
}

// Health calls HealthFunc.
func (mock *ClientMock) Health(contextMoqParam context.Context) (*coretypes.ResultHealth, error) {
	if mock.HealthFunc == nil {
		panic("ClientMock.HealthFunc: method is nil but Client.Health was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockHealth.Lock()
	mock.calls.Health = append(mock.calls.Health, callInfo)
	mock.lockHealth.Unlock()
	return mock.HealthFunc(contextMoqParam)
}

// HealthCalls gets all the calls that were made to Health.
// Check the length with:
//
//	len(mockedClient.HealthCalls())
func (mock *ClientMock) HealthCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockHealth.RLock()
	calls = mock.calls.Health
	mock.lockHealth.RUnlock()
	return calls
}

// IsRunning calls IsRunningFunc.
func (mock *ClientMock) IsRunning() bool {
	if mock.IsRunningFunc == nil {
		panic("ClientMock.IsRunningFunc: method is nil but Client.IsRunning was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIsRunning.Lock()
	mock.calls.IsRunning = append(mock.calls.IsRunning, callInfo)
	mock.lockIsRunning.Unlock()
	return mock.IsRunningFunc()
}

// IsRunningCalls gets all the calls that were made to IsRunning.
// Check the length with:
//
//	len(mockedClient.IsRunningCalls())
func (mock *ClientMock) IsRunningCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsRunning.RLock()
	calls = mock.calls.IsRunning
	mock.lockIsRunning.RUnlock()
	return calls
}

// NetInfo calls NetInfoFunc.
func (mock *ClientMock) NetInfo(contextMoqParam context.Context) (*coretypes.ResultNetInfo, error) {
	if mock.NetInfoFunc == nil {
		panic("ClientMock.NetInfoFunc: method is nil but Client.NetInfo was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockNetInfo.Lock()
	mock.calls.NetInfo = append(mock.calls.NetInfo, callInfo)
	mock.lockNetInfo.Unlock()
	return mock.NetInfoFunc(contextMoqParam)
}

// NetInfoCalls gets all the calls that were made to NetInfo.
// Check the length with:
//
//	len(mockedClient.NetInfoCalls())
func (mock *ClientMock) NetInfoCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockNetInfo.RLock()
	calls = mock.calls.NetInfo
	mock.lockNetInfo.RUnlock()
	return calls
}

// NumUnconfirmedTxs calls NumUnconfirmedTxsFunc.
func (mock *ClientMock) NumUnconfirmedTxs(contextMoqParam context.Context) (*coretypes.ResultUnconfirmedTxs, error) {
	if mock.NumUnconfirmedTxsFunc == nil {
		panic("ClientMock.NumUnconfirmedTxsFunc: method is nil but Client.NumUnconfirmedTxs was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockNumUnconfirmedTxs.Lock()
	mock.calls.NumUnconfirmedTxs = append(mock.calls.NumUnconfirmedTxs, callInfo)
	mock.lockNumUnconfirmedTxs.Unlock()
	return mock.NumUnconfirmedTxsFunc(contextMoqParam)
}

// NumUnconfirmedTxsCalls gets all the calls that were made to NumUnconfirmedTxs.
// Check the length with:
//
//	len(mockedClient.NumUnconfirmedTxsCalls())
func (mock *ClientMock) NumUnconfirmedTxsCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockNumUnconfirmedTxs.RLock()
	calls = mock.calls.NumUnconfirmedTxs
	mock.lockNumUnconfirmedTxs.RUnlock()
	return calls
}

// OnReset calls OnResetFunc.
func (mock *ClientMock) OnReset() error {
	if mock.OnResetFunc == nil {
		panic("ClientMock.OnResetFunc: method is nil but Client.OnReset was just called")
	}
	callInfo := struct {
	}{}
	mock.lockOnReset.Lock()
	mock.calls.OnReset = append(mock.calls.OnReset, callInfo)
	mock.lockOnReset.Unlock()
	return mock.OnResetFunc()
}

// OnResetCalls gets all the calls that were made to OnReset.
// Check the length with:
//
//	len(mockedClient.OnResetCalls())
func (mock *ClientMock) OnResetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockOnReset.RLock()
	calls = mock.calls.OnReset
	mock.lockOnReset.RUnlock()
	return calls
}

// OnStart calls OnStartFunc.
func (mock *ClientMock) OnStart() error {
	if mock.OnStartFunc == nil {
		panic("ClientMock.OnStartFunc: method is nil but Client.OnStart was just called")
	}
	callInfo := struct {
	}{}
	mock.lockOnStart.Lock()
	mock.calls.OnStart = append(mock.calls.OnStart, callInfo)
	mock.lockOnStart.Unlock()
	return mock.OnStartFunc()
}

// OnStartCalls gets all the calls that were made to OnStart.
// Check the length with:
//
//	len(mockedClient.OnStartCalls())
func (mock *ClientMock) OnStartCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockOnStart.RLock()
	calls = mock.calls.OnStart
	mock.lockOnStart.RUnlock()
	return calls
}

// OnStop calls OnStopFunc.
func (mock *ClientMock) OnStop() {
	if mock.OnStopFunc == nil {
		panic("ClientMock.OnStopFunc: method is nil but Client.OnStop was just called")
	}
	callInfo := struct {
	}{}
	mock.lockOnStop.Lock()
	mock.calls.OnStop = append(mock.calls.OnStop, callInfo)
	mock.lockOnStop.Unlock()
	mock.OnStopFunc()
}

// OnStopCalls gets all the calls that were made to OnStop.
// Check the length with:
//
//	len(mockedClient.OnStopCalls())
func (mock *ClientMock) OnStopCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockOnStop.RLock()
	calls = mock.calls.OnStop
	mock.lockOnStop.RUnlock()
	return calls
}

// Quit calls QuitFunc.
func (mock *ClientMock) Quit() <-chan struct{} {
	if mock.QuitFunc == nil {
		panic("ClientMock.QuitFunc: method is nil but Client.Quit was just called")
	}
	callInfo := struct {
	}{}
	mock.lockQuit.Lock()
	mock.calls.Quit = append(mock.calls.Quit, callInfo)
	mock.lockQuit.Unlock()
	return mock.QuitFunc()
}

// QuitCalls gets all the calls that were made to Quit.
// Check the length with:
//
//	len(mockedClient.QuitCalls())
func (mock *ClientMock) QuitCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockQuit.RLock()
	calls = mock.calls.Quit
	mock.lockQuit.RUnlock()
	return calls
}

// Reset calls ResetFunc.
func (mock *ClientMock) Reset() error {
	if mock.ResetFunc == nil {
		panic("ClientMock.ResetFunc: method is nil but Client.Reset was just called")
	}
	callInfo := struct {
	}{}
	mock.lockReset.Lock()
	mock.calls.Reset = append(mock.calls.Reset, callInfo)
	mock.lockReset.Unlock()
	return mock.ResetFunc()
}

// ResetCalls gets all the calls that were made to Reset.
// Check the length with:
//
//	len(mockedClient.ResetCalls())
func (mock *ClientMock) ResetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockReset.RLock()
	calls = mock.calls.Reset
	mock.lockReset.RUnlock()
	return calls
}

// SetLogger calls SetLoggerFunc.
func (mock *ClientMock) SetLogger(logger log.Logger) {
	if mock.SetLoggerFunc == nil {
		panic("ClientMock.SetLoggerFunc: method is nil but Client.SetLogger was just called")
	}
	callInfo := struct {
		Logger log.Logger
	}{
		Logger: logger,
	}
	mock.lockSetLogger.Lock()
	mock.calls.SetLogger = append(mock.calls.SetLogger, callInfo)
	mock.lockSetLogger.Unlock()
	mock.SetLoggerFunc(logger)
}

// SetLoggerCalls gets all the calls that were made to SetLogger.
// Check the length with:
//
//	len(mockedClient.SetLoggerCalls())
func (mock *ClientMock) SetLoggerCalls() []struct {
	Logger log.Logger
} {
	var calls []struct {
		Logger log.Logger
	}
	mock.lockSetLogger.RLock()
	calls = mock.calls.SetLogger
	mock.lockSetLogger.RUnlock()
	return calls
}

// Start calls StartFunc.
func (mock *ClientMock) Start() error {
	if mock.StartFunc == nil {
		panic("ClientMock.StartFunc: method is nil but Client.Start was just called")
	}
	callInfo := struct {
	}{}
	mock.lockStart.Lock()
	mock.calls.Start = append(mock.calls.Start, callInfo)
	mock.lockStart.Unlock()
	return mock.StartFunc()
}

// StartCalls gets all the calls that were made to Start.
// Check the length with:
//
//	len(mockedClient.StartCalls())
func (mock *ClientMock) StartCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockStart.RLock()
	calls = mock.calls.Start
	mock.lockStart.RUnlock()
	return calls
}

// Status calls StatusFunc.
func (mock *ClientMock) Status(contextMoqParam context.Context) (*coretypes.ResultStatus, error) {
	if mock.StatusFunc == nil {
		panic("ClientMock.StatusFunc: method is nil but Client.Status was just called")
	}
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockStatus.Lock()
	mock.calls.Status = append(mock.calls.Status, callInfo)
	mock.lockStatus.Unlock()
	return mock.StatusFunc(contextMoqParam)
}

// StatusCalls gets all the calls that were made to Status.
// Check the length with:
//
//	len(mockedClient.StatusCalls())
func (mock *ClientMock) StatusCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockStatus.RLock()
	calls = mock.calls.Status
	mock.lockStatus.RUnlock()
	return calls
}

// Stop calls StopFunc.
func (mock *ClientMock) Stop() error {
	if mock.StopFunc == nil {
		panic("ClientMock.StopFunc: method is nil but Client.Stop was just called")
	}
	callInfo := struct {
	}{}
	mock.lockStop.Lock()
	mock.calls.Stop = append(mock.calls.Stop, callInfo)
	mock.lockStop.Unlock()
	return mock.StopFunc()
}

// StopCalls gets all the calls that were made to Stop.
// Check the length with:
//
//	len(mockedClient.StopCalls())
func (mock *ClientMock) StopCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockStop.RLock()
	calls = mock.calls.Stop
	mock.lockStop.RUnlock()
	return calls
}

// String calls StringFunc.
func (mock *ClientMock) String() string {
	if mock.StringFunc == nil {
		panic("ClientMock.StringFunc: method is nil but Client.String was just called")
	}
	callInfo := struct {
	}{}
	mock.lockString.Lock()
	mock.calls.String = append(mock.calls.String, callInfo)
	mock.lockString.Unlock()
	return mock.StringFunc()
}

// StringCalls gets all the calls that were made to String.
// Check the length with:
//
//	len(mockedClient.StringCalls())
func (mock *ClientMock) StringCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockString.RLock()
	calls = mock.calls.String
	mock.lockString.RUnlock()
	return calls
}

// Subscribe calls SubscribeFunc.
func (mock *ClientMock) Subscribe(ctx context.Context, subscriber string, query string, outCapacity ...int) (<-chan coretypes.ResultEvent, error) {
	if mock.SubscribeFunc == nil {
		panic("ClientMock.SubscribeFunc: method is nil but Client.Subscribe was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Subscriber  string
		Query       string
		OutCapacity []int
	}{
		Ctx:         ctx,
		Subscriber:  subscriber,
		Query:       query,
		OutCapacity: outCapacity,
	}
	mock.lockSubscribe.Lock()
	mock.calls.Subscribe = append(mock.calls.Subscribe, callInfo)
	mock.lockSubscribe.Unlock()
	return mock.SubscribeFunc(ctx, subscriber, query, outCapacity...)
}

// SubscribeCalls gets all the calls that were made to Subscribe.
// Check the length with:
//
//	len(mockedClient.SubscribeCalls())
func (mock *ClientMock) SubscribeCalls() []struct {
	Ctx         context.Context
	Subscriber  string
	Query       string
	OutCapacity []int
} {
	var calls []struct {
		Ctx         context.Context
		Subscriber  string
		Query       string
		OutCapacity []int
	}
	mock.lockSubscribe.RLock()
	calls = mock.calls.Subscribe
	mock.lockSubscribe.RUnlock()
	return calls
}

// Tx calls TxFunc.
func (mock *ClientMock) Tx(ctx context.Context, hash []byte, prove bool) (*coretypes.ResultTx, error) {
	if mock.TxFunc == nil {
		panic("ClientMock.TxFunc: method is nil but Client.Tx was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Hash  []byte
		Prove bool
	}{
		Ctx:   ctx,
		Hash:  hash,
		Prove: prove,
	}
	mock.lockTx.Lock()
	mock.calls.Tx = append(mock.calls.Tx, callInfo)
	mock.lockTx.Unlock()
	return mock.TxFunc(ctx, hash, prove)
}

// TxCalls gets all the calls that were made to Tx.
// Check the length with:
//
//	len(mockedClient.TxCalls())
func (mock *ClientMock) TxCalls() []struct {
	Ctx   context.Context
	Hash  []byte
	Prove bool
} {
	var calls []struct {
		Ctx   context.Context
		Hash  []byte
		Prove bool
	}
	mock.lockTx.RLock()
	calls = mock.calls.Tx
	mock.lockTx.RUnlock()
	return calls
}

// TxSearch calls TxSearchFunc.
func (mock *ClientMock) TxSearch(ctx context.Context, query string, prove bool, page *int, perPage *int, orderBy string) (*coretypes.ResultTxSearch, error) {
	if mock.TxSearchFunc == nil {
		panic("ClientMock.TxSearchFunc: method is nil but Client.TxSearch was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Query   string
		Prove   bool
		Page    *int
		PerPage *int
		OrderBy string
	}{
		Ctx:     ctx,
		Query:   query,
		Prove:   prove,
		Page:    page,
		PerPage: perPage,
		OrderBy: orderBy,
	}
	mock.lockTxSearch.Lock()
	mock.calls.TxSearch = append(mock.calls.TxSearch, callInfo)
	mock.lockTxSearch.Unlock()
	return mock.TxSearchFunc(ctx, query, prove, page, perPage, orderBy)
}

// TxSearchCalls gets all the calls that were made to TxSearch.
// Check the length with:
//
//	len(mockedClient.TxSearchCalls())
func (mock *ClientMock) TxSearchCalls() []struct {
	Ctx     context.Context
	Query   string
	Prove   bool
	Page    *int
	PerPage *int
	OrderBy string
} {
	var calls []struct {
		Ctx     context.Context
		Query   string
		Prove   bool
		Page    *int
		PerPage *int
		OrderBy string
	}
	mock.lockTxSearch.RLock()
	calls = mock.calls.TxSearch
	mock.lockTxSearch.RUnlock()
	return calls
}

// UnconfirmedTxs calls UnconfirmedTxsFunc.
func (mock *ClientMock) UnconfirmedTxs(ctx context.Context, limit *int) (*coretypes.ResultUnconfirmedTxs, error) {
	if mock.UnconfirmedTxsFunc == nil {
		panic("ClientMock.UnconfirmedTxsFunc: method is nil but Client.UnconfirmedTxs was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Limit *int
	}{
		Ctx:   ctx,
		Limit: limit,
	}
	mock.lockUnconfirmedTxs.Lock()
	mock.calls.UnconfirmedTxs = append(mock.calls.UnconfirmedTxs, callInfo)
	mock.lockUnconfirmedTxs.Unlock()
	return mock.UnconfirmedTxsFunc(ctx, limit)
}

// UnconfirmedTxsCalls gets all the calls that were made to UnconfirmedTxs.
// Check the length with:
//
//	len(mockedClient.UnconfirmedTxsCalls())
func (mock *ClientMock) UnconfirmedTxsCalls() []struct {
	Ctx   context.Context
	Limit *int
} {
	var calls []struct {
		Ctx   context.Context
		Limit *int
	}
	mock.lockUnconfirmedTxs.RLock()
	calls = mock.calls.UnconfirmedTxs
	mock.lockUnconfirmedTxs.RUnlock()
	return calls
}

// Unsubscribe calls UnsubscribeFunc.
func (mock *ClientMock) Unsubscribe(ctx context.Context, subscriber string, query string) error {
	if mock.UnsubscribeFunc == nil {
		panic("ClientMock.UnsubscribeFunc: method is nil but Client.Unsubscribe was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Subscriber string
		Query      string
	}{
		Ctx:        ctx,
		Subscriber: subscriber,
		Query:      query,
	}
	mock.lockUnsubscribe.Lock()
	mock.calls.Unsubscribe = append(mock.calls.Unsubscribe, callInfo)
	mock.lockUnsubscribe.Unlock()
	return mock.UnsubscribeFunc(ctx, subscriber, query)
}

// UnsubscribeCalls gets all the calls that were made to Unsubscribe.
// Check the length with:
//
//	len(mockedClient.UnsubscribeCalls())
func (mock *ClientMock) UnsubscribeCalls() []struct {
	Ctx        context.Context
	Subscriber string
	Query      string
} {
	var calls []struct {
		Ctx        context.Context
		Subscriber string
		Query      string
	}
	mock.lockUnsubscribe.RLock()
	calls = mock.calls.Unsubscribe
	mock.lockUnsubscribe.RUnlock()
	return calls
}

// UnsubscribeAll calls UnsubscribeAllFunc.
func (mock *ClientMock) UnsubscribeAll(ctx context.Context, subscriber string) error {
	if mock.UnsubscribeAllFunc == nil {
		panic("ClientMock.UnsubscribeAllFunc: method is nil but Client.UnsubscribeAll was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Subscriber string
	}{
		Ctx:        ctx,
		Subscriber: subscriber,
	}
	mock.lockUnsubscribeAll.Lock()
	mock.calls.UnsubscribeAll = append(mock.calls.UnsubscribeAll, callInfo)
	mock.lockUnsubscribeAll.Unlock()
	return mock.UnsubscribeAllFunc(ctx, subscriber)
}

// UnsubscribeAllCalls gets all the calls that were made to UnsubscribeAll.
// Check the length with:
//
//	len(mockedClient.UnsubscribeAllCalls())
func (mock *ClientMock) UnsubscribeAllCalls() []struct {
	Ctx        context.Context
	Subscriber string
} {
	var calls []struct {
		Ctx        context.Context
		Subscriber string
	}
	mock.lockUnsubscribeAll.RLock()
	calls = mock.calls.UnsubscribeAll
	mock.lockUnsubscribeAll.RUnlock()
	return calls
}

// Validators calls ValidatorsFunc.
func (mock *ClientMock) Validators(ctx context.Context, height *int64, page *int, perPage *int) (*coretypes.ResultValidators, error) {
	if mock.ValidatorsFunc == nil {
		panic("ClientMock.ValidatorsFunc: method is nil but Client.Validators was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Height  *int64
		Page    *int
		PerPage *int
	}{
		Ctx:     ctx,
		Height:  height,
		Page:    page,
		PerPage: perPage,
	}
	mock.lockValidators.Lock()
	mock.calls.Validators = append(mock.calls.Validators, callInfo)
	mock.lockValidators.Unlock()
	return mock.ValidatorsFunc(ctx, height, page, perPage)
}

// ValidatorsCalls gets all the calls that were made to Validators.
// Check the length with:
//
//	len(mockedClient.ValidatorsCalls())
func (mock *ClientMock) ValidatorsCalls() []struct {
	Ctx     context.Context
	Height  *int64
	Page    *int
	PerPage *int
} {
	var calls []struct {
		Ctx     context.Context
		Height  *int64
		Page    *int
		PerPage *int
	}
	mock.lockValidators.RLock()
	calls = mock.calls.Validators
	mock.lockValidators.RUnlock()
	return calls
}

// Ensure, that AccountRetrieverMock does implement AccountRetriever.
// If this is not the case, regenerate this file with moq.
var _ AccountRetriever = &AccountRetrieverMock{}

// AccountRetrieverMock is a mock implementation of AccountRetriever.
//
//	func TestSomethingThatUsesAccountRetriever(t *testing.T) {
//
//		// make and configure a mocked AccountRetriever
//		mockedAccountRetriever := &AccountRetrieverMock{
//			EnsureExistsFunc: func(clientCtx sdkClient.Context, addr sdk.AccAddress) error {
//				panic("mock out the EnsureExists method")
//			},
//			GetAccountFunc: func(clientCtx sdkClient.Context, addr sdk.AccAddress) (sdkClient.Account, error) {
//				panic("mock out the GetAccount method")
//			},
//			GetAccountNumberSequenceFunc: func(clientCtx sdkClient.Context, addr sdk.AccAddress) (uint64, uint64, error) {
//				panic("mock out the GetAccountNumberSequence method")
//			},
//			GetAccountWithHeightFunc: func(clientCtx sdkClient.Context, addr sdk.AccAddress) (sdkClient.Account, int64, error) {
//				panic("mock out the GetAccountWithHeight method")
//			},
//		}
//
//		// use mockedAccountRetriever in code that requires AccountRetriever
//		// and then make assertions.
//
//	}
type AccountRetrieverMock struct {
	// EnsureExistsFunc mocks the EnsureExists method.
	EnsureExistsFunc func(clientCtx sdkClient.Context, addr sdk.AccAddress) error

	// GetAccountFunc mocks the GetAccount method.
	GetAccountFunc func(clientCtx sdkClient.Context, addr sdk.AccAddress) (sdkClient.Account, error)

	// GetAccountNumberSequenceFunc mocks the GetAccountNumberSequence method.
	GetAccountNumberSequenceFunc func(clientCtx sdkClient.Context, addr sdk.AccAddress) (uint64, uint64, error)

	// GetAccountWithHeightFunc mocks the GetAccountWithHeight method.
	GetAccountWithHeightFunc func(clientCtx sdkClient.Context, addr sdk.AccAddress) (sdkClient.Account, int64, error)

	// calls tracks calls to the methods.
	calls struct {
		// EnsureExists holds details about calls to the EnsureExists method.
		EnsureExists []struct {
			// ClientCtx is the clientCtx argument value.
			ClientCtx sdkClient.Context
			// Addr is the addr argument value.
			Addr sdk.AccAddress
		}
		// GetAccount holds details about calls to the GetAccount method.
		GetAccount []struct {
			// ClientCtx is the clientCtx argument value.
			ClientCtx sdkClient.Context
			// Addr is the addr argument value.
			Addr sdk.AccAddress
		}
		// GetAccountNumberSequence holds details about calls to the GetAccountNumberSequence method.
		GetAccountNumberSequence []struct {
			// ClientCtx is the clientCtx argument value.
			ClientCtx sdkClient.Context
			// Addr is the addr argument value.
			Addr sdk.AccAddress
		}
		// GetAccountWithHeight holds details about calls to the GetAccountWithHeight method.
		GetAccountWithHeight []struct {
			// ClientCtx is the clientCtx argument value.
			ClientCtx sdkClient.Context
			// Addr is the addr argument value.
			Addr sdk.AccAddress
		}
	}
	lockEnsureExists             sync.RWMutex
	lockGetAccount               sync.RWMutex
	lockGetAccountNumberSequence sync.RWMutex
	lockGetAccountWithHeight     sync.RWMutex
}

// EnsureExists calls EnsureExistsFunc.
func (mock *AccountRetrieverMock) EnsureExists(clientCtx sdkClient.Context, addr sdk.AccAddress) error {
	if mock.EnsureExistsFunc == nil {
		panic("AccountRetrieverMock.EnsureExistsFunc: method is nil but AccountRetriever.EnsureExists was just called")
	}
	callInfo := struct {
		ClientCtx sdkClient.Context
		Addr      sdk.AccAddress
	}{
		ClientCtx: clientCtx,
		Addr:      addr,
	}
	mock.lockEnsureExists.Lock()
	mock.calls.EnsureExists = append(mock.calls.EnsureExists, callInfo)
	mock.lockEnsureExists.Unlock()
	return mock.EnsureExistsFunc(clientCtx, addr)
}

// EnsureExistsCalls gets all the calls that were made to EnsureExists.
// Check the length with:
//
//	len(mockedAccountRetriever.EnsureExistsCalls())
func (mock *AccountRetrieverMock) EnsureExistsCalls() []struct {
	ClientCtx sdkClient.Context
	Addr      sdk.AccAddress
} {
	var calls []struct {
		ClientCtx sdkClient.Context
		Addr      sdk.AccAddress
	}
	mock.lockEnsureExists.RLock()
	calls = mock.calls.EnsureExists
	mock.lockEnsureExists.RUnlock()
	return calls
}

// GetAccount calls GetAccountFunc.
func (mock *AccountRetrieverMock) GetAccount(clientCtx sdkClient.Context, addr sdk.AccAddress) (sdkClient.Account, error) {
	if mock.GetAccountFunc == nil {
		panic("AccountRetrieverMock.GetAccountFunc: method is nil but AccountRetriever.GetAccount was just called")
	}
	callInfo := struct {
		ClientCtx sdkClient.Context
		Addr      sdk.AccAddress
	}{
		ClientCtx: clientCtx,
		Addr:      addr,
	}
	mock.lockGetAccount.Lock()
	mock.calls.GetAccount = append(mock.calls.GetAccount, callInfo)
	mock.lockGetAccount.Unlock()
	return mock.GetAccountFunc(clientCtx, addr)
}

// GetAccountCalls gets all the calls that were made to GetAccount.
// Check the length with:
//
//	len(mockedAccountRetriever.GetAccountCalls())
func (mock *AccountRetrieverMock) GetAccountCalls() []struct {
	ClientCtx sdkClient.Context
	Addr      sdk.AccAddress
} {
	var calls []struct {
		ClientCtx sdkClient.Context
		Addr      sdk.AccAddress
	}
	mock.lockGetAccount.RLock()
	calls = mock.calls.GetAccount
	mock.lockGetAccount.RUnlock()
	return calls
}

// GetAccountNumberSequence calls GetAccountNumberSequenceFunc.
func (mock *AccountRetrieverMock) GetAccountNumberSequence(clientCtx sdkClient.Context, addr sdk.AccAddress) (uint64, uint64, error) {
	if mock.GetAccountNumberSequenceFunc == nil {
		panic("AccountRetrieverMock.GetAccountNumberSequenceFunc: method is nil but AccountRetriever.GetAccountNumberSequence was just called")
	}
	callInfo := struct {
		ClientCtx sdkClient.Context
		Addr      sdk.AccAddress
	}{
		ClientCtx: clientCtx,
		Addr:      addr,
	}
	mock.lockGetAccountNumberSequence.Lock()
	mock.calls.GetAccountNumberSequence = append(mock.calls.GetAccountNumberSequence, callInfo)
	mock.lockGetAccountNumberSequence.Unlock()
	return mock.GetAccountNumberSequenceFunc(clientCtx, addr)
}

// GetAccountNumberSequenceCalls gets all the calls that were made to GetAccountNumberSequence.
// Check the length with:
//
//	len(mockedAccountRetriever.GetAccountNumberSequenceCalls())
func (mock *AccountRetrieverMock) GetAccountNumberSequenceCalls() []struct {
	ClientCtx sdkClient.Context
	Addr      sdk.AccAddress
} {
	var calls []struct {
		ClientCtx sdkClient.Context
		Addr      sdk.AccAddress
	}
	mock.lockGetAccountNumberSequence.RLock()
	calls = mock.calls.GetAccountNumberSequence
	mock.lockGetAccountNumberSequence.RUnlock()
	return calls
}

// GetAccountWithHeight calls GetAccountWithHeightFunc.
func (mock *AccountRetrieverMock) GetAccountWithHeight(clientCtx sdkClient.Context, addr sdk.AccAddress) (sdkClient.Account, int64, error) {
	if mock.GetAccountWithHeightFunc == nil {
		panic("AccountRetrieverMock.GetAccountWithHeightFunc: method is nil but AccountRetriever.GetAccountWithHeight was just called")
	}
	callInfo := struct {
		ClientCtx sdkClient.Context
		Addr      sdk.AccAddress
	}{
		ClientCtx: clientCtx,
		Addr:      addr,
	}
	mock.lockGetAccountWithHeight.Lock()
	mock.calls.GetAccountWithHeight = append(mock.calls.GetAccountWithHeight, callInfo)
	mock.lockGetAccountWithHeight.Unlock()
	return mock.GetAccountWithHeightFunc(clientCtx, addr)
}

// GetAccountWithHeightCalls gets all the calls that were made to GetAccountWithHeight.
// Check the length with:
//
//	len(mockedAccountRetriever.GetAccountWithHeightCalls())
func (mock *AccountRetrieverMock) GetAccountWithHeightCalls() []struct {
	ClientCtx sdkClient.Context
	Addr      sdk.AccAddress
} {
	var calls []struct {
		ClientCtx sdkClient.Context
		Addr      sdk.AccAddress
	}
	mock.lockGetAccountWithHeight.RLock()
	calls = mock.calls.GetAccountWithHeight
	mock.lockGetAccountWithHeight.RUnlock()
	return calls
}

// Ensure, that KeyringMock does implement Keyring.
// If this is not the case, regenerate this file with moq.
var _ Keyring = &KeyringMock{}

// KeyringMock is a mock implementation of Keyring.
//
//	func TestSomethingThatUsesKeyring(t *testing.T) {
//
//		// make and configure a mocked Keyring
//		mockedKeyring := &KeyringMock{
//			DeleteFunc: func(uid string) error {
//				panic("mock out the Delete method")
//			},
//			DeleteByAddressFunc: func(address sdk.Address) error {
//				panic("mock out the DeleteByAddress method")
//			},
//			ExportPrivKeyArmorFunc: func(uid string, encryptPassphrase string) (string, error) {
//				panic("mock out the ExportPrivKeyArmor method")
//			},
//			ExportPrivKeyArmorByAddressFunc: func(address sdk.Address, encryptPassphrase string) (string, error) {
//				panic("mock out the ExportPrivKeyArmorByAddress method")
//			},
//			ExportPubKeyArmorFunc: func(uid string) (string, error) {
//				panic("mock out the ExportPubKeyArmor method")
//			},
//			ExportPubKeyArmorByAddressFunc: func(address sdk.Address) (string, error) {
//				panic("mock out the ExportPubKeyArmorByAddress method")
//			},
//			ImportPrivKeyFunc: func(uid string, armor string, passphrase string) error {
//				panic("mock out the ImportPrivKey method")
//			},
//			ImportPubKeyFunc: func(uid string, armor string) error {
//				panic("mock out the ImportPubKey method")
//			},
//			KeyFunc: func(uid string) (keyring.Info, error) {
//				panic("mock out the Key method")
//			},
//			KeyByAddressFunc: func(address sdk.Address) (keyring.Info, error) {
//				panic("mock out the KeyByAddress method")
//			},
//			ListFunc: func() ([]keyring.Info, error) {
//				panic("mock out the List method")
//			},
//			NewAccountFunc: func(uid string, mnemonic string, bip39Passphrase string, hdPath string, algo keyring.SignatureAlgo) (keyring.Info, error) {
//				panic("mock out the NewAccount method")
//			},
//			NewMnemonicFunc: func(uid string, language keyring.Language, hdPath string, bip39Passphrase string, algo keyring.SignatureAlgo) (keyring.Info, string, error) {
//				panic("mock out the NewMnemonic method")
//			},
//			SaveLedgerKeyFunc: func(uid string, algo keyring.SignatureAlgo, hrp string, coinType uint32, account uint32, index uint32) (keyring.Info, error) {
//				panic("mock out the SaveLedgerKey method")
//			},
//			SaveMultisigFunc: func(uid string, pubkey cryptotypes.PubKey) (keyring.Info, error) {
//				panic("mock out the SaveMultisig method")
//			},
//			SavePubKeyFunc: func(uid string, pubkey cryptotypes.PubKey, algo hd.PubKeyType) (keyring.Info, error) {
//				panic("mock out the SavePubKey method")
//			},
//			SignFunc: func(uid string, msg []byte) ([]byte, cryptotypes.PubKey, error) {
//				panic("mock out the Sign method")
//			},
//			SignByAddressFunc: func(address sdk.Address, msg []byte) ([]byte, cryptotypes.PubKey, error) {
//				panic("mock out the SignByAddress method")
//			},
//			SupportedAlgorithmsFunc: func() (keyring.SigningAlgoList, keyring.SigningAlgoList) {
//				panic("mock out the SupportedAlgorithms method")
//			},
//		}
//
//		// use mockedKeyring in code that requires Keyring
//		// and then make assertions.
//
//	}
type KeyringMock struct {
	// DeleteFunc mocks the Delete method.
	DeleteFunc func(uid string) error

	// DeleteByAddressFunc mocks the DeleteByAddress method.
	DeleteByAddressFunc func(address sdk.Address) error

	// ExportPrivKeyArmorFunc mocks the ExportPrivKeyArmor method.
	ExportPrivKeyArmorFunc func(uid string, encryptPassphrase string) (string, error)

	// ExportPrivKeyArmorByAddressFunc mocks the ExportPrivKeyArmorByAddress method.
	ExportPrivKeyArmorByAddressFunc func(address sdk.Address, encryptPassphrase string) (string, error)

	// ExportPubKeyArmorFunc mocks the ExportPubKeyArmor method.
	ExportPubKeyArmorFunc func(uid string) (string, error)

	// ExportPubKeyArmorByAddressFunc mocks the ExportPubKeyArmorByAddress method.
	ExportPubKeyArmorByAddressFunc func(address sdk.Address) (string, error)

	// ImportPrivKeyFunc mocks the ImportPrivKey method.
	ImportPrivKeyFunc func(uid string, armor string, passphrase string) error

	// ImportPubKeyFunc mocks the ImportPubKey method.
	ImportPubKeyFunc func(uid string, armor string) error

	// KeyFunc mocks the Key method.
	KeyFunc func(uid string) (keyring.Info, error)

	// KeyByAddressFunc mocks the KeyByAddress method.
	KeyByAddressFunc func(address sdk.Address) (keyring.Info, error)

	// ListFunc mocks the List method.
	ListFunc func() ([]keyring.Info, error)

	// NewAccountFunc mocks the NewAccount method.
	NewAccountFunc func(uid string, mnemonic string, bip39Passphrase string, hdPath string, algo keyring.SignatureAlgo) (keyring.Info, error)

	// NewMnemonicFunc mocks the NewMnemonic method.
	NewMnemonicFunc func(uid string, language keyring.Language, hdPath string, bip39Passphrase string, algo keyring.SignatureAlgo) (keyring.Info, string, error)

	// SaveLedgerKeyFunc mocks the SaveLedgerKey method.
	SaveLedgerKeyFunc func(uid string, algo keyring.SignatureAlgo, hrp string, coinType uint32, account uint32, index uint32) (keyring.Info, error)

	// SaveMultisigFunc mocks the SaveMultisig method.
	SaveMultisigFunc func(uid string, pubkey cryptotypes.PubKey) (keyring.Info, error)

	// SavePubKeyFunc mocks the SavePubKey method.
	SavePubKeyFunc func(uid string, pubkey cryptotypes.PubKey, algo hd.PubKeyType) (keyring.Info, error)

	// SignFunc mocks the Sign method.
	SignFunc func(uid string, msg []byte) ([]byte, cryptotypes.PubKey, error)

	// SignByAddressFunc mocks the SignByAddress method.
	SignByAddressFunc func(address sdk.Address, msg []byte) ([]byte, cryptotypes.PubKey, error)

	// SupportedAlgorithmsFunc mocks the SupportedAlgorithms method.
	SupportedAlgorithmsFunc func() (keyring.SigningAlgoList, keyring.SigningAlgoList)

	// calls tracks calls to the methods.
	calls struct {
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// UID is the uid argument value.
			UID string
		}
		// DeleteByAddress holds details about calls to the DeleteByAddress method.
		DeleteByAddress []struct {
			// Address is the address argument value.
			Address sdk.Address
		}
		// ExportPrivKeyArmor holds details about calls to the ExportPrivKeyArmor method.
		ExportPrivKeyArmor []struct {
			// UID is the uid argument value.
			UID string
			// EncryptPassphrase is the encryptPassphrase argument value.
			EncryptPassphrase string
		}
		// ExportPrivKeyArmorByAddress holds details about calls to the ExportPrivKeyArmorByAddress method.
		ExportPrivKeyArmorByAddress []struct {
			// Address is the address argument value.
			Address sdk.Address
			// EncryptPassphrase is the encryptPassphrase argument value.
			EncryptPassphrase string
		}
		// ExportPubKeyArmor holds details about calls to the ExportPubKeyArmor method.
		ExportPubKeyArmor []struct {
			// UID is the uid argument value.
			UID string
		}
		// ExportPubKeyArmorByAddress holds details about calls to the ExportPubKeyArmorByAddress method.
		ExportPubKeyArmorByAddress []struct {
			// Address is the address argument value.
			Address sdk.Address
		}
		// ImportPrivKey holds details about calls to the ImportPrivKey method.
		ImportPrivKey []struct {
			// UID is the uid argument value.
			UID string
			// Armor is the armor argument value.
			Armor string
			// Passphrase is the passphrase argument value.
			Passphrase string
		}
		// ImportPubKey holds details about calls to the ImportPubKey method.
		ImportPubKey []struct {
			// UID is the uid argument value.
			UID string
			// Armor is the armor argument value.
			Armor string
		}
		// Key holds details about calls to the Key method.
		Key []struct {
			// UID is the uid argument value.
			UID string
		}
		// KeyByAddress holds details about calls to the KeyByAddress method.
		KeyByAddress []struct {
			// Address is the address argument value.
			Address sdk.Address
		}
		// List holds details about calls to the List method.
		List []struct {
		}
		// NewAccount holds details about calls to the NewAccount method.
		NewAccount []struct {
			// UID is the uid argument value.
			UID string
			// Mnemonic is the mnemonic argument value.
			Mnemonic string
			// Bip39Passphrase is the bip39Passphrase argument value.
			Bip39Passphrase string
			// HdPath is the hdPath argument value.
			HdPath string
			// Algo is the algo argument value.
			Algo keyring.SignatureAlgo
		}
		// NewMnemonic holds details about calls to the NewMnemonic method.
		NewMnemonic []struct {
			// UID is the uid argument value.
			UID string
			// Language is the language argument value.
			Language keyring.Language
			// HdPath is the hdPath argument value.
			HdPath string
			// Bip39Passphrase is the bip39Passphrase argument value.
			Bip39Passphrase string
			// Algo is the algo argument value.
			Algo keyring.SignatureAlgo
		}
		// SaveLedgerKey holds details about calls to the SaveLedgerKey method.
		SaveLedgerKey []struct {
			// UID is the uid argument value.
			UID string
			// Algo is the algo argument value.
			Algo keyring.SignatureAlgo
			// Hrp is the hrp argument value.
			Hrp string
			// CoinType is the coinType argument value.
			CoinType uint32
			// Account is the account argument value.
			Account uint32
			// Index is the index argument value.
			Index uint32
		}
		// SaveMultisig holds details about calls to the SaveMultisig method.
		SaveMultisig []struct {
			// UID is the uid argument value.
			UID string
			// Pubkey is the pubkey argument value.
			Pubkey cryptotypes.PubKey
		}
		// SavePubKey holds details about calls to the SavePubKey method.
		SavePubKey []struct {
			// UID is the uid argument value.
			UID string
			// Pubkey is the pubkey argument value.
			Pubkey cryptotypes.PubKey
			// Algo is the algo argument value.
			Algo hd.PubKeyType
		}
		// Sign holds details about calls to the Sign method.
		Sign []struct {
			// UID is the uid argument value.
			UID string
			// Msg is the msg argument value.
			Msg []byte
		}
		// SignByAddress holds details about calls to the SignByAddress method.
		SignByAddress []struct {
			// Address is the address argument value.
			Address sdk.Address
			// Msg is the msg argument value.
			Msg []byte
		}
		// SupportedAlgorithms holds details about calls to the SupportedAlgorithms method.
		SupportedAlgorithms []struct {
		}
	}
	lockDelete                      sync.RWMutex
	lockDeleteByAddress             sync.RWMutex
	lockExportPrivKeyArmor          sync.RWMutex
	lockExportPrivKeyArmorByAddress sync.RWMutex
	lockExportPubKeyArmor           sync.RWMutex
	lockExportPubKeyArmorByAddress  sync.RWMutex
	lockImportPrivKey               sync.RWMutex
	lockImportPubKey                sync.RWMutex
	lockKey                         sync.RWMutex
	lockKeyByAddress                sync.RWMutex
	lockList                        sync.RWMutex
	lockNewAccount                  sync.RWMutex
	lockNewMnemonic                 sync.RWMutex
	lockSaveLedgerKey               sync.RWMutex
	lockSaveMultisig                sync.RWMutex
	lockSavePubKey                  sync.RWMutex
	lockSign                        sync.RWMutex
	lockSignByAddress               sync.RWMutex
	lockSupportedAlgorithms         sync.RWMutex
}

// Delete calls DeleteFunc.
func (mock *KeyringMock) Delete(uid string) error {
	if mock.DeleteFunc == nil {
		panic("KeyringMock.DeleteFunc: method is nil but Keyring.Delete was just called")
	}
	callInfo := struct {
		UID string
	}{
		UID: uid,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(uid)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedKeyring.DeleteCalls())
func (mock *KeyringMock) DeleteCalls() []struct {
	UID string
} {
	var calls []struct {
		UID string
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// DeleteByAddress calls DeleteByAddressFunc.
func (mock *KeyringMock) DeleteByAddress(address sdk.Address) error {
	if mock.DeleteByAddressFunc == nil {
		panic("KeyringMock.DeleteByAddressFunc: method is nil but Keyring.DeleteByAddress was just called")
	}
	callInfo := struct {
		Address sdk.Address
	}{
		Address: address,
	}
	mock.lockDeleteByAddress.Lock()
	mock.calls.DeleteByAddress = append(mock.calls.DeleteByAddress, callInfo)
	mock.lockDeleteByAddress.Unlock()
	return mock.DeleteByAddressFunc(address)
}

// DeleteByAddressCalls gets all the calls that were made to DeleteByAddress.
// Check the length with:
//
//	len(mockedKeyring.DeleteByAddressCalls())
func (mock *KeyringMock) DeleteByAddressCalls() []struct {
	Address sdk.Address
} {
	var calls []struct {
		Address sdk.Address
	}
	mock.lockDeleteByAddress.RLock()
	calls = mock.calls.DeleteByAddress
	mock.lockDeleteByAddress.RUnlock()
	return calls
}

// ExportPrivKeyArmor calls ExportPrivKeyArmorFunc.
func (mock *KeyringMock) ExportPrivKeyArmor(uid string, encryptPassphrase string) (string, error) {
	if mock.ExportPrivKeyArmorFunc == nil {
		panic("KeyringMock.ExportPrivKeyArmorFunc: method is nil but Keyring.ExportPrivKeyArmor was just called")
	}
	callInfo := struct {
		UID               string
		EncryptPassphrase string
	}{
		UID:               uid,
		EncryptPassphrase: encryptPassphrase,
	}
	mock.lockExportPrivKeyArmor.Lock()
	mock.calls.ExportPrivKeyArmor = append(mock.calls.ExportPrivKeyArmor, callInfo)
	mock.lockExportPrivKeyArmor.Unlock()
	return mock.ExportPrivKeyArmorFunc(uid, encryptPassphrase)
}

// ExportPrivKeyArmorCalls gets all the calls that were made to ExportPrivKeyArmor.
// Check the length with:
//
//	len(mockedKeyring.ExportPrivKeyArmorCalls())
func (mock *KeyringMock) ExportPrivKeyArmorCalls() []struct {
	UID               string
	EncryptPassphrase string
} {
	var calls []struct {
		UID               string
		EncryptPassphrase string
	}
	mock.lockExportPrivKeyArmor.RLock()
	calls = mock.calls.ExportPrivKeyArmor
	mock.lockExportPrivKeyArmor.RUnlock()
	return calls
}

// ExportPrivKeyArmorByAddress calls ExportPrivKeyArmorByAddressFunc.
func (mock *KeyringMock) ExportPrivKeyArmorByAddress(address sdk.Address, encryptPassphrase string) (string, error) {
	if mock.ExportPrivKeyArmorByAddressFunc == nil {
		panic("KeyringMock.ExportPrivKeyArmorByAddressFunc: method is nil but Keyring.ExportPrivKeyArmorByAddress was just called")
	}
	callInfo := struct {
		Address           sdk.Address
		EncryptPassphrase string
	}{
		Address:           address,
		EncryptPassphrase: encryptPassphrase,
	}
	mock.lockExportPrivKeyArmorByAddress.Lock()
	mock.calls.ExportPrivKeyArmorByAddress = append(mock.calls.ExportPrivKeyArmorByAddress, callInfo)
	mock.lockExportPrivKeyArmorByAddress.Unlock()
	return mock.ExportPrivKeyArmorByAddressFunc(address, encryptPassphrase)
}

// ExportPrivKeyArmorByAddressCalls gets all the calls that were made to ExportPrivKeyArmorByAddress.
// Check the length with:
//
//	len(mockedKeyring.ExportPrivKeyArmorByAddressCalls())
func (mock *KeyringMock) ExportPrivKeyArmorByAddressCalls() []struct {
	Address           sdk.Address
	EncryptPassphrase string
} {
	var calls []struct {
		Address           sdk.Address
		EncryptPassphrase string
	}
	mock.lockExportPrivKeyArmorByAddress.RLock()
	calls = mock.calls.ExportPrivKeyArmorByAddress
	mock.lockExportPrivKeyArmorByAddress.RUnlock()
	return calls
}

// ExportPubKeyArmor calls ExportPubKeyArmorFunc.
func (mock *KeyringMock) ExportPubKeyArmor(uid string) (string, error) {
	if mock.ExportPubKeyArmorFunc == nil {
		panic("KeyringMock.ExportPubKeyArmorFunc: method is nil but Keyring.ExportPubKeyArmor was just called")
	}
	callInfo := struct {
		UID string
	}{
		UID: uid,
	}
	mock.lockExportPubKeyArmor.Lock()
	mock.calls.ExportPubKeyArmor = append(mock.calls.ExportPubKeyArmor, callInfo)
	mock.lockExportPubKeyArmor.Unlock()
	return mock.ExportPubKeyArmorFunc(uid)
}

// ExportPubKeyArmorCalls gets all the calls that were made to ExportPubKeyArmor.
// Check the length with:
//
//	len(mockedKeyring.ExportPubKeyArmorCalls())
func (mock *KeyringMock) ExportPubKeyArmorCalls() []struct {
	UID string
} {
	var calls []struct {
		UID string
	}
	mock.lockExportPubKeyArmor.RLock()
	calls = mock.calls.ExportPubKeyArmor
	mock.lockExportPubKeyArmor.RUnlock()
	return calls
}

// ExportPubKeyArmorByAddress calls ExportPubKeyArmorByAddressFunc.
func (mock *KeyringMock) ExportPubKeyArmorByAddress(address sdk.Address) (string, error) {
	if mock.ExportPubKeyArmorByAddressFunc == nil {
		panic("KeyringMock.ExportPubKeyArmorByAddressFunc: method is nil but Keyring.ExportPubKeyArmorByAddress was just called")
	}
	callInfo := struct {
		Address sdk.Address
	}{
		Address: address,
	}
	mock.lockExportPubKeyArmorByAddress.Lock()
	mock.calls.ExportPubKeyArmorByAddress = append(mock.calls.ExportPubKeyArmorByAddress, callInfo)
	mock.lockExportPubKeyArmorByAddress.Unlock()
	return mock.ExportPubKeyArmorByAddressFunc(address)
}

// ExportPubKeyArmorByAddressCalls gets all the calls that were made to ExportPubKeyArmorByAddress.
// Check the length with:
//
//	len(mockedKeyring.ExportPubKeyArmorByAddressCalls())
func (mock *KeyringMock) ExportPubKeyArmorByAddressCalls() []struct {
	Address sdk.Address
} {
	var calls []struct {
		Address sdk.Address
	}
	mock.lockExportPubKeyArmorByAddress.RLock()
	calls = mock.calls.ExportPubKeyArmorByAddress
	mock.lockExportPubKeyArmorByAddress.RUnlock()
	return calls
}

// ImportPrivKey calls ImportPrivKeyFunc.
func (mock *KeyringMock) ImportPrivKey(uid string, armor string, passphrase string) error {
	if mock.ImportPrivKeyFunc == nil {
		panic("KeyringMock.ImportPrivKeyFunc: method is nil but Keyring.ImportPrivKey was just called")
	}
	callInfo := struct {
		UID        string
		Armor      string
		Passphrase string
	}{
		UID:        uid,
		Armor:      armor,
		Passphrase: passphrase,
	}
	mock.lockImportPrivKey.Lock()
	mock.calls.ImportPrivKey = append(mock.calls.ImportPrivKey, callInfo)
	mock.lockImportPrivKey.Unlock()
	return mock.ImportPrivKeyFunc(uid, armor, passphrase)
}

// ImportPrivKeyCalls gets all the calls that were made to ImportPrivKey.
// Check the length with:
//
//	len(mockedKeyring.ImportPrivKeyCalls())
func (mock *KeyringMock) ImportPrivKeyCalls() []struct {
	UID        string
	Armor      string
	Passphrase string
} {
	var calls []struct {
		UID        string
		Armor      string
		Passphrase string
	}
	mock.lockImportPrivKey.RLock()
	calls = mock.calls.ImportPrivKey
	mock.lockImportPrivKey.RUnlock()
	return calls
}

// ImportPubKey calls ImportPubKeyFunc.
func (mock *KeyringMock) ImportPubKey(uid string, armor string) error {
	if mock.ImportPubKeyFunc == nil {
		panic("KeyringMock.ImportPubKeyFunc: method is nil but Keyring.ImportPubKey was just called")
	}
	callInfo := struct {
		UID   string
		Armor string
	}{
		UID:   uid,
		Armor: armor,
	}
	mock.lockImportPubKey.Lock()
	mock.calls.ImportPubKey = append(mock.calls.ImportPubKey, callInfo)
	mock.lockImportPubKey.Unlock()
	return mock.ImportPubKeyFunc(uid, armor)
}

// ImportPubKeyCalls gets all the calls that were made to ImportPubKey.
// Check the length with:
//
//	len(mockedKeyring.ImportPubKeyCalls())
func (mock *KeyringMock) ImportPubKeyCalls() []struct {
	UID   string
	Armor string
} {
	var calls []struct {
		UID   string
		Armor string
	}
	mock.lockImportPubKey.RLock()
	calls = mock.calls.ImportPubKey
	mock.lockImportPubKey.RUnlock()
	return calls
}

// Key calls KeyFunc.
func (mock *KeyringMock) Key(uid string) (keyring.Info, error) {
	if mock.KeyFunc == nil {
		panic("KeyringMock.KeyFunc: method is nil but Keyring.Key was just called")
	}
	callInfo := struct {
		UID string
	}{
		UID: uid,
	}
	mock.lockKey.Lock()
	mock.calls.Key = append(mock.calls.Key, callInfo)
	mock.lockKey.Unlock()
	return mock.KeyFunc(uid)
}

// KeyCalls gets all the calls that were made to Key.
// Check the length with:
//
//	len(mockedKeyring.KeyCalls())
func (mock *KeyringMock) KeyCalls() []struct {
	UID string
} {
	var calls []struct {
		UID string
	}
	mock.lockKey.RLock()
	calls = mock.calls.Key
	mock.lockKey.RUnlock()
	return calls
}

// KeyByAddress calls KeyByAddressFunc.
func (mock *KeyringMock) KeyByAddress(address sdk.Address) (keyring.Info, error) {
	if mock.KeyByAddressFunc == nil {
		panic("KeyringMock.KeyByAddressFunc: method is nil but Keyring.KeyByAddress was just called")
	}
	callInfo := struct {
		Address sdk.Address
	}{
		Address: address,
	}
	mock.lockKeyByAddress.Lock()
	mock.calls.KeyByAddress = append(mock.calls.KeyByAddress, callInfo)
	mock.lockKeyByAddress.Unlock()
	return mock.KeyByAddressFunc(address)
}

// KeyByAddressCalls gets all the calls that were made to KeyByAddress.
// Check the length with:
//
//	len(mockedKeyring.KeyByAddressCalls())
func (mock *KeyringMock) KeyByAddressCalls() []struct {
	Address sdk.Address
} {
	var calls []struct {
		Address sdk.Address
	}
	mock.lockKeyByAddress.RLock()
	calls = mock.calls.KeyByAddress
	mock.lockKeyByAddress.RUnlock()
	return calls
}

// List calls ListFunc.
func (mock *KeyringMock) List() ([]keyring.Info, error) {
	if mock.ListFunc == nil {
		panic("KeyringMock.ListFunc: method is nil but Keyring.List was just called")
	}
	callInfo := struct {
	}{}
	mock.lockList.Lock()
	mock.calls.List = append(mock.calls.List, callInfo)
	mock.lockList.Unlock()
	return mock.ListFunc()
}

// ListCalls gets all the calls that were made to List.
// Check the length with:
//
//	len(mockedKeyring.ListCalls())
func (mock *KeyringMock) ListCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockList.RLock()
	calls = mock.calls.List
	mock.lockList.RUnlock()
	return calls
}

// NewAccount calls NewAccountFunc.
func (mock *KeyringMock) NewAccount(uid string, mnemonic string, bip39Passphrase string, hdPath string, algo keyring.SignatureAlgo) (keyring.Info, error) {
	if mock.NewAccountFunc == nil {
		panic("KeyringMock.NewAccountFunc: method is nil but Keyring.NewAccount was just called")
	}
	callInfo := struct {
		UID             string
		Mnemonic        string
		Bip39Passphrase string
		HdPath          string
		Algo            keyring.SignatureAlgo
	}{
		UID:             uid,
		Mnemonic:        mnemonic,
		Bip39Passphrase: bip39Passphrase,
		HdPath:          hdPath,
		Algo:            algo,
	}
	mock.lockNewAccount.Lock()
	mock.calls.NewAccount = append(mock.calls.NewAccount, callInfo)
	mock.lockNewAccount.Unlock()
	return mock.NewAccountFunc(uid, mnemonic, bip39Passphrase, hdPath, algo)
}

// NewAccountCalls gets all the calls that were made to NewAccount.
// Check the length with:
//
//	len(mockedKeyring.NewAccountCalls())
func (mock *KeyringMock) NewAccountCalls() []struct {
	UID             string
	Mnemonic        string
	Bip39Passphrase string
	HdPath          string
	Algo            keyring.SignatureAlgo
} {
	var calls []struct {
		UID             string
		Mnemonic        string
		Bip39Passphrase string
		HdPath          string
		Algo            keyring.SignatureAlgo
	}
	mock.lockNewAccount.RLock()
	calls = mock.calls.NewAccount
	mock.lockNewAccount.RUnlock()
	return calls
}

// NewMnemonic calls NewMnemonicFunc.
func (mock *KeyringMock) NewMnemonic(uid string, language keyring.Language, hdPath string, bip39Passphrase string, algo keyring.SignatureAlgo) (keyring.Info, string, error) {
	if mock.NewMnemonicFunc == nil {
		panic("KeyringMock.NewMnemonicFunc: method is nil but Keyring.NewMnemonic was just called")
	}
	callInfo := struct {
		UID             string
		Language        keyring.Language
		HdPath          string
		Bip39Passphrase string
		Algo            keyring.SignatureAlgo
	}{
		UID:             uid,
		Language:        language,
		HdPath:          hdPath,
		Bip39Passphrase: bip39Passphrase,
		Algo:            algo,
	}
	mock.lockNewMnemonic.Lock()
	mock.calls.NewMnemonic = append(mock.calls.NewMnemonic, callInfo)
	mock.lockNewMnemonic.Unlock()
	return mock.NewMnemonicFunc(uid, language, hdPath, bip39Passphrase, algo)
}

// NewMnemonicCalls gets all the calls that were made to NewMnemonic.
// Check the length with:
//
//	len(mockedKeyring.NewMnemonicCalls())
func (mock *KeyringMock) NewMnemonicCalls() []struct {
	UID             string
	Language        keyring.Language
	HdPath          string
	Bip39Passphrase string
	Algo            keyring.SignatureAlgo
} {
	var calls []struct {
		UID             string
		Language        keyring.Language
		HdPath          string
		Bip39Passphrase string
		Algo            keyring.SignatureAlgo
	}
	mock.lockNewMnemonic.RLock()
	calls = mock.calls.NewMnemonic
	mock.lockNewMnemonic.RUnlock()
	return calls
}

// SaveLedgerKey calls SaveLedgerKeyFunc.
func (mock *KeyringMock) SaveLedgerKey(uid string, algo keyring.SignatureAlgo, hrp string, coinType uint32, account uint32, index uint32) (keyring.Info, error) {
	if mock.SaveLedgerKeyFunc == nil {
		panic("KeyringMock.SaveLedgerKeyFunc: method is nil but Keyring.SaveLedgerKey was just called")
	}
	callInfo := struct {
		UID      string
		Algo     keyring.SignatureAlgo
		Hrp      string
		CoinType uint32
		Account  uint32
		Index    uint32
	}{
		UID:      uid,
		Algo:     algo,
		Hrp:      hrp,
		CoinType: coinType,
		Account:  account,
		Index:    index,
	}
	mock.lockSaveLedgerKey.Lock()
	mock.calls.SaveLedgerKey = append(mock.calls.SaveLedgerKey, callInfo)
	mock.lockSaveLedgerKey.Unlock()
	return mock.SaveLedgerKeyFunc(uid, algo, hrp, coinType, account, index)
}

// SaveLedgerKeyCalls gets all the calls that were made to SaveLedgerKey.
// Check the length with:
//
//	len(mockedKeyring.SaveLedgerKeyCalls())
func (mock *KeyringMock) SaveLedgerKeyCalls() []struct {
	UID      string
	Algo     keyring.SignatureAlgo
	Hrp      string
	CoinType uint32
	Account  uint32
	Index    uint32
} {
	var calls []struct {
		UID      string
		Algo     keyring.SignatureAlgo
		Hrp      string
		CoinType uint32
		Account  uint32
		Index    uint32
	}
	mock.lockSaveLedgerKey.RLock()
	calls = mock.calls.SaveLedgerKey
	mock.lockSaveLedgerKey.RUnlock()
	return calls
}

// SaveMultisig calls SaveMultisigFunc.
func (mock *KeyringMock) SaveMultisig(uid string, pubkey cryptotypes.PubKey) (keyring.Info, error) {
	if mock.SaveMultisigFunc == nil {
		panic("KeyringMock.SaveMultisigFunc: method is nil but Keyring.SaveMultisig was just called")
	}
	callInfo := struct {
		UID    string
		Pubkey cryptotypes.PubKey
	}{
		UID:    uid,
		Pubkey: pubkey,
	}
	mock.lockSaveMultisig.Lock()
	mock.calls.SaveMultisig = append(mock.calls.SaveMultisig, callInfo)
	mock.lockSaveMultisig.Unlock()
	return mock.SaveMultisigFunc(uid, pubkey)
}

// SaveMultisigCalls gets all the calls that were made to SaveMultisig.
// Check the length with:
//
//	len(mockedKeyring.SaveMultisigCalls())
func (mock *KeyringMock) SaveMultisigCalls() []struct {
	UID    string
	Pubkey cryptotypes.PubKey
} {
	var calls []struct {
		UID    string
		Pubkey cryptotypes.PubKey
	}
	mock.lockSaveMultisig.RLock()
	calls = mock.calls.SaveMultisig
	mock.lockSaveMultisig.RUnlock()
	return calls
}

// SavePubKey calls SavePubKeyFunc.
func (mock *KeyringMock) SavePubKey(uid string, pubkey cryptotypes.PubKey, algo hd.PubKeyType) (keyring.Info, error) {
	if mock.SavePubKeyFunc == nil {
		panic("KeyringMock.SavePubKeyFunc: method is nil but Keyring.SavePubKey was just called")
	}
	callInfo := struct {
		UID    string
		Pubkey cryptotypes.PubKey
		Algo   hd.PubKeyType
	}{
		UID:    uid,
		Pubkey: pubkey,
		Algo:   algo,
	}
	mock.lockSavePubKey.Lock()
	mock.calls.SavePubKey = append(mock.calls.SavePubKey, callInfo)
	mock.lockSavePubKey.Unlock()
	return mock.SavePubKeyFunc(uid, pubkey, algo)
}

// SavePubKeyCalls gets all the calls that were made to SavePubKey.
// Check the length with:
//
//	len(mockedKeyring.SavePubKeyCalls())
func (mock *KeyringMock) SavePubKeyCalls() []struct {
	UID    string
	Pubkey cryptotypes.PubKey
	Algo   hd.PubKeyType
} {
	var calls []struct {
		UID    string
		Pubkey cryptotypes.PubKey
		Algo   hd.PubKeyType
	}
	mock.lockSavePubKey.RLock()
	calls = mock.calls.SavePubKey
	mock.lockSavePubKey.RUnlock()
	return calls
}

// Sign calls SignFunc.
func (mock *KeyringMock) Sign(uid string, msg []byte) ([]byte, cryptotypes.PubKey, error) {
	if mock.SignFunc == nil {
		panic("KeyringMock.SignFunc: method is nil but Keyring.Sign was just called")
	}
	callInfo := struct {
		UID string
		Msg []byte
	}{
		UID: uid,
		Msg: msg,
	}
	mock.lockSign.Lock()
	mock.calls.Sign = append(mock.calls.Sign, callInfo)
	mock.lockSign.Unlock()
	return mock.SignFunc(uid, msg)
}

// SignCalls gets all the calls that were made to Sign.
// Check the length with:
//
//	len(mockedKeyring.SignCalls())
func (mock *KeyringMock) SignCalls() []struct {
	UID string
	Msg []byte
} {
	var calls []struct {
		UID string
		Msg []byte
	}
	mock.lockSign.RLock()
	calls = mock.calls.Sign
	mock.lockSign.RUnlock()
	return calls
}

// SignByAddress calls SignByAddressFunc.
func (mock *KeyringMock) SignByAddress(address sdk.Address, msg []byte) ([]byte, cryptotypes.PubKey, error) {
	if mock.SignByAddressFunc == nil {
		panic("KeyringMock.SignByAddressFunc: method is nil but Keyring.SignByAddress was just called")
	}
	callInfo := struct {
		Address sdk.Address
		Msg     []byte
	}{
		Address: address,
		Msg:     msg,
	}
	mock.lockSignByAddress.Lock()
	mock.calls.SignByAddress = append(mock.calls.SignByAddress, callInfo)
	mock.lockSignByAddress.Unlock()
	return mock.SignByAddressFunc(address, msg)
}

// SignByAddressCalls gets all the calls that were made to SignByAddress.
// Check the length with:
//
//	len(mockedKeyring.SignByAddressCalls())
func (mock *KeyringMock) SignByAddressCalls() []struct {
	Address sdk.Address
	Msg     []byte
} {
	var calls []struct {
		Address sdk.Address
		Msg     []byte
	}
	mock.lockSignByAddress.RLock()
	calls = mock.calls.SignByAddress
	mock.lockSignByAddress.RUnlock()
	return calls
}

// SupportedAlgorithms calls SupportedAlgorithmsFunc.
func (mock *KeyringMock) SupportedAlgorithms() (keyring.SigningAlgoList, keyring.SigningAlgoList) {
	if mock.SupportedAlgorithmsFunc == nil {
		panic("KeyringMock.SupportedAlgorithmsFunc: method is nil but Keyring.SupportedAlgorithms was just called")
	}
	callInfo := struct {
	}{}
	mock.lockSupportedAlgorithms.Lock()
	mock.calls.SupportedAlgorithms = append(mock.calls.SupportedAlgorithms, callInfo)
	mock.lockSupportedAlgorithms.Unlock()
	return mock.SupportedAlgorithmsFunc()
}

// SupportedAlgorithmsCalls gets all the calls that were made to SupportedAlgorithms.
// Check the length with:
//
//	len(mockedKeyring.SupportedAlgorithmsCalls())
func (mock *KeyringMock) SupportedAlgorithmsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockSupportedAlgorithms.RLock()
	calls = mock.calls.SupportedAlgorithms
	mock.lockSupportedAlgorithms.RUnlock()
	return calls
}

// Ensure, that InfoMock does implement Info.
// If this is not the case, regenerate this file with moq.
var _ Info = &InfoMock{}

// InfoMock is a mock implementation of Info.
//
//	func TestSomethingThatUsesInfo(t *testing.T) {
//
//		// make and configure a mocked Info
//		mockedInfo := &InfoMock{
//			GetAddressFunc: func() sdk.AccAddress {
//				panic("mock out the GetAddress method")
//			},
//			GetAlgoFunc: func() hd.PubKeyType {
//				panic("mock out the GetAlgo method")
//			},
//			GetNameFunc: func() string {
//				panic("mock out the GetName method")
//			},
//			GetPathFunc: func() (*hd.BIP44Params, error) {
//				panic("mock out the GetPath method")
//			},
//			GetPubKeyFunc: func() cryptotypes.PubKey {
//				panic("mock out the GetPubKey method")
//			},
//			GetTypeFunc: func() keyring.KeyType {
//				panic("mock out the GetType method")
//			},
//		}
//
//		// use mockedInfo in code that requires Info
//		// and then make assertions.
//
//	}
type InfoMock struct {
	// GetAddressFunc mocks the GetAddress method.
	GetAddressFunc func() sdk.AccAddress

	// GetAlgoFunc mocks the GetAlgo method.
	GetAlgoFunc func() hd.PubKeyType

	// GetNameFunc mocks the GetName method.
	GetNameFunc func() string

	// GetPathFunc mocks the GetPath method.
	GetPathFunc func() (*hd.BIP44Params, error)

	// GetPubKeyFunc mocks the GetPubKey method.
	GetPubKeyFunc func() cryptotypes.PubKey

	// GetTypeFunc mocks the GetType method.
	GetTypeFunc func() keyring.KeyType

	// calls tracks calls to the methods.
	calls struct {
		// GetAddress holds details about calls to the GetAddress method.
		GetAddress []struct {
		}
		// GetAlgo holds details about calls to the GetAlgo method.
		GetAlgo []struct {
		}
		// GetName holds details about calls to the GetName method.
		GetName []struct {
		}
		// GetPath holds details about calls to the GetPath method.
		GetPath []struct {
		}
		// GetPubKey holds details about calls to the GetPubKey method.
		GetPubKey []struct {
		}
		// GetType holds details about calls to the GetType method.
		GetType []struct {
		}
	}
	lockGetAddress sync.RWMutex
	lockGetAlgo    sync.RWMutex
	lockGetName    sync.RWMutex
	lockGetPath    sync.RWMutex
	lockGetPubKey  sync.RWMutex
	lockGetType    sync.RWMutex
}

// GetAddress calls GetAddressFunc.
func (mock *InfoMock) GetAddress() sdk.AccAddress {
	if mock.GetAddressFunc == nil {
		panic("InfoMock.GetAddressFunc: method is nil but Info.GetAddress was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetAddress.Lock()
	mock.calls.GetAddress = append(mock.calls.GetAddress, callInfo)
	mock.lockGetAddress.Unlock()
	return mock.GetAddressFunc()
}

// GetAddressCalls gets all the calls that were made to GetAddress.
// Check the length with:
//
//	len(mockedInfo.GetAddressCalls())
func (mock *InfoMock) GetAddressCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetAddress.RLock()
	calls = mock.calls.GetAddress
	mock.lockGetAddress.RUnlock()
	return calls
}

// GetAlgo calls GetAlgoFunc.
func (mock *InfoMock) GetAlgo() hd.PubKeyType {
	if mock.GetAlgoFunc == nil {
		panic("InfoMock.GetAlgoFunc: method is nil but Info.GetAlgo was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetAlgo.Lock()
	mock.calls.GetAlgo = append(mock.calls.GetAlgo, callInfo)
	mock.lockGetAlgo.Unlock()
	return mock.GetAlgoFunc()
}

// GetAlgoCalls gets all the calls that were made to GetAlgo.
// Check the length with:
//
//	len(mockedInfo.GetAlgoCalls())
func (mock *InfoMock) GetAlgoCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetAlgo.RLock()
	calls = mock.calls.GetAlgo
	mock.lockGetAlgo.RUnlock()
	return calls
}

// GetName calls GetNameFunc.
func (mock *InfoMock) GetName() string {
	if mock.GetNameFunc == nil {
		panic("InfoMock.GetNameFunc: method is nil but Info.GetName was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetName.Lock()
	mock.calls.GetName = append(mock.calls.GetName, callInfo)
	mock.lockGetName.Unlock()
	return mock.GetNameFunc()
}

// GetNameCalls gets all the calls that were made to GetName.
// Check the length with:
//
//	len(mockedInfo.GetNameCalls())
func (mock *InfoMock) GetNameCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetName.RLock()
	calls = mock.calls.GetName
	mock.lockGetName.RUnlock()
	return calls
}

// GetPath calls GetPathFunc.
func (mock *InfoMock) GetPath() (*hd.BIP44Params, error) {
	if mock.GetPathFunc == nil {
		panic("InfoMock.GetPathFunc: method is nil but Info.GetPath was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetPath.Lock()
	mock.calls.GetPath = append(mock.calls.GetPath, callInfo)
	mock.lockGetPath.Unlock()
	return mock.GetPathFunc()
}

// GetPathCalls gets all the calls that were made to GetPath.
// Check the length with:
//
//	len(mockedInfo.GetPathCalls())
func (mock *InfoMock) GetPathCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetPath.RLock()
	calls = mock.calls.GetPath
	mock.lockGetPath.RUnlock()
	return calls
}

// GetPubKey calls GetPubKeyFunc.
func (mock *InfoMock) GetPubKey() cryptotypes.PubKey {
	if mock.GetPubKeyFunc == nil {
		panic("InfoMock.GetPubKeyFunc: method is nil but Info.GetPubKey was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetPubKey.Lock()
	mock.calls.GetPubKey = append(mock.calls.GetPubKey, callInfo)
	mock.lockGetPubKey.Unlock()
	return mock.GetPubKeyFunc()
}

// GetPubKeyCalls gets all the calls that were made to GetPubKey.
// Check the length with:
//
//	len(mockedInfo.GetPubKeyCalls())
func (mock *InfoMock) GetPubKeyCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetPubKey.RLock()
	calls = mock.calls.GetPubKey
	mock.lockGetPubKey.RUnlock()
	return calls
}

// GetType calls GetTypeFunc.
func (mock *InfoMock) GetType() keyring.KeyType {
	if mock.GetTypeFunc == nil {
		panic("InfoMock.GetTypeFunc: method is nil but Info.GetType was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetType.Lock()
	mock.calls.GetType = append(mock.calls.GetType, callInfo)
	mock.lockGetType.Unlock()
	return mock.GetTypeFunc()
}

// GetTypeCalls gets all the calls that were made to GetType.
// Check the length with:
//
//	len(mockedInfo.GetTypeCalls())
func (mock *InfoMock) GetTypeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetType.RLock()
	calls = mock.calls.GetType
	mock.lockGetType.RUnlock()
	return calls
}
